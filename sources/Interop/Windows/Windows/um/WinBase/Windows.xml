<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.AccessCheckAndAuditAlarm">
    <summary>
      <para>The <b>AccessCheckAndAuditAlarm</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client being impersonated by the calling thread. If the security descriptor has a SACL with ACEs that apply to the client, the function generates any necessary audit messages in the security event log.</para>
      <para>Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>A pointer to a unique value representing the client's handle to the object. If the access is denied, the system ignores this value.</para>
    </param>
    <param name="ObjectTypeName">
      <para>A pointer to a null-terminated string specifying the type of object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="ObjectName">
      <para>A pointer to a null-terminated string specifying the name of the object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="SecurityDescriptor">
      <para>A pointer to the
<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</para>
    </param>
    <param name="DesiredAccess">
      <para>
        <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">Access mask</a> that specifies the access rights to check. This mask must have been mapped by the
<see cref="MapGenericMask" /> function to contain no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the <i>GrantedAccess</i> access mask to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="GenericMapping">
      <para>A pointer to the
<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</para>
    </param>
    <param name="ObjectCreation">
      <para>Specifies a flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</para>
    </param>
    <param name="GrantedAccess">
      <para>A pointer to an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that receives the granted access rights. If <i>AccessStatus</i> is set to <b>FALSE</b>, the function sets the access mask to zero. If the function fails, it does not set the access mask.</para>
    </param>
    <param name="AccessStatus">
      <para>A pointer to a variable that receives the results of the access check. If the security descriptor allows the requested access rights to the client, <i>AccessStatus</i> is set to <b>TRUE</b>. Otherwise, <i>AccessStatus</i> is set to <b>FALSE</b>.</para>
    </param>
    <param name="pfGenerateOnClose">
      <para>A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the
<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For more information, see the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</a> overview.</para>
      <para>The <b>AccessCheckAndAuditAlarm</b> function requires the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> to have the SE_AUDIT_NAME privilege enabled. The test for this privilege is performed against the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling process, not the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> of the thread.</para>
      <para>The <b>AccessCheckAndAuditAlarm</b> function fails if the calling thread is not impersonating a client.</para>
    </remarks>
    <seealso cref="AccessCheck" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control </seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="GENERIC_MAPPING" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</seealso>
    <seealso cref="MakeAbsoluteSD" />
    <seealso cref="MapGenericMask" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="ObjectOpenAuditAlarm" />
    <seealso cref="ObjectPrivilegeAuditAlarm" />
    <seealso cref="PrivilegeCheck" />
    <seealso cref="PrivilegedServiceAuditAlarm" />
    <seealso cref="SECURITY_DESCRIPTOR" />
  </member>
  <member name="Windows.AccessCheckAndAuditAlarmA">
    <summary>
      <para>The <b>AccessCheckAndAuditAlarm</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client being impersonated by the calling thread. If the security descriptor has a SACL with ACEs that apply to the client, the function generates any necessary audit messages in the security event log.</para>
      <para>Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>A pointer to a unique value representing the client's handle to the object. If the access is denied, the system ignores this value.</para>
    </param>
    <param name="ObjectTypeName">
      <para>A pointer to a null-terminated string specifying the type of object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="ObjectName">
      <para>A pointer to a null-terminated string specifying the name of the object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="SecurityDescriptor">
      <para>A pointer to the
<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</para>
    </param>
    <param name="DesiredAccess">
      <para>
        <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">Access mask</a> that specifies the access rights to check. This mask must have been mapped by the
<see cref="MapGenericMask" /> function to contain no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the <i>GrantedAccess</i> access mask to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="GenericMapping">
      <para>A pointer to the
<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</para>
    </param>
    <param name="ObjectCreation">
      <para>Specifies a flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</para>
    </param>
    <param name="GrantedAccess">
      <para>A pointer to an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that receives the granted access rights. If <i>AccessStatus</i> is set to <b>FALSE</b>, the function sets the access mask to zero. If the function fails, it does not set the access mask.</para>
    </param>
    <param name="AccessStatus">
      <para>A pointer to a variable that receives the results of the access check. If the security descriptor allows the requested access rights to the client, <i>AccessStatus</i> is set to <b>TRUE</b>. Otherwise, <i>AccessStatus</i> is set to <b>FALSE</b>.</para>
    </param>
    <param name="pfGenerateOnClose">
      <para>A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the
<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For more information, see the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</a> overview.</para>
      <para>The <b>AccessCheckAndAuditAlarm</b> function requires the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> to have the SE_AUDIT_NAME privilege enabled. The test for this privilege is performed against the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling process, not the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> of the thread.</para>
      <para>The <b>AccessCheckAndAuditAlarm</b> function fails if the calling thread is not impersonating a client.</para>
    </remarks>
    <seealso cref="AccessCheck" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control </seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="GENERIC_MAPPING" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</seealso>
    <seealso cref="MakeAbsoluteSD" />
    <seealso cref="MapGenericMask" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="ObjectOpenAuditAlarm" />
    <seealso cref="ObjectPrivilegeAuditAlarm" />
    <seealso cref="PrivilegeCheck" />
    <seealso cref="PrivilegedServiceAuditAlarm" />
    <seealso cref="SECURITY_DESCRIPTOR" />
  </member>
  <member name="Windows.AccessCheckAndAuditAlarmW">
    <summary>
      <para>The <b>AccessCheckAndAuditAlarm</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client being impersonated by the calling thread. If the security descriptor has a SACL with ACEs that apply to the client, the function generates any necessary audit messages in the security event log.</para>
      <para>Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>A pointer to a unique value representing the client's handle to the object. If the access is denied, the system ignores this value.</para>
    </param>
    <param name="ObjectTypeName">
      <para>A pointer to a null-terminated string specifying the type of object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="ObjectName">
      <para>A pointer to a null-terminated string specifying the name of the object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="SecurityDescriptor">
      <para>A pointer to the
<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</para>
    </param>
    <param name="DesiredAccess">
      <para>
        <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">Access mask</a> that specifies the access rights to check. This mask must have been mapped by the
<see cref="MapGenericMask" /> function to contain no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the <i>GrantedAccess</i> access mask to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="GenericMapping">
      <para>A pointer to the
<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</para>
    </param>
    <param name="ObjectCreation">
      <para>Specifies a flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</para>
    </param>
    <param name="GrantedAccess">
      <para>A pointer to an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that receives the granted access rights. If <i>AccessStatus</i> is set to <b>FALSE</b>, the function sets the access mask to zero. If the function fails, it does not set the access mask.</para>
    </param>
    <param name="AccessStatus">
      <para>A pointer to a variable that receives the results of the access check. If the security descriptor allows the requested access rights to the client, <i>AccessStatus</i> is set to <b>TRUE</b>. Otherwise, <i>AccessStatus</i> is set to <b>FALSE</b>.</para>
    </param>
    <param name="pfGenerateOnClose">
      <para>A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the
<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For more information, see the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</a> overview.</para>
      <para>The <b>AccessCheckAndAuditAlarm</b> function requires the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> to have the SE_AUDIT_NAME privilege enabled. The test for this privilege is performed against the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling process, not the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> of the thread.</para>
      <para>The <b>AccessCheckAndAuditAlarm</b> function fails if the calling thread is not impersonating a client.</para>
    </remarks>
    <seealso cref="AccessCheck" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control </seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="GENERIC_MAPPING" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</seealso>
    <seealso cref="MakeAbsoluteSD" />
    <seealso cref="MapGenericMask" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="ObjectOpenAuditAlarm" />
    <seealso cref="ObjectPrivilegeAuditAlarm" />
    <seealso cref="PrivilegeCheck" />
    <seealso cref="PrivilegedServiceAuditAlarm" />
    <seealso cref="SECURITY_DESCRIPTOR" />
  </member>
  <member name="Windows.AccessCheckByTypeAndAuditAlarm">
    <summary>
      <para>The <b>AccessCheckByTypeAndAuditAlarm</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client being impersonated by the calling thread. The function can check the client's access to a hierarchy of objects, such as an object, its property sets, and properties. The function grants or denies access to the hierarchy as a whole. If the security descriptor has a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) with <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control entries</a> (ACEs) that apply to the client, the function generates any necessary audit messages in the security event log.</para>
      <para>Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.</para>
    </param>
    <param name="ObjectTypeName">
      <para>A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="ObjectName">
      <para>A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="SecurityDescriptor">
      <para>A pointer to a
<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</para>
    </param>
    <param name="PrincipalSelfSid">
      <para>A pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID). If the security descriptor is associated with an object that represents a principal (for example, a user object), the <i>PrincipalSelfSid</i> parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE containing the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-known SIDs</a>.</para>
      <para>If the protected object does not represent a principal, set this parameter to <b>NULL</b>.</para>
    </param>
    <param name="DesiredAccess">
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the access rights to check. This mask must have been mapped by the
<see cref="MapGenericMask" /> function to contain no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the <i>GrantedAccess</i> access mask to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="AuditType">
      <para>The type of audit to be generated. This can be one of the values from the
<see cref="AUDIT_EVENT_TYPE" /> enumeration type.</para>
    </param>
    <param name="Flags">
      <para>A flag that controls the function's behavior if the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.</para>
    </param>
    <param name="ObjectTypeList">
      <para>A pointer to an array of
<see cref="OBJECT_TYPE_LIST" /> structures that identify the hierarchy of object types for which to check access. Each element in the array specifies a GUID that identifies the object type and a value that indicates the level of the object type in the hierarchy of object types. The array should not have two elements with the same GUID.</para>
      <para>The array must have at least one element. The first element in the array must be at level zero and identify the object itself. The array can have only one level zero element. The second element is a subobject, such as a property set, at level 1. Following each level 1 entry are subordinate entries for the level 2 through 4 subobjects. Thus, the levels for the elements in the array might be {0, 1, 2, 2, 1, 2, 3}. If the object type list is out of order, <b>AccessCheckByTypeAndAuditAlarm</b> fails and
<see cref="GetLastError" /> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <param name="ObjectTypeListLength">
      <para>The number of elements in the <i>ObjectTypeList</i> array.</para>
    </param>
    <param name="GenericMapping">
      <para>A pointer to the
<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</para>
    </param>
    <param name="ObjectCreation">
      <para>A flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</para>
    </param>
    <param name="GrantedAccess">
      <para>A pointer to an access mask that receives the granted access rights. If <i>AccessStatus</i> is set to <b>FALSE</b>, the function sets the access mask to zero. If the function fails, it does not set the access mask.</para>
    </param>
    <param name="AccessStatus">
      <para>A pointer to a variable that receives the results of the access check. If the security descriptor allows the requested access rights to the client, <i>AccessStatus</i> is set to <b>TRUE</b>. Otherwise, <i>AccessStatus</i> is set to <b>FALSE</b> and you can call
<see cref="GetLastError" /> to get extended error information.</para>
    </param>
    <param name="pfGenerateOnClose">
      <para>A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the
<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For more information, see the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</a> overview.</para>
      <para>If the <i>PrincipalSelfSid</i> and <i>ObjectTypeList</i> parameters are <b>NULL</b>, the <i>AuditType</i> parameter is <i>AuditEventObjectAccess</i>, and the <i>Flags</i> parameter is zero, <b>AccessCheckByTypeAndAuditAlarm</b> performs in the same way as the
<see cref="AccessCheckAndAuditAlarm" /> function.</para>
      <para>The <i>ObjectTypeList</i> array does not necessarily represent the entire defined object. Rather, it represents that subset of the object for which to check access. For instance, to check access to two properties in a property set, specify an object type list with four elements: the object itself at level zero, the property set at level 1, and the two properties at level 2.</para>
      <para>The <b>AccessCheckByTypeAndAuditAlarm</b> function evaluates ACEs that apply to the object itself and object-specific ACEs for the object types listed in the <i>ObjectTypeList</i> array. The function ignores object-specific ACEs for object types not listed in the <i>ObjectTypeList</i> array. Thus, the results returned in the <i>AccessStatus</i> parameter indicate the access allowed to the subset of the object defined by the <i>ObjectTypeList</i> parameter, not to the entire object.</para>
      <para>For more information about how a hierarchy of ACEs controls access to an object and its subobjects, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/aces-to-control-access-to-an-object-s-properties">ACEs to Control Access to an Object's Properties</a>.</para>
      <para>To generate audit messages in the security event log, the calling process must have the SE_AUDIT_NAME privilege enabled. The system checks for this privilege in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling process, not the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> of the thread. If the <i>Flags</i> parameter includes the AUDIT_ALLOW_NO_PRIVILEGE flag, the function performs the access check without generating audit messages when the privilege is not enabled.</para>
      <para>The <b>AccessCheckByTypeAndAuditAlarm</b> function fails if the calling thread is not impersonating a client.</para>
      <para>If the security descriptor does not contain owner and group SIDs, <b>AccessCheckByTypeAndAuditAlarm</b> fails with ERROR_INVALID_SECURITY_DESCR.</para>
    </remarks>
    <seealso cref="AUDIT_EVENT_TYPE" />
    <seealso cref="AccessCheck" />
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso cref="AccessCheckByType" />
    <seealso cref="AccessCheckByTypeResultList" />
    <seealso cref="AccessCheckByTypeResultListAndAuditAlarm" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control </seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="GENERIC_MAPPING" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</seealso>
    <seealso cref="MakeAbsoluteSD" />
    <seealso cref="MapGenericMask" />
    <seealso cref="OBJECT_TYPE_LIST" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="PRIVILEGE_SET" />
    <seealso cref="SECURITY_DESCRIPTOR" />
  </member>
  <member name="Windows.AccessCheckByTypeAndAuditAlarmA">
    <summary>
      <para>The <b>AccessCheckByTypeAndAuditAlarm</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client being impersonated by the calling thread. The function can check the client's access to a hierarchy of objects, such as an object, its property sets, and properties. The function grants or denies access to the hierarchy as a whole. If the security descriptor has a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) with <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control entries</a> (ACEs) that apply to the client, the function generates any necessary audit messages in the security event log.</para>
      <para>Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.</para>
    </param>
    <param name="ObjectTypeName">
      <para>A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="ObjectName">
      <para>A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="SecurityDescriptor">
      <para>A pointer to a
<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</para>
    </param>
    <param name="PrincipalSelfSid">
      <para>A pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID). If the security descriptor is associated with an object that represents a principal (for example, a user object), the <i>PrincipalSelfSid</i> parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE containing the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-known SIDs</a>.</para>
      <para>If the protected object does not represent a principal, set this parameter to <b>NULL</b>.</para>
    </param>
    <param name="DesiredAccess">
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the access rights to check. This mask must have been mapped by the
<see cref="MapGenericMask" /> function to contain no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the <i>GrantedAccess</i> access mask to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="AuditType">
      <para>The type of audit to be generated. This can be one of the values from the
<see cref="AUDIT_EVENT_TYPE" /> enumeration type.</para>
    </param>
    <param name="Flags">
      <para>A flag that controls the function's behavior if the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.</para>
    </param>
    <param name="ObjectTypeList">
      <para>A pointer to an array of
<see cref="OBJECT_TYPE_LIST" /> structures that identify the hierarchy of object types for which to check access. Each element in the array specifies a GUID that identifies the object type and a value that indicates the level of the object type in the hierarchy of object types. The array should not have two elements with the same GUID.</para>
      <para>The array must have at least one element. The first element in the array must be at level zero and identify the object itself. The array can have only one level zero element. The second element is a subobject, such as a property set, at level 1. Following each level 1 entry are subordinate entries for the level 2 through 4 subobjects. Thus, the levels for the elements in the array might be {0, 1, 2, 2, 1, 2, 3}. If the object type list is out of order, <b>AccessCheckByTypeAndAuditAlarm</b> fails and
<see cref="GetLastError" /> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <param name="ObjectTypeListLength">
      <para>The number of elements in the <i>ObjectTypeList</i> array.</para>
    </param>
    <param name="GenericMapping">
      <para>A pointer to the
<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</para>
    </param>
    <param name="ObjectCreation">
      <para>A flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</para>
    </param>
    <param name="GrantedAccess">
      <para>A pointer to an access mask that receives the granted access rights. If <i>AccessStatus</i> is set to <b>FALSE</b>, the function sets the access mask to zero. If the function fails, it does not set the access mask.</para>
    </param>
    <param name="AccessStatus">
      <para>A pointer to a variable that receives the results of the access check. If the security descriptor allows the requested access rights to the client, <i>AccessStatus</i> is set to <b>TRUE</b>. Otherwise, <i>AccessStatus</i> is set to <b>FALSE</b> and you can call
<see cref="GetLastError" /> to get extended error information.</para>
    </param>
    <param name="pfGenerateOnClose">
      <para>A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the
<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For more information, see the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</a> overview.</para>
      <para>If the <i>PrincipalSelfSid</i> and <i>ObjectTypeList</i> parameters are <b>NULL</b>, the <i>AuditType</i> parameter is <i>AuditEventObjectAccess</i>, and the <i>Flags</i> parameter is zero, <b>AccessCheckByTypeAndAuditAlarm</b> performs in the same way as the
<see cref="AccessCheckAndAuditAlarm" /> function.</para>
      <para>The <i>ObjectTypeList</i> array does not necessarily represent the entire defined object. Rather, it represents that subset of the object for which to check access. For instance, to check access to two properties in a property set, specify an object type list with four elements: the object itself at level zero, the property set at level 1, and the two properties at level 2.</para>
      <para>The <b>AccessCheckByTypeAndAuditAlarm</b> function evaluates ACEs that apply to the object itself and object-specific ACEs for the object types listed in the <i>ObjectTypeList</i> array. The function ignores object-specific ACEs for object types not listed in the <i>ObjectTypeList</i> array. Thus, the results returned in the <i>AccessStatus</i> parameter indicate the access allowed to the subset of the object defined by the <i>ObjectTypeList</i> parameter, not to the entire object.</para>
      <para>For more information about how a hierarchy of ACEs controls access to an object and its subobjects, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/aces-to-control-access-to-an-object-s-properties">ACEs to Control Access to an Object's Properties</a>.</para>
      <para>To generate audit messages in the security event log, the calling process must have the SE_AUDIT_NAME privilege enabled. The system checks for this privilege in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling process, not the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> of the thread. If the <i>Flags</i> parameter includes the AUDIT_ALLOW_NO_PRIVILEGE flag, the function performs the access check without generating audit messages when the privilege is not enabled.</para>
      <para>The <b>AccessCheckByTypeAndAuditAlarm</b> function fails if the calling thread is not impersonating a client.</para>
      <para>If the security descriptor does not contain owner and group SIDs, <b>AccessCheckByTypeAndAuditAlarm</b> fails with ERROR_INVALID_SECURITY_DESCR.</para>
    </remarks>
    <seealso cref="AUDIT_EVENT_TYPE" />
    <seealso cref="AccessCheck" />
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso cref="AccessCheckByType" />
    <seealso cref="AccessCheckByTypeResultList" />
    <seealso cref="AccessCheckByTypeResultListAndAuditAlarm" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control </seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="GENERIC_MAPPING" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</seealso>
    <seealso cref="MakeAbsoluteSD" />
    <seealso cref="MapGenericMask" />
    <seealso cref="OBJECT_TYPE_LIST" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="PRIVILEGE_SET" />
    <seealso cref="SECURITY_DESCRIPTOR" />
  </member>
  <member name="Windows.AccessCheckByTypeAndAuditAlarmW">
    <summary>
      <para>The <b>AccessCheckByTypeAndAuditAlarm</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client being impersonated by the calling thread. The function can check the client's access to a hierarchy of objects, such as an object, its property sets, and properties. The function grants or denies access to the hierarchy as a whole. If the security descriptor has a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) with <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control entries</a> (ACEs) that apply to the client, the function generates any necessary audit messages in the security event log.</para>
      <para>Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.</para>
    </param>
    <param name="ObjectTypeName">
      <para>A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="ObjectName">
      <para>A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="SecurityDescriptor">
      <para>A pointer to a
<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</para>
    </param>
    <param name="PrincipalSelfSid">
      <para>A pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID). If the security descriptor is associated with an object that represents a principal (for example, a user object), the <i>PrincipalSelfSid</i> parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE containing the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-known SIDs</a>.</para>
      <para>If the protected object does not represent a principal, set this parameter to <b>NULL</b>.</para>
    </param>
    <param name="DesiredAccess">
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the access rights to check. This mask must have been mapped by the
<see cref="MapGenericMask" /> function to contain no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the <i>GrantedAccess</i> access mask to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="AuditType">
      <para>The type of audit to be generated. This can be one of the values from the
<see cref="AUDIT_EVENT_TYPE" /> enumeration type.</para>
    </param>
    <param name="Flags">
      <para>A flag that controls the function's behavior if the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.</para>
    </param>
    <param name="ObjectTypeList">
      <para>A pointer to an array of
<see cref="OBJECT_TYPE_LIST" /> structures that identify the hierarchy of object types for which to check access. Each element in the array specifies a GUID that identifies the object type and a value that indicates the level of the object type in the hierarchy of object types. The array should not have two elements with the same GUID.</para>
      <para>The array must have at least one element. The first element in the array must be at level zero and identify the object itself. The array can have only one level zero element. The second element is a subobject, such as a property set, at level 1. Following each level 1 entry are subordinate entries for the level 2 through 4 subobjects. Thus, the levels for the elements in the array might be {0, 1, 2, 2, 1, 2, 3}. If the object type list is out of order, <b>AccessCheckByTypeAndAuditAlarm</b> fails and
<see cref="GetLastError" /> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <param name="ObjectTypeListLength">
      <para>The number of elements in the <i>ObjectTypeList</i> array.</para>
    </param>
    <param name="GenericMapping">
      <para>A pointer to the
<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</para>
    </param>
    <param name="ObjectCreation">
      <para>A flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</para>
    </param>
    <param name="GrantedAccess">
      <para>A pointer to an access mask that receives the granted access rights. If <i>AccessStatus</i> is set to <b>FALSE</b>, the function sets the access mask to zero. If the function fails, it does not set the access mask.</para>
    </param>
    <param name="AccessStatus">
      <para>A pointer to a variable that receives the results of the access check. If the security descriptor allows the requested access rights to the client, <i>AccessStatus</i> is set to <b>TRUE</b>. Otherwise, <i>AccessStatus</i> is set to <b>FALSE</b> and you can call
<see cref="GetLastError" /> to get extended error information.</para>
    </param>
    <param name="pfGenerateOnClose">
      <para>A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the
<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For more information, see the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</a> overview.</para>
      <para>If the <i>PrincipalSelfSid</i> and <i>ObjectTypeList</i> parameters are <b>NULL</b>, the <i>AuditType</i> parameter is <i>AuditEventObjectAccess</i>, and the <i>Flags</i> parameter is zero, <b>AccessCheckByTypeAndAuditAlarm</b> performs in the same way as the
<see cref="AccessCheckAndAuditAlarm" /> function.</para>
      <para>The <i>ObjectTypeList</i> array does not necessarily represent the entire defined object. Rather, it represents that subset of the object for which to check access. For instance, to check access to two properties in a property set, specify an object type list with four elements: the object itself at level zero, the property set at level 1, and the two properties at level 2.</para>
      <para>The <b>AccessCheckByTypeAndAuditAlarm</b> function evaluates ACEs that apply to the object itself and object-specific ACEs for the object types listed in the <i>ObjectTypeList</i> array. The function ignores object-specific ACEs for object types not listed in the <i>ObjectTypeList</i> array. Thus, the results returned in the <i>AccessStatus</i> parameter indicate the access allowed to the subset of the object defined by the <i>ObjectTypeList</i> parameter, not to the entire object.</para>
      <para>For more information about how a hierarchy of ACEs controls access to an object and its subobjects, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/aces-to-control-access-to-an-object-s-properties">ACEs to Control Access to an Object's Properties</a>.</para>
      <para>To generate audit messages in the security event log, the calling process must have the SE_AUDIT_NAME privilege enabled. The system checks for this privilege in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling process, not the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> of the thread. If the <i>Flags</i> parameter includes the AUDIT_ALLOW_NO_PRIVILEGE flag, the function performs the access check without generating audit messages when the privilege is not enabled.</para>
      <para>The <b>AccessCheckByTypeAndAuditAlarm</b> function fails if the calling thread is not impersonating a client.</para>
      <para>If the security descriptor does not contain owner and group SIDs, <b>AccessCheckByTypeAndAuditAlarm</b> fails with ERROR_INVALID_SECURITY_DESCR.</para>
    </remarks>
    <seealso cref="AUDIT_EVENT_TYPE" />
    <seealso cref="AccessCheck" />
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso cref="AccessCheckByType" />
    <seealso cref="AccessCheckByTypeResultList" />
    <seealso cref="AccessCheckByTypeResultListAndAuditAlarm" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control </seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="GENERIC_MAPPING" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</seealso>
    <seealso cref="MakeAbsoluteSD" />
    <seealso cref="MapGenericMask" />
    <seealso cref="OBJECT_TYPE_LIST" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="PRIVILEGE_SET" />
    <seealso cref="SECURITY_DESCRIPTOR" />
  </member>
  <member name="Windows.AccessCheckByTypeResultListAndAuditAlarm">
    <summary>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarm</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client being impersonated by the calling thread. The function can check access to a hierarchy of objects, such as an object, its property sets, and properties. The function reports the access rights granted or denied to each object type in the hierarchy. If the security descriptor has a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) with <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control entries</a> (ACEs) that apply to the client, the function generates any necessary audit messages in the security event log. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.</para>
    </param>
    <param name="ObjectTypeName">
      <para>A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="ObjectName">
      <para>A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="SecurityDescriptor">
      <para>A pointer to a
<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</para>
    </param>
    <param name="PrincipalSelfSid">
      <para>A pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID). If the security descriptor is associated with an object that represents a principal (for example, a user object), the <i>PrincipalSelfSid</i> parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE that contains the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-known SIDs</a>.</para>
      <para>Set this parameter to <b>NULL</b> if the protected object does not represent a principal.</para>
    </param>
    <param name="DesiredAccess">
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the access rights to check. This mask must have been mapped by the
<see cref="MapGenericMask" /> function so that it contains no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the access mask in <i>GrantedAccess</i> to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="AuditType">
      <para>The type of audit to be generated. This can be one of the values from the
<see cref="AUDIT_EVENT_TYPE" /> enumeration type.</para>
    </param>
    <param name="Flags">
      <para>A flag that controls the function's behavior if the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.</para>
    </param>
    <param name="ObjectTypeList">
      <para>A pointer to an array of
<see cref="OBJECT_TYPE_LIST" /> structures that identify the hierarchy of object types for which to check access. Each element in the array specifies a GUID that identifies the object type and a value that indicates the level of the object type in the hierarchy of object types. The array should not have two elements with the same GUID.</para>
      <para>The array must have at least one element. The first element in the array must be at level zero and identify the object itself. The array can have only one level zero element. The second element is a subobject, such as a property set, at level 1. Following each level 1 entry are subordinate entries for the level 2 through 4 subobjects. Thus, the levels for the elements in the array might be {0, 1, 2, 2, 1, 2, 3}. If the object type list is out of order, <b>AccessCheckByTypeResultListAndAuditAlarm</b> fails, and
<see cref="GetLastError" /> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <param name="ObjectTypeListLength">
      <para>The number of elements in the <i>ObjectTypeList</i> array.</para>
    </param>
    <param name="GenericMapping">
      <para>A pointer to the
<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</para>
    </param>
    <param name="ObjectCreation">
      <para>A flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</para>
    </param>
    <param name="GrantedAccess">
      <para>A pointer to an array of access masks. The function sets each access mask to indicate the access rights granted to the corresponding element in the object type list. If the function fails, it does not set the access masks.</para>
    </param>
    <param name="AccessStatusList">
      <para>A pointer to an array of status codes for the corresponding elements in the object type list. The function sets an element to zero to indicate success or to a nonzero value to indicate the specific error during the access check. If the function fails, it does not set any of the elements in the array.</para>
    </param>
    <param name="pfGenerateOnClose">
      <para>A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the
<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For more information, see the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</a> overview.</para>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarm</b> function is a combination of the
<see cref="AccessCheckByTypeResultList" /> and
<see cref="AccessCheckAndAuditAlarm" /> functions.</para>
      <para>The <i>ObjectTypeList</i> array does not necessarily represent the entire defined object. Rather, it represents that subset of the object for which to check access. For instance, to check access to two properties in a property set, specify an object type list with four elements: the object itself at level zero, the property set at level 1, and the two properties at level 2.</para>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarm</b> function evaluates ACEs that apply to the object itself and object-specific ACEs for the object types listed in the <i>ObjectTypeList</i> array. The function ignores object-specific ACEs for object types not listed in the <i>ObjectTypeList</i> array.</para>
      <para>For more information about how a hierarchy of ACEs controls access to an object and its subobjects, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/aces-to-control-access-to-an-object-s-properties">ACEs to Control Access to an Object's Properties</a>.</para>
      <para>To generate audit messages in the security event log, the calling process must have the SE_AUDIT_NAME privilege enabled. The system checks for this privilege in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling process, not the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> of the thread. If the <i>Flags</i> parameter includes the AUDIT_ALLOW_NO_PRIVILEGE flag, the function performs the access check without generating audit messages when the privilege is not enabled.</para>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarm</b> function fails if the calling thread is not impersonating a client.</para>
      <para>If the security descriptor does not contain owner and group SIDs, <b>AccessCheckByTypeResultListAndAuditAlarm</b> fails with ERROR_INVALID_SECURITY_DESCR.</para>
    </remarks>
    <seealso cref="AUDIT_EVENT_TYPE" />
    <seealso cref="AccessCheck" />
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso cref="AccessCheckByType" />
    <seealso cref="AccessCheckByTypeResultList" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="GENERIC_MAPPING" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</seealso>
    <seealso cref="MakeAbsoluteSD" />
    <seealso cref="MapGenericMask" />
    <seealso cref="OBJECT_TYPE_LIST" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="PRIVILEGE_SET" />
    <seealso cref="SECURITY_DESCRIPTOR" />
  </member>
  <member name="Windows.AccessCheckByTypeResultListAndAuditAlarmA">
    <summary>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarm</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client being impersonated by the calling thread. The function can check access to a hierarchy of objects, such as an object, its property sets, and properties. The function reports the access rights granted or denied to each object type in the hierarchy. If the security descriptor has a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) with <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control entries</a> (ACEs) that apply to the client, the function generates any necessary audit messages in the security event log. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.</para>
    </param>
    <param name="ObjectTypeName">
      <para>A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="ObjectName">
      <para>A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="SecurityDescriptor">
      <para>A pointer to a
<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</para>
    </param>
    <param name="PrincipalSelfSid">
      <para>A pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID). If the security descriptor is associated with an object that represents a principal (for example, a user object), the <i>PrincipalSelfSid</i> parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE that contains the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-known SIDs</a>.</para>
      <para>Set this parameter to <b>NULL</b> if the protected object does not represent a principal.</para>
    </param>
    <param name="DesiredAccess">
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the access rights to check. This mask must have been mapped by the
<see cref="MapGenericMask" /> function so that it contains no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the access mask in <i>GrantedAccess</i> to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="AuditType">
      <para>The type of audit to be generated. This can be one of the values from the
<see cref="AUDIT_EVENT_TYPE" /> enumeration type.</para>
    </param>
    <param name="Flags">
      <para>A flag that controls the function's behavior if the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.</para>
    </param>
    <param name="ObjectTypeList">
      <para>A pointer to an array of
<see cref="OBJECT_TYPE_LIST" /> structures that identify the hierarchy of object types for which to check access. Each element in the array specifies a GUID that identifies the object type and a value that indicates the level of the object type in the hierarchy of object types. The array should not have two elements with the same GUID.</para>
      <para>The array must have at least one element. The first element in the array must be at level zero and identify the object itself. The array can have only one level zero element. The second element is a subobject, such as a property set, at level 1. Following each level 1 entry are subordinate entries for the level 2 through 4 subobjects. Thus, the levels for the elements in the array might be {0, 1, 2, 2, 1, 2, 3}. If the object type list is out of order, <b>AccessCheckByTypeResultListAndAuditAlarm</b> fails, and
<see cref="GetLastError" /> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <param name="ObjectTypeListLength">
      <para>The number of elements in the <i>ObjectTypeList</i> array.</para>
    </param>
    <param name="GenericMapping">
      <para>A pointer to the
<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</para>
    </param>
    <param name="ObjectCreation">
      <para>A flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</para>
    </param>
    <param name="GrantedAccess">
      <para>A pointer to an array of access masks. The function sets each access mask to indicate the access rights granted to the corresponding element in the object type list. If the function fails, it does not set the access masks.</para>
    </param>
    <param name="AccessStatusList">
      <para>A pointer to an array of status codes for the corresponding elements in the object type list. The function sets an element to zero to indicate success or to a nonzero value to indicate the specific error during the access check. If the function fails, it does not set any of the elements in the array.</para>
    </param>
    <param name="pfGenerateOnClose">
      <para>A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the
<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For more information, see the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</a> overview.</para>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarm</b> function is a combination of the
<see cref="AccessCheckByTypeResultList" /> and
<see cref="AccessCheckAndAuditAlarm" /> functions.</para>
      <para>The <i>ObjectTypeList</i> array does not necessarily represent the entire defined object. Rather, it represents that subset of the object for which to check access. For instance, to check access to two properties in a property set, specify an object type list with four elements: the object itself at level zero, the property set at level 1, and the two properties at level 2.</para>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarm</b> function evaluates ACEs that apply to the object itself and object-specific ACEs for the object types listed in the <i>ObjectTypeList</i> array. The function ignores object-specific ACEs for object types not listed in the <i>ObjectTypeList</i> array.</para>
      <para>For more information about how a hierarchy of ACEs controls access to an object and its subobjects, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/aces-to-control-access-to-an-object-s-properties">ACEs to Control Access to an Object's Properties</a>.</para>
      <para>To generate audit messages in the security event log, the calling process must have the SE_AUDIT_NAME privilege enabled. The system checks for this privilege in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling process, not the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> of the thread. If the <i>Flags</i> parameter includes the AUDIT_ALLOW_NO_PRIVILEGE flag, the function performs the access check without generating audit messages when the privilege is not enabled.</para>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarm</b> function fails if the calling thread is not impersonating a client.</para>
      <para>If the security descriptor does not contain owner and group SIDs, <b>AccessCheckByTypeResultListAndAuditAlarm</b> fails with ERROR_INVALID_SECURITY_DESCR.</para>
    </remarks>
    <seealso cref="AUDIT_EVENT_TYPE" />
    <seealso cref="AccessCheck" />
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso cref="AccessCheckByType" />
    <seealso cref="AccessCheckByTypeResultList" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="GENERIC_MAPPING" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</seealso>
    <seealso cref="MakeAbsoluteSD" />
    <seealso cref="MapGenericMask" />
    <seealso cref="OBJECT_TYPE_LIST" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="PRIVILEGE_SET" />
    <seealso cref="SECURITY_DESCRIPTOR" />
  </member>
  <member name="Windows.AccessCheckByTypeResultListAndAuditAlarmW">
    <summary>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarm</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client being impersonated by the calling thread. The function can check access to a hierarchy of objects, such as an object, its property sets, and properties. The function reports the access rights granted or denied to each object type in the hierarchy. If the security descriptor has a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) with <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control entries</a> (ACEs) that apply to the client, the function generates any necessary audit messages in the security event log. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.</para>
    </param>
    <param name="ObjectTypeName">
      <para>A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="ObjectName">
      <para>A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="SecurityDescriptor">
      <para>A pointer to a
<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</para>
    </param>
    <param name="PrincipalSelfSid">
      <para>A pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID). If the security descriptor is associated with an object that represents a principal (for example, a user object), the <i>PrincipalSelfSid</i> parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE that contains the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-known SIDs</a>.</para>
      <para>Set this parameter to <b>NULL</b> if the protected object does not represent a principal.</para>
    </param>
    <param name="DesiredAccess">
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the access rights to check. This mask must have been mapped by the
<see cref="MapGenericMask" /> function so that it contains no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the access mask in <i>GrantedAccess</i> to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="AuditType">
      <para>The type of audit to be generated. This can be one of the values from the
<see cref="AUDIT_EVENT_TYPE" /> enumeration type.</para>
    </param>
    <param name="Flags">
      <para>A flag that controls the function's behavior if the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.</para>
    </param>
    <param name="ObjectTypeList">
      <para>A pointer to an array of
<see cref="OBJECT_TYPE_LIST" /> structures that identify the hierarchy of object types for which to check access. Each element in the array specifies a GUID that identifies the object type and a value that indicates the level of the object type in the hierarchy of object types. The array should not have two elements with the same GUID.</para>
      <para>The array must have at least one element. The first element in the array must be at level zero and identify the object itself. The array can have only one level zero element. The second element is a subobject, such as a property set, at level 1. Following each level 1 entry are subordinate entries for the level 2 through 4 subobjects. Thus, the levels for the elements in the array might be {0, 1, 2, 2, 1, 2, 3}. If the object type list is out of order, <b>AccessCheckByTypeResultListAndAuditAlarm</b> fails, and
<see cref="GetLastError" /> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <param name="ObjectTypeListLength">
      <para>The number of elements in the <i>ObjectTypeList</i> array.</para>
    </param>
    <param name="GenericMapping">
      <para>A pointer to the
<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</para>
    </param>
    <param name="ObjectCreation">
      <para>A flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</para>
    </param>
    <param name="GrantedAccess">
      <para>A pointer to an array of access masks. The function sets each access mask to indicate the access rights granted to the corresponding element in the object type list. If the function fails, it does not set the access masks.</para>
    </param>
    <param name="AccessStatusList">
      <para>A pointer to an array of status codes for the corresponding elements in the object type list. The function sets an element to zero to indicate success or to a nonzero value to indicate the specific error during the access check. If the function fails, it does not set any of the elements in the array.</para>
    </param>
    <param name="pfGenerateOnClose">
      <para>A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the
<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For more information, see the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</a> overview.</para>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarm</b> function is a combination of the
<see cref="AccessCheckByTypeResultList" /> and
<see cref="AccessCheckAndAuditAlarm" /> functions.</para>
      <para>The <i>ObjectTypeList</i> array does not necessarily represent the entire defined object. Rather, it represents that subset of the object for which to check access. For instance, to check access to two properties in a property set, specify an object type list with four elements: the object itself at level zero, the property set at level 1, and the two properties at level 2.</para>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarm</b> function evaluates ACEs that apply to the object itself and object-specific ACEs for the object types listed in the <i>ObjectTypeList</i> array. The function ignores object-specific ACEs for object types not listed in the <i>ObjectTypeList</i> array.</para>
      <para>For more information about how a hierarchy of ACEs controls access to an object and its subobjects, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/aces-to-control-access-to-an-object-s-properties">ACEs to Control Access to an Object's Properties</a>.</para>
      <para>To generate audit messages in the security event log, the calling process must have the SE_AUDIT_NAME privilege enabled. The system checks for this privilege in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling process, not the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> of the thread. If the <i>Flags</i> parameter includes the AUDIT_ALLOW_NO_PRIVILEGE flag, the function performs the access check without generating audit messages when the privilege is not enabled.</para>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarm</b> function fails if the calling thread is not impersonating a client.</para>
      <para>If the security descriptor does not contain owner and group SIDs, <b>AccessCheckByTypeResultListAndAuditAlarm</b> fails with ERROR_INVALID_SECURITY_DESCR.</para>
    </remarks>
    <seealso cref="AUDIT_EVENT_TYPE" />
    <seealso cref="AccessCheck" />
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso cref="AccessCheckByType" />
    <seealso cref="AccessCheckByTypeResultList" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="GENERIC_MAPPING" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</seealso>
    <seealso cref="MakeAbsoluteSD" />
    <seealso cref="MapGenericMask" />
    <seealso cref="OBJECT_TYPE_LIST" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="PRIVILEGE_SET" />
    <seealso cref="SECURITY_DESCRIPTOR" />
  </member>
  <member name="Windows.AccessCheckByTypeResultListAndAuditAlarmByHandle">
    <summary>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client that the calling thread is impersonating. The difference between this function and
<see cref="AccessCheckByTypeResultListAndAuditAlarm" /> is that this function allows the calling thread to perform the access check before impersonating the client.</para>
      <para>The function can check access to a hierarchy of objects, such as an object, its property sets, and properties. The function reports the access rights granted or denied to each object type in the hierarchy. If the security descriptor has a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) with <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control entries</a> (ACEs) that apply to the client, the function generates any necessary audit messages in the security event log. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.</para>
    </param>
    <param name="ClientToken">
      <para>A handle to a token object that represents the client that requested the operation. This handle must be obtained through a communication session layer, such as a local named pipe, to prevent possible security policy violations. The caller must have TOKEN_QUERY access for the specified token.</para>
    </param>
    <param name="ObjectTypeName">
      <para>A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="ObjectName">
      <para>A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="SecurityDescriptor">
      <para>A pointer to a
<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</para>
    </param>
    <param name="PrincipalSelfSid">
      <para>A pointer to a SID. If the security descriptor is associated with an object that represents a principal (for example, a user object), the <i>PrincipalSelfSid</i> parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE containing the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-known SIDs</a>.</para>
      <para>Set this parameter to <b>NULL</b> if the protected object does not represent a principal.</para>
    </param>
    <param name="DesiredAccess">
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the access rights to check. This mask must have been mapped by the
<see cref="MapGenericMask" /> function so that it contains no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the access mask in <i>GrantedAccess</i> to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="AuditType">
      <para>The type of audit to be generated. This can be one of the values from the
<see cref="AUDIT_EVENT_TYPE" /> enumeration type.</para>
    </param>
    <param name="Flags">
      <para>A flag that controls the function's behavior if the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.</para>
    </param>
    <param name="ObjectTypeList">
      <para>A pointer to an array of
<see cref="OBJECT_TYPE_LIST" /> structures that identify the hierarchy of object types for which to check access. Each element in the array specifies a GUID that identifies the object type and a value that indicates the level of the object type in the hierarchy of object types. The array should not have two elements with the same GUID.</para>
      <para>The array must have at least one element. The first element in the array must be at level zero and identify the object itself. The array can have only one level zero element. The second element is a subobject, such as a property set, at level 1. Following each level 1 entry are subordinate entries for the level 2 through 4 subobjects. Thus, the levels for the elements in the array might be {0, 1, 2, 2, 1, 2, 3}. If the object type list is out of order, <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> fails, and
<see cref="GetLastError" /> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <param name="ObjectTypeListLength">
      <para>The number of elements in the <i>ObjectTypeList</i> array.</para>
    </param>
    <param name="GenericMapping">
      <para>A pointer to the
<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</para>
    </param>
    <param name="ObjectCreation">
      <para>A flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</para>
    </param>
    <param name="GrantedAccess">
      <para>A pointer to an array of access masks. The function sets each access mask to indicate the access rights granted to the corresponding element in the object type list. If the function fails, it does not set the access masks.</para>
    </param>
    <param name="AccessStatusList">
      <para>A pointer to an array of status codes for the corresponding elements in the object type list. The function sets an element to zero to indicate success or to a nonzero value to indicate the specific error during the access check. If the function fails, it does not set any of the elements in the array.</para>
    </param>
    <param name="pfGenerateOnClose">
      <para>A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the
<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For more information, see the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</a> overview.</para>
      <para>Like
<see cref="AccessCheckByTypeResultListAndAuditAlarm" />, the <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> function is a combination of the
<see cref="AccessCheckByTypeResultList" /> and
<see cref="AccessCheckAndAuditAlarm" /> functions. However, <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> also requires a client token handle to provide security information on the client.</para>
      <para>The <i>ObjectTypeList</i> array does not necessarily represent the entire defined object. Rather, it represents that subset of the object for which to check access. For instance, to check access to two properties in a property set, specify an object type list with four elements: the object itself at level zero, the property set at level 1, and the two properties at level 2.</para>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> function evaluates ACEs that apply to the object itself and object-specific ACEs for the object types listed in the <i>ObjectTypeList</i> array. The function ignores object-specific ACEs for object types not listed in the <i>ObjectTypeList</i> array.</para>
      <para>For more information about how a hierarchy of ACEs controls access to an object and its subobjects, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/aces-to-control-access-to-an-object-s-properties">ACEs to Control Access to an Object's Properties</a>.</para>
      <para>To generate audit messages in the security event log, the calling process must have the SE_AUDIT_NAME privilege enabled. The system checks for this privilege in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling process, not the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> of the thread. If the <i>Flags</i> parameter includes the AUDIT_ALLOW_NO_PRIVILEGE flag, the function performs the access check without generating audit messages when the privilege is not enabled.</para>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> function fails if the calling thread is not impersonating a client.</para>
      <para>If the security descriptor does not contain owner and group SIDs, <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> fails with ERROR_INVALID_SECURITY_DESCR.</para>
    </remarks>
    <seealso cref="AUDIT_EVENT_TYPE" />
    <seealso cref="AccessCheck" />
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso cref="AccessCheckByType" />
    <seealso cref="AccessCheckByTypeResultList" />
    <seealso cref="AccessCheckByTypeResultListAndAuditAlarm" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="GENERIC_MAPPING" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</seealso>
    <seealso cref="MakeAbsoluteSD" />
    <seealso cref="MapGenericMask" />
    <seealso cref="OBJECT_TYPE_LIST" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="PRIVILEGE_SET" />
    <seealso cref="SECURITY_DESCRIPTOR" />
  </member>
  <member name="Windows.AccessCheckByTypeResultListAndAuditAlarmByHandleA">
    <summary>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client that the calling thread is impersonating. The difference between this function and
<see cref="AccessCheckByTypeResultListAndAuditAlarm" /> is that this function allows the calling thread to perform the access check before impersonating the client.</para>
      <para>The function can check access to a hierarchy of objects, such as an object, its property sets, and properties. The function reports the access rights granted or denied to each object type in the hierarchy. If the security descriptor has a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) with <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control entries</a> (ACEs) that apply to the client, the function generates any necessary audit messages in the security event log. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.</para>
    </param>
    <param name="ClientToken">
      <para>A handle to a token object that represents the client that requested the operation. This handle must be obtained through a communication session layer, such as a local named pipe, to prevent possible security policy violations. The caller must have TOKEN_QUERY access for the specified token.</para>
    </param>
    <param name="ObjectTypeName">
      <para>A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="ObjectName">
      <para>A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="SecurityDescriptor">
      <para>A pointer to a
<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</para>
    </param>
    <param name="PrincipalSelfSid">
      <para>A pointer to a SID. If the security descriptor is associated with an object that represents a principal (for example, a user object), the <i>PrincipalSelfSid</i> parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE containing the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-known SIDs</a>.</para>
      <para>Set this parameter to <b>NULL</b> if the protected object does not represent a principal.</para>
    </param>
    <param name="DesiredAccess">
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the access rights to check. This mask must have been mapped by the
<see cref="MapGenericMask" /> function so that it contains no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the access mask in <i>GrantedAccess</i> to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="AuditType">
      <para>The type of audit to be generated. This can be one of the values from the
<see cref="AUDIT_EVENT_TYPE" /> enumeration type.</para>
    </param>
    <param name="Flags">
      <para>A flag that controls the function's behavior if the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.</para>
    </param>
    <param name="ObjectTypeList">
      <para>A pointer to an array of
<see cref="OBJECT_TYPE_LIST" /> structures that identify the hierarchy of object types for which to check access. Each element in the array specifies a GUID that identifies the object type and a value that indicates the level of the object type in the hierarchy of object types. The array should not have two elements with the same GUID.</para>
      <para>The array must have at least one element. The first element in the array must be at level zero and identify the object itself. The array can have only one level zero element. The second element is a subobject, such as a property set, at level 1. Following each level 1 entry are subordinate entries for the level 2 through 4 subobjects. Thus, the levels for the elements in the array might be {0, 1, 2, 2, 1, 2, 3}. If the object type list is out of order, <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> fails, and
<see cref="GetLastError" /> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <param name="ObjectTypeListLength">
      <para>The number of elements in the <i>ObjectTypeList</i> array.</para>
    </param>
    <param name="GenericMapping">
      <para>A pointer to the
<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</para>
    </param>
    <param name="ObjectCreation">
      <para>A flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</para>
    </param>
    <param name="GrantedAccess">
      <para>A pointer to an array of access masks. The function sets each access mask to indicate the access rights granted to the corresponding element in the object type list. If the function fails, it does not set the access masks.</para>
    </param>
    <param name="AccessStatusList">
      <para>A pointer to an array of status codes for the corresponding elements in the object type list. The function sets an element to zero to indicate success or to a nonzero value to indicate the specific error during the access check. If the function fails, it does not set any of the elements in the array.</para>
    </param>
    <param name="pfGenerateOnClose">
      <para>A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the
<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For more information, see the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</a> overview.</para>
      <para>Like
<see cref="AccessCheckByTypeResultListAndAuditAlarm" />, the <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> function is a combination of the
<see cref="AccessCheckByTypeResultList" /> and
<see cref="AccessCheckAndAuditAlarm" /> functions. However, <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> also requires a client token handle to provide security information on the client.</para>
      <para>The <i>ObjectTypeList</i> array does not necessarily represent the entire defined object. Rather, it represents that subset of the object for which to check access. For instance, to check access to two properties in a property set, specify an object type list with four elements: the object itself at level zero, the property set at level 1, and the two properties at level 2.</para>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> function evaluates ACEs that apply to the object itself and object-specific ACEs for the object types listed in the <i>ObjectTypeList</i> array. The function ignores object-specific ACEs for object types not listed in the <i>ObjectTypeList</i> array.</para>
      <para>For more information about how a hierarchy of ACEs controls access to an object and its subobjects, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/aces-to-control-access-to-an-object-s-properties">ACEs to Control Access to an Object's Properties</a>.</para>
      <para>To generate audit messages in the security event log, the calling process must have the SE_AUDIT_NAME privilege enabled. The system checks for this privilege in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling process, not the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> of the thread. If the <i>Flags</i> parameter includes the AUDIT_ALLOW_NO_PRIVILEGE flag, the function performs the access check without generating audit messages when the privilege is not enabled.</para>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> function fails if the calling thread is not impersonating a client.</para>
      <para>If the security descriptor does not contain owner and group SIDs, <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> fails with ERROR_INVALID_SECURITY_DESCR.</para>
    </remarks>
    <seealso cref="AUDIT_EVENT_TYPE" />
    <seealso cref="AccessCheck" />
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso cref="AccessCheckByType" />
    <seealso cref="AccessCheckByTypeResultList" />
    <seealso cref="AccessCheckByTypeResultListAndAuditAlarm" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="GENERIC_MAPPING" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</seealso>
    <seealso cref="MakeAbsoluteSD" />
    <seealso cref="MapGenericMask" />
    <seealso cref="OBJECT_TYPE_LIST" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="PRIVILEGE_SET" />
    <seealso cref="SECURITY_DESCRIPTOR" />
  </member>
  <member name="Windows.AccessCheckByTypeResultListAndAuditAlarmByHandleW">
    <summary>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client that the calling thread is impersonating. The difference between this function and
<see cref="AccessCheckByTypeResultListAndAuditAlarm" /> is that this function allows the calling thread to perform the access check before impersonating the client.</para>
      <para>The function can check access to a hierarchy of objects, such as an object, its property sets, and properties. The function reports the access rights granted or denied to each object type in the hierarchy. If the security descriptor has a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) with <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control entries</a> (ACEs) that apply to the client, the function generates any necessary audit messages in the security event log. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.</para>
    </param>
    <param name="ClientToken">
      <para>A handle to a token object that represents the client that requested the operation. This handle must be obtained through a communication session layer, such as a local named pipe, to prevent possible security policy violations. The caller must have TOKEN_QUERY access for the specified token.</para>
    </param>
    <param name="ObjectTypeName">
      <para>A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="ObjectName">
      <para>A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="SecurityDescriptor">
      <para>A pointer to a
<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</para>
    </param>
    <param name="PrincipalSelfSid">
      <para>A pointer to a SID. If the security descriptor is associated with an object that represents a principal (for example, a user object), the <i>PrincipalSelfSid</i> parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE containing the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-known SIDs</a>.</para>
      <para>Set this parameter to <b>NULL</b> if the protected object does not represent a principal.</para>
    </param>
    <param name="DesiredAccess">
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the access rights to check. This mask must have been mapped by the
<see cref="MapGenericMask" /> function so that it contains no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the access mask in <i>GrantedAccess</i> to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="AuditType">
      <para>The type of audit to be generated. This can be one of the values from the
<see cref="AUDIT_EVENT_TYPE" /> enumeration type.</para>
    </param>
    <param name="Flags">
      <para>A flag that controls the function's behavior if the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.</para>
    </param>
    <param name="ObjectTypeList">
      <para>A pointer to an array of
<see cref="OBJECT_TYPE_LIST" /> structures that identify the hierarchy of object types for which to check access. Each element in the array specifies a GUID that identifies the object type and a value that indicates the level of the object type in the hierarchy of object types. The array should not have two elements with the same GUID.</para>
      <para>The array must have at least one element. The first element in the array must be at level zero and identify the object itself. The array can have only one level zero element. The second element is a subobject, such as a property set, at level 1. Following each level 1 entry are subordinate entries for the level 2 through 4 subobjects. Thus, the levels for the elements in the array might be {0, 1, 2, 2, 1, 2, 3}. If the object type list is out of order, <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> fails, and
<see cref="GetLastError" /> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <param name="ObjectTypeListLength">
      <para>The number of elements in the <i>ObjectTypeList</i> array.</para>
    </param>
    <param name="GenericMapping">
      <para>A pointer to the
<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</para>
    </param>
    <param name="ObjectCreation">
      <para>A flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</para>
    </param>
    <param name="GrantedAccess">
      <para>A pointer to an array of access masks. The function sets each access mask to indicate the access rights granted to the corresponding element in the object type list. If the function fails, it does not set the access masks.</para>
    </param>
    <param name="AccessStatusList">
      <para>A pointer to an array of status codes for the corresponding elements in the object type list. The function sets an element to zero to indicate success or to a nonzero value to indicate the specific error during the access check. If the function fails, it does not set any of the elements in the array.</para>
    </param>
    <param name="pfGenerateOnClose">
      <para>A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the
<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For more information, see the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</a> overview.</para>
      <para>Like
<see cref="AccessCheckByTypeResultListAndAuditAlarm" />, the <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> function is a combination of the
<see cref="AccessCheckByTypeResultList" /> and
<see cref="AccessCheckAndAuditAlarm" /> functions. However, <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> also requires a client token handle to provide security information on the client.</para>
      <para>The <i>ObjectTypeList</i> array does not necessarily represent the entire defined object. Rather, it represents that subset of the object for which to check access. For instance, to check access to two properties in a property set, specify an object type list with four elements: the object itself at level zero, the property set at level 1, and the two properties at level 2.</para>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> function evaluates ACEs that apply to the object itself and object-specific ACEs for the object types listed in the <i>ObjectTypeList</i> array. The function ignores object-specific ACEs for object types not listed in the <i>ObjectTypeList</i> array.</para>
      <para>For more information about how a hierarchy of ACEs controls access to an object and its subobjects, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/aces-to-control-access-to-an-object-s-properties">ACEs to Control Access to an Object's Properties</a>.</para>
      <para>To generate audit messages in the security event log, the calling process must have the SE_AUDIT_NAME privilege enabled. The system checks for this privilege in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling process, not the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> of the thread. If the <i>Flags</i> parameter includes the AUDIT_ALLOW_NO_PRIVILEGE flag, the function performs the access check without generating audit messages when the privilege is not enabled.</para>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> function fails if the calling thread is not impersonating a client.</para>
      <para>If the security descriptor does not contain owner and group SIDs, <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> fails with ERROR_INVALID_SECURITY_DESCR.</para>
    </remarks>
    <seealso cref="AUDIT_EVENT_TYPE" />
    <seealso cref="AccessCheck" />
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso cref="AccessCheckByType" />
    <seealso cref="AccessCheckByTypeResultList" />
    <seealso cref="AccessCheckByTypeResultListAndAuditAlarm" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="GENERIC_MAPPING" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/how-dacls-control-access-to-an-object">How AccessCheck Works</seealso>
    <seealso cref="MakeAbsoluteSD" />
    <seealso cref="MapGenericMask" />
    <seealso cref="OBJECT_TYPE_LIST" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="PRIVILEGE_SET" />
    <seealso cref="SECURITY_DESCRIPTOR" />
  </member>
  <member name="Windows.ActivateActCtx">
    <summary>
      <para>The
<b>ActivateActCtx</b> function activates the specified activation context. It does this by pushing the specified activation context to the top of the activation stack. The specified activation context is thus associated with the current thread and any appropriate side-by-side API functions.</para>
    </summary>
    <param name="hActCtx">
      <para>Handle to an
<see cref="ACTCTX" /> structure that contains information on the activation context that is to be made active.</para>
    </param>
    <param name="lpCookie">
      <para>Pointer to a <b>ULONG_PTR</b> that functions as a cookie, uniquely identifying a specific, activated activation context.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling
<see cref="GetLastError" />. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
    <remarks>
      <para>The <i>lpCookie</i> parameter is later passed to
<see cref="DeactivateActCtx" />, which verifies the pairing of calls to
<b>ActivateActCtx</b> and
<b>DeactivateActCtx</b> and ensures that the appropriate activation context is being deactivated. This is done because the deactivation of activation contexts must occur in the reverse order of activation.</para>
      <para>The activation of activation contexts can be understood as pushing an activation context onto a stack of activation contexts. The activation context you activate through this function  redirects any binding to DLLs, window classes, COM servers, type libraries, and mutexes for any side-by-side APIs you call.</para>
      <para>The top item of an activation context stack is the active, default-activation context of the current thread. If a null activation context handle is pushed onto the stack, thereby activating it, the default settings in the original manifest override all activation contexts that are lower on the stack.</para>
    </remarks>
    <seealso cref="ACTCTX" />
    <seealso cref="DeactivateActCtx" />
  </member>
  <member name="Windows.AddAtom">
    <summary>
      <para>Adds a character string to the local atom table and returns a unique value (an atom) identifying the string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings differing only in case are considered identical. The case of the first string added is preserved and returned by the <see cref="GetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>AddAtom</b> function stores no more than one copy of a given string in the atom table. If the string is already in the table, the function returns the existing atom and, in the case of a string atom, increments the string's reference count.</para>
      <para>If
<i>lpString</i> has the form "#1234", <b>AddAtom</b> returns an integer atom whose value is the 16-bit representation of the decimal number specified in the string (0x04D2, in this example). If the decimal value specified is 0x0000 or is greater than or equal to 0xC000, the return value is zero, indicating an error. If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <para>If
<i>lpString</i> has any other form, <b>AddAtom</b> returns a string atom.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines AddAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GetAtomName" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="GlobalGetAtomName" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.AddAtomA">
    <summary>
      <para>Adds a character string to the local atom table and returns a unique value (an atom) identifying the string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings differing only in case are considered identical. The case of the first string added is preserved and returned by the <see cref="GetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>AddAtom</b> function stores no more than one copy of a given string in the atom table. If the string is already in the table, the function returns the existing atom and, in the case of a string atom, increments the string's reference count.</para>
      <para>If
<i>lpString</i> has the form "#1234", <b>AddAtom</b> returns an integer atom whose value is the 16-bit representation of the decimal number specified in the string (0x04D2, in this example). If the decimal value specified is 0x0000 or is greater than or equal to 0xC000, the return value is zero, indicating an error. If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <para>If
<i>lpString</i> has any other form, <b>AddAtom</b> returns a string atom.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines AddAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GetAtomName" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="GlobalGetAtomName" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.AddAtomW">
    <summary>
      <para>Adds a character string to the local atom table and returns a unique value (an atom) identifying the string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings differing only in case are considered identical. The case of the first string added is preserved and returned by the <see cref="GetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>AddAtom</b> function stores no more than one copy of a given string in the atom table. If the string is already in the table, the function returns the existing atom and, in the case of a string atom, increments the string's reference count.</para>
      <para>If
<i>lpString</i> has the form "#1234", <b>AddAtom</b> returns an integer atom whose value is the 16-bit representation of the decimal number specified in the string (0x04D2, in this example). If the decimal value specified is 0x0000 or is greater than or equal to 0xC000, the return value is zero, indicating an error. If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <para>If
<i>lpString</i> has any other form, <b>AddAtom</b> returns a string atom.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines AddAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GetAtomName" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="GlobalGetAtomName" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.AddAtom">
    <summary>
      <para>Adds a character string to the local atom table and returns a unique value (an atom) identifying the string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings differing only in case are considered identical. The case of the first string added is preserved and returned by the <see cref="GetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>AddAtom</b> function stores no more than one copy of a given string in the atom table. If the string is already in the table, the function returns the existing atom and, in the case of a string atom, increments the string's reference count.</para>
      <para>If
<i>lpString</i> has the form "#1234", <b>AddAtom</b> returns an integer atom whose value is the 16-bit representation of the decimal number specified in the string (0x04D2, in this example). If the decimal value specified is 0x0000 or is greater than or equal to 0xC000, the return value is zero, indicating an error. If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <para>If
<i>lpString</i> has any other form, <b>AddAtom</b> returns a string atom.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines AddAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GetAtomName" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="GlobalGetAtomName" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.AddAtomA">
    <summary>
      <para>Adds a character string to the local atom table and returns a unique value (an atom) identifying the string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings differing only in case are considered identical. The case of the first string added is preserved and returned by the <see cref="GetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>AddAtom</b> function stores no more than one copy of a given string in the atom table. If the string is already in the table, the function returns the existing atom and, in the case of a string atom, increments the string's reference count.</para>
      <para>If
<i>lpString</i> has the form "#1234", <b>AddAtom</b> returns an integer atom whose value is the 16-bit representation of the decimal number specified in the string (0x04D2, in this example). If the decimal value specified is 0x0000 or is greater than or equal to 0xC000, the return value is zero, indicating an error. If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <para>If
<i>lpString</i> has any other form, <b>AddAtom</b> returns a string atom.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines AddAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GetAtomName" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="GlobalGetAtomName" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.AddAtomW">
    <summary>
      <para>Adds a character string to the local atom table and returns a unique value (an atom) identifying the string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings differing only in case are considered identical. The case of the first string added is preserved and returned by the <see cref="GetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>AddAtom</b> function stores no more than one copy of a given string in the atom table. If the string is already in the table, the function returns the existing atom and, in the case of a string atom, increments the string's reference count.</para>
      <para>If
<i>lpString</i> has the form "#1234", <b>AddAtom</b> returns an integer atom whose value is the 16-bit representation of the decimal number specified in the string (0x04D2, in this example). If the decimal value specified is 0x0000 or is greater than or equal to 0xC000, the return value is zero, indicating an error. If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <para>If
<i>lpString</i> has any other form, <b>AddAtom</b> returns a string atom.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines AddAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GetAtomName" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="GlobalGetAtomName" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.AddConditionalAce">
    <summary>
      <para>The <b>AddConditionalAce</b> function adds a conditional  <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control entry</a> (ACE) to the specified <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control list</a> (ACL). A conditional ACE specifies a logical condition that is evaluated during access checks.</para>
    </summary>
    <param name="pAcl">
      <para>A pointer to an
ACL. This function adds an ACE to this ACL.</para>
      <para>The value of this parameter cannot be <b>NULL</b>.</para>
    </param>
    <param name="dwAceRevision">
      <para>Specifies the revision level of the ACL being modified. This value can be ACL_REVISION or ACL_REVISION_DS.
Use ACL_REVISION_DS if the ACL contains object-specific ACEs.</para>
    </param>
    <param name="AceFlags">
      <para>A set of bit flags that control ACE inheritance. The function sets these flags in the <b>AceFlags</b> member of the
<see cref="ACE_HEADER" /> structure of the new ACE. This parameter can be a combination of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>CONTAINER_INHERIT_ACE</b>
          </description>
          <description>
            <para>The ACE is inherited by container objects.</para>
          </description>
        </item>
        <item>
          <description>
            <b>INHERIT_ONLY_ACE</b>
          </description>
          <description>
            <para>The ACE does not apply to the object to which the ACL is assigned, but it can be inherited by child objects.</para>
          </description>
        </item>
        <item>
          <description>
            <b>INHERITED_ACE</b>
          </description>
          <description>
            <para>Indicates an inherited ACE. This flag allows operations that change the security on a tree of objects to modify inherited ACEs while not changing ACEs that were directly applied to the object.</para>
          </description>
        </item>
        <item>
          <description>
            <b>NO_PROPAGATE_INHERIT_ACE</b>
          </description>
          <description>
            <para>The OBJECT_INHERIT_ACE and CONTAINER_INHERIT_ACE bits are not propagated to an inherited ACE.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OBJECT_INHERIT_ACE</b>
          </description>
          <description>
            <para>The ACE is inherited by noncontainer objects.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="AceType">
      <para>The type of the ACE.</para>
      <para>This can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ACCESS_ALLOWED_CALLBACK_ACE_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x9</description>
              </item>
            </list>
          </description>
          <description>
            <para>Access-allowed callback ACE that uses the
<see cref="ACCESS_ALLOWED_CALLBACK_ACE" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ACCESS_DENIED_CALLBACK_ACE_TYPE</b>
                </description>
              </item>
              <item>
                <description>0xA</description>
              </item>
            </list>
          </description>
          <description>
            <para>Access-denied callback ACE that uses the
<see cref="ACCESS_DENIED_CALLBACK_ACE" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SYSTEM_AUDIT_CALLBACK_ACE_TYPE</b>
                </description>
              </item>
              <item>
                <description>0xD</description>
              </item>
            </list>
          </description>
          <description>
            <para>System audit callback ACE that uses the
<see cref="SYSTEM_AUDIT_CALLBACK_ACE" /> structure.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="AccessMask">
      <para>Specifies the mask of access rights to be granted to the specified SID.</para>
    </param>
    <param name="pSid">
      <para>A pointer to the
SID  that represents a user, group, or logon account being granted access.</para>
    </param>
    <param name="ConditionStr">
      <para>A string that specifies the conditional statement to be evaluated for the ACE.</para>
    </param>
    <param name="ReturnLength">
      <para>The size, in bytes, of the ACL. If the buffer specified by the <i>pACL</i> parameter is not of sufficient size, the value of this parameter is the required size.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>.</para>
      <para>If the function fails, it returns <b>FALSE</b>. For extended error information, call
<see cref="GetLastError" />. The following are possible error values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INSUFFICIENT_BUFFER</b>
            </para>
          </description>
          <description>
            <para>The new ACE does not fit into the <i>pAcl</i> buffer.</para>
          </description>
        </item>
      </list>
    </returns>
  </member>
  <member name="Windows.AddIntegrityLabelToBoundaryDescriptor">
    <summary>
      <para>Adds a new required security identifier (SID) to the specified boundary descriptor.</para>
    </summary>
    <param name="BoundaryDescriptor">
      <para>A handle to the boundary descriptor. The <see cref="CreateBoundaryDescriptor" /> function returns this handle.</para>
    </param>
    <param name="IntegrityLabel">
      <para>A pointer to a <see cref="SID" /> structure that represents the mandatory integrity level for the namespace. Use one of the following RID values to create the SID:</para>
      <para>
        <b>SECURITY_MANDATORY_UNTRUSTED_RID</b>
        <b>SECURITY_MANDATORY_LOW_RID</b>
        <b>SECURITY_MANDATORY_MEDIUM_RID</b>
        <b>SECURITY_MANDATORY_SYSTEM_RID</b>
        <b>SECURITY_MANDATORY_PROTECTED_PROCESS_RID</b>
      </para>
      <para>For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-Known SIDs</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>A process can create a private namespace only with an integrity level that is  equal to or lower than the  current integrity level of the process. Therefore, a high integrity-level process can create a high, medium or low integrity-level namespace. A medium integrity-level process can create only a medium or low integrity-level namespace.</para>
      <para>A process would usually specify a namespace at the same integrity level as the process for protection against squatting attacks by lower integrity-level processes.</para>
      <para>The security descriptor that the creator places on the namespace determines who can open the namespace. So a low or medium integrity-level process could be given permission to open a high integrity level namespace if the security descriptor of the namespace permits it.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0601 or later.</para>
    </remarks>
    <seealso cref="CreateBoundaryDescriptor" />
  </member>
  <member name="Windows.AddRefActCtx">
    <summary>
      <para>The
<b>AddRefActCtx</b> function increments the reference count of the specified activation context.</para>
    </summary>
    <param name="hActCtx">
      <para>Handle to an
<see cref="ACTCTX" /> structure that contains information on the activation context for which the reference count is to be incremented.</para>
    </param>
    <remarks>
      <para>This function is provided so that multiple clients can access a single activation context.</para>
    </remarks>
    <seealso cref="ACTCTX" />
  </member>
  <member name="Windows.AddSecureMemoryCacheCallback">
    <summary>
      <para>Registers a callback function to be called when a secured memory range is freed or its protections are
changed.</para>
    </summary>
    <param name="pfnCallBack">
      <para>A pointer to the application-defined
<a href="https://docs.microsoft.com//windows/desktop/api/winnt/nc-winnt-psecure_memory_cache_callback">SecureMemoryCacheCallback</a> function to
register.</para>
    </param>
    <returns>
      <para>If the function succeeds, it registers the callback function and returns
<b>TRUE</b>.</para>
      <para>If the function fails, it returns <b>FALSE</b>. To get extended error information, call
the <see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>An application that performs I/O directly to a high-performance device typically caches a virtual-to-physical
memory mapping for the buffer it uses for the I/O. The device's driver typically secures this memory address range
by calling the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-mmsecurevirtualmemory">MmSecureVirtualMemory</a> routine,
which prevents the memory range from being freed or its protections  changed until the driver unsecures the
memory.</para>
      <para>An application can use
<b>AddSecureMemoryCacheCallback</b> to register
a callback function that will be called when the memory is freed or its protections are changed, so the
application can invalidate its cached memory mapping. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/api/winnt/nc-winnt-psecure_memory_cache_callback">SecureMemoryCacheCallback</a>.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0600
or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="RemoveSecureMemoryCacheCallback" />
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winnt/nc-winnt-psecure_memory_cache_callback">SecureMemoryCacheCallback</seealso>
  </member>
  <member name="Windows.ApplicationRecoveryFinished">
    <summary>
      <para>Indicates that  the calling application has completed its data recovery.</para>
    </summary>
    <param name="bSuccess">
      <para>Specify <b>TRUE</b> to indicate that the data was successfully recovered; otherwise, <b>FALSE</b>.</para>
    </param>
    <remarks>
      <para>This should be the last call that you make in your callback because your application terminates as soon as this function is called.</para>
    </remarks>
    <seealso cref="ApplicationRecoveryInProgress" />
    <seealso cref="RegisterApplicationRecoveryCallback" />
  </member>
  <member name="Windows.ApplicationRecoveryInProgress">
    <summary>
      <para>Indicates that  the calling application is continuing to recover data.</para>
    </summary>
    <param name="pbCancelled">
      <para>Indicates whether the user has canceled the recovery process. Set by WER if the user clicks the Cancel button.</para>
    </param>
    <returns>
      <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>E_FAIL</b>
            </para>
          </description>
          <description>
            <para>You can call this function only after Windows Error Reporting has called your recovery callback function.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>The <i>pbCancelled</i> cannot be <b>NULL</b>.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The application must call this function within the interval specified when calling the <see cref="RegisterApplicationRecoveryCallback" /> function. If the application fails to call this function within the specified interval, WER terminates the application. The recovery process can continue as long as this function is being called.</para>
      <para>If the user cancels the recovery process, the application should terminate.</para>
      <para>To indicate that the recovery process has been completed, call the <see cref="ApplicationRecoveryFinished" /> function.</para>
    </remarks>
    <seealso cref="ApplicationRecoveryFinished" />
    <seealso cref="RegisterApplicationRecoveryCallback" />
  </member>
  <member name="Windows.BackupEventLog">
    <summary>
      <para>Saves the specified event log to a backup file. The function does not clear the event log.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the open event log. The <see cref="OpenEventLog" /> function returns this handle.</para>
    </param>
    <param name="lpBackupFileName">
      <para>The absolute or relative path of the backup file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>BackupEventLog</b> function fails with the ERROR_PRIVILEGE_NOT_HELD error if the user does not have the SE_BACKUP_NAME privilege.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BackupEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="OpenBackupEventLog" />
    <seealso cref="OpenEventLog" />
  </member>
  <member name="Windows.BackupEventLogA">
    <summary>
      <para>Saves the specified event log to a backup file. The function does not clear the event log.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the open event log. The <see cref="OpenEventLog" /> function returns this handle.</para>
    </param>
    <param name="lpBackupFileName">
      <para>The absolute or relative path of the backup file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>BackupEventLog</b> function fails with the ERROR_PRIVILEGE_NOT_HELD error if the user does not have the SE_BACKUP_NAME privilege.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BackupEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="OpenBackupEventLog" />
    <seealso cref="OpenEventLog" />
  </member>
  <member name="Windows.BackupEventLogW">
    <summary>
      <para>Saves the specified event log to a backup file. The function does not clear the event log.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the open event log. The <see cref="OpenEventLog" /> function returns this handle.</para>
    </param>
    <param name="lpBackupFileName">
      <para>The absolute or relative path of the backup file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>BackupEventLog</b> function fails with the ERROR_PRIVILEGE_NOT_HELD error if the user does not have the SE_BACKUP_NAME privilege.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BackupEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="OpenBackupEventLog" />
    <seealso cref="OpenEventLog" />
  </member>
  <member name="Windows.BackupEventLog">
    <summary>
      <para>Saves the specified event log to a backup file. The function does not clear the event log.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the open event log. The <see cref="OpenEventLog" /> function returns this handle.</para>
    </param>
    <param name="lpBackupFileName">
      <para>The absolute or relative path of the backup file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>BackupEventLog</b> function fails with the ERROR_PRIVILEGE_NOT_HELD error if the user does not have the SE_BACKUP_NAME privilege.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BackupEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="OpenBackupEventLog" />
    <seealso cref="OpenEventLog" />
  </member>
  <member name="Windows.BackupEventLogA">
    <summary>
      <para>Saves the specified event log to a backup file. The function does not clear the event log.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the open event log. The <see cref="OpenEventLog" /> function returns this handle.</para>
    </param>
    <param name="lpBackupFileName">
      <para>The absolute or relative path of the backup file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>BackupEventLog</b> function fails with the ERROR_PRIVILEGE_NOT_HELD error if the user does not have the SE_BACKUP_NAME privilege.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BackupEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="OpenBackupEventLog" />
    <seealso cref="OpenEventLog" />
  </member>
  <member name="Windows.BackupEventLogW">
    <summary>
      <para>Saves the specified event log to a backup file. The function does not clear the event log.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the open event log. The <see cref="OpenEventLog" /> function returns this handle.</para>
    </param>
    <param name="lpBackupFileName">
      <para>The absolute or relative path of the backup file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>BackupEventLog</b> function fails with the ERROR_PRIVILEGE_NOT_HELD error if the user does not have the SE_BACKUP_NAME privilege.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BackupEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="OpenBackupEventLog" />
    <seealso cref="OpenEventLog" />
  </member>
  <member name="Windows.BackupRead">
    <summary>
      <para>The <b>BackupRead</b> function can be used to back up
a file or directory, including the security information. The function reads data associated with a
specified file or directory into a buffer, which can then be written to the backup medium using the
<see cref="WriteFile" /> function.</para>
    </summary>
    <param name="hFile">
      <para>Handle to the file or directory to be backed up. To obtain the handle, call the <see cref="CreateFile" /> function. The SACLs are not read unless the file handle was created with the <b>ACCESS_SYSTEM_SECURITY</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/file-security-and-access-rights">File security and access rights</a>.</para>
      <para>The handle must be synchronous (nonoverlapped). This means that the <b>FILE_FLAG_OVERLAPPED</b> flag must not be set when <see cref="CreateFile" /> is called. This function does not validate that the handle it receives is synchronous, so it does not return an error code for a synchronous handle, but calling it with an asynchronous (overlapped) handle can result in subtle errors that are very difficult to debug.</para>
      <para>The <b>BackupRead</b> function may fail if
<b>CreateFile</b> was called with the flag
<b>FILE_FLAG_NO_BUFFERING</b>. In this case, the
<see cref="GetLastError" /> function returns the value
<b>ERROR_INVALID_PARAMETER</b>.</para>
    </param>
    <param name="lpBuffer">
      <para>Pointer to a buffer that receives the data.</para>
    </param>
    <param name="nNumberOfBytesToRead">
      <para>Length of the buffer, in bytes. The buffer size must be greater than the size of a
<see cref="WIN32_STREAM_ID" /> structure.</para>
    </param>
    <param name="lpNumberOfBytesRead">
      <para>Pointer to a variable that receives the number of bytes read.</para>
      <para>If the function returns a nonzero value, and the variable pointed to by
<i>lpNumberOfBytesRead</i> is zero, then all the data associated with the file handle has
been read.</para>
    </param>
    <param name="bAbort">
      <para>Indicates whether you have finished using <b>BackupRead</b></para>
      <para>on the handle. While you are backing up the file, specify this parameter as <b>FALSE</b>.
Once you are done using <b>BackupRead</b>, you must call
<b>BackupRead</b> one more time specifying
<b>TRUE</b> for this parameter and passing the appropriate
<i>lpContext</i>. <i>lpContext</i> must be passed when
<i>bAbort</i> is <b>TRUE</b>; all other parameters are ignored.</para>
    </param>
    <param name="bProcessSecurity">
      <para>Indicates whether the function will restore the access-control list (ACL) data for the file or directory.</para>
      <para>If <i>bProcessSecurity</i> is <b>TRUE</b>, the ACL data will be backed
up.</para>
    </param>
    <param name="lpContext">
      <para>Pointer to a variable that receives a pointer to an internal data structure used by
<b>BackupRead</b> to maintain context information during a
backup operation.</para>
      <para>You must set the variable pointed to by <i>lpContext</i> to <b>NULL</b></para>
      <para>before the first call to <b>BackupRead</b> for the specified
file or directory. The function allocates memory for the data structure, and then sets the variable to point to
that structure. You must not change <i>lpContext</i> or the variable that it points to
between calls to <b>BackupRead</b>.</para>
      <para>To release the memory used by the data structure, call
<b>BackupRead</b> with the
<i>bAbort</i> parameter set to <b>TRUE</b> when the backup operation is complete.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero, indicating that an I/O error occurred. To get extended
error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function is not intended for use in backing up files encrypted under the
Encrypted File System. Use
<see cref="ReadEncryptedFileRaw" /> for that purpose.</para>
      <para>If an error occurs while <b>BackupRead</b> is reading data,
the calling process can skip the bad data by calling the
<see cref="BackupSeek" /> function.</para>
      <para>The file or directory should be restored using the
<see cref="BackupWrite" /> function.</para>
    </remarks>
    <seealso cref="BackupSeek" />
    <seealso cref="BackupWrite" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Backup/creating-a-backup-application">Creating a Backup Application</seealso>
    <seealso cref="ReadEncryptedFileRaw" />
    <seealso cref="WIN32_STREAM_ID" />
  </member>
  <member name="Windows.BackupSeek">
    <summary>
      <para>The
<b>BackupSeek</b> function seeks forward in a data stream initially accessed by using the
<see cref="BackupRead" /> or
<see cref="BackupWrite" /> function.</para>
    </summary>
    <param name="hFile">
      <para>Handle to the file or directory. This handle is created by using the
<see cref="CreateFile" /> function.</para>
      <para>The handle must be synchronous (nonoverlapped). This means that the FILE_FLAG_OVERLAPPED flag must not be set when <see cref="CreateFile" /> is called. This function does not validate that the handle it receives is synchronous, so it does not return an error code for a synchronous handle, but calling it with an asynchronous (overlapped) handle can result in subtle errors that are very difficult to debug.</para>
    </param>
    <param name="dwLowBytesToSeek">
      <para>Low-order part of the number of bytes to seek.</para>
    </param>
    <param name="dwHighBytesToSeek">
      <para>High-order part of the number of bytes to seek.</para>
    </param>
    <param name="lpdwLowByteSeeked">
      <para>Pointer to a variable that receives the low-order bits of the number of bytes the function actually seeks.</para>
    </param>
    <param name="lpdwHighByteSeeked">
      <para>Pointer to a variable that receives the high-order bits of the number of bytes the function actually seeks.</para>
    </param>
    <param name="lpContext">
      <para>Pointer to an internal data structure used by the function. This structure must be the same structure that was initialized by the
<see cref="BackupRead" /> or <see cref="BackupWrite" /> function. An application must not touch the contents of this structure.</para>
    </param>
    <returns>
      <para>If the function could seek the requested amount, the function returns a nonzero value.</para>
      <para>If the function could not seek the requested amount, the function returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Applications use the <b>BackupSeek</b> function to skip portions of a data stream that cause errors. This function does not seek across stream headers. For example, this function cannot be used to skip the stream name. If an application attempts to seek past the end of a substream, the function fails, the <i>lpdwLowByteSeeked</i> and <i>lpdwHighByteSeeked</i> parameters indicate the actual number of bytes the function seeks, and the file position is placed at the start of the next stream header.</para>
    </remarks>
    <seealso cref="BackupRead" />
    <seealso cref="BackupWrite" />
    <seealso cref="CreateFile" />
  </member>
  <member name="Windows.BackupWrite">
    <summary>
      <para>The <b>BackupWrite</b> function can be used to
restore a file or directory that was backed up using
<see cref="BackupRead" />. Use the
<see cref="ReadFile" /> function to get a stream of data from the backup
medium, then use <b>BackupWrite</b> to write the data to the specified file or
directory.</para>
    </summary>
    <param name="hFile">
      <para>Handle to the file or directory to be restored. To obtain the handle, call the <see cref="CreateFile" /> function. The SACLs are not restored unless the file handle was created with the <b>ACCESS_SYSTEM_SECURITY</b> access right. To ensure that the integrity ACEs are restored correctly, the file handle must also have been created with the <b>WRITE_OWNER</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/file-security-and-access-rights">File security and access rights</a>.</para>
      <para>The handle must be synchronous (nonoverlapped). This means that the <b>FILE_FLAG_OVERLAPPED</b> flag must not be set when <see cref="CreateFile" /> is called. This function does not validate that the handle it receives is synchronous, so it does not return an error code for a synchronous handle, but calling it with an asynchronous (overlapped) handle can result in subtle errors that are very difficult to debug.</para>
      <para>The <b>BackupWrite</b> function may fail if
<see cref="CreateFile" /> was called with the flag
<b>FILE_FLAG_NO_BUFFERING</b>. In this case, the
<see cref="GetLastError" /> function returns the value
<b>ERROR_INVALID_PARAMETER</b>.</para>
    </param>
    <param name="lpBuffer">
      <para>Pointer to a buffer that the function writes data from.</para>
    </param>
    <param name="nNumberOfBytesToWrite">
      <para>Size of the buffer, in bytes. The buffer size must be greater than the size of a
<see cref="WIN32_STREAM_ID" /> structure.</para>
    </param>
    <param name="lpNumberOfBytesWritten">
      <para>Pointer to a variable that receives the number of bytes written.</para>
    </param>
    <param name="bAbort">
      <para>Indicates whether you have finished using <b>BackupWrite</b> on the handle.
While you are restoring the file, specify this parameter as <b>FALSE</b>. After you are done
using <b>BackupWrite</b>, you must call <b>BackupWrite</b></para>
      <para>one more time specifying <b>TRUE</b> for this parameter and passing the appropriate
<i>lpContext</i>. <i>lpContext</i> must be passed when
<i>bAbort</i> is <b>TRUE</b>; all other parameters are ignored.</para>
    </param>
    <param name="bProcessSecurity">
      <para>Specifies whether the function will restore the access-control list (ACL) data for the file or directory.</para>
      <para>If <i>bProcessSecurity</i> is <b>TRUE</b>, you need to specify
<b>WRITE_OWNER</b> and <b>WRITE_DAC</b> access when opening the file or
directory handle. If the handle does not have those access rights, the operating system denies access to the
ACL data, and ACL data restoration will not occur.</para>
    </param>
    <param name="lpContext">
      <para>Pointer to a variable that receives a pointer to an internal data structure used by
<b>BackupWrite</b> to maintain context information during a restore operation.</para>
      <para>You must set the variable pointed to by <i>lpContext</i> to <b>NULL</b></para>
      <para>before the first call to <b>BackupWrite</b> for the specified file or directory. The
function allocates memory for the data structure, and then sets the variable to point to that structure. You
must not change <i>lpContext</i> or the variable that it points to between calls to
<b>BackupWrite</b>.</para>
      <para>To release the memory used by the data structure, call <b>BackupWrite</b> with the
<i>bAbort</i> parameter set to <b>TRUE</b> when the restore operation is
complete.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero, indicating that an I/O error occurred. To get extended
error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function is not intended for use in restoring files encrypted under the
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">Encrypted File System</a>. Use
<see cref="WriteEncryptedFileRaw" /> for that purpose.</para>
      <para>The data read from the backup medium must be substreams separated by
<see cref="WIN32_STREAM_ID" /> structures.</para>
      <para>The <b>BACKUP_LINK</b> stream type lets you restore files with hard links.</para>
    </remarks>
    <seealso cref="BackupRead" />
    <seealso cref="BackupSeek" />
    <seealso cref="CreateFile" />
    <seealso cref="WIN32_STREAM_ID" />
    <seealso cref="WriteEncryptedFileRaw" />
  </member>
  <member name="Windows.BeginUpdateResource">
    <summary>
      <para>Retrieves a handle that can be used by the <see cref="UpdateResource" /> function to add, delete, or replace resources in a binary module.</para>
    </summary>
    <param name="pFileName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The binary file in which to update resources. An application must be able to obtain write-access to this file; the file referenced by <i>pFileName</i> cannot be currently executing. If <i>pFileName</i> does not specify a full path, the system searches for the file in the current directory.</para>
    </param>
    <param name="bDeleteExistingResources">
      <para>Type: <b>BOOL</b></para>
      <para>Indicates whether to delete the <i>pFileName</i> parameter's existing resources. If this parameter is <b>TRUE</b>, existing resources are deleted and the updated file includes only resources added with the <see cref="UpdateResource" /> function. If this parameter is <b>FALSE</b>, the updated file includes existing resources unless they are explicitly deleted or replaced by using <b>UpdateResource</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HANDLE</b></para>
      <para>If the function succeeds, the return value is a handle that can be used by the <see cref="UpdateResource" /> and <see cref="EndUpdateResource" /> functions. The return value is <b>NULL</b> if the specified file is not a PE, the file does not exist, or the file cannot be opened for writing. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>It is recommended that the resource file is not loaded before this function is called. However, if that file is already loaded, it will not cause an error to be returned.</para>
      <para>There are some restrictions on resource updates in files that contain  Resource Configuration(RC Config) data: LN files and the associated .mui files. Details on which types of resources are allowed to be updated in these files are in the Remarks section for the <see cref="UpdateResource" /> function.</para>
      <para>This function can update resources within modules that contain both code and resources. As noted above, there are restrictions on resource updates in LN files and .mui files, both of which contain RC Config data; details of the restrictions are in the reference for the <see cref="UpdateResource" /> function.</para>
      <h4>Examples</h4>
      <para>For an example see, <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BeginUpdateResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EndUpdateResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="UpdateResource" />
  </member>
  <member name="Windows.BeginUpdateResourceA">
    <summary>
      <para>Retrieves a handle that can be used by the <see cref="UpdateResource" /> function to add, delete, or replace resources in a binary module.</para>
    </summary>
    <param name="pFileName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The binary file in which to update resources. An application must be able to obtain write-access to this file; the file referenced by <i>pFileName</i> cannot be currently executing. If <i>pFileName</i> does not specify a full path, the system searches for the file in the current directory.</para>
    </param>
    <param name="bDeleteExistingResources">
      <para>Type: <b>BOOL</b></para>
      <para>Indicates whether to delete the <i>pFileName</i> parameter's existing resources. If this parameter is <b>TRUE</b>, existing resources are deleted and the updated file includes only resources added with the <see cref="UpdateResource" /> function. If this parameter is <b>FALSE</b>, the updated file includes existing resources unless they are explicitly deleted or replaced by using <b>UpdateResource</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HANDLE</b></para>
      <para>If the function succeeds, the return value is a handle that can be used by the <see cref="UpdateResource" /> and <see cref="EndUpdateResource" /> functions. The return value is <b>NULL</b> if the specified file is not a PE, the file does not exist, or the file cannot be opened for writing. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>It is recommended that the resource file is not loaded before this function is called. However, if that file is already loaded, it will not cause an error to be returned.</para>
      <para>There are some restrictions on resource updates in files that contain  Resource Configuration(RC Config) data: LN files and the associated .mui files. Details on which types of resources are allowed to be updated in these files are in the Remarks section for the <see cref="UpdateResource" /> function.</para>
      <para>This function can update resources within modules that contain both code and resources. As noted above, there are restrictions on resource updates in LN files and .mui files, both of which contain RC Config data; details of the restrictions are in the reference for the <see cref="UpdateResource" /> function.</para>
      <h4>Examples</h4>
      <para>For an example see, <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BeginUpdateResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EndUpdateResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="UpdateResource" />
  </member>
  <member name="Windows.BeginUpdateResourceW">
    <summary>
      <para>Retrieves a handle that can be used by the <see cref="UpdateResource" /> function to add, delete, or replace resources in a binary module.</para>
    </summary>
    <param name="pFileName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The binary file in which to update resources. An application must be able to obtain write-access to this file; the file referenced by <i>pFileName</i> cannot be currently executing. If <i>pFileName</i> does not specify a full path, the system searches for the file in the current directory.</para>
    </param>
    <param name="bDeleteExistingResources">
      <para>Type: <b>BOOL</b></para>
      <para>Indicates whether to delete the <i>pFileName</i> parameter's existing resources. If this parameter is <b>TRUE</b>, existing resources are deleted and the updated file includes only resources added with the <see cref="UpdateResource" /> function. If this parameter is <b>FALSE</b>, the updated file includes existing resources unless they are explicitly deleted or replaced by using <b>UpdateResource</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HANDLE</b></para>
      <para>If the function succeeds, the return value is a handle that can be used by the <see cref="UpdateResource" /> and <see cref="EndUpdateResource" /> functions. The return value is <b>NULL</b> if the specified file is not a PE, the file does not exist, or the file cannot be opened for writing. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>It is recommended that the resource file is not loaded before this function is called. However, if that file is already loaded, it will not cause an error to be returned.</para>
      <para>There are some restrictions on resource updates in files that contain  Resource Configuration(RC Config) data: LN files and the associated .mui files. Details on which types of resources are allowed to be updated in these files are in the Remarks section for the <see cref="UpdateResource" /> function.</para>
      <para>This function can update resources within modules that contain both code and resources. As noted above, there are restrictions on resource updates in LN files and .mui files, both of which contain RC Config data; details of the restrictions are in the reference for the <see cref="UpdateResource" /> function.</para>
      <h4>Examples</h4>
      <para>For an example see, <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BeginUpdateResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EndUpdateResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="UpdateResource" />
  </member>
  <member name="Windows.BeginUpdateResource">
    <summary>
      <para>Retrieves a handle that can be used by the <see cref="UpdateResource" /> function to add, delete, or replace resources in a binary module.</para>
    </summary>
    <param name="pFileName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The binary file in which to update resources. An application must be able to obtain write-access to this file; the file referenced by <i>pFileName</i> cannot be currently executing. If <i>pFileName</i> does not specify a full path, the system searches for the file in the current directory.</para>
    </param>
    <param name="bDeleteExistingResources">
      <para>Type: <b>BOOL</b></para>
      <para>Indicates whether to delete the <i>pFileName</i> parameter's existing resources. If this parameter is <b>TRUE</b>, existing resources are deleted and the updated file includes only resources added with the <see cref="UpdateResource" /> function. If this parameter is <b>FALSE</b>, the updated file includes existing resources unless they are explicitly deleted or replaced by using <b>UpdateResource</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HANDLE</b></para>
      <para>If the function succeeds, the return value is a handle that can be used by the <see cref="UpdateResource" /> and <see cref="EndUpdateResource" /> functions. The return value is <b>NULL</b> if the specified file is not a PE, the file does not exist, or the file cannot be opened for writing. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>It is recommended that the resource file is not loaded before this function is called. However, if that file is already loaded, it will not cause an error to be returned.</para>
      <para>There are some restrictions on resource updates in files that contain  Resource Configuration(RC Config) data: LN files and the associated .mui files. Details on which types of resources are allowed to be updated in these files are in the Remarks section for the <see cref="UpdateResource" /> function.</para>
      <para>This function can update resources within modules that contain both code and resources. As noted above, there are restrictions on resource updates in LN files and .mui files, both of which contain RC Config data; details of the restrictions are in the reference for the <see cref="UpdateResource" /> function.</para>
      <h4>Examples</h4>
      <para>For an example see, <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BeginUpdateResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EndUpdateResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="UpdateResource" />
  </member>
  <member name="Windows.BeginUpdateResourceA">
    <summary>
      <para>Retrieves a handle that can be used by the <see cref="UpdateResource" /> function to add, delete, or replace resources in a binary module.</para>
    </summary>
    <param name="pFileName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The binary file in which to update resources. An application must be able to obtain write-access to this file; the file referenced by <i>pFileName</i> cannot be currently executing. If <i>pFileName</i> does not specify a full path, the system searches for the file in the current directory.</para>
    </param>
    <param name="bDeleteExistingResources">
      <para>Type: <b>BOOL</b></para>
      <para>Indicates whether to delete the <i>pFileName</i> parameter's existing resources. If this parameter is <b>TRUE</b>, existing resources are deleted and the updated file includes only resources added with the <see cref="UpdateResource" /> function. If this parameter is <b>FALSE</b>, the updated file includes existing resources unless they are explicitly deleted or replaced by using <b>UpdateResource</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HANDLE</b></para>
      <para>If the function succeeds, the return value is a handle that can be used by the <see cref="UpdateResource" /> and <see cref="EndUpdateResource" /> functions. The return value is <b>NULL</b> if the specified file is not a PE, the file does not exist, or the file cannot be opened for writing. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>It is recommended that the resource file is not loaded before this function is called. However, if that file is already loaded, it will not cause an error to be returned.</para>
      <para>There are some restrictions on resource updates in files that contain  Resource Configuration(RC Config) data: LN files and the associated .mui files. Details on which types of resources are allowed to be updated in these files are in the Remarks section for the <see cref="UpdateResource" /> function.</para>
      <para>This function can update resources within modules that contain both code and resources. As noted above, there are restrictions on resource updates in LN files and .mui files, both of which contain RC Config data; details of the restrictions are in the reference for the <see cref="UpdateResource" /> function.</para>
      <h4>Examples</h4>
      <para>For an example see, <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BeginUpdateResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EndUpdateResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="UpdateResource" />
  </member>
  <member name="Windows.BeginUpdateResourceW">
    <summary>
      <para>Retrieves a handle that can be used by the <see cref="UpdateResource" /> function to add, delete, or replace resources in a binary module.</para>
    </summary>
    <param name="pFileName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The binary file in which to update resources. An application must be able to obtain write-access to this file; the file referenced by <i>pFileName</i> cannot be currently executing. If <i>pFileName</i> does not specify a full path, the system searches for the file in the current directory.</para>
    </param>
    <param name="bDeleteExistingResources">
      <para>Type: <b>BOOL</b></para>
      <para>Indicates whether to delete the <i>pFileName</i> parameter's existing resources. If this parameter is <b>TRUE</b>, existing resources are deleted and the updated file includes only resources added with the <see cref="UpdateResource" /> function. If this parameter is <b>FALSE</b>, the updated file includes existing resources unless they are explicitly deleted or replaced by using <b>UpdateResource</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HANDLE</b></para>
      <para>If the function succeeds, the return value is a handle that can be used by the <see cref="UpdateResource" /> and <see cref="EndUpdateResource" /> functions. The return value is <b>NULL</b> if the specified file is not a PE, the file does not exist, or the file cannot be opened for writing. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>It is recommended that the resource file is not loaded before this function is called. However, if that file is already loaded, it will not cause an error to be returned.</para>
      <para>There are some restrictions on resource updates in files that contain  Resource Configuration(RC Config) data: LN files and the associated .mui files. Details on which types of resources are allowed to be updated in these files are in the Remarks section for the <see cref="UpdateResource" /> function.</para>
      <para>This function can update resources within modules that contain both code and resources. As noted above, there are restrictions on resource updates in LN files and .mui files, both of which contain RC Config data; details of the restrictions are in the reference for the <see cref="UpdateResource" /> function.</para>
      <h4>Examples</h4>
      <para>For an example see, <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BeginUpdateResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EndUpdateResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="UpdateResource" />
  </member>
  <member name="Windows.BindIoCompletionCallback">
    <summary>
      <para>Associates the I/O completion port owned by the <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-pooling">thread pool</a> with the specified file handle. On completion of an I/O request involving this file, a non-I/O worker thread will execute the specified callback function.</para>
    </summary>
    <param name="FileHandle">
      <para>A handle to the file opened for overlapped I/O completion. This handle is returned by the
<see cref="CreateFile" /> function, with the <b>FILE_FLAG_OVERLAPPED</b> flag.</para>
    </param>
    <param name="Function">
      <para>A pointer to the callback function to be executed in a non-I/O worker thread when the I/O operation is complete. This callback function must not call the
<see cref="TerminateThread" /> function.</para>
      <para>For more information about the completion routine, see
<a href="https://docs.microsoft.com//windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</a>.</para>
    </param>
    <param name="Flags">
      <para>This parameter must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
the <see cref="GetLastError" /> function. The value returned is an <b>NTSTATUS</b> error code. To retrieve the corresponding system error code, use the <see cref="RtlNtStatusToDosError" /> function.</para>
    </returns>
    <remarks>
      <para>The callback function might not be executed if the process issues an asynchronous request on the file specified by the <i>FileHandle</i> parameter but the request returns immediately with an error code other than ERROR_IO_PENDING.</para>
      <para>Be sure that the thread that initiates the asynchronous I/O request does not terminate before the request is completed. Also, if a function in a DLL is queued to a worker thread, be sure that the function in the DLL has completed execution before the DLL is unloaded.</para>
      <para>The thread pool maintains an I/O completion port. When you call <b>BindIoCompletionCallback</b>, it associates the specified file with the thread pool's I/O completion port. Asynchronous requests on that file object will complete by posting to the completion port, where they will be picked up by thread pool worker threads. For callbacks that must issue an I/O request that completes as an asynchronous procedure call, the thread pool provides an I/O worker pool. The I/O worker threads do not wait on the completion port; they sleep in an alertable wait state so that I/O request packets that complete can wake them up. Both types of worker threads check whether there is I/O pending on them and if there is, they do not exit. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/asynchronous-procedure-calls">Asynchronous Procedure Calls</a>.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-pooling">Thread Pooling</seealso>
  </member>
  <member name="Windows.BuildCommDCB">
    <summary>
      <para>Fills a specified
<see cref="DCB" /> structure with values specified in a device-control string. The device-control string uses the syntax of the <b>mode</b> command.</para>
    </summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the
<see cref="DCB" /> structure pointed to by <i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>COM<i>x</i>[:][baud=<i>b</i>][parity=<i>p</i>][data=<i>d</i>][stop=<i>s</i>][to={on|off}][xon={on|off}][odsr={on|off}][octs={on|off}][dtr={on|off|hs}][rts={on|off|hs|tg}][idsr={on|off}]</para>
      <para>The device name is optional, but it must specify a valid device if used.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">
      <para>A pointer to a
<see cref="DCB" /> structure that receives the information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>BuildCommDCB</b> function adjusts only those members of the
<see cref="DCB" /> structure that are specifically affected by the <i>lpDef</i> parameter, with the following exceptions:</para>
      <list type="bullet">
        <item>
          <description>If the specified baud rate is 110, the function sets the stop bits to 2 to remain compatible with the system's <b>mode</b> command.</description>
        </item>
        <item>
          <description>By default,
<b>BuildCommDCB</b> disables XON/XOFF and hardware flow control. To enable flow control, you must explicitly set the appropriate members of the
<see cref="DCB" /> structure.</description>
        </item>
      </list>
      <para>The
<b>BuildCommDCB</b> function only fills in the members of the
<see cref="DCB" /> structure. To apply these settings to a serial port, use the
<see cref="SetCommState" /> function.</para>
      <para>There are older and newer forms of the <b>mode</b> syntax. The
<b>BuildCommDCB</b> function supports both forms. However, you cannot mix the two forms together.</para>
      <para>The newer form of the <b>mode</b> syntax lets you explicitly set the values of the flow control members of the
<see cref="DCB" /> structure. If you use an older form of the <b>mode</b> syntax, the
<b>BuildCommDCB</b> function sets the flow control members of the
<b>DCB</b> structure, as follows:</para>
      <list type="bullet">
        <item>
          <description>For a string that does not end with an x or a p:
<list type="bullet"><item><description><b>fInX</b>, <b>fOutX</b>, <b>fOutXDsrFlow</b>, and <b>fOutXCtsFlow</b> are all set to <b>FALSE</b></description></item><item><description><b>fDtrControl</b> is set to DTR_CONTROL_ENABLE</description></item><item><description><b>fRtsControl</b> is set to RTS_CONTROL_ENABLE</description></item></list></description>
        </item>
        <item>
          <description>For a string that ends with an x:
<list type="bullet"><item><description><b>fInX</b> and <b>fOutX</b> are both set to <b>TRUE</b></description></item><item><description><b>fOutXDsrFlow</b> and <b>fOutXCtsFlow</b> are both set to <b>FALSE</b></description></item><item><description><b>fDtrControl</b> is set to DTR_CONTROL_ENABLE</description></item><item><description><b>fRtsControl</b> is set to RTS_CONTROL_ENABLE</description></item></list></description>
        </item>
        <item>
          <description>For a string that ends with a p:
<list type="bullet"><item><description><b>fInX</b> and <b>fOutX</b> are both set to <b>FALSE</b></description></item><item><description><b>fOutXDsrFlow</b> and <b>fOutXCtsFlow</b> are both set to <b>TRUE</b></description></item><item><description><b>fDtrControl</b> is set to DTR_CONTROL_HANDSHAKE</description></item><item><description><b>fRtsControl</b> is set to RTS_CONTROL_HANDSHAKE</description></item></list></description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BuildCommDCB as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="DCB" />
    <seealso cref="SetCommState" />
  </member>
  <member name="Windows.BuildCommDCBA">
    <summary>
      <para>Fills a specified
<see cref="DCB" /> structure with values specified in a device-control string. The device-control string uses the syntax of the <b>mode</b> command.</para>
    </summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the
<see cref="DCB" /> structure pointed to by <i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>COM<i>x</i>[:][baud=<i>b</i>][parity=<i>p</i>][data=<i>d</i>][stop=<i>s</i>][to={on|off}][xon={on|off}][odsr={on|off}][octs={on|off}][dtr={on|off|hs}][rts={on|off|hs|tg}][idsr={on|off}]</para>
      <para>The device name is optional, but it must specify a valid device if used.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">
      <para>A pointer to a
<see cref="DCB" /> structure that receives the information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>BuildCommDCB</b> function adjusts only those members of the
<see cref="DCB" /> structure that are specifically affected by the <i>lpDef</i> parameter, with the following exceptions:</para>
      <list type="bullet">
        <item>
          <description>If the specified baud rate is 110, the function sets the stop bits to 2 to remain compatible with the system's <b>mode</b> command.</description>
        </item>
        <item>
          <description>By default,
<b>BuildCommDCB</b> disables XON/XOFF and hardware flow control. To enable flow control, you must explicitly set the appropriate members of the
<see cref="DCB" /> structure.</description>
        </item>
      </list>
      <para>The
<b>BuildCommDCB</b> function only fills in the members of the
<see cref="DCB" /> structure. To apply these settings to a serial port, use the
<see cref="SetCommState" /> function.</para>
      <para>There are older and newer forms of the <b>mode</b> syntax. The
<b>BuildCommDCB</b> function supports both forms. However, you cannot mix the two forms together.</para>
      <para>The newer form of the <b>mode</b> syntax lets you explicitly set the values of the flow control members of the
<see cref="DCB" /> structure. If you use an older form of the <b>mode</b> syntax, the
<b>BuildCommDCB</b> function sets the flow control members of the
<b>DCB</b> structure, as follows:</para>
      <list type="bullet">
        <item>
          <description>For a string that does not end with an x or a p:
<list type="bullet"><item><description><b>fInX</b>, <b>fOutX</b>, <b>fOutXDsrFlow</b>, and <b>fOutXCtsFlow</b> are all set to <b>FALSE</b></description></item><item><description><b>fDtrControl</b> is set to DTR_CONTROL_ENABLE</description></item><item><description><b>fRtsControl</b> is set to RTS_CONTROL_ENABLE</description></item></list></description>
        </item>
        <item>
          <description>For a string that ends with an x:
<list type="bullet"><item><description><b>fInX</b> and <b>fOutX</b> are both set to <b>TRUE</b></description></item><item><description><b>fOutXDsrFlow</b> and <b>fOutXCtsFlow</b> are both set to <b>FALSE</b></description></item><item><description><b>fDtrControl</b> is set to DTR_CONTROL_ENABLE</description></item><item><description><b>fRtsControl</b> is set to RTS_CONTROL_ENABLE</description></item></list></description>
        </item>
        <item>
          <description>For a string that ends with a p:
<list type="bullet"><item><description><b>fInX</b> and <b>fOutX</b> are both set to <b>FALSE</b></description></item><item><description><b>fOutXDsrFlow</b> and <b>fOutXCtsFlow</b> are both set to <b>TRUE</b></description></item><item><description><b>fDtrControl</b> is set to DTR_CONTROL_HANDSHAKE</description></item><item><description><b>fRtsControl</b> is set to RTS_CONTROL_HANDSHAKE</description></item></list></description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BuildCommDCB as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="DCB" />
    <seealso cref="SetCommState" />
  </member>
  <member name="Windows.BuildCommDCBW">
    <summary>
      <para>Fills a specified
<see cref="DCB" /> structure with values specified in a device-control string. The device-control string uses the syntax of the <b>mode</b> command.</para>
    </summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the
<see cref="DCB" /> structure pointed to by <i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>COM<i>x</i>[:][baud=<i>b</i>][parity=<i>p</i>][data=<i>d</i>][stop=<i>s</i>][to={on|off}][xon={on|off}][odsr={on|off}][octs={on|off}][dtr={on|off|hs}][rts={on|off|hs|tg}][idsr={on|off}]</para>
      <para>The device name is optional, but it must specify a valid device if used.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">
      <para>A pointer to a
<see cref="DCB" /> structure that receives the information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>BuildCommDCB</b> function adjusts only those members of the
<see cref="DCB" /> structure that are specifically affected by the <i>lpDef</i> parameter, with the following exceptions:</para>
      <list type="bullet">
        <item>
          <description>If the specified baud rate is 110, the function sets the stop bits to 2 to remain compatible with the system's <b>mode</b> command.</description>
        </item>
        <item>
          <description>By default,
<b>BuildCommDCB</b> disables XON/XOFF and hardware flow control. To enable flow control, you must explicitly set the appropriate members of the
<see cref="DCB" /> structure.</description>
        </item>
      </list>
      <para>The
<b>BuildCommDCB</b> function only fills in the members of the
<see cref="DCB" /> structure. To apply these settings to a serial port, use the
<see cref="SetCommState" /> function.</para>
      <para>There are older and newer forms of the <b>mode</b> syntax. The
<b>BuildCommDCB</b> function supports both forms. However, you cannot mix the two forms together.</para>
      <para>The newer form of the <b>mode</b> syntax lets you explicitly set the values of the flow control members of the
<see cref="DCB" /> structure. If you use an older form of the <b>mode</b> syntax, the
<b>BuildCommDCB</b> function sets the flow control members of the
<b>DCB</b> structure, as follows:</para>
      <list type="bullet">
        <item>
          <description>For a string that does not end with an x or a p:
<list type="bullet"><item><description><b>fInX</b>, <b>fOutX</b>, <b>fOutXDsrFlow</b>, and <b>fOutXCtsFlow</b> are all set to <b>FALSE</b></description></item><item><description><b>fDtrControl</b> is set to DTR_CONTROL_ENABLE</description></item><item><description><b>fRtsControl</b> is set to RTS_CONTROL_ENABLE</description></item></list></description>
        </item>
        <item>
          <description>For a string that ends with an x:
<list type="bullet"><item><description><b>fInX</b> and <b>fOutX</b> are both set to <b>TRUE</b></description></item><item><description><b>fOutXDsrFlow</b> and <b>fOutXCtsFlow</b> are both set to <b>FALSE</b></description></item><item><description><b>fDtrControl</b> is set to DTR_CONTROL_ENABLE</description></item><item><description><b>fRtsControl</b> is set to RTS_CONTROL_ENABLE</description></item></list></description>
        </item>
        <item>
          <description>For a string that ends with a p:
<list type="bullet"><item><description><b>fInX</b> and <b>fOutX</b> are both set to <b>FALSE</b></description></item><item><description><b>fOutXDsrFlow</b> and <b>fOutXCtsFlow</b> are both set to <b>TRUE</b></description></item><item><description><b>fDtrControl</b> is set to DTR_CONTROL_HANDSHAKE</description></item><item><description><b>fRtsControl</b> is set to RTS_CONTROL_HANDSHAKE</description></item></list></description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BuildCommDCB as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="DCB" />
    <seealso cref="SetCommState" />
  </member>
  <member name="Windows.BuildCommDCBAndTimeouts">
    <summary>
      <para>Translates a device-definition string into appropriate device-control block codes and places them into
a device control block. The function can also set up time-out values, including the possibility of no
time-outs, for a device; the function's behavior in this regard depends on the contents of the device-definition
string.</para>
    </summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values
in the <see cref="DCB" /> structure pointed to by
<i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>
        <b>COM</b>
        <i>x</i>[<b>:</b>][<b>baud=</b>{<b>11</b>|<b>110</b>|<b>15</b>|<b>150</b>|<b>30</b>|<b>300</b>|<b>60</b>|<b>600</b>|<b>12</b>|<b>1200</b>|<b>24</b>|<b>2400</b>|<b>48</b>|<b>4800</b>|<b>96</b>|<b>9600</b>|<b>19</b>|<b>19200</b>}][<b>parity=</b>{<b>n</b>|<b>e</b>|<b>o</b>|<b>m</b>|<b>s</b>}][<b>data=</b>{<b>5</b>|<b>6</b>|<b>7</b>|<b>8</b>}][<b>stop=</b>{<b>1</b>|<b>1.5</b>|<b>2</b>}][<b>to=</b>{<b>on</b>|<b>off</b>}][<b>xon=</b>{<b>on</b>|<b>off</b>}][<b>odsr=</b>{<b>on</b>|<b>off</b>}][<b>octs=</b>{<b>on</b>|<b>off</b>}][<b>dtr=</b>{<b>on</b>|<b>off</b>|<b>hs</b>}][<b>rts=</b>{<b>on</b>|<b>off</b>|<b>hs</b>|<b>tg</b>}][<b>idsr=</b>{<b>on</b>|<b>off</b>}]</para>
      <para>The "baud" substring can be any of the values listed, which are in pairs. The two-digit
values are the first two digits of the associated values that they represent. For example, 11 represents 110 baud, 19
represents 19,200 baud.</para>
      <para>The "parity" substring indicates how the parity bit is used to detect transmission errors.
The values represent "none", "even", "odd",
"mark", and "space".</para>
      <para>For more information, see the <a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732236(v=ws.11)">Mode</a> command
reference in TechNet.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">
      <para>A pointer to a <see cref="DCB" /> structure that receives information
from the device-control information string pointed to by <i>lpDef</i>. This
<b>DCB</b> structure defines the control settings for a
communications device.</para>
    </param>
    <param name="lpCommTimeouts">
      <para>A pointer to a <see cref="COMMTIMEOUTS" /> structure that
receives time-out information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>BuildCommDCBAndTimeouts</b> function
modifies its time-out setting behavior based on the presence or absence of a "to={on|off}"
substring in <i>lpDef</i>:</para>
      <list type="bullet">
        <item>
          <description>If that string contains the substring "to=on", the function sets the
<b>WriteTotalTimeoutConstant</b> member of the
<see cref="COMMTIMEOUTS" /> structure to 60000 and all other members
to 0.</description>
        </item>
        <item>
          <description>If that string contains the substring "to=off", the function sets the members of
<see cref="COMMTIMEOUTS" /> to 0.</description>
        </item>
        <item>
          <description>If that string does not specify a "to={on|off}" substring, the function ignores the
<see cref="COMMTIMEOUTS" /> structure in
<i>lpCommTimeouts</i>.</description>
        </item>
      </list>
      <para>For more information, see the Remarks for the
<see cref="BuildCommDCB" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BuildCommDCBAndTimeouts as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BuildCommDCB" />
    <seealso cref="COMMTIMEOUTS" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="DCB" />
    <seealso cref="GetCommTimeouts" />
    <seealso cref="SetCommTimeouts" />
  </member>
  <member name="Windows.BuildCommDCBAndTimeoutsA">
    <summary>
      <para>Translates a device-definition string into appropriate device-control block codes and places them into
a device control block. The function can also set up time-out values, including the possibility of no
time-outs, for a device; the function's behavior in this regard depends on the contents of the device-definition
string.</para>
    </summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values
in the <see cref="DCB" /> structure pointed to by
<i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>
        <b>COM</b>
        <i>x</i>[<b>:</b>][<b>baud=</b>{<b>11</b>|<b>110</b>|<b>15</b>|<b>150</b>|<b>30</b>|<b>300</b>|<b>60</b>|<b>600</b>|<b>12</b>|<b>1200</b>|<b>24</b>|<b>2400</b>|<b>48</b>|<b>4800</b>|<b>96</b>|<b>9600</b>|<b>19</b>|<b>19200</b>}][<b>parity=</b>{<b>n</b>|<b>e</b>|<b>o</b>|<b>m</b>|<b>s</b>}][<b>data=</b>{<b>5</b>|<b>6</b>|<b>7</b>|<b>8</b>}][<b>stop=</b>{<b>1</b>|<b>1.5</b>|<b>2</b>}][<b>to=</b>{<b>on</b>|<b>off</b>}][<b>xon=</b>{<b>on</b>|<b>off</b>}][<b>odsr=</b>{<b>on</b>|<b>off</b>}][<b>octs=</b>{<b>on</b>|<b>off</b>}][<b>dtr=</b>{<b>on</b>|<b>off</b>|<b>hs</b>}][<b>rts=</b>{<b>on</b>|<b>off</b>|<b>hs</b>|<b>tg</b>}][<b>idsr=</b>{<b>on</b>|<b>off</b>}]</para>
      <para>The "baud" substring can be any of the values listed, which are in pairs. The two-digit
values are the first two digits of the associated values that they represent. For example, 11 represents 110 baud, 19
represents 19,200 baud.</para>
      <para>The "parity" substring indicates how the parity bit is used to detect transmission errors.
The values represent "none", "even", "odd",
"mark", and "space".</para>
      <para>For more information, see the <a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732236(v=ws.11)">Mode</a> command
reference in TechNet.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">
      <para>A pointer to a <see cref="DCB" /> structure that receives information
from the device-control information string pointed to by <i>lpDef</i>. This
<b>DCB</b> structure defines the control settings for a
communications device.</para>
    </param>
    <param name="lpCommTimeouts">
      <para>A pointer to a <see cref="COMMTIMEOUTS" /> structure that
receives time-out information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>BuildCommDCBAndTimeouts</b> function
modifies its time-out setting behavior based on the presence or absence of a "to={on|off}"
substring in <i>lpDef</i>:</para>
      <list type="bullet">
        <item>
          <description>If that string contains the substring "to=on", the function sets the
<b>WriteTotalTimeoutConstant</b> member of the
<see cref="COMMTIMEOUTS" /> structure to 60000 and all other members
to 0.</description>
        </item>
        <item>
          <description>If that string contains the substring "to=off", the function sets the members of
<see cref="COMMTIMEOUTS" /> to 0.</description>
        </item>
        <item>
          <description>If that string does not specify a "to={on|off}" substring, the function ignores the
<see cref="COMMTIMEOUTS" /> structure in
<i>lpCommTimeouts</i>.</description>
        </item>
      </list>
      <para>For more information, see the Remarks for the
<see cref="BuildCommDCB" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BuildCommDCBAndTimeouts as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BuildCommDCB" />
    <seealso cref="COMMTIMEOUTS" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="DCB" />
    <seealso cref="GetCommTimeouts" />
    <seealso cref="SetCommTimeouts" />
  </member>
  <member name="Windows.BuildCommDCBAndTimeoutsW">
    <summary>
      <para>Translates a device-definition string into appropriate device-control block codes and places them into
a device control block. The function can also set up time-out values, including the possibility of no
time-outs, for a device; the function's behavior in this regard depends on the contents of the device-definition
string.</para>
    </summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values
in the <see cref="DCB" /> structure pointed to by
<i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>
        <b>COM</b>
        <i>x</i>[<b>:</b>][<b>baud=</b>{<b>11</b>|<b>110</b>|<b>15</b>|<b>150</b>|<b>30</b>|<b>300</b>|<b>60</b>|<b>600</b>|<b>12</b>|<b>1200</b>|<b>24</b>|<b>2400</b>|<b>48</b>|<b>4800</b>|<b>96</b>|<b>9600</b>|<b>19</b>|<b>19200</b>}][<b>parity=</b>{<b>n</b>|<b>e</b>|<b>o</b>|<b>m</b>|<b>s</b>}][<b>data=</b>{<b>5</b>|<b>6</b>|<b>7</b>|<b>8</b>}][<b>stop=</b>{<b>1</b>|<b>1.5</b>|<b>2</b>}][<b>to=</b>{<b>on</b>|<b>off</b>}][<b>xon=</b>{<b>on</b>|<b>off</b>}][<b>odsr=</b>{<b>on</b>|<b>off</b>}][<b>octs=</b>{<b>on</b>|<b>off</b>}][<b>dtr=</b>{<b>on</b>|<b>off</b>|<b>hs</b>}][<b>rts=</b>{<b>on</b>|<b>off</b>|<b>hs</b>|<b>tg</b>}][<b>idsr=</b>{<b>on</b>|<b>off</b>}]</para>
      <para>The "baud" substring can be any of the values listed, which are in pairs. The two-digit
values are the first two digits of the associated values that they represent. For example, 11 represents 110 baud, 19
represents 19,200 baud.</para>
      <para>The "parity" substring indicates how the parity bit is used to detect transmission errors.
The values represent "none", "even", "odd",
"mark", and "space".</para>
      <para>For more information, see the <a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732236(v=ws.11)">Mode</a> command
reference in TechNet.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">
      <para>A pointer to a <see cref="DCB" /> structure that receives information
from the device-control information string pointed to by <i>lpDef</i>. This
<b>DCB</b> structure defines the control settings for a
communications device.</para>
    </param>
    <param name="lpCommTimeouts">
      <para>A pointer to a <see cref="COMMTIMEOUTS" /> structure that
receives time-out information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>BuildCommDCBAndTimeouts</b> function
modifies its time-out setting behavior based on the presence or absence of a "to={on|off}"
substring in <i>lpDef</i>:</para>
      <list type="bullet">
        <item>
          <description>If that string contains the substring "to=on", the function sets the
<b>WriteTotalTimeoutConstant</b> member of the
<see cref="COMMTIMEOUTS" /> structure to 60000 and all other members
to 0.</description>
        </item>
        <item>
          <description>If that string contains the substring "to=off", the function sets the members of
<see cref="COMMTIMEOUTS" /> to 0.</description>
        </item>
        <item>
          <description>If that string does not specify a "to={on|off}" substring, the function ignores the
<see cref="COMMTIMEOUTS" /> structure in
<i>lpCommTimeouts</i>.</description>
        </item>
      </list>
      <para>For more information, see the Remarks for the
<see cref="BuildCommDCB" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BuildCommDCBAndTimeouts as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BuildCommDCB" />
    <seealso cref="COMMTIMEOUTS" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="DCB" />
    <seealso cref="GetCommTimeouts" />
    <seealso cref="SetCommTimeouts" />
  </member>
  <member name="Windows.BuildCommDCBAndTimeouts">
    <summary>
      <para>Translates a device-definition string into appropriate device-control block codes and places them into
a device control block. The function can also set up time-out values, including the possibility of no
time-outs, for a device; the function's behavior in this regard depends on the contents of the device-definition
string.</para>
    </summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values
in the <see cref="DCB" /> structure pointed to by
<i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>
        <b>COM</b>
        <i>x</i>[<b>:</b>][<b>baud=</b>{<b>11</b>|<b>110</b>|<b>15</b>|<b>150</b>|<b>30</b>|<b>300</b>|<b>60</b>|<b>600</b>|<b>12</b>|<b>1200</b>|<b>24</b>|<b>2400</b>|<b>48</b>|<b>4800</b>|<b>96</b>|<b>9600</b>|<b>19</b>|<b>19200</b>}][<b>parity=</b>{<b>n</b>|<b>e</b>|<b>o</b>|<b>m</b>|<b>s</b>}][<b>data=</b>{<b>5</b>|<b>6</b>|<b>7</b>|<b>8</b>}][<b>stop=</b>{<b>1</b>|<b>1.5</b>|<b>2</b>}][<b>to=</b>{<b>on</b>|<b>off</b>}][<b>xon=</b>{<b>on</b>|<b>off</b>}][<b>odsr=</b>{<b>on</b>|<b>off</b>}][<b>octs=</b>{<b>on</b>|<b>off</b>}][<b>dtr=</b>{<b>on</b>|<b>off</b>|<b>hs</b>}][<b>rts=</b>{<b>on</b>|<b>off</b>|<b>hs</b>|<b>tg</b>}][<b>idsr=</b>{<b>on</b>|<b>off</b>}]</para>
      <para>The "baud" substring can be any of the values listed, which are in pairs. The two-digit
values are the first two digits of the associated values that they represent. For example, 11 represents 110 baud, 19
represents 19,200 baud.</para>
      <para>The "parity" substring indicates how the parity bit is used to detect transmission errors.
The values represent "none", "even", "odd",
"mark", and "space".</para>
      <para>For more information, see the <a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732236(v=ws.11)">Mode</a> command
reference in TechNet.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">
      <para>A pointer to a <see cref="DCB" /> structure that receives information
from the device-control information string pointed to by <i>lpDef</i>. This
<b>DCB</b> structure defines the control settings for a
communications device.</para>
    </param>
    <param name="lpCommTimeouts">
      <para>A pointer to a <see cref="COMMTIMEOUTS" /> structure that
receives time-out information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>BuildCommDCBAndTimeouts</b> function
modifies its time-out setting behavior based on the presence or absence of a "to={on|off}"
substring in <i>lpDef</i>:</para>
      <list type="bullet">
        <item>
          <description>If that string contains the substring "to=on", the function sets the
<b>WriteTotalTimeoutConstant</b> member of the
<see cref="COMMTIMEOUTS" /> structure to 60000 and all other members
to 0.</description>
        </item>
        <item>
          <description>If that string contains the substring "to=off", the function sets the members of
<see cref="COMMTIMEOUTS" /> to 0.</description>
        </item>
        <item>
          <description>If that string does not specify a "to={on|off}" substring, the function ignores the
<see cref="COMMTIMEOUTS" /> structure in
<i>lpCommTimeouts</i>.</description>
        </item>
      </list>
      <para>For more information, see the Remarks for the
<see cref="BuildCommDCB" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BuildCommDCBAndTimeouts as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BuildCommDCB" />
    <seealso cref="COMMTIMEOUTS" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="DCB" />
    <seealso cref="GetCommTimeouts" />
    <seealso cref="SetCommTimeouts" />
  </member>
  <member name="Windows.BuildCommDCBAndTimeoutsA">
    <summary>
      <para>Translates a device-definition string into appropriate device-control block codes and places them into
a device control block. The function can also set up time-out values, including the possibility of no
time-outs, for a device; the function's behavior in this regard depends on the contents of the device-definition
string.</para>
    </summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values
in the <see cref="DCB" /> structure pointed to by
<i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>
        <b>COM</b>
        <i>x</i>[<b>:</b>][<b>baud=</b>{<b>11</b>|<b>110</b>|<b>15</b>|<b>150</b>|<b>30</b>|<b>300</b>|<b>60</b>|<b>600</b>|<b>12</b>|<b>1200</b>|<b>24</b>|<b>2400</b>|<b>48</b>|<b>4800</b>|<b>96</b>|<b>9600</b>|<b>19</b>|<b>19200</b>}][<b>parity=</b>{<b>n</b>|<b>e</b>|<b>o</b>|<b>m</b>|<b>s</b>}][<b>data=</b>{<b>5</b>|<b>6</b>|<b>7</b>|<b>8</b>}][<b>stop=</b>{<b>1</b>|<b>1.5</b>|<b>2</b>}][<b>to=</b>{<b>on</b>|<b>off</b>}][<b>xon=</b>{<b>on</b>|<b>off</b>}][<b>odsr=</b>{<b>on</b>|<b>off</b>}][<b>octs=</b>{<b>on</b>|<b>off</b>}][<b>dtr=</b>{<b>on</b>|<b>off</b>|<b>hs</b>}][<b>rts=</b>{<b>on</b>|<b>off</b>|<b>hs</b>|<b>tg</b>}][<b>idsr=</b>{<b>on</b>|<b>off</b>}]</para>
      <para>The "baud" substring can be any of the values listed, which are in pairs. The two-digit
values are the first two digits of the associated values that they represent. For example, 11 represents 110 baud, 19
represents 19,200 baud.</para>
      <para>The "parity" substring indicates how the parity bit is used to detect transmission errors.
The values represent "none", "even", "odd",
"mark", and "space".</para>
      <para>For more information, see the <a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732236(v=ws.11)">Mode</a> command
reference in TechNet.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">
      <para>A pointer to a <see cref="DCB" /> structure that receives information
from the device-control information string pointed to by <i>lpDef</i>. This
<b>DCB</b> structure defines the control settings for a
communications device.</para>
    </param>
    <param name="lpCommTimeouts">
      <para>A pointer to a <see cref="COMMTIMEOUTS" /> structure that
receives time-out information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>BuildCommDCBAndTimeouts</b> function
modifies its time-out setting behavior based on the presence or absence of a "to={on|off}"
substring in <i>lpDef</i>:</para>
      <list type="bullet">
        <item>
          <description>If that string contains the substring "to=on", the function sets the
<b>WriteTotalTimeoutConstant</b> member of the
<see cref="COMMTIMEOUTS" /> structure to 60000 and all other members
to 0.</description>
        </item>
        <item>
          <description>If that string contains the substring "to=off", the function sets the members of
<see cref="COMMTIMEOUTS" /> to 0.</description>
        </item>
        <item>
          <description>If that string does not specify a "to={on|off}" substring, the function ignores the
<see cref="COMMTIMEOUTS" /> structure in
<i>lpCommTimeouts</i>.</description>
        </item>
      </list>
      <para>For more information, see the Remarks for the
<see cref="BuildCommDCB" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BuildCommDCBAndTimeouts as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BuildCommDCB" />
    <seealso cref="COMMTIMEOUTS" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="DCB" />
    <seealso cref="GetCommTimeouts" />
    <seealso cref="SetCommTimeouts" />
  </member>
  <member name="Windows.BuildCommDCBAndTimeoutsW">
    <summary>
      <para>Translates a device-definition string into appropriate device-control block codes and places them into
a device control block. The function can also set up time-out values, including the possibility of no
time-outs, for a device; the function's behavior in this regard depends on the contents of the device-definition
string.</para>
    </summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values
in the <see cref="DCB" /> structure pointed to by
<i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>
        <b>COM</b>
        <i>x</i>[<b>:</b>][<b>baud=</b>{<b>11</b>|<b>110</b>|<b>15</b>|<b>150</b>|<b>30</b>|<b>300</b>|<b>60</b>|<b>600</b>|<b>12</b>|<b>1200</b>|<b>24</b>|<b>2400</b>|<b>48</b>|<b>4800</b>|<b>96</b>|<b>9600</b>|<b>19</b>|<b>19200</b>}][<b>parity=</b>{<b>n</b>|<b>e</b>|<b>o</b>|<b>m</b>|<b>s</b>}][<b>data=</b>{<b>5</b>|<b>6</b>|<b>7</b>|<b>8</b>}][<b>stop=</b>{<b>1</b>|<b>1.5</b>|<b>2</b>}][<b>to=</b>{<b>on</b>|<b>off</b>}][<b>xon=</b>{<b>on</b>|<b>off</b>}][<b>odsr=</b>{<b>on</b>|<b>off</b>}][<b>octs=</b>{<b>on</b>|<b>off</b>}][<b>dtr=</b>{<b>on</b>|<b>off</b>|<b>hs</b>}][<b>rts=</b>{<b>on</b>|<b>off</b>|<b>hs</b>|<b>tg</b>}][<b>idsr=</b>{<b>on</b>|<b>off</b>}]</para>
      <para>The "baud" substring can be any of the values listed, which are in pairs. The two-digit
values are the first two digits of the associated values that they represent. For example, 11 represents 110 baud, 19
represents 19,200 baud.</para>
      <para>The "parity" substring indicates how the parity bit is used to detect transmission errors.
The values represent "none", "even", "odd",
"mark", and "space".</para>
      <para>For more information, see the <a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732236(v=ws.11)">Mode</a> command
reference in TechNet.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">
      <para>A pointer to a <see cref="DCB" /> structure that receives information
from the device-control information string pointed to by <i>lpDef</i>. This
<b>DCB</b> structure defines the control settings for a
communications device.</para>
    </param>
    <param name="lpCommTimeouts">
      <para>A pointer to a <see cref="COMMTIMEOUTS" /> structure that
receives time-out information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>BuildCommDCBAndTimeouts</b> function
modifies its time-out setting behavior based on the presence or absence of a "to={on|off}"
substring in <i>lpDef</i>:</para>
      <list type="bullet">
        <item>
          <description>If that string contains the substring "to=on", the function sets the
<b>WriteTotalTimeoutConstant</b> member of the
<see cref="COMMTIMEOUTS" /> structure to 60000 and all other members
to 0.</description>
        </item>
        <item>
          <description>If that string contains the substring "to=off", the function sets the members of
<see cref="COMMTIMEOUTS" /> to 0.</description>
        </item>
        <item>
          <description>If that string does not specify a "to={on|off}" substring, the function ignores the
<see cref="COMMTIMEOUTS" /> structure in
<i>lpCommTimeouts</i>.</description>
        </item>
      </list>
      <para>For more information, see the Remarks for the
<see cref="BuildCommDCB" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BuildCommDCBAndTimeouts as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BuildCommDCB" />
    <seealso cref="COMMTIMEOUTS" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="DCB" />
    <seealso cref="GetCommTimeouts" />
    <seealso cref="SetCommTimeouts" />
  </member>
  <member name="Windows.BuildCommDCB">
    <summary>
      <para>Fills a specified
<see cref="DCB" /> structure with values specified in a device-control string. The device-control string uses the syntax of the <b>mode</b> command.</para>
    </summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the
<see cref="DCB" /> structure pointed to by <i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>COM<i>x</i>[:][baud=<i>b</i>][parity=<i>p</i>][data=<i>d</i>][stop=<i>s</i>][to={on|off}][xon={on|off}][odsr={on|off}][octs={on|off}][dtr={on|off|hs}][rts={on|off|hs|tg}][idsr={on|off}]</para>
      <para>The device name is optional, but it must specify a valid device if used.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">
      <para>A pointer to a
<see cref="DCB" /> structure that receives the information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>BuildCommDCB</b> function adjusts only those members of the
<see cref="DCB" /> structure that are specifically affected by the <i>lpDef</i> parameter, with the following exceptions:</para>
      <list type="bullet">
        <item>
          <description>If the specified baud rate is 110, the function sets the stop bits to 2 to remain compatible with the system's <b>mode</b> command.</description>
        </item>
        <item>
          <description>By default,
<b>BuildCommDCB</b> disables XON/XOFF and hardware flow control. To enable flow control, you must explicitly set the appropriate members of the
<see cref="DCB" /> structure.</description>
        </item>
      </list>
      <para>The
<b>BuildCommDCB</b> function only fills in the members of the
<see cref="DCB" /> structure. To apply these settings to a serial port, use the
<see cref="SetCommState" /> function.</para>
      <para>There are older and newer forms of the <b>mode</b> syntax. The
<b>BuildCommDCB</b> function supports both forms. However, you cannot mix the two forms together.</para>
      <para>The newer form of the <b>mode</b> syntax lets you explicitly set the values of the flow control members of the
<see cref="DCB" /> structure. If you use an older form of the <b>mode</b> syntax, the
<b>BuildCommDCB</b> function sets the flow control members of the
<b>DCB</b> structure, as follows:</para>
      <list type="bullet">
        <item>
          <description>For a string that does not end with an x or a p:
<list type="bullet"><item><description><b>fInX</b>, <b>fOutX</b>, <b>fOutXDsrFlow</b>, and <b>fOutXCtsFlow</b> are all set to <b>FALSE</b></description></item><item><description><b>fDtrControl</b> is set to DTR_CONTROL_ENABLE</description></item><item><description><b>fRtsControl</b> is set to RTS_CONTROL_ENABLE</description></item></list></description>
        </item>
        <item>
          <description>For a string that ends with an x:
<list type="bullet"><item><description><b>fInX</b> and <b>fOutX</b> are both set to <b>TRUE</b></description></item><item><description><b>fOutXDsrFlow</b> and <b>fOutXCtsFlow</b> are both set to <b>FALSE</b></description></item><item><description><b>fDtrControl</b> is set to DTR_CONTROL_ENABLE</description></item><item><description><b>fRtsControl</b> is set to RTS_CONTROL_ENABLE</description></item></list></description>
        </item>
        <item>
          <description>For a string that ends with a p:
<list type="bullet"><item><description><b>fInX</b> and <b>fOutX</b> are both set to <b>FALSE</b></description></item><item><description><b>fOutXDsrFlow</b> and <b>fOutXCtsFlow</b> are both set to <b>TRUE</b></description></item><item><description><b>fDtrControl</b> is set to DTR_CONTROL_HANDSHAKE</description></item><item><description><b>fRtsControl</b> is set to RTS_CONTROL_HANDSHAKE</description></item></list></description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BuildCommDCB as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="DCB" />
    <seealso cref="SetCommState" />
  </member>
  <member name="Windows.BuildCommDCBA">
    <summary>
      <para>Fills a specified
<see cref="DCB" /> structure with values specified in a device-control string. The device-control string uses the syntax of the <b>mode</b> command.</para>
    </summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the
<see cref="DCB" /> structure pointed to by <i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>COM<i>x</i>[:][baud=<i>b</i>][parity=<i>p</i>][data=<i>d</i>][stop=<i>s</i>][to={on|off}][xon={on|off}][odsr={on|off}][octs={on|off}][dtr={on|off|hs}][rts={on|off|hs|tg}][idsr={on|off}]</para>
      <para>The device name is optional, but it must specify a valid device if used.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">
      <para>A pointer to a
<see cref="DCB" /> structure that receives the information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>BuildCommDCB</b> function adjusts only those members of the
<see cref="DCB" /> structure that are specifically affected by the <i>lpDef</i> parameter, with the following exceptions:</para>
      <list type="bullet">
        <item>
          <description>If the specified baud rate is 110, the function sets the stop bits to 2 to remain compatible with the system's <b>mode</b> command.</description>
        </item>
        <item>
          <description>By default,
<b>BuildCommDCB</b> disables XON/XOFF and hardware flow control. To enable flow control, you must explicitly set the appropriate members of the
<see cref="DCB" /> structure.</description>
        </item>
      </list>
      <para>The
<b>BuildCommDCB</b> function only fills in the members of the
<see cref="DCB" /> structure. To apply these settings to a serial port, use the
<see cref="SetCommState" /> function.</para>
      <para>There are older and newer forms of the <b>mode</b> syntax. The
<b>BuildCommDCB</b> function supports both forms. However, you cannot mix the two forms together.</para>
      <para>The newer form of the <b>mode</b> syntax lets you explicitly set the values of the flow control members of the
<see cref="DCB" /> structure. If you use an older form of the <b>mode</b> syntax, the
<b>BuildCommDCB</b> function sets the flow control members of the
<b>DCB</b> structure, as follows:</para>
      <list type="bullet">
        <item>
          <description>For a string that does not end with an x or a p:
<list type="bullet"><item><description><b>fInX</b>, <b>fOutX</b>, <b>fOutXDsrFlow</b>, and <b>fOutXCtsFlow</b> are all set to <b>FALSE</b></description></item><item><description><b>fDtrControl</b> is set to DTR_CONTROL_ENABLE</description></item><item><description><b>fRtsControl</b> is set to RTS_CONTROL_ENABLE</description></item></list></description>
        </item>
        <item>
          <description>For a string that ends with an x:
<list type="bullet"><item><description><b>fInX</b> and <b>fOutX</b> are both set to <b>TRUE</b></description></item><item><description><b>fOutXDsrFlow</b> and <b>fOutXCtsFlow</b> are both set to <b>FALSE</b></description></item><item><description><b>fDtrControl</b> is set to DTR_CONTROL_ENABLE</description></item><item><description><b>fRtsControl</b> is set to RTS_CONTROL_ENABLE</description></item></list></description>
        </item>
        <item>
          <description>For a string that ends with a p:
<list type="bullet"><item><description><b>fInX</b> and <b>fOutX</b> are both set to <b>FALSE</b></description></item><item><description><b>fOutXDsrFlow</b> and <b>fOutXCtsFlow</b> are both set to <b>TRUE</b></description></item><item><description><b>fDtrControl</b> is set to DTR_CONTROL_HANDSHAKE</description></item><item><description><b>fRtsControl</b> is set to RTS_CONTROL_HANDSHAKE</description></item></list></description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BuildCommDCB as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="DCB" />
    <seealso cref="SetCommState" />
  </member>
  <member name="Windows.BuildCommDCBW">
    <summary>
      <para>Fills a specified
<see cref="DCB" /> structure with values specified in a device-control string. The device-control string uses the syntax of the <b>mode</b> command.</para>
    </summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the
<see cref="DCB" /> structure pointed to by <i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>COM<i>x</i>[:][baud=<i>b</i>][parity=<i>p</i>][data=<i>d</i>][stop=<i>s</i>][to={on|off}][xon={on|off}][odsr={on|off}][octs={on|off}][dtr={on|off|hs}][rts={on|off|hs|tg}][idsr={on|off}]</para>
      <para>The device name is optional, but it must specify a valid device if used.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">
      <para>A pointer to a
<see cref="DCB" /> structure that receives the information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>BuildCommDCB</b> function adjusts only those members of the
<see cref="DCB" /> structure that are specifically affected by the <i>lpDef</i> parameter, with the following exceptions:</para>
      <list type="bullet">
        <item>
          <description>If the specified baud rate is 110, the function sets the stop bits to 2 to remain compatible with the system's <b>mode</b> command.</description>
        </item>
        <item>
          <description>By default,
<b>BuildCommDCB</b> disables XON/XOFF and hardware flow control. To enable flow control, you must explicitly set the appropriate members of the
<see cref="DCB" /> structure.</description>
        </item>
      </list>
      <para>The
<b>BuildCommDCB</b> function only fills in the members of the
<see cref="DCB" /> structure. To apply these settings to a serial port, use the
<see cref="SetCommState" /> function.</para>
      <para>There are older and newer forms of the <b>mode</b> syntax. The
<b>BuildCommDCB</b> function supports both forms. However, you cannot mix the two forms together.</para>
      <para>The newer form of the <b>mode</b> syntax lets you explicitly set the values of the flow control members of the
<see cref="DCB" /> structure. If you use an older form of the <b>mode</b> syntax, the
<b>BuildCommDCB</b> function sets the flow control members of the
<b>DCB</b> structure, as follows:</para>
      <list type="bullet">
        <item>
          <description>For a string that does not end with an x or a p:
<list type="bullet"><item><description><b>fInX</b>, <b>fOutX</b>, <b>fOutXDsrFlow</b>, and <b>fOutXCtsFlow</b> are all set to <b>FALSE</b></description></item><item><description><b>fDtrControl</b> is set to DTR_CONTROL_ENABLE</description></item><item><description><b>fRtsControl</b> is set to RTS_CONTROL_ENABLE</description></item></list></description>
        </item>
        <item>
          <description>For a string that ends with an x:
<list type="bullet"><item><description><b>fInX</b> and <b>fOutX</b> are both set to <b>TRUE</b></description></item><item><description><b>fOutXDsrFlow</b> and <b>fOutXCtsFlow</b> are both set to <b>FALSE</b></description></item><item><description><b>fDtrControl</b> is set to DTR_CONTROL_ENABLE</description></item><item><description><b>fRtsControl</b> is set to RTS_CONTROL_ENABLE</description></item></list></description>
        </item>
        <item>
          <description>For a string that ends with a p:
<list type="bullet"><item><description><b>fInX</b> and <b>fOutX</b> are both set to <b>FALSE</b></description></item><item><description><b>fOutXDsrFlow</b> and <b>fOutXCtsFlow</b> are both set to <b>TRUE</b></description></item><item><description><b>fDtrControl</b> is set to DTR_CONTROL_HANDSHAKE</description></item><item><description><b>fRtsControl</b> is set to RTS_CONTROL_HANDSHAKE</description></item></list></description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines BuildCommDCB as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="DCB" />
    <seealso cref="SetCommState" />
  </member>
  <member name="Windows.CallNamedPipe">
    <summary>
      <para>Connects to a message-type pipe (and waits if an instance of the pipe is not available), writes to and reads from the pipe, and then closes the pipe.</para>
    </summary>
    <param name="lpNamedPipeName">
      <para>The pipe name.</para>
    </param>
    <param name="lpInBuffer">
      <para>The data to be written to the pipe.</para>
    </param>
    <param name="nInBufferSize">
      <para>The size of the write buffer, in bytes.</para>
    </param>
    <param name="lpOutBuffer">
      <para>A pointer to the buffer that receives the data read from the pipe.</para>
    </param>
    <param name="nOutBufferSize">
      <para>The size of the read buffer, in bytes.</para>
    </param>
    <param name="lpBytesRead">
      <para>A pointer to a variable that receives the number of bytes read from the pipe.</para>
    </param>
    <param name="nTimeOut">
      <para>The number of milliseconds to wait for the named pipe to be available. In addition to numeric values, the following special values can be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NMPWAIT_NOWAIT</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Does not wait for the named pipe. If the named pipe is not available, the function returns an error.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NMPWAIT_WAIT_FOREVER</b>
                </description>
              </item>
              <item>
                <description>0xffffffff</description>
              </item>
            </list>
          </description>
          <description>
            <para>Waits indefinitely.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NMPWAIT_USE_DEFAULT_WAIT</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Uses the default time-out specified in a call to the
<see cref="CreateNamedPipe" /> function.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the message written to the pipe by the server process is longer than <i>nOutBufferSize</i>,
<b>CallNamedPipe</b> returns <b>FALSE</b>, and <see cref="GetLastError" /> returns ERROR_MORE_DATA. The remainder of the message is discarded, because
<b>CallNamedPipe</b> closes the handle to the pipe before returning.</para>
    </returns>
    <remarks>
      <para>Calling <b>CallNamedPipe</b> is equivalent to calling the <see cref="CreateFile" /> (or <see cref="WaitNamedPipe" />, if <b>CreateFile</b> cannot open the pipe immediately), <see cref="TransactNamedPipe" />, and <see cref="CloseHandle" /> functions. <b>CreateFile</b> is called with an access flag of GENERIC_READ | GENERIC_WRITE, and an inherit handle flag of <b>FALSE</b>.</para>
      <para>
        <b>CallNamedPipe</b> fails if the pipe is a byte-type pipe.</para>
      <para>
        <b>Windows 10, version 1709:  </b>Pipes are only supported within an app-container; ie, from one UWP process to another UWP process that's part of the same app. Also, named pipes must use the syntax "\.\pipe\LOCAL" for the pipe name.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/transactions-on-named-pipes">Transactions on Named Pipes</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFile" />
    <seealso cref="CreateNamedPipe" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipe-functions">Pipe Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipes">Pipes Overview</seealso>
    <seealso cref="TransactNamedPipe" />
    <seealso cref="WaitNamedPipe" />
  </member>
  <member name="Windows.CallNamedPipeA">
    <summary>
      <para>Connects to a message-type pipe (and waits if an instance of the pipe is not available), writes to and reads from the pipe, and then closes the pipe.</para>
    </summary>
    <param name="lpNamedPipeName">
      <para>The pipe name.</para>
    </param>
    <param name="lpInBuffer">
      <para>The data to be written to the pipe.</para>
    </param>
    <param name="nInBufferSize">
      <para>The size of the write buffer, in bytes.</para>
    </param>
    <param name="lpOutBuffer">
      <para>A pointer to the buffer that receives the data read from the pipe.</para>
    </param>
    <param name="nOutBufferSize">
      <para>The size of the read buffer, in bytes.</para>
    </param>
    <param name="lpBytesRead">
      <para>A pointer to a variable that receives the number of bytes read from the pipe.</para>
    </param>
    <param name="nTimeOut">
      <para>The number of milliseconds to wait for the named pipe to be available. In addition to numeric values, the following special values can be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NMPWAIT_NOWAIT</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Does not wait for the named pipe. If the named pipe is not available, the function returns an error.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NMPWAIT_WAIT_FOREVER</b>
                </description>
              </item>
              <item>
                <description>0xffffffff</description>
              </item>
            </list>
          </description>
          <description>
            <para>Waits indefinitely.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NMPWAIT_USE_DEFAULT_WAIT</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Uses the default time-out specified in a call to the
<see cref="CreateNamedPipe" /> function.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the message written to the pipe by the server process is longer than <i>nOutBufferSize</i>,
<b>CallNamedPipe</b> returns <b>FALSE</b>, and <see cref="GetLastError" /> returns ERROR_MORE_DATA. The remainder of the message is discarded, because
<b>CallNamedPipe</b> closes the handle to the pipe before returning.</para>
    </returns>
    <remarks>
      <para>Calling <b>CallNamedPipe</b> is equivalent to calling the <see cref="CreateFile" /> (or <see cref="WaitNamedPipe" />, if <b>CreateFile</b> cannot open the pipe immediately), <see cref="TransactNamedPipe" />, and <see cref="CloseHandle" /> functions. <b>CreateFile</b> is called with an access flag of GENERIC_READ | GENERIC_WRITE, and an inherit handle flag of <b>FALSE</b>.</para>
      <para>
        <b>CallNamedPipe</b> fails if the pipe is a byte-type pipe.</para>
      <para>
        <b>Windows 10, version 1709:  </b>Pipes are only supported within an app-container; ie, from one UWP process to another UWP process that's part of the same app. Also, named pipes must use the syntax "\.\pipe\LOCAL" for the pipe name.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/transactions-on-named-pipes">Transactions on Named Pipes</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFile" />
    <seealso cref="CreateNamedPipe" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipe-functions">Pipe Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipes">Pipes Overview</seealso>
    <seealso cref="TransactNamedPipe" />
    <seealso cref="WaitNamedPipe" />
  </member>
  <member name="Windows.CallNamedPipeW">
    <summary>
      <para>Connects to a message-type pipe (and waits if an instance of the pipe is not available), writes to and reads from the pipe, and then closes the pipe.</para>
    </summary>
    <param name="lpNamedPipeName">
      <para>The pipe name.</para>
    </param>
    <param name="lpInBuffer">
      <para>The data to be written to the pipe.</para>
    </param>
    <param name="nInBufferSize">
      <para>The size of the write buffer, in bytes.</para>
    </param>
    <param name="lpOutBuffer">
      <para>A pointer to the buffer that receives the data read from the pipe.</para>
    </param>
    <param name="nOutBufferSize">
      <para>The size of the read buffer, in bytes.</para>
    </param>
    <param name="lpBytesRead">
      <para>A pointer to a variable that receives the number of bytes read from the pipe.</para>
    </param>
    <param name="nTimeOut">
      <para>The number of milliseconds to wait for the named pipe to be available. In addition to numeric values, the following special values can be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NMPWAIT_NOWAIT</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Does not wait for the named pipe. If the named pipe is not available, the function returns an error.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NMPWAIT_WAIT_FOREVER</b>
                </description>
              </item>
              <item>
                <description>0xffffffff</description>
              </item>
            </list>
          </description>
          <description>
            <para>Waits indefinitely.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NMPWAIT_USE_DEFAULT_WAIT</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Uses the default time-out specified in a call to the
<see cref="CreateNamedPipe" /> function.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the message written to the pipe by the server process is longer than <i>nOutBufferSize</i>,
<b>CallNamedPipe</b> returns <b>FALSE</b>, and <see cref="GetLastError" /> returns ERROR_MORE_DATA. The remainder of the message is discarded, because
<b>CallNamedPipe</b> closes the handle to the pipe before returning.</para>
    </returns>
    <remarks>
      <para>Calling <b>CallNamedPipe</b> is equivalent to calling the <see cref="CreateFile" /> (or <see cref="WaitNamedPipe" />, if <b>CreateFile</b> cannot open the pipe immediately), <see cref="TransactNamedPipe" />, and <see cref="CloseHandle" /> functions. <b>CreateFile</b> is called with an access flag of GENERIC_READ | GENERIC_WRITE, and an inherit handle flag of <b>FALSE</b>.</para>
      <para>
        <b>CallNamedPipe</b> fails if the pipe is a byte-type pipe.</para>
      <para>
        <b>Windows 10, version 1709:  </b>Pipes are only supported within an app-container; ie, from one UWP process to another UWP process that's part of the same app. Also, named pipes must use the syntax "\.\pipe\LOCAL" for the pipe name.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/transactions-on-named-pipes">Transactions on Named Pipes</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFile" />
    <seealso cref="CreateNamedPipe" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipe-functions">Pipe Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipes">Pipes Overview</seealso>
    <seealso cref="TransactNamedPipe" />
    <seealso cref="WaitNamedPipe" />
  </member>
  <member name="Windows.CheckNameLegalDOS8Dot3">
    <summary>
      <para>Determines whether the  specified name can be used to create a file on a FAT file
system.</para>
    </summary>
    <param name="lpName">
      <para>The file name, in 8.3 format.</para>
    </param>
    <param name="lpOemName">
      <para>A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This
parameter can be <b>NULL</b>.</para>
    </param>
    <param name="OemNameSize">
      <para>The size of the <i>lpOemName</i> buffer, in characters. If
<i>lpOemName</i> is <b>NULL</b>, this parameter must be 0 (zero).</para>
    </param>
    <param name="pbNameContainsSpaces">
      <para>Indicates whether or not a name contains spaces. This parameter can be <b>NULL</b>. If
the name is not a valid 8.3 FAT file system name, this parameter is undefined.</para>
    </param>
    <param name="pbNameLegal">
      <para>If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when
the current OEM code page is applied to the file name.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function can be used to determine whether or not a file name can be passed to a 16-bit Windows-based
application or an MS-DOS-based application.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>See remarks</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>See remarks</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Note that SMB 3.0 does not support short names on shares with continuous availability capability, so function will always return zero (fail).</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CheckNameLegalDOS8Dot3 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetOEMCP" />
  </member>
  <member name="Windows.CheckNameLegalDOS8Dot3A">
    <summary>
      <para>Determines whether the  specified name can be used to create a file on a FAT file
system.</para>
    </summary>
    <param name="lpName">
      <para>The file name, in 8.3 format.</para>
    </param>
    <param name="lpOemName">
      <para>A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This
parameter can be <b>NULL</b>.</para>
    </param>
    <param name="OemNameSize">
      <para>The size of the <i>lpOemName</i> buffer, in characters. If
<i>lpOemName</i> is <b>NULL</b>, this parameter must be 0 (zero).</para>
    </param>
    <param name="pbNameContainsSpaces">
      <para>Indicates whether or not a name contains spaces. This parameter can be <b>NULL</b>. If
the name is not a valid 8.3 FAT file system name, this parameter is undefined.</para>
    </param>
    <param name="pbNameLegal">
      <para>If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when
the current OEM code page is applied to the file name.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function can be used to determine whether or not a file name can be passed to a 16-bit Windows-based
application or an MS-DOS-based application.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>See remarks</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>See remarks</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Note that SMB 3.0 does not support short names on shares with continuous availability capability, so function will always return zero (fail).</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CheckNameLegalDOS8Dot3 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetOEMCP" />
  </member>
  <member name="Windows.CheckNameLegalDOS8Dot3W">
    <summary>
      <para>Determines whether the  specified name can be used to create a file on a FAT file
system.</para>
    </summary>
    <param name="lpName">
      <para>The file name, in 8.3 format.</para>
    </param>
    <param name="lpOemName">
      <para>A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This
parameter can be <b>NULL</b>.</para>
    </param>
    <param name="OemNameSize">
      <para>The size of the <i>lpOemName</i> buffer, in characters. If
<i>lpOemName</i> is <b>NULL</b>, this parameter must be 0 (zero).</para>
    </param>
    <param name="pbNameContainsSpaces">
      <para>Indicates whether or not a name contains spaces. This parameter can be <b>NULL</b>. If
the name is not a valid 8.3 FAT file system name, this parameter is undefined.</para>
    </param>
    <param name="pbNameLegal">
      <para>If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when
the current OEM code page is applied to the file name.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function can be used to determine whether or not a file name can be passed to a 16-bit Windows-based
application or an MS-DOS-based application.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>See remarks</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>See remarks</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Note that SMB 3.0 does not support short names on shares with continuous availability capability, so function will always return zero (fail).</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CheckNameLegalDOS8Dot3 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetOEMCP" />
  </member>
  <member name="Windows.CheckNameLegalDOS8Dot3">
    <summary>
      <para>Determines whether the  specified name can be used to create a file on a FAT file
system.</para>
    </summary>
    <param name="lpName">
      <para>The file name, in 8.3 format.</para>
    </param>
    <param name="lpOemName">
      <para>A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This
parameter can be <b>NULL</b>.</para>
    </param>
    <param name="OemNameSize">
      <para>The size of the <i>lpOemName</i> buffer, in characters. If
<i>lpOemName</i> is <b>NULL</b>, this parameter must be 0 (zero).</para>
    </param>
    <param name="pbNameContainsSpaces">
      <para>Indicates whether or not a name contains spaces. This parameter can be <b>NULL</b>. If
the name is not a valid 8.3 FAT file system name, this parameter is undefined.</para>
    </param>
    <param name="pbNameLegal">
      <para>If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when
the current OEM code page is applied to the file name.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function can be used to determine whether or not a file name can be passed to a 16-bit Windows-based
application or an MS-DOS-based application.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>See remarks</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>See remarks</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Note that SMB 3.0 does not support short names on shares with continuous availability capability, so function will always return zero (fail).</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CheckNameLegalDOS8Dot3 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetOEMCP" />
  </member>
  <member name="Windows.CheckNameLegalDOS8Dot3A">
    <summary>
      <para>Determines whether the  specified name can be used to create a file on a FAT file
system.</para>
    </summary>
    <param name="lpName">
      <para>The file name, in 8.3 format.</para>
    </param>
    <param name="lpOemName">
      <para>A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This
parameter can be <b>NULL</b>.</para>
    </param>
    <param name="OemNameSize">
      <para>The size of the <i>lpOemName</i> buffer, in characters. If
<i>lpOemName</i> is <b>NULL</b>, this parameter must be 0 (zero).</para>
    </param>
    <param name="pbNameContainsSpaces">
      <para>Indicates whether or not a name contains spaces. This parameter can be <b>NULL</b>. If
the name is not a valid 8.3 FAT file system name, this parameter is undefined.</para>
    </param>
    <param name="pbNameLegal">
      <para>If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when
the current OEM code page is applied to the file name.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function can be used to determine whether or not a file name can be passed to a 16-bit Windows-based
application or an MS-DOS-based application.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>See remarks</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>See remarks</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Note that SMB 3.0 does not support short names on shares with continuous availability capability, so function will always return zero (fail).</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CheckNameLegalDOS8Dot3 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetOEMCP" />
  </member>
  <member name="Windows.CheckNameLegalDOS8Dot3W">
    <summary>
      <para>Determines whether the  specified name can be used to create a file on a FAT file
system.</para>
    </summary>
    <param name="lpName">
      <para>The file name, in 8.3 format.</para>
    </param>
    <param name="lpOemName">
      <para>A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This
parameter can be <b>NULL</b>.</para>
    </param>
    <param name="OemNameSize">
      <para>The size of the <i>lpOemName</i> buffer, in characters. If
<i>lpOemName</i> is <b>NULL</b>, this parameter must be 0 (zero).</para>
    </param>
    <param name="pbNameContainsSpaces">
      <para>Indicates whether or not a name contains spaces. This parameter can be <b>NULL</b>. If
the name is not a valid 8.3 FAT file system name, this parameter is undefined.</para>
    </param>
    <param name="pbNameLegal">
      <para>If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when
the current OEM code page is applied to the file name.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function can be used to determine whether or not a file name can be passed to a 16-bit Windows-based
application or an MS-DOS-based application.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>See remarks</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>See remarks</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>Note that SMB 3.0 does not support short names on shares with continuous availability capability, so function will always return zero (fail).</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CheckNameLegalDOS8Dot3 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetOEMCP" />
  </member>
  <member name="Windows.ClearCommBreak">
    <summary>
      <para>Restores character transmission for a specified communications device and places the transmission line in a nonbreak state.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the communications device. The
<see cref="CreateFile" /> function returns this handle.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>A communications device is placed in a break state by the
<see cref="SetCommBreak" /> or
<see cref="EscapeCommFunction" /> function. Character transmission is then suspended until the break state is cleared by calling
<b>ClearCommBreak</b>.</para>
    </remarks>
    <seealso cref="ClearCommError" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="CreateFile" />
    <seealso cref="EscapeCommFunction" />
    <seealso cref="SetCommBreak" />
  </member>
  <member name="Windows.ClearCommError">
    <summary>
      <para>Retrieves information about a communications error and reports the current status of a communications device. The function is called when a communications error occurs, and it clears the device's error flag to enable additional input and output (I/O) operations.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the communications device. The
<see cref="CreateFile" /> function returns this handle.</para>
    </param>
    <param name="lpErrors">
      <para>A pointer to a variable that receives a mask indicating the type of error. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CE_BREAK</b>
                </description>
              </item>
              <item>
                <description>0x0010</description>
              </item>
            </list>
          </description>
          <description>
            <para>The hardware detected a break condition.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CE_FRAME</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The hardware detected a framing error.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CE_OVERRUN</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>A character-buffer overrun has occurred. The next character is lost.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CE_RXOVER</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>An input buffer overflow has occurred. There is either no room in the input buffer, or a character was received after the end-of-file (EOF) character.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CE_RXPARITY</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The hardware detected a parity error.</para>
          </description>
        </item>
      </list>
      <para>The following values are not supported:</para>
    </param>
    <param name="lpStat">
      <para>A pointer to a
<see cref="COMSTAT" /> structure in which the device's status information is returned. If this parameter is <b>NULL</b>, no status information is returned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If a communications port has been set up with a <b>TRUE</b> value for the <b>fAbortOnError</b> member of the setup
<see cref="DCB" /> structure, the communications software will terminate all read and write operations on the communications port when a communications error occurs. No new read or write operations will be accepted until the application acknowledges the communications error by calling the
<b>ClearCommError</b> function.</para>
      <para>The
<b>ClearCommError</b> function fills the status buffer pointed to by the <i>lpStat</i> parameter with the current status of the communications device specified by the <i>hFile</i> parameter.</para>
    </remarks>
    <seealso cref="COMSTAT" />
    <seealso cref="ClearCommBreak" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="CreateFile" />
    <seealso cref="DCB" />
  </member>
  <member name="Windows.ClearEventLog">
    <summary>
      <para>Clears the specified event log, and optionally saves the current copy of the log to a backup file.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log to be cleared. The <see cref="OpenEventLog" /> function returns this handle.</para>
    </param>
    <param name="lpBackupFileName">
      <para>The absolute or relative path of the backup file. If this file already exists, the function fails.</para>
      <para>If the <i>lpBackupFileName</i> parameter is <b>NULL</b>, the event log is not backed up.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. The
<b>ClearEventLog</b> function can fail if the event log is empty or the backup file already exists.</para>
    </returns>
    <remarks>
      <para>After this function returns, any handles that reference the cleared event log cannot be used to read the log.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines ClearEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
  </member>
  <member name="Windows.ClearEventLogA">
    <summary>
      <para>Clears the specified event log, and optionally saves the current copy of the log to a backup file.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log to be cleared. The <see cref="OpenEventLog" /> function returns this handle.</para>
    </param>
    <param name="lpBackupFileName">
      <para>The absolute or relative path of the backup file. If this file already exists, the function fails.</para>
      <para>If the <i>lpBackupFileName</i> parameter is <b>NULL</b>, the event log is not backed up.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. The
<b>ClearEventLog</b> function can fail if the event log is empty or the backup file already exists.</para>
    </returns>
    <remarks>
      <para>After this function returns, any handles that reference the cleared event log cannot be used to read the log.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines ClearEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
  </member>
  <member name="Windows.ClearEventLogW">
    <summary>
      <para>Clears the specified event log, and optionally saves the current copy of the log to a backup file.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log to be cleared. The <see cref="OpenEventLog" /> function returns this handle.</para>
    </param>
    <param name="lpBackupFileName">
      <para>The absolute or relative path of the backup file. If this file already exists, the function fails.</para>
      <para>If the <i>lpBackupFileName</i> parameter is <b>NULL</b>, the event log is not backed up.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. The
<b>ClearEventLog</b> function can fail if the event log is empty or the backup file already exists.</para>
    </returns>
    <remarks>
      <para>After this function returns, any handles that reference the cleared event log cannot be used to read the log.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines ClearEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
  </member>
  <member name="Windows.ClearEventLog">
    <summary>
      <para>Clears the specified event log, and optionally saves the current copy of the log to a backup file.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log to be cleared. The <see cref="OpenEventLog" /> function returns this handle.</para>
    </param>
    <param name="lpBackupFileName">
      <para>The absolute or relative path of the backup file. If this file already exists, the function fails.</para>
      <para>If the <i>lpBackupFileName</i> parameter is <b>NULL</b>, the event log is not backed up.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. The
<b>ClearEventLog</b> function can fail if the event log is empty or the backup file already exists.</para>
    </returns>
    <remarks>
      <para>After this function returns, any handles that reference the cleared event log cannot be used to read the log.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines ClearEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
  </member>
  <member name="Windows.ClearEventLogA">
    <summary>
      <para>Clears the specified event log, and optionally saves the current copy of the log to a backup file.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log to be cleared. The <see cref="OpenEventLog" /> function returns this handle.</para>
    </param>
    <param name="lpBackupFileName">
      <para>The absolute or relative path of the backup file. If this file already exists, the function fails.</para>
      <para>If the <i>lpBackupFileName</i> parameter is <b>NULL</b>, the event log is not backed up.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. The
<b>ClearEventLog</b> function can fail if the event log is empty or the backup file already exists.</para>
    </returns>
    <remarks>
      <para>After this function returns, any handles that reference the cleared event log cannot be used to read the log.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines ClearEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
  </member>
  <member name="Windows.ClearEventLogW">
    <summary>
      <para>Clears the specified event log, and optionally saves the current copy of the log to a backup file.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log to be cleared. The <see cref="OpenEventLog" /> function returns this handle.</para>
    </param>
    <param name="lpBackupFileName">
      <para>The absolute or relative path of the backup file. If this file already exists, the function fails.</para>
      <para>If the <i>lpBackupFileName</i> parameter is <b>NULL</b>, the event log is not backed up.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. The
<b>ClearEventLog</b> function can fail if the event log is empty or the backup file already exists.</para>
    </returns>
    <remarks>
      <para>After this function returns, any handles that reference the cleared event log cannot be used to read the log.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines ClearEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
  </member>
  <member name="Windows.CloseEncryptedFileRaw">
    <summary>
      <para>Closes an encrypted file after a backup
or restore operation, and frees associated system resources. This is one of a group of Encrypted File System (EFS) functions that is intended  to implement backup and restore functionality, while maintaining files in their encrypted state.</para>
    </summary>
    <param name="pvContext">
      <para>A pointer to a system-defined context block. The
<see cref="OpenEncryptedFileRaw" /> function returns the context block.</para>
    </param>
    <remarks>
      <para>The <b>CloseEncryptedFileRaw</b> function frees allocated system resources
such as the system-defined context block and closes the file.</para>
      <para>The  <see cref="BackupRead" /> and <see cref="BackupWrite" /> functions handle backup and restore of unencrypted files.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>Note that SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
    </remarks>
    <seealso cref="BackupRead" />
    <seealso cref="BackupWrite" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="OpenEncryptedFileRaw" />
    <seealso cref="ReadEncryptedFileRaw" />
    <seealso cref="WriteEncryptedFileRaw" />
  </member>
  <member name="Windows.CloseEventLog">
    <summary>
      <para>Closes the specified event log.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log to be closed. The
<see cref="OpenEventLog" /> or
<see cref="OpenBackupEventLog" /> function returns this handle.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
  </member>
  <member name="Windows.CommConfigDialog">
    <summary>
      <para>Displays a driver-supplied configuration dialog box.</para>
    </summary>
    <param name="lpszName">
      <para>The name of the device for which a dialog box should be displayed. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</para>
    </param>
    <param name="hWnd">
      <para>A handle to the window that owns the dialog box. This parameter can be any valid window handle, or it should be <b>NULL</b> if the dialog box is to have no owner.</para>
    </param>
    <param name="lpCC">
      <para>A pointer to a
<see cref="COMMCONFIG" /> structure. This structure contains initial settings for the dialog box before the call, and changed values after the call.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>CommConfigDialog</b> function requires a dynamic-link library (DLL) provided by the communications hardware vendor.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CommConfigDialog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMMCONFIG" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
  </member>
  <member name="Windows.CommConfigDialogA">
    <summary>
      <para>Displays a driver-supplied configuration dialog box.</para>
    </summary>
    <param name="lpszName">
      <para>The name of the device for which a dialog box should be displayed. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</para>
    </param>
    <param name="hWnd">
      <para>A handle to the window that owns the dialog box. This parameter can be any valid window handle, or it should be <b>NULL</b> if the dialog box is to have no owner.</para>
    </param>
    <param name="lpCC">
      <para>A pointer to a
<see cref="COMMCONFIG" /> structure. This structure contains initial settings for the dialog box before the call, and changed values after the call.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>CommConfigDialog</b> function requires a dynamic-link library (DLL) provided by the communications hardware vendor.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CommConfigDialog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMMCONFIG" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
  </member>
  <member name="Windows.CommConfigDialogW">
    <summary>
      <para>Displays a driver-supplied configuration dialog box.</para>
    </summary>
    <param name="lpszName">
      <para>The name of the device for which a dialog box should be displayed. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</para>
    </param>
    <param name="hWnd">
      <para>A handle to the window that owns the dialog box. This parameter can be any valid window handle, or it should be <b>NULL</b> if the dialog box is to have no owner.</para>
    </param>
    <param name="lpCC">
      <para>A pointer to a
<see cref="COMMCONFIG" /> structure. This structure contains initial settings for the dialog box before the call, and changed values after the call.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>CommConfigDialog</b> function requires a dynamic-link library (DLL) provided by the communications hardware vendor.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CommConfigDialog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMMCONFIG" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
  </member>
  <member name="Windows.CommConfigDialog">
    <summary>
      <para>Displays a driver-supplied configuration dialog box.</para>
    </summary>
    <param name="lpszName">
      <para>The name of the device for which a dialog box should be displayed. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</para>
    </param>
    <param name="hWnd">
      <para>A handle to the window that owns the dialog box. This parameter can be any valid window handle, or it should be <b>NULL</b> if the dialog box is to have no owner.</para>
    </param>
    <param name="lpCC">
      <para>A pointer to a
<see cref="COMMCONFIG" /> structure. This structure contains initial settings for the dialog box before the call, and changed values after the call.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>CommConfigDialog</b> function requires a dynamic-link library (DLL) provided by the communications hardware vendor.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CommConfigDialog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMMCONFIG" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
  </member>
  <member name="Windows.CommConfigDialogA">
    <summary>
      <para>Displays a driver-supplied configuration dialog box.</para>
    </summary>
    <param name="lpszName">
      <para>The name of the device for which a dialog box should be displayed. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</para>
    </param>
    <param name="hWnd">
      <para>A handle to the window that owns the dialog box. This parameter can be any valid window handle, or it should be <b>NULL</b> if the dialog box is to have no owner.</para>
    </param>
    <param name="lpCC">
      <para>A pointer to a
<see cref="COMMCONFIG" /> structure. This structure contains initial settings for the dialog box before the call, and changed values after the call.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>CommConfigDialog</b> function requires a dynamic-link library (DLL) provided by the communications hardware vendor.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CommConfigDialog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMMCONFIG" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
  </member>
  <member name="Windows.CommConfigDialogW">
    <summary>
      <para>Displays a driver-supplied configuration dialog box.</para>
    </summary>
    <param name="lpszName">
      <para>The name of the device for which a dialog box should be displayed. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</para>
    </param>
    <param name="hWnd">
      <para>A handle to the window that owns the dialog box. This parameter can be any valid window handle, or it should be <b>NULL</b> if the dialog box is to have no owner.</para>
    </param>
    <param name="lpCC">
      <para>A pointer to a
<see cref="COMMCONFIG" /> structure. This structure contains initial settings for the dialog box before the call, and changed values after the call.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>CommConfigDialog</b> function requires a dynamic-link library (DLL) provided by the communications hardware vendor.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CommConfigDialog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMMCONFIG" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
  </member>
  <member name="Windows.ConvertFiberToThread">
    <summary>
      <para>Converts the current fiber into a thread.</para>
    </summary>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The function releases the resources allocated by the
<see cref="ConvertThreadToFiber" /> function. After calling this function, you cannot call any of the fiber functions from the thread.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as _WIN32_WINNT_WS03 (0x0502) or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="ConvertThreadToFiber" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/fibers">Fibers</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
  </member>
  <member name="Windows.ConvertThreadToFiber">
    <summary>
      <para>Converts the current thread into a fiber. You must convert a thread into a fiber before you can schedule other fibers.</para>
    </summary>
    <param name="lpParameter">
      <para>A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the
<see cref="GetFiberData" /> macro.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the address of the fiber.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Only fibers can execute other fibers. If a thread needs to execute a fiber, it must call
<b>ConvertThreadToFiber</b> or
<see cref="ConvertThreadToFiberEx" /> to create an area in which to save fiber state information. The thread is now the current fiber. The state information for this fiber includes the fiber data specified by <i>lpParameter</i>.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/using-fibers">Using Fibers</a>.</para>
    </remarks>
    <seealso cref="ConvertFiberToThread" />
    <seealso cref="ConvertThreadToFiberEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/fibers">Fibers</seealso>
    <seealso cref="GetFiberData" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
  </member>
  <member name="Windows.ConvertThreadToFiberEx">
    <summary>
      <para>Converts the current thread into a fiber. You must convert a thread into a fiber before you can schedule other fibers.</para>
    </summary>
    <param name="lpParameter">
      <para>A  pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the
<see cref="GetFiberData" /> macro.</para>
    </param>
    <param name="dwFlags">
      <para>If this parameter is zero, the floating-point state on x86 systems is not switched and data can be corrupted if a fiber uses floating-point arithmetic. If this parameter is FIBER_FLAG_FLOAT_SWITCH, the floating-point state is switched for the fiber.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the address of the fiber.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Only fibers can execute other fibers. If a thread needs to execute a fiber, it must call
<see cref="ConvertTheadToFiber" /> or
<b>ConvertThreadToFiberEx</b> to create an area in which to save fiber state information. The thread is now the current fiber. The state information for this fiber includes the fiber data specified by <i>lpParameter</i>.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="ConvertFiberToThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/fibers">Fibers</seealso>
    <seealso cref="GetFiberData" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
  </member>
  <member name="Windows.CopyContext">
    <summary>
      <para>Copies a source context structure (including any XState) onto an initialized destination context
structure.</para>
    </summary>
    <param name="Destination">
      <para>A pointer to a <see cref="CONTEXT" /> structure that receives the
context copied from the <i>Source</i>. The
<b>CONTEXT</b> structure should be initialized by calling
<see cref="InitializeContext" /> before calling this
function.</para>
    </param>
    <param name="ContextFlags">
      <para>Flags specifying the pieces of the <i>Source</i><see cref="CONTEXT" /> structure that will be copied into the
destination. This must be a subset of the <i>ContextFlags</i> specified when calling
<see cref="InitializeContext" /> on the
<i>Destination</i><b>CONTEXT</b>.</para>
    </param>
    <param name="Source">
      <para>A pointer to a <see cref="CONTEXT" /> structure from which to copy
processor context data.</para>
    </param>
    <returns>
      <para>This function returns <b>TRUE</b> if the context was copied successfully, otherwise
<b>FALSE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The function copies data from the <i>Source</i><see cref="CONTEXT" /> over the corresponding data in the
<i>Destination</i><b>CONTEXT</b>, including
extended context if any is present. The <i>Destination</i><b>CONTEXT</b> must have been initialized with
<see cref="InitializeContext" /> to ensure proper alignment and
initialization. If any data is present in the <i>Destination</i><b>CONTEXT</b> and the corresponding flag is not set in the
<i>Source</i><b>CONTEXT</b> or in the
<i>ContextFlags</i> parameter, the data remains valid in the
<i>Destination</i>.</para>
      <para>
        <b>Windows 7 with SP1 and Windows Server 2008 R2 with SP1:  </b>The <a href="https://docs.microsoft.com//windows/desktop/Debug/avx-support-portal">AVX API</a> is first implemented on
Windows 7 with SP1 and Windows Server 2008 R2 with SP1 . Since there is no SDK for SP1, that means there are
no available headers and library files to work with. In this situation, a caller must declare the needed
functions from this documentation and get pointers to them using
<see cref="GetModuleHandle" /> on
"Kernel32.dll", followed by calls to
<see cref="GetProcAddress" />. See
<a href="https://docs.microsoft.com//windows/desktop/Debug/working-with-xstate-context">Working with XState Context</a> for
details.</para>
    </remarks>
    <seealso cref="CONTEXT" />
    <seealso cref="InitializeContext" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/avx-support-portal">Intel AVX</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/working-with-xstate-context">Working with XState Context</seealso>
  </member>
  <member name="Windows.CopyFile">
    <summary>
      <para>Copies an existing file to a new file.</para>
      <para>The <see cref="CopyFileEx" /> function provides two additional
capabilities. <b>CopyFileEx</b> can call a specified callback
function each time a portion of the copy operation is completed, and
<b>CopyFileEx</b> can be canceled during the copy operation.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
      <para>If <i>lpExistingFileName</i> does not exist,
<b>CopyFile</b> fails, and
<see cref="GetLastError" /> returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="bFailIfExists">
      <para>If this parameter is <b>TRUE</b> and the new file specified by
<i>lpNewFileName</i> already exists, the function fails. If this parameter is
<b>FALSE</b> and the new file already exists, the function overwrites the existing file and
succeeds.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The security resource properties (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are
copied to the new file.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource properties for the existing file are not copied to the new file until
Windows 8 and Windows Server 2012.</para>
      <para>File attributes for the existing file are copied to the new file. For example, if an existing file has the
<b>FILE_ATTRIBUTE_READONLY</b> file attribute, a copy created through a call to
<b>CopyFile</b> will also have the
<b>FILE_ATTRIBUTE_READONLY</b> file attribute. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <para>This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists
and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b></para>
      <para>attribute set.</para>
      <para>When <b>CopyFile</b> is used to copy an encrypted file, it attempts
to encrypt the destination file with the keys used in the encryption of the source file. If this cannot be done,
this function attempts to encrypt the destination file with default keys. If
neither of these methods can be done, <b>CopyFile</b> fails with an
<b>ERROR_ENCRYPTION_FAILED</b> error code.</para>
      <para>Symbolic link behavior—If the source file is a symbolic link, the actual file copied is
the target of the symbolic link.</para>
      <para>If the destination file already exists and is a symbolic link, the target of the symbolic link is overwritten
by the source file.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
    </remarks>
    <seealso cref="CopyFileEx" />
    <seealso cref="CopyFileTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CopyFileA">
    <summary>
      <para>Copies an existing file to a new file.</para>
      <para>The <see cref="CopyFileEx" /> function provides two additional
capabilities. <b>CopyFileEx</b> can call a specified callback
function each time a portion of the copy operation is completed, and
<b>CopyFileEx</b> can be canceled during the copy operation.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
      <para>If <i>lpExistingFileName</i> does not exist,
<b>CopyFile</b> fails, and
<see cref="GetLastError" /> returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="bFailIfExists">
      <para>If this parameter is <b>TRUE</b> and the new file specified by
<i>lpNewFileName</i> already exists, the function fails. If this parameter is
<b>FALSE</b> and the new file already exists, the function overwrites the existing file and
succeeds.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The security resource properties (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are
copied to the new file.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource properties for the existing file are not copied to the new file until
Windows 8 and Windows Server 2012.</para>
      <para>File attributes for the existing file are copied to the new file. For example, if an existing file has the
<b>FILE_ATTRIBUTE_READONLY</b> file attribute, a copy created through a call to
<b>CopyFile</b> will also have the
<b>FILE_ATTRIBUTE_READONLY</b> file attribute. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <para>This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists
and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b></para>
      <para>attribute set.</para>
      <para>When <b>CopyFile</b> is used to copy an encrypted file, it attempts
to encrypt the destination file with the keys used in the encryption of the source file. If this cannot be done,
this function attempts to encrypt the destination file with default keys. If
neither of these methods can be done, <b>CopyFile</b> fails with an
<b>ERROR_ENCRYPTION_FAILED</b> error code.</para>
      <para>Symbolic link behavior—If the source file is a symbolic link, the actual file copied is
the target of the symbolic link.</para>
      <para>If the destination file already exists and is a symbolic link, the target of the symbolic link is overwritten
by the source file.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
    </remarks>
    <seealso cref="CopyFileEx" />
    <seealso cref="CopyFileTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CopyFileW">
    <summary>
      <para>Copies an existing file to a new file.</para>
      <para>The <see cref="CopyFileEx" /> function provides two additional
capabilities. <b>CopyFileEx</b> can call a specified callback
function each time a portion of the copy operation is completed, and
<b>CopyFileEx</b> can be canceled during the copy operation.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
      <para>If <i>lpExistingFileName</i> does not exist,
<b>CopyFile</b> fails, and
<see cref="GetLastError" /> returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="bFailIfExists">
      <para>If this parameter is <b>TRUE</b> and the new file specified by
<i>lpNewFileName</i> already exists, the function fails. If this parameter is
<b>FALSE</b> and the new file already exists, the function overwrites the existing file and
succeeds.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The security resource properties (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are
copied to the new file.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource properties for the existing file are not copied to the new file until
Windows 8 and Windows Server 2012.</para>
      <para>File attributes for the existing file are copied to the new file. For example, if an existing file has the
<b>FILE_ATTRIBUTE_READONLY</b> file attribute, a copy created through a call to
<b>CopyFile</b> will also have the
<b>FILE_ATTRIBUTE_READONLY</b> file attribute. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <para>This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists
and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b></para>
      <para>attribute set.</para>
      <para>When <b>CopyFile</b> is used to copy an encrypted file, it attempts
to encrypt the destination file with the keys used in the encryption of the source file. If this cannot be done,
this function attempts to encrypt the destination file with default keys. If
neither of these methods can be done, <b>CopyFile</b> fails with an
<b>ERROR_ENCRYPTION_FAILED</b> error code.</para>
      <para>Symbolic link behavior—If the source file is a symbolic link, the actual file copied is
the target of the symbolic link.</para>
      <para>If the destination file already exists and is a symbolic link, the target of the symbolic link is overwritten
by the source file.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
    </remarks>
    <seealso cref="CopyFileEx" />
    <seealso cref="CopyFileTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CopyFile2">
    <summary>
      <para>Copies an existing file to a new file, notifying the application of its progress through a callback
function.</para>
    </summary>
    <param name="pwszExistingFileName">
      <para>The name of an existing file.</para>
      <para>To extend this limit to 32,767 wide characters, prepend "\?" to the path. For more
information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?".  See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
      <para>If <i>lpExistingFileName</i> does not exist, the
<b>CopyFile2</b> function fails returns
<code>HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)</code>.</para>
    </param>
    <param name="pwszNewFileName">
      <para>The name of the new file.</para>
      <para>To extend this limit to 32,767 wide characters, prepend "\?" to the path. For more
information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="pExtendedParameters">
      <para>Optional address of a
<see cref="COPYFILE2_EXTENDED_PARAMETERS" /></para>
      <para>structure.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value will return <b>TRUE</b> when passed to the
<see cref="SUCCEEDED" /> macro.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>The copy operation completed successfully.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>HRESULT_FROM_WIN32(ERROR_REQUEST_PAUSED)</b>
            </para>
          </description>
          <description>
            <para>The copy operation was paused by a <b>COPYFILE2_PROGRESS_PAUSE</b> return from the
<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-pcopyfile2_progress_routine">CopyFile2ProgressRoutine</a> callback
function.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>HRESULT_FROM_WIN32(ERROR_REQUEST_ABORTED)</b>
            </para>
          </description>
          <description>
            <para>The copy operation was paused by a <b>COPYFILE2_PROGRESS_CANCEL</b> or
<b>COPYFILE2_PROGRESS_STOP</b> return from the
<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-pcopyfile2_progress_routine">CopyFile2ProgressRoutine</a> callback
function.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)</b>
            </para>
          </description>
          <description>
            <para>The <b>dwCopyFlags</b> member of the
<see cref="COPYFILE2_EXTENDED_PARAMETERS" /> structure
passed through the <i>pExtendedParameters</i> parameter contains the
<b>COPY_FILE_FAIL_IF_EXISTS</b> flag and a conflicting name existed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>HRESULT_FROM_WIN32(ERROR_FILE_EXISTS)</b>
            </para>
          </description>
          <description>
            <para>The <b>dwCopyFlags</b> member of the
<see cref="COPYFILE2_EXTENDED_PARAMETERS" /> structure
passed through the <i>pExtendedParameters</i> parameter contains the
<b>COPY_FILE_FAIL_IF_EXISTS</b> flag and a conflicting name existed.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function preserves extended attributes, OLE structured storage, NTFS file system alternate data streams,
and file attributes. Security attributes for the existing file are not copied to the new file. To copy security
attributes, use the <see cref="SHFileOperation" /> function.</para>
      <para>This function fails with
<code>HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED)</code> if the destination
file already exists and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or
<b>FILE_ATTRIBUTE_READONLY</b> attribute set.</para>
      <para>To compile an application that uses this function, define the <b>_WIN32_WINNT</b> macro
as <b>_WIN32_WINNT_WIN8</b> or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso cref="COPYFILE2_EXTENDED_PARAMETERS" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.CopyFile">
    <summary>
      <para>Copies an existing file to a new file.</para>
      <para>The <see cref="CopyFileEx" /> function provides two additional
capabilities. <b>CopyFileEx</b> can call a specified callback
function each time a portion of the copy operation is completed, and
<b>CopyFileEx</b> can be canceled during the copy operation.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
      <para>If <i>lpExistingFileName</i> does not exist,
<b>CopyFile</b> fails, and
<see cref="GetLastError" /> returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="bFailIfExists">
      <para>If this parameter is <b>TRUE</b> and the new file specified by
<i>lpNewFileName</i> already exists, the function fails. If this parameter is
<b>FALSE</b> and the new file already exists, the function overwrites the existing file and
succeeds.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The security resource properties (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are
copied to the new file.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource properties for the existing file are not copied to the new file until
Windows 8 and Windows Server 2012.</para>
      <para>File attributes for the existing file are copied to the new file. For example, if an existing file has the
<b>FILE_ATTRIBUTE_READONLY</b> file attribute, a copy created through a call to
<b>CopyFile</b> will also have the
<b>FILE_ATTRIBUTE_READONLY</b> file attribute. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <para>This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists
and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b></para>
      <para>attribute set.</para>
      <para>When <b>CopyFile</b> is used to copy an encrypted file, it attempts
to encrypt the destination file with the keys used in the encryption of the source file. If this cannot be done,
this function attempts to encrypt the destination file with default keys. If
neither of these methods can be done, <b>CopyFile</b> fails with an
<b>ERROR_ENCRYPTION_FAILED</b> error code.</para>
      <para>Symbolic link behavior—If the source file is a symbolic link, the actual file copied is
the target of the symbolic link.</para>
      <para>If the destination file already exists and is a symbolic link, the target of the symbolic link is overwritten
by the source file.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CopyFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFileEx" />
    <seealso cref="CopyFileTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CopyFileA">
    <summary>
      <para>Copies an existing file to a new file.</para>
      <para>The <see cref="CopyFileEx" /> function provides two additional
capabilities. <b>CopyFileEx</b> can call a specified callback
function each time a portion of the copy operation is completed, and
<b>CopyFileEx</b> can be canceled during the copy operation.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
      <para>If <i>lpExistingFileName</i> does not exist,
<b>CopyFile</b> fails, and
<see cref="GetLastError" /> returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="bFailIfExists">
      <para>If this parameter is <b>TRUE</b> and the new file specified by
<i>lpNewFileName</i> already exists, the function fails. If this parameter is
<b>FALSE</b> and the new file already exists, the function overwrites the existing file and
succeeds.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The security resource properties (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are
copied to the new file.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource properties for the existing file are not copied to the new file until
Windows 8 and Windows Server 2012.</para>
      <para>File attributes for the existing file are copied to the new file. For example, if an existing file has the
<b>FILE_ATTRIBUTE_READONLY</b> file attribute, a copy created through a call to
<b>CopyFile</b> will also have the
<b>FILE_ATTRIBUTE_READONLY</b> file attribute. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <para>This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists
and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b></para>
      <para>attribute set.</para>
      <para>When <b>CopyFile</b> is used to copy an encrypted file, it attempts
to encrypt the destination file with the keys used in the encryption of the source file. If this cannot be done,
this function attempts to encrypt the destination file with default keys. If
neither of these methods can be done, <b>CopyFile</b> fails with an
<b>ERROR_ENCRYPTION_FAILED</b> error code.</para>
      <para>Symbolic link behavior—If the source file is a symbolic link, the actual file copied is
the target of the symbolic link.</para>
      <para>If the destination file already exists and is a symbolic link, the target of the symbolic link is overwritten
by the source file.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CopyFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFileEx" />
    <seealso cref="CopyFileTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CopyFileW">
    <summary>
      <para>Copies an existing file to a new file.</para>
      <para>The <see cref="CopyFileEx" /> function provides two additional
capabilities. <b>CopyFileEx</b> can call a specified callback
function each time a portion of the copy operation is completed, and
<b>CopyFileEx</b> can be canceled during the copy operation.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
      <para>If <i>lpExistingFileName</i> does not exist,
<b>CopyFile</b> fails, and
<see cref="GetLastError" /> returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="bFailIfExists">
      <para>If this parameter is <b>TRUE</b> and the new file specified by
<i>lpNewFileName</i> already exists, the function fails. If this parameter is
<b>FALSE</b> and the new file already exists, the function overwrites the existing file and
succeeds.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The security resource properties (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are
copied to the new file.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource properties for the existing file are not copied to the new file until
Windows 8 and Windows Server 2012.</para>
      <para>File attributes for the existing file are copied to the new file. For example, if an existing file has the
<b>FILE_ATTRIBUTE_READONLY</b> file attribute, a copy created through a call to
<b>CopyFile</b> will also have the
<b>FILE_ATTRIBUTE_READONLY</b> file attribute. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <para>This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists
and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b></para>
      <para>attribute set.</para>
      <para>When <b>CopyFile</b> is used to copy an encrypted file, it attempts
to encrypt the destination file with the keys used in the encryption of the source file. If this cannot be done,
this function attempts to encrypt the destination file with default keys. If
neither of these methods can be done, <b>CopyFile</b> fails with an
<b>ERROR_ENCRYPTION_FAILED</b> error code.</para>
      <para>Symbolic link behavior—If the source file is a symbolic link, the actual file copied is
the target of the symbolic link.</para>
      <para>If the destination file already exists and is a symbolic link, the target of the symbolic link is overwritten
by the source file.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CopyFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFileEx" />
    <seealso cref="CopyFileTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CopyFileEx">
    <summary>
      <para>Copies an existing file to a new file, notifying the application of its progress through a callback
function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
      <para>If <i>lpExistingFileName</i> does not exist, the
<b>CopyFileEx</b> function fails, and the
<see cref="GetLastError" /> function returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\?" to
the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting inWindows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpProgressRoutine">
      <para>The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called
each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For
more information on the progress callback function, see the
<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.</para>
    </param>
    <param name="lpData">
      <para>The argument to be passed to the callback function. This parameter can be
<b>NULL</b>.</para>
    </param>
    <param name="pbCancel">
      <para>If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled.
Otherwise, the copy operation will continue to completion.</para>
    </param>
    <param name="dwCopyFlags">
      <para>Flags that specify how the file is to be copied. This parameter can be a combination of the following
values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to copy an encrypted file will succeed even if the destination copy cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_COPY_SYMLINK</b>
                </description>
              </item>
              <item>
                <description>0x00000800</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same
file that the source symbolic link is pointing to.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_FAIL_IF_EXISTS</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The copy operation fails immediately if the target file already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_NO_BUFFERING</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The copy operation is performed using unbuffered I/O, bypassing system I/O cache resources. Recommended
for very large file transfers.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is copied and the original file is opened for write access.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_RESTARTABLE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be
restarted at a later time by specifying the same values for <i>lpExistingFileName</i> and
<i>lpNewFileName</i> as those used in the call that failed. This can significantly slow
down the copy operation as the new file may be flushed multiple times during the copy operation.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information call
<see cref="GetLastError" />.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the
user canceling the operation, <b>CopyFileEx</b> will return zero
and <see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is
deleted.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the
user stopping the operation, <b>CopyFileEx</b> will return zero
and <see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left
intact.</para>
    </returns>
    <remarks>
      <para>This function preserves extended attributes, OLE structured storage, NTFS file system alternate data streams,
security resource attributes, and file attributes.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource attributes (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are not copied to the new file until Windows 8
and Windows Server 2012.</para>
      <para>The security resource properties (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are
copied to the new file.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource properties for the existing file are not copied to the new file until
Windows 8 and Windows Server 2012.</para>
      <para>This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists
and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b></para>
      <para>attribute set.</para>
      <para>When encrypted files are copied using <b>CopyFileEx</b>, the
function attempts to encrypt the destination file with the keys used in the encryption of the source file. If
this cannot be done, this function attempts to encrypt the destination file with default keys. If both of these
methods cannot be done, <b>CopyFileEx</b> fails with an
<b>ERROR_ENCRYPTION_FAILED</b> error code. If you want
<b>CopyFileEx</b> to complete the copy operation even if the
destination file cannot be encrypted, include the
<b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b> as the value of the
<i>dwCopyFlags</i> parameter in your call to
<b>CopyFileEx</b>.</para>
      <para>If <b>COPY_FILE_COPY_SYMLINK</b>  is specified, the following rules apply:</para>
      <list type="bullet">
        <item>
          <description>If the source file is a symbolic link, the symbolic link is copied, not the target file.</description>
        </item>
        <item>
          <description>If the source file is not a symbolic link, there is no change in behavior.</description>
        </item>
        <item>
          <description>If the destination file is an existing symbolic link, the symbolic link is overwritten, not the target
file.</description>
        </item>
        <item>
          <description>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is also specified, and the destination file is an
existing symbolic link, the operation fails in all cases.</description>
        </item>
      </list>
      <para>If <b>COPY_FILE_COPY_SYMLINK</b> is not specified, the following rules apply:</para>
      <list type="bullet">
        <item>
          <description>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is also specified, and the destination file is an
existing symbolic link, the operation fails only if the target of the symbolic link exists.</description>
        </item>
        <item>
          <description>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is not specified, there is no change in behavior.</description>
        </item>
      </list>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>If you are writing an application that is optimizing file copy operations across a LAN, consider using the
<see cref="TransmitFile" /> function from Windows Sockets
(Winsock). <b>TransmitFile</b> supports high-performance
network transfers and provides a simple interface to send the contents of a file to a remote computer. To use
<b>TransmitFile</b>, you must write a Winsock client
application that sends the file from the source computer as well as a Winsock server application that uses
other Winsock functions to receive the file on the remote computer.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CopyFileEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso cref="CopyFileTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</seealso>
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFile" />
    <seealso cref="MoveFileWithProgress" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso cref="TransmitFile" />
  </member>
  <member name="Windows.CopyFileExA">
    <summary>
      <para>Copies an existing file to a new file, notifying the application of its progress through a callback
function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
      <para>If <i>lpExistingFileName</i> does not exist, the
<b>CopyFileEx</b> function fails, and the
<see cref="GetLastError" /> function returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\?" to
the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting inWindows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpProgressRoutine">
      <para>The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called
each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For
more information on the progress callback function, see the
<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.</para>
    </param>
    <param name="lpData">
      <para>The argument to be passed to the callback function. This parameter can be
<b>NULL</b>.</para>
    </param>
    <param name="pbCancel">
      <para>If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled.
Otherwise, the copy operation will continue to completion.</para>
    </param>
    <param name="dwCopyFlags">
      <para>Flags that specify how the file is to be copied. This parameter can be a combination of the following
values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to copy an encrypted file will succeed even if the destination copy cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_COPY_SYMLINK</b>
                </description>
              </item>
              <item>
                <description>0x00000800</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same
file that the source symbolic link is pointing to.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_FAIL_IF_EXISTS</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The copy operation fails immediately if the target file already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_NO_BUFFERING</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The copy operation is performed using unbuffered I/O, bypassing system I/O cache resources. Recommended
for very large file transfers.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is copied and the original file is opened for write access.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_RESTARTABLE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be
restarted at a later time by specifying the same values for <i>lpExistingFileName</i> and
<i>lpNewFileName</i> as those used in the call that failed. This can significantly slow
down the copy operation as the new file may be flushed multiple times during the copy operation.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information call
<see cref="GetLastError" />.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the
user canceling the operation, <b>CopyFileEx</b> will return zero
and <see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is
deleted.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the
user stopping the operation, <b>CopyFileEx</b> will return zero
and <see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left
intact.</para>
    </returns>
    <remarks>
      <para>This function preserves extended attributes, OLE structured storage, NTFS file system alternate data streams,
security resource attributes, and file attributes.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource attributes (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are not copied to the new file until Windows 8
and Windows Server 2012.</para>
      <para>The security resource properties (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are
copied to the new file.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource properties for the existing file are not copied to the new file until
Windows 8 and Windows Server 2012.</para>
      <para>This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists
and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b></para>
      <para>attribute set.</para>
      <para>When encrypted files are copied using <b>CopyFileEx</b>, the
function attempts to encrypt the destination file with the keys used in the encryption of the source file. If
this cannot be done, this function attempts to encrypt the destination file with default keys. If both of these
methods cannot be done, <b>CopyFileEx</b> fails with an
<b>ERROR_ENCRYPTION_FAILED</b> error code. If you want
<b>CopyFileEx</b> to complete the copy operation even if the
destination file cannot be encrypted, include the
<b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b> as the value of the
<i>dwCopyFlags</i> parameter in your call to
<b>CopyFileEx</b>.</para>
      <para>If <b>COPY_FILE_COPY_SYMLINK</b>  is specified, the following rules apply:</para>
      <list type="bullet">
        <item>
          <description>If the source file is a symbolic link, the symbolic link is copied, not the target file.</description>
        </item>
        <item>
          <description>If the source file is not a symbolic link, there is no change in behavior.</description>
        </item>
        <item>
          <description>If the destination file is an existing symbolic link, the symbolic link is overwritten, not the target
file.</description>
        </item>
        <item>
          <description>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is also specified, and the destination file is an
existing symbolic link, the operation fails in all cases.</description>
        </item>
      </list>
      <para>If <b>COPY_FILE_COPY_SYMLINK</b> is not specified, the following rules apply:</para>
      <list type="bullet">
        <item>
          <description>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is also specified, and the destination file is an
existing symbolic link, the operation fails only if the target of the symbolic link exists.</description>
        </item>
        <item>
          <description>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is not specified, there is no change in behavior.</description>
        </item>
      </list>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>If you are writing an application that is optimizing file copy operations across a LAN, consider using the
<see cref="TransmitFile" /> function from Windows Sockets
(Winsock). <b>TransmitFile</b> supports high-performance
network transfers and provides a simple interface to send the contents of a file to a remote computer. To use
<b>TransmitFile</b>, you must write a Winsock client
application that sends the file from the source computer as well as a Winsock server application that uses
other Winsock functions to receive the file on the remote computer.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CopyFileEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso cref="CopyFileTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</seealso>
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFile" />
    <seealso cref="MoveFileWithProgress" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso cref="TransmitFile" />
  </member>
  <member name="Windows.CopyFileExW">
    <summary>
      <para>Copies an existing file to a new file, notifying the application of its progress through a callback
function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
      <para>If <i>lpExistingFileName</i> does not exist, the
<b>CopyFileEx</b> function fails, and the
<see cref="GetLastError" /> function returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\?" to
the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting inWindows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpProgressRoutine">
      <para>The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called
each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For
more information on the progress callback function, see the
<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.</para>
    </param>
    <param name="lpData">
      <para>The argument to be passed to the callback function. This parameter can be
<b>NULL</b>.</para>
    </param>
    <param name="pbCancel">
      <para>If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled.
Otherwise, the copy operation will continue to completion.</para>
    </param>
    <param name="dwCopyFlags">
      <para>Flags that specify how the file is to be copied. This parameter can be a combination of the following
values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to copy an encrypted file will succeed even if the destination copy cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_COPY_SYMLINK</b>
                </description>
              </item>
              <item>
                <description>0x00000800</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same
file that the source symbolic link is pointing to.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_FAIL_IF_EXISTS</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The copy operation fails immediately if the target file already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_NO_BUFFERING</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The copy operation is performed using unbuffered I/O, bypassing system I/O cache resources. Recommended
for very large file transfers.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is copied and the original file is opened for write access.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_RESTARTABLE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be
restarted at a later time by specifying the same values for <i>lpExistingFileName</i> and
<i>lpNewFileName</i> as those used in the call that failed. This can significantly slow
down the copy operation as the new file may be flushed multiple times during the copy operation.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information call
<see cref="GetLastError" />.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the
user canceling the operation, <b>CopyFileEx</b> will return zero
and <see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is
deleted.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the
user stopping the operation, <b>CopyFileEx</b> will return zero
and <see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left
intact.</para>
    </returns>
    <remarks>
      <para>This function preserves extended attributes, OLE structured storage, NTFS file system alternate data streams,
security resource attributes, and file attributes.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource attributes (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are not copied to the new file until Windows 8
and Windows Server 2012.</para>
      <para>The security resource properties (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are
copied to the new file.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource properties for the existing file are not copied to the new file until
Windows 8 and Windows Server 2012.</para>
      <para>This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists
and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b></para>
      <para>attribute set.</para>
      <para>When encrypted files are copied using <b>CopyFileEx</b>, the
function attempts to encrypt the destination file with the keys used in the encryption of the source file. If
this cannot be done, this function attempts to encrypt the destination file with default keys. If both of these
methods cannot be done, <b>CopyFileEx</b> fails with an
<b>ERROR_ENCRYPTION_FAILED</b> error code. If you want
<b>CopyFileEx</b> to complete the copy operation even if the
destination file cannot be encrypted, include the
<b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b> as the value of the
<i>dwCopyFlags</i> parameter in your call to
<b>CopyFileEx</b>.</para>
      <para>If <b>COPY_FILE_COPY_SYMLINK</b>  is specified, the following rules apply:</para>
      <list type="bullet">
        <item>
          <description>If the source file is a symbolic link, the symbolic link is copied, not the target file.</description>
        </item>
        <item>
          <description>If the source file is not a symbolic link, there is no change in behavior.</description>
        </item>
        <item>
          <description>If the destination file is an existing symbolic link, the symbolic link is overwritten, not the target
file.</description>
        </item>
        <item>
          <description>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is also specified, and the destination file is an
existing symbolic link, the operation fails in all cases.</description>
        </item>
      </list>
      <para>If <b>COPY_FILE_COPY_SYMLINK</b> is not specified, the following rules apply:</para>
      <list type="bullet">
        <item>
          <description>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is also specified, and the destination file is an
existing symbolic link, the operation fails only if the target of the symbolic link exists.</description>
        </item>
        <item>
          <description>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is not specified, there is no change in behavior.</description>
        </item>
      </list>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>If you are writing an application that is optimizing file copy operations across a LAN, consider using the
<see cref="TransmitFile" /> function from Windows Sockets
(Winsock). <b>TransmitFile</b> supports high-performance
network transfers and provides a simple interface to send the contents of a file to a remote computer. To use
<b>TransmitFile</b>, you must write a Winsock client
application that sends the file from the source computer as well as a Winsock server application that uses
other Winsock functions to receive the file on the remote computer.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CopyFileEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso cref="CopyFileTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</seealso>
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFile" />
    <seealso cref="MoveFileWithProgress" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso cref="TransmitFile" />
  </member>
  <member name="Windows.CopyFileEx">
    <summary>
      <para>Copies an existing file to a new file, notifying the application of its progress through a callback
function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
      <para>If <i>lpExistingFileName</i> does not exist, the
<b>CopyFileEx</b> function fails, and the
<see cref="GetLastError" /> function returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\?" to
the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting inWindows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpProgressRoutine">
      <para>The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called
each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For
more information on the progress callback function, see the
<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.</para>
    </param>
    <param name="lpData">
      <para>The argument to be passed to the callback function. This parameter can be
<b>NULL</b>.</para>
    </param>
    <param name="pbCancel">
      <para>If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled.
Otherwise, the copy operation will continue to completion.</para>
    </param>
    <param name="dwCopyFlags">
      <para>Flags that specify how the file is to be copied. This parameter can be a combination of the following
values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to copy an encrypted file will succeed even if the destination copy cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_COPY_SYMLINK</b>
                </description>
              </item>
              <item>
                <description>0x00000800</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same
file that the source symbolic link is pointing to.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_FAIL_IF_EXISTS</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The copy operation fails immediately if the target file already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_NO_BUFFERING</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The copy operation is performed using unbuffered I/O, bypassing system I/O cache resources. Recommended
for very large file transfers.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is copied and the original file is opened for write access.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_RESTARTABLE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be
restarted at a later time by specifying the same values for <i>lpExistingFileName</i> and
<i>lpNewFileName</i> as those used in the call that failed. This can significantly slow
down the copy operation as the new file may be flushed multiple times during the copy operation.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information call
<see cref="GetLastError" />.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the
user canceling the operation, <b>CopyFileEx</b> will return zero
and <see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is
deleted.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the
user stopping the operation, <b>CopyFileEx</b> will return zero
and <see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left
intact.</para>
    </returns>
    <remarks>
      <para>This function preserves extended attributes, OLE structured storage, NTFS file system alternate data streams,
security resource attributes, and file attributes.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource attributes (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are not copied to the new file until Windows 8
and Windows Server 2012.</para>
      <para>The security resource properties (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are
copied to the new file.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource properties for the existing file are not copied to the new file until
Windows 8 and Windows Server 2012.</para>
      <para>This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists
and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b></para>
      <para>attribute set.</para>
      <para>When encrypted files are copied using <b>CopyFileEx</b>, the
function attempts to encrypt the destination file with the keys used in the encryption of the source file. If
this cannot be done, this function attempts to encrypt the destination file with default keys. If both of these
methods cannot be done, <b>CopyFileEx</b> fails with an
<b>ERROR_ENCRYPTION_FAILED</b> error code. If you want
<b>CopyFileEx</b> to complete the copy operation even if the
destination file cannot be encrypted, include the
<b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b> as the value of the
<i>dwCopyFlags</i> parameter in your call to
<b>CopyFileEx</b>.</para>
      <para>If <b>COPY_FILE_COPY_SYMLINK</b>  is specified, the following rules apply:</para>
      <list type="bullet">
        <item>
          <description>If the source file is a symbolic link, the symbolic link is copied, not the target file.</description>
        </item>
        <item>
          <description>If the source file is not a symbolic link, there is no change in behavior.</description>
        </item>
        <item>
          <description>If the destination file is an existing symbolic link, the symbolic link is overwritten, not the target
file.</description>
        </item>
        <item>
          <description>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is also specified, and the destination file is an
existing symbolic link, the operation fails in all cases.</description>
        </item>
      </list>
      <para>If <b>COPY_FILE_COPY_SYMLINK</b> is not specified, the following rules apply:</para>
      <list type="bullet">
        <item>
          <description>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is also specified, and the destination file is an
existing symbolic link, the operation fails only if the target of the symbolic link exists.</description>
        </item>
        <item>
          <description>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is not specified, there is no change in behavior.</description>
        </item>
      </list>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>If you are writing an application that is optimizing file copy operations across a LAN, consider using the
<see cref="TransmitFile" /> function from Windows Sockets
(Winsock). <b>TransmitFile</b> supports high-performance
network transfers and provides a simple interface to send the contents of a file to a remote computer. To use
<b>TransmitFile</b>, you must write a Winsock client
application that sends the file from the source computer as well as a Winsock server application that uses
other Winsock functions to receive the file on the remote computer.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CopyFileEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso cref="CopyFileTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</seealso>
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFile" />
    <seealso cref="MoveFileWithProgress" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso cref="TransmitFile" />
  </member>
  <member name="Windows.CopyFileExA">
    <summary>
      <para>Copies an existing file to a new file, notifying the application of its progress through a callback
function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
      <para>If <i>lpExistingFileName</i> does not exist, the
<b>CopyFileEx</b> function fails, and the
<see cref="GetLastError" /> function returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\?" to
the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting inWindows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpProgressRoutine">
      <para>The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called
each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For
more information on the progress callback function, see the
<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.</para>
    </param>
    <param name="lpData">
      <para>The argument to be passed to the callback function. This parameter can be
<b>NULL</b>.</para>
    </param>
    <param name="pbCancel">
      <para>If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled.
Otherwise, the copy operation will continue to completion.</para>
    </param>
    <param name="dwCopyFlags">
      <para>Flags that specify how the file is to be copied. This parameter can be a combination of the following
values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to copy an encrypted file will succeed even if the destination copy cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_COPY_SYMLINK</b>
                </description>
              </item>
              <item>
                <description>0x00000800</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same
file that the source symbolic link is pointing to.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_FAIL_IF_EXISTS</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The copy operation fails immediately if the target file already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_NO_BUFFERING</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The copy operation is performed using unbuffered I/O, bypassing system I/O cache resources. Recommended
for very large file transfers.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is copied and the original file is opened for write access.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_RESTARTABLE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be
restarted at a later time by specifying the same values for <i>lpExistingFileName</i> and
<i>lpNewFileName</i> as those used in the call that failed. This can significantly slow
down the copy operation as the new file may be flushed multiple times during the copy operation.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information call
<see cref="GetLastError" />.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the
user canceling the operation, <b>CopyFileEx</b> will return zero
and <see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is
deleted.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the
user stopping the operation, <b>CopyFileEx</b> will return zero
and <see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left
intact.</para>
    </returns>
    <remarks>
      <para>This function preserves extended attributes, OLE structured storage, NTFS file system alternate data streams,
security resource attributes, and file attributes.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource attributes (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are not copied to the new file until Windows 8
and Windows Server 2012.</para>
      <para>The security resource properties (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are
copied to the new file.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource properties for the existing file are not copied to the new file until
Windows 8 and Windows Server 2012.</para>
      <para>This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists
and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b></para>
      <para>attribute set.</para>
      <para>When encrypted files are copied using <b>CopyFileEx</b>, the
function attempts to encrypt the destination file with the keys used in the encryption of the source file. If
this cannot be done, this function attempts to encrypt the destination file with default keys. If both of these
methods cannot be done, <b>CopyFileEx</b> fails with an
<b>ERROR_ENCRYPTION_FAILED</b> error code. If you want
<b>CopyFileEx</b> to complete the copy operation even if the
destination file cannot be encrypted, include the
<b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b> as the value of the
<i>dwCopyFlags</i> parameter in your call to
<b>CopyFileEx</b>.</para>
      <para>If <b>COPY_FILE_COPY_SYMLINK</b>  is specified, the following rules apply:</para>
      <list type="bullet">
        <item>
          <description>If the source file is a symbolic link, the symbolic link is copied, not the target file.</description>
        </item>
        <item>
          <description>If the source file is not a symbolic link, there is no change in behavior.</description>
        </item>
        <item>
          <description>If the destination file is an existing symbolic link, the symbolic link is overwritten, not the target
file.</description>
        </item>
        <item>
          <description>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is also specified, and the destination file is an
existing symbolic link, the operation fails in all cases.</description>
        </item>
      </list>
      <para>If <b>COPY_FILE_COPY_SYMLINK</b> is not specified, the following rules apply:</para>
      <list type="bullet">
        <item>
          <description>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is also specified, and the destination file is an
existing symbolic link, the operation fails only if the target of the symbolic link exists.</description>
        </item>
        <item>
          <description>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is not specified, there is no change in behavior.</description>
        </item>
      </list>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>If you are writing an application that is optimizing file copy operations across a LAN, consider using the
<see cref="TransmitFile" /> function from Windows Sockets
(Winsock). <b>TransmitFile</b> supports high-performance
network transfers and provides a simple interface to send the contents of a file to a remote computer. To use
<b>TransmitFile</b>, you must write a Winsock client
application that sends the file from the source computer as well as a Winsock server application that uses
other Winsock functions to receive the file on the remote computer.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CopyFileEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso cref="CopyFileTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</seealso>
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFile" />
    <seealso cref="MoveFileWithProgress" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso cref="TransmitFile" />
  </member>
  <member name="Windows.CopyFileExW">
    <summary>
      <para>Copies an existing file to a new file, notifying the application of its progress through a callback
function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
      <para>If <i>lpExistingFileName</i> does not exist, the
<b>CopyFileEx</b> function fails, and the
<see cref="GetLastError" /> function returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\?" to
the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting inWindows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpProgressRoutine">
      <para>The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called
each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For
more information on the progress callback function, see the
<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.</para>
    </param>
    <param name="lpData">
      <para>The argument to be passed to the callback function. This parameter can be
<b>NULL</b>.</para>
    </param>
    <param name="pbCancel">
      <para>If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled.
Otherwise, the copy operation will continue to completion.</para>
    </param>
    <param name="dwCopyFlags">
      <para>Flags that specify how the file is to be copied. This parameter can be a combination of the following
values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to copy an encrypted file will succeed even if the destination copy cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_COPY_SYMLINK</b>
                </description>
              </item>
              <item>
                <description>0x00000800</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same
file that the source symbolic link is pointing to.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_FAIL_IF_EXISTS</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The copy operation fails immediately if the target file already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_NO_BUFFERING</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The copy operation is performed using unbuffered I/O, bypassing system I/O cache resources. Recommended
for very large file transfers.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is copied and the original file is opened for write access.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>COPY_FILE_RESTARTABLE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be
restarted at a later time by specifying the same values for <i>lpExistingFileName</i> and
<i>lpNewFileName</i> as those used in the call that failed. This can significantly slow
down the copy operation as the new file may be flushed multiple times during the copy operation.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information call
<see cref="GetLastError" />.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the
user canceling the operation, <b>CopyFileEx</b> will return zero
and <see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is
deleted.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the
user stopping the operation, <b>CopyFileEx</b> will return zero
and <see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left
intact.</para>
    </returns>
    <remarks>
      <para>This function preserves extended attributes, OLE structured storage, NTFS file system alternate data streams,
security resource attributes, and file attributes.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource attributes (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are not copied to the new file until Windows 8
and Windows Server 2012.</para>
      <para>The security resource properties (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are
copied to the new file.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource properties for the existing file are not copied to the new file until
Windows 8 and Windows Server 2012.</para>
      <para>This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists
and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b></para>
      <para>attribute set.</para>
      <para>When encrypted files are copied using <b>CopyFileEx</b>, the
function attempts to encrypt the destination file with the keys used in the encryption of the source file. If
this cannot be done, this function attempts to encrypt the destination file with default keys. If both of these
methods cannot be done, <b>CopyFileEx</b> fails with an
<b>ERROR_ENCRYPTION_FAILED</b> error code. If you want
<b>CopyFileEx</b> to complete the copy operation even if the
destination file cannot be encrypted, include the
<b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b> as the value of the
<i>dwCopyFlags</i> parameter in your call to
<b>CopyFileEx</b>.</para>
      <para>If <b>COPY_FILE_COPY_SYMLINK</b>  is specified, the following rules apply:</para>
      <list type="bullet">
        <item>
          <description>If the source file is a symbolic link, the symbolic link is copied, not the target file.</description>
        </item>
        <item>
          <description>If the source file is not a symbolic link, there is no change in behavior.</description>
        </item>
        <item>
          <description>If the destination file is an existing symbolic link, the symbolic link is overwritten, not the target
file.</description>
        </item>
        <item>
          <description>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is also specified, and the destination file is an
existing symbolic link, the operation fails in all cases.</description>
        </item>
      </list>
      <para>If <b>COPY_FILE_COPY_SYMLINK</b> is not specified, the following rules apply:</para>
      <list type="bullet">
        <item>
          <description>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is also specified, and the destination file is an
existing symbolic link, the operation fails only if the target of the symbolic link exists.</description>
        </item>
        <item>
          <description>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is not specified, there is no change in behavior.</description>
        </item>
      </list>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>If you are writing an application that is optimizing file copy operations across a LAN, consider using the
<see cref="TransmitFile" /> function from Windows Sockets
(Winsock). <b>TransmitFile</b> supports high-performance
network transfers and provides a simple interface to send the contents of a file to a remote computer. To use
<b>TransmitFile</b>, you must write a Winsock client
application that sends the file from the source computer as well as a Winsock server application that uses
other Winsock functions to receive the file on the remote computer.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CopyFileEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso cref="CopyFileTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</seealso>
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFile" />
    <seealso cref="MoveFileWithProgress" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
    <seealso cref="TransmitFile" />
  </member>
  <member name="Windows.CopyFile">
    <summary>
      <para>Copies an existing file to a new file.</para>
      <para>The <see cref="CopyFileEx" /> function provides two additional
capabilities. <b>CopyFileEx</b> can call a specified callback
function each time a portion of the copy operation is completed, and
<b>CopyFileEx</b> can be canceled during the copy operation.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
      <para>If <i>lpExistingFileName</i> does not exist,
<b>CopyFile</b> fails, and
<see cref="GetLastError" /> returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="bFailIfExists">
      <para>If this parameter is <b>TRUE</b> and the new file specified by
<i>lpNewFileName</i> already exists, the function fails. If this parameter is
<b>FALSE</b> and the new file already exists, the function overwrites the existing file and
succeeds.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The security resource properties (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are
copied to the new file.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource properties for the existing file are not copied to the new file until
Windows 8 and Windows Server 2012.</para>
      <para>File attributes for the existing file are copied to the new file. For example, if an existing file has the
<b>FILE_ATTRIBUTE_READONLY</b> file attribute, a copy created through a call to
<b>CopyFile</b> will also have the
<b>FILE_ATTRIBUTE_READONLY</b> file attribute. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <para>This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists
and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b></para>
      <para>attribute set.</para>
      <para>When <b>CopyFile</b> is used to copy an encrypted file, it attempts
to encrypt the destination file with the keys used in the encryption of the source file. If this cannot be done,
this function attempts to encrypt the destination file with default keys. If
neither of these methods can be done, <b>CopyFile</b> fails with an
<b>ERROR_ENCRYPTION_FAILED</b> error code.</para>
      <para>Symbolic link behavior—If the source file is a symbolic link, the actual file copied is
the target of the symbolic link.</para>
      <para>If the destination file already exists and is a symbolic link, the target of the symbolic link is overwritten
by the source file.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CopyFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFileEx" />
    <seealso cref="CopyFileTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CopyFileA">
    <summary>
      <para>Copies an existing file to a new file.</para>
      <para>The <see cref="CopyFileEx" /> function provides two additional
capabilities. <b>CopyFileEx</b> can call a specified callback
function each time a portion of the copy operation is completed, and
<b>CopyFileEx</b> can be canceled during the copy operation.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
      <para>If <i>lpExistingFileName</i> does not exist,
<b>CopyFile</b> fails, and
<see cref="GetLastError" /> returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="bFailIfExists">
      <para>If this parameter is <b>TRUE</b> and the new file specified by
<i>lpNewFileName</i> already exists, the function fails. If this parameter is
<b>FALSE</b> and the new file already exists, the function overwrites the existing file and
succeeds.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The security resource properties (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are
copied to the new file.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource properties for the existing file are not copied to the new file until
Windows 8 and Windows Server 2012.</para>
      <para>File attributes for the existing file are copied to the new file. For example, if an existing file has the
<b>FILE_ATTRIBUTE_READONLY</b> file attribute, a copy created through a call to
<b>CopyFile</b> will also have the
<b>FILE_ATTRIBUTE_READONLY</b> file attribute. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <para>This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists
and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b></para>
      <para>attribute set.</para>
      <para>When <b>CopyFile</b> is used to copy an encrypted file, it attempts
to encrypt the destination file with the keys used in the encryption of the source file. If this cannot be done,
this function attempts to encrypt the destination file with default keys. If
neither of these methods can be done, <b>CopyFile</b> fails with an
<b>ERROR_ENCRYPTION_FAILED</b> error code.</para>
      <para>Symbolic link behavior—If the source file is a symbolic link, the actual file copied is
the target of the symbolic link.</para>
      <para>If the destination file already exists and is a symbolic link, the target of the symbolic link is overwritten
by the source file.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CopyFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFileEx" />
    <seealso cref="CopyFileTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CopyFileW">
    <summary>
      <para>Copies an existing file to a new file.</para>
      <para>The <see cref="CopyFileEx" /> function provides two additional
capabilities. <b>CopyFileEx</b> can call a specified callback
function each time a portion of the copy operation is completed, and
<b>CopyFileEx</b> can be canceled during the copy operation.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
      <para>If <i>lpExistingFileName</i> does not exist,
<b>CopyFile</b> fails, and
<see cref="GetLastError" /> returns
<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="bFailIfExists">
      <para>If this parameter is <b>TRUE</b> and the new file specified by
<i>lpNewFileName</i> already exists, the function fails. If this parameter is
<b>FALSE</b> and the new file already exists, the function overwrites the existing file and
succeeds.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The security resource properties (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are
copied to the new file.</para>
      <para>
        <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource properties for the existing file are not copied to the new file until
Windows 8 and Windows Server 2012.</para>
      <para>File attributes for the existing file are copied to the new file. For example, if an existing file has the
<b>FILE_ATTRIBUTE_READONLY</b> file attribute, a copy created through a call to
<b>CopyFile</b> will also have the
<b>FILE_ATTRIBUTE_READONLY</b> file attribute. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <para>This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists
and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b></para>
      <para>attribute set.</para>
      <para>When <b>CopyFile</b> is used to copy an encrypted file, it attempts
to encrypt the destination file with the keys used in the encryption of the source file. If this cannot be done,
this function attempts to encrypt the destination file with default keys. If
neither of these methods can be done, <b>CopyFile</b> fails with an
<b>ERROR_ENCRYPTION_FAILED</b> error code.</para>
      <para>Symbolic link behavior—If the source file is a symbolic link, the actual file copied is
the target of the symbolic link.</para>
      <para>If the destination file already exists and is a symbolic link, the target of the symbolic link is overwritten
by the source file.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CopyFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFileEx" />
    <seealso cref="CopyFileTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CreateActCtx">
    <summary>
      <para>The
<b>CreateActCtx</b> function creates an activation context.</para>
    </summary>
    <param name="pActCtx">
      <para>Pointer to an
<see cref="ACTCTX" /> structure that contains information about the activation context to be created.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a handle to the returned activation context. Otherwise, it returns INVALID_HANDLE_VALUE.</para>
      <para>This function sets errors that can be retrieved by calling
<see cref="GetLastError" />. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
    <remarks>
      <para>Set any undefined bits in <b>dwFlags</b> of
<see cref="ACTCTX" /> to 0. If any undefined bits are not set to 0, the call to
<b>CreateActCtx</b> that creates the activation context fails and returns an invalid parameter error code. The handle returned from
<b>CreateActCtx</b> is passed in a call to
<see cref="ActivateActCtx" /> to activate the context for the current thread.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateActCtx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ACTCTX" />
  </member>
  <member name="Windows.CreateActCtxA">
    <summary>
      <para>The
<b>CreateActCtx</b> function creates an activation context.</para>
    </summary>
    <param name="pActCtx">
      <para>Pointer to an
<see cref="ACTCTX" /> structure that contains information about the activation context to be created.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a handle to the returned activation context. Otherwise, it returns INVALID_HANDLE_VALUE.</para>
      <para>This function sets errors that can be retrieved by calling
<see cref="GetLastError" />. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
    <remarks>
      <para>Set any undefined bits in <b>dwFlags</b> of
<see cref="ACTCTX" /> to 0. If any undefined bits are not set to 0, the call to
<b>CreateActCtx</b> that creates the activation context fails and returns an invalid parameter error code. The handle returned from
<b>CreateActCtx</b> is passed in a call to
<see cref="ActivateActCtx" /> to activate the context for the current thread.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateActCtx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ACTCTX" />
  </member>
  <member name="Windows.CreateActCtxW">
    <summary>
      <para>The
<b>CreateActCtx</b> function creates an activation context.</para>
    </summary>
    <param name="pActCtx">
      <para>Pointer to an
<see cref="ACTCTX" /> structure that contains information about the activation context to be created.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a handle to the returned activation context. Otherwise, it returns INVALID_HANDLE_VALUE.</para>
      <para>This function sets errors that can be retrieved by calling
<see cref="GetLastError" />. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
    <remarks>
      <para>Set any undefined bits in <b>dwFlags</b> of
<see cref="ACTCTX" /> to 0. If any undefined bits are not set to 0, the call to
<b>CreateActCtx</b> that creates the activation context fails and returns an invalid parameter error code. The handle returned from
<b>CreateActCtx</b> is passed in a call to
<see cref="ActivateActCtx" /> to activate the context for the current thread.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateActCtx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ACTCTX" />
  </member>
  <member name="Windows.CreateActCtx">
    <summary>
      <para>The
<b>CreateActCtx</b> function creates an activation context.</para>
    </summary>
    <param name="pActCtx">
      <para>Pointer to an
<see cref="ACTCTX" /> structure that contains information about the activation context to be created.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a handle to the returned activation context. Otherwise, it returns INVALID_HANDLE_VALUE.</para>
      <para>This function sets errors that can be retrieved by calling
<see cref="GetLastError" />. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
    <remarks>
      <para>Set any undefined bits in <b>dwFlags</b> of
<see cref="ACTCTX" /> to 0. If any undefined bits are not set to 0, the call to
<b>CreateActCtx</b> that creates the activation context fails and returns an invalid parameter error code. The handle returned from
<b>CreateActCtx</b> is passed in a call to
<see cref="ActivateActCtx" /> to activate the context for the current thread.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateActCtx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ACTCTX" />
  </member>
  <member name="Windows.CreateActCtxA">
    <summary>
      <para>The
<b>CreateActCtx</b> function creates an activation context.</para>
    </summary>
    <param name="pActCtx">
      <para>Pointer to an
<see cref="ACTCTX" /> structure that contains information about the activation context to be created.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a handle to the returned activation context. Otherwise, it returns INVALID_HANDLE_VALUE.</para>
      <para>This function sets errors that can be retrieved by calling
<see cref="GetLastError" />. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
    <remarks>
      <para>Set any undefined bits in <b>dwFlags</b> of
<see cref="ACTCTX" /> to 0. If any undefined bits are not set to 0, the call to
<b>CreateActCtx</b> that creates the activation context fails and returns an invalid parameter error code. The handle returned from
<b>CreateActCtx</b> is passed in a call to
<see cref="ActivateActCtx" /> to activate the context for the current thread.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateActCtx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ACTCTX" />
  </member>
  <member name="Windows.CreateActCtxW">
    <summary>
      <para>The
<b>CreateActCtx</b> function creates an activation context.</para>
    </summary>
    <param name="pActCtx">
      <para>Pointer to an
<see cref="ACTCTX" /> structure that contains information about the activation context to be created.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a handle to the returned activation context. Otherwise, it returns INVALID_HANDLE_VALUE.</para>
      <para>This function sets errors that can be retrieved by calling
<see cref="GetLastError" />. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
    <remarks>
      <para>Set any undefined bits in <b>dwFlags</b> of
<see cref="ACTCTX" /> to 0. If any undefined bits are not set to 0, the call to
<b>CreateActCtx</b> that creates the activation context fails and returns an invalid parameter error code. The handle returned from
<b>CreateActCtx</b> is passed in a call to
<see cref="ActivateActCtx" /> to activate the context for the current thread.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateActCtx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ACTCTX" />
  </member>
  <member name="Windows.CreateDirectory">
    <summary>
      <para>Creates a new directory. If the underlying file system supports security on files and
directories, the function applies a specified security descriptor to the new directory.</para>
      <para>To specify a template directory, use the
<see cref="CreateDirectoryEx" /> function.</para>
      <para>To perform this
operation as a transacted operation, use the
<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be created.</para>
      <para>For the ANSI version of this function, there is a default string size limit for paths of 248 characters (<b>MAX_PATH</b> - enough room for a 8.3 filename). To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryW</b>), you can opt-in to remove the 248 character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
descriptor for the new directory. If <i>lpSecurityAttributes</i> is
<b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default
security descriptor for a  directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect.
(This is indicated when <see cref="GetVolumeInformation" /></para>
      <para>returns <b>FS_PERSISTENT_ACLS</b>.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible errors include the
following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified directory already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>One or more intermediate directories do not exist; this function will only create the final directory in
the path.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Some file systems, such as the NTFS file system, support compression or encryption for individual files and
directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption
attributes of its parent directory.</para>
      <para>An application can obtain a handle to a directory by calling
<see cref="CreateFile" /> with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set. For a code example, see
<b>CreateFile</b>.</para>
      <para>To support inheritance functions that query the security descriptor of this object may heuristically determine
and report that inheritance is in effect. See
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a></para>
      <para>for more information.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
    </remarks>
    <seealso cref="CreateDirectoryEx" />
    <seealso cref="CreateDirectoryTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</seealso>
  </member>
  <member name="Windows.CreateDirectoryA">
    <summary>
      <para>Creates a new directory. If the underlying file system supports security on files and
directories, the function applies a specified security descriptor to the new directory.</para>
      <para>To specify a template directory, use the
<see cref="CreateDirectoryEx" /> function.</para>
      <para>To perform this
operation as a transacted operation, use the
<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be created.</para>
      <para>For the ANSI version of this function, there is a default string size limit for paths of 248 characters (<b>MAX_PATH</b> - enough room for a 8.3 filename). To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryW</b>), you can opt-in to remove the 248 character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
descriptor for the new directory. If <i>lpSecurityAttributes</i> is
<b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default
security descriptor for a  directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect.
(This is indicated when <see cref="GetVolumeInformation" /></para>
      <para>returns <b>FS_PERSISTENT_ACLS</b>.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible errors include the
following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified directory already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>One or more intermediate directories do not exist; this function will only create the final directory in
the path.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Some file systems, such as the NTFS file system, support compression or encryption for individual files and
directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption
attributes of its parent directory.</para>
      <para>An application can obtain a handle to a directory by calling
<see cref="CreateFile" /> with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set. For a code example, see
<b>CreateFile</b>.</para>
      <para>To support inheritance functions that query the security descriptor of this object may heuristically determine
and report that inheritance is in effect. See
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a></para>
      <para>for more information.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
    </remarks>
    <seealso cref="CreateDirectoryEx" />
    <seealso cref="CreateDirectoryTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</seealso>
  </member>
  <member name="Windows.CreateDirectoryW">
    <summary>
      <para>Creates a new directory. If the underlying file system supports security on files and
directories, the function applies a specified security descriptor to the new directory.</para>
      <para>To specify a template directory, use the
<see cref="CreateDirectoryEx" /> function.</para>
      <para>To perform this
operation as a transacted operation, use the
<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be created.</para>
      <para>For the ANSI version of this function, there is a default string size limit for paths of 248 characters (<b>MAX_PATH</b> - enough room for a 8.3 filename). To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryW</b>), you can opt-in to remove the 248 character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
descriptor for the new directory. If <i>lpSecurityAttributes</i> is
<b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default
security descriptor for a  directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect.
(This is indicated when <see cref="GetVolumeInformation" /></para>
      <para>returns <b>FS_PERSISTENT_ACLS</b>.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible errors include the
following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified directory already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>One or more intermediate directories do not exist; this function will only create the final directory in
the path.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Some file systems, such as the NTFS file system, support compression or encryption for individual files and
directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption
attributes of its parent directory.</para>
      <para>An application can obtain a handle to a directory by calling
<see cref="CreateFile" /> with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set. For a code example, see
<b>CreateFile</b>.</para>
      <para>To support inheritance functions that query the security descriptor of this object may heuristically determine
and report that inheritance is in effect. See
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a></para>
      <para>for more information.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.</para>
    </remarks>
    <seealso cref="CreateDirectoryEx" />
    <seealso cref="CreateDirectoryTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</seealso>
  </member>
  <member name="Windows.CreateDirectoryEx">
    <summary>
      <para>Creates a new directory with the attributes of a specified template directory. If the
underlying file system supports security on files and directories, the function applies a specified security
descriptor to the new directory. The new directory retains the other attributes of the specified template
directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpTemplateDirectory">
      <para>The path of the directory to use as a template when creating the new directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewDirectory">
      <para>The path of the directory to be created.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
descriptor for the new directory.</para>
      <para>If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a
default security descriptor. The access control lists (ACL) in the default security descriptor for a directory
are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect.
This is indicated when <see cref="GetVolumeInformation" /></para>
      <para>returns <b>FS_PERSISTENT_ACLS</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />. Possible errors include the
following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified directory already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>One or more intermediate directories do not exist. This function only creates the final directory in the
path. To create all intermediate directories on the path, use the
<see cref="SHCreateDirectoryEx" /> function.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>CreateDirectoryEx</b> function allows you to
create directories that inherit stream information from other directories. This function is useful, for example,
when you are using Macintosh directories, which have a resource stream that is needed to properly identify
directory contents as an attribute.</para>
      <para>Some file systems, such as the NTFS file system, support compression or encryption for individual files and
directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption
attributes of its parent directory.</para>
      <para>You can obtain a handle to a directory by calling the
<see cref="CreateFile" /> function with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set. For a code example, see
<b>CreateFile</b>.</para>
      <para>To support inheritance functions that query the security descriptor of this
object can heuristically determine and report that inheritance is in effect. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateDirectoryEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateDirectory" />
    <seealso cref="CreateDirectoryTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
  </member>
  <member name="Windows.CreateDirectoryExA">
    <summary>
      <para>Creates a new directory with the attributes of a specified template directory. If the
underlying file system supports security on files and directories, the function applies a specified security
descriptor to the new directory. The new directory retains the other attributes of the specified template
directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpTemplateDirectory">
      <para>The path of the directory to use as a template when creating the new directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewDirectory">
      <para>The path of the directory to be created.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
descriptor for the new directory.</para>
      <para>If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a
default security descriptor. The access control lists (ACL) in the default security descriptor for a directory
are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect.
This is indicated when <see cref="GetVolumeInformation" /></para>
      <para>returns <b>FS_PERSISTENT_ACLS</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />. Possible errors include the
following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified directory already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>One or more intermediate directories do not exist. This function only creates the final directory in the
path. To create all intermediate directories on the path, use the
<see cref="SHCreateDirectoryEx" /> function.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>CreateDirectoryEx</b> function allows you to
create directories that inherit stream information from other directories. This function is useful, for example,
when you are using Macintosh directories, which have a resource stream that is needed to properly identify
directory contents as an attribute.</para>
      <para>Some file systems, such as the NTFS file system, support compression or encryption for individual files and
directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption
attributes of its parent directory.</para>
      <para>You can obtain a handle to a directory by calling the
<see cref="CreateFile" /> function with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set. For a code example, see
<b>CreateFile</b>.</para>
      <para>To support inheritance functions that query the security descriptor of this
object can heuristically determine and report that inheritance is in effect. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateDirectoryEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateDirectory" />
    <seealso cref="CreateDirectoryTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
  </member>
  <member name="Windows.CreateDirectoryExW">
    <summary>
      <para>Creates a new directory with the attributes of a specified template directory. If the
underlying file system supports security on files and directories, the function applies a specified security
descriptor to the new directory. The new directory retains the other attributes of the specified template
directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpTemplateDirectory">
      <para>The path of the directory to use as a template when creating the new directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewDirectory">
      <para>The path of the directory to be created.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
descriptor for the new directory.</para>
      <para>If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a
default security descriptor. The access control lists (ACL) in the default security descriptor for a directory
are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect.
This is indicated when <see cref="GetVolumeInformation" /></para>
      <para>returns <b>FS_PERSISTENT_ACLS</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />. Possible errors include the
following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified directory already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>One or more intermediate directories do not exist. This function only creates the final directory in the
path. To create all intermediate directories on the path, use the
<see cref="SHCreateDirectoryEx" /> function.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>CreateDirectoryEx</b> function allows you to
create directories that inherit stream information from other directories. This function is useful, for example,
when you are using Macintosh directories, which have a resource stream that is needed to properly identify
directory contents as an attribute.</para>
      <para>Some file systems, such as the NTFS file system, support compression or encryption for individual files and
directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption
attributes of its parent directory.</para>
      <para>You can obtain a handle to a directory by calling the
<see cref="CreateFile" /> function with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set. For a code example, see
<b>CreateFile</b>.</para>
      <para>To support inheritance functions that query the security descriptor of this
object can heuristically determine and report that inheritance is in effect. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateDirectoryEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateDirectory" />
    <seealso cref="CreateDirectoryTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
  </member>
  <member name="Windows.CreateDirectoryEx">
    <summary>
      <para>Creates a new directory with the attributes of a specified template directory. If the
underlying file system supports security on files and directories, the function applies a specified security
descriptor to the new directory. The new directory retains the other attributes of the specified template
directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpTemplateDirectory">
      <para>The path of the directory to use as a template when creating the new directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewDirectory">
      <para>The path of the directory to be created.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
descriptor for the new directory.</para>
      <para>If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a
default security descriptor. The access control lists (ACL) in the default security descriptor for a directory
are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect.
This is indicated when <see cref="GetVolumeInformation" /></para>
      <para>returns <b>FS_PERSISTENT_ACLS</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />. Possible errors include the
following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified directory already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>One or more intermediate directories do not exist. This function only creates the final directory in the
path. To create all intermediate directories on the path, use the
<see cref="SHCreateDirectoryEx" /> function.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>CreateDirectoryEx</b> function allows you to
create directories that inherit stream information from other directories. This function is useful, for example,
when you are using Macintosh directories, which have a resource stream that is needed to properly identify
directory contents as an attribute.</para>
      <para>Some file systems, such as the NTFS file system, support compression or encryption for individual files and
directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption
attributes of its parent directory.</para>
      <para>You can obtain a handle to a directory by calling the
<see cref="CreateFile" /> function with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set. For a code example, see
<b>CreateFile</b>.</para>
      <para>To support inheritance functions that query the security descriptor of this
object can heuristically determine and report that inheritance is in effect. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateDirectoryEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateDirectory" />
    <seealso cref="CreateDirectoryTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
  </member>
  <member name="Windows.CreateDirectoryExA">
    <summary>
      <para>Creates a new directory with the attributes of a specified template directory. If the
underlying file system supports security on files and directories, the function applies a specified security
descriptor to the new directory. The new directory retains the other attributes of the specified template
directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpTemplateDirectory">
      <para>The path of the directory to use as a template when creating the new directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewDirectory">
      <para>The path of the directory to be created.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
descriptor for the new directory.</para>
      <para>If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a
default security descriptor. The access control lists (ACL) in the default security descriptor for a directory
are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect.
This is indicated when <see cref="GetVolumeInformation" /></para>
      <para>returns <b>FS_PERSISTENT_ACLS</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />. Possible errors include the
following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified directory already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>One or more intermediate directories do not exist. This function only creates the final directory in the
path. To create all intermediate directories on the path, use the
<see cref="SHCreateDirectoryEx" /> function.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>CreateDirectoryEx</b> function allows you to
create directories that inherit stream information from other directories. This function is useful, for example,
when you are using Macintosh directories, which have a resource stream that is needed to properly identify
directory contents as an attribute.</para>
      <para>Some file systems, such as the NTFS file system, support compression or encryption for individual files and
directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption
attributes of its parent directory.</para>
      <para>You can obtain a handle to a directory by calling the
<see cref="CreateFile" /> function with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set. For a code example, see
<b>CreateFile</b>.</para>
      <para>To support inheritance functions that query the security descriptor of this
object can heuristically determine and report that inheritance is in effect. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateDirectoryEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateDirectory" />
    <seealso cref="CreateDirectoryTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
  </member>
  <member name="Windows.CreateDirectoryExW">
    <summary>
      <para>Creates a new directory with the attributes of a specified template directory. If the
underlying file system supports security on files and directories, the function applies a specified security
descriptor to the new directory. The new directory retains the other attributes of the specified template
directory.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpTemplateDirectory">
      <para>The path of the directory to use as a template when creating the new directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewDirectory">
      <para>The path of the directory to be created.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
descriptor for the new directory.</para>
      <para>If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a
default security descriptor. The access control lists (ACL) in the default security descriptor for a directory
are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect.
This is indicated when <see cref="GetVolumeInformation" /></para>
      <para>returns <b>FS_PERSISTENT_ACLS</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />. Possible errors include the
following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified directory already exists.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>One or more intermediate directories do not exist. This function only creates the final directory in the
path. To create all intermediate directories on the path, use the
<see cref="SHCreateDirectoryEx" /> function.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>CreateDirectoryEx</b> function allows you to
create directories that inherit stream information from other directories. This function is useful, for example,
when you are using Macintosh directories, which have a resource stream that is needed to properly identify
directory contents as an attribute.</para>
      <para>Some file systems, such as the NTFS file system, support compression or encryption for individual files and
directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption
attributes of its parent directory.</para>
      <para>You can obtain a handle to a directory by calling the
<see cref="CreateFile" /> function with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set. For a code example, see
<b>CreateFile</b>.</para>
      <para>To support inheritance functions that query the security descriptor of this
object can heuristically determine and report that inheritance is in effect. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateDirectoryEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateDirectory" />
    <seealso cref="CreateDirectoryTransacted" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-deleting-directories">Creating and Deleting Directories</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="RemoveDirectory" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
  </member>
  <member name="Windows.CreateFiber">
    <summary>
      <para>Allocates a fiber object, assigns it a stack, and sets up execution to begin at the specified start address, typically the fiber function. This function does not schedule the fiber.</para>
      <para>To specify both a commit and reserve stack size, use the
<see cref="CreateFiberEx" /> function.</para>
    </summary>
    <param name="dwStackSize">
      <para>The initial committed size of the stack, in bytes. If this parameter is zero, the new fiber uses the default commit stack size for the executable. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-stack-size">Thread Stack Size</a>.</para>
    </param>
    <param name="lpStartAddress">
      <para>A pointer to the application-defined function to be executed by the fiber and represents the starting address of the fiber. Execution of the newly created fiber does not begin until another fiber calls the
<see cref="SwitchToFiber" /> function with this address. For more information of the fiber callback function, see
<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-pfiber_start_routine">FiberProc</a>.</para>
    </param>
    <param name="lpParameter">
      <para>A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the
<see cref="GetFiberData" /> macro.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the address of the fiber.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The number of fibers a process can create is limited by the available virtual memory. For example, if you create each fiber with 1 megabyte of reserved stack space, you can create at most 2028 fibers. If you reduce the default stack size by using the STACKSIZE statement in the module definition (.def) file or
by using <see cref="CreateFiberEx" />, you can create more fibers. However, your application will have better performance if you use an alternate strategy for processing requests instead of creating such a large number of fibers.</para>
      <para>Before a thread can schedule a fiber using the
<see cref="SwitchToFiber" /> function, it must call the
<see cref="ConvertThreadToFiber" /> function so there is a fiber associated with the thread.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/using-fibers">Using Fibers</a>.</para>
    </remarks>
    <seealso cref="ConvertThreadToFiber" />
    <seealso cref="CreateFiberEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-pfiber_start_routine">FiberProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/fibers">Fibers</seealso>
    <seealso cref="GetFiberData" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso cref="SwitchToFiber" />
  </member>
  <member name="Windows.CreateFiberEx">
    <summary>
      <para>Allocates a fiber object, assigns it a stack, and sets up execution to begin at the specified start address, typically the fiber function. This function does not schedule the fiber.</para>
    </summary>
    <param name="dwStackCommitSize">
      <para>The initial commit size of the stack, in bytes. If this parameter is zero, the new fiber uses the default commit stack size for the executable. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-stack-size">Thread Stack Size</a>.</para>
    </param>
    <param name="dwStackReserveSize">
      <para>The initial reserve size of the stack, in bytes. If this parameter is zero, the new fiber uses the default reserved stack size for the executable. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-stack-size">Thread Stack Size</a>.</para>
    </param>
    <param name="dwFlags">
      <para>If this parameter is zero, the floating-point state on x86 systems is not switched and data can be corrupted if a fiber uses floating-point arithmetic. If this parameter is <b>FIBER_FLAG_FLOAT_SWITCH</b>, the floating-point state is switched for the fiber.</para>
      <para>
        <b>Windows XP:  </b>The <b>FIBER_FLAG_FLOAT_SWITCH</b> flag is not supported.</para>
    </param>
    <param name="lpStartAddress">
      <para>A pointer to the application-defined function to be executed by the fiber and represents the starting address of the fiber. Execution of the newly created fiber does not begin until another fiber calls the
<see cref="SwitchToFiber" /> function with this address. For more information on the fiber callback function, see
<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-pfiber_start_routine">FiberProc</a>.</para>
    </param>
    <param name="lpParameter">
      <para>A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the
<see cref="GetFiberData" /> macro.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the address of the fiber.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The number of fibers a process can create is limited by the available virtual memory. By default, every fiber has 1 megabyte of reserved stack space. Therefore, you can create at most 2028 fibers. If you reduce the default stack size, you can create more fibers. However, your application will have better performance if you use an alternate strategy for processing requests.</para>
      <para>Before a thread can schedule a fiber using the
<see cref="SwitchToFiber" /> function, it must call the
<see cref="ConvertThreadToFiber" /> function so there is a fiber associated with the thread.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="ConvertThreadToFiber" />
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-pfiber_start_routine">FiberProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/fibers">Fibers</seealso>
    <seealso cref="GetFiberData" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso cref="SwitchToFiber" />
  </member>
  <member name="Windows.CreateFileMapping">
    <summary>
      <para>Creates or opens a named or unnamed file mapping object for a specified file.</para>
      <para>To specify the NUMA node for the physical memory, see
<see cref="CreateFileMappingNuma" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the
<i>flProtect</i> parameter specifies. It is not required, but it is recommended that files
you intend to map be opened for exclusive access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process
must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and
<i>dwMaximumSizeLow</i> parameters. In this scenario,
<b>CreateFileMapping</b> creates a file mapping object
of a specified size  that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure that determines whether a returned handle can be inherited by child processes. The
<b>lpSecurityDescriptor</b> member of the
<b>SECURITY_ATTRIBUTES</b> structure specifies a
security descriptor for a new file mapping object.</para>
      <para>If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle cannot be inherited
and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default
security descriptor for a file mapping object come from the primary or impersonation token of the creator. For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible
with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READ</b>
                </description>
              </item>
              <item>
                <description>0x20</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access.</para>
            <para>The file handle specified by  the <i>hFile</i> parameter must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and
Windows Server 2003 with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x40</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, read/write, or execute access.</para>
            <para>The file   handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and
<b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and
Windows Server 2003 with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x80</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to
<b>PAGE_EXECUTE_READ</b>.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READONLY</b>
                </description>
              </item>
              <item>
                <description>0x02</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific
region results in an access violation.</para>
            <para>The file handle that  the <i>hFile</i> parameter
specifies must be created with the <b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x04</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or read/write access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and
<b>GENERIC_WRITE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x08</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to
<b>PAGE_READONLY</b>.</para>
            <para>The file handle that  the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
      </list>
      <para>An application can specify one or more of the following attributes for the file mapping object by combining
them with one of the preceding page protection values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_COMMIT</b>
                </description>
              </item>
              <item>
                <description>0x8000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file mapping object is backed by the operating system paging file (the
<i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that
when  a view of the file is mapped into a process address space, the entire range of pages is committed
rather than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise,
<b>CreateFileMapping</b> fails.</para>
            <para>This attribute has no effect for file mapping objects that are backed by executable image files or data
files (the <i>hfile</i> parameter is a handle to a file).</para>
            <para>
              <b>SEC_COMMIT</b> cannot be combined with <b>SEC_RESERVE</b>.</para>
            <para>If no attribute is specified, <b>SEC_COMMIT</b> is assumed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE</b>
                </description>
              </item>
              <item>
                <description>0x1000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file.</para>
            <para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as
<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the
executable image file. Page protection for views of an executable image file is determined by the executable
file itself.</para>
            <para>No other attributes are valid with <b>SEC_IMAGE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE_NO_EXECUTE</b>
                </description>
              </item>
              <item>
                <description>0x11000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file that will not be executed and the loaded image file will have no forced integrity checks run.
Additionally, mapping a view of a file mapping object created with the
<b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using
the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a></para>
            <para>kernel API.</para>
            <para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the
<b>PAGE_READONLY</b> page protection value. No other attributes are valid with
<b>SEC_IMAGE_NO_EXECUTE</b>.</para>
            <para>
              <b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x80000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables large pages to be used for file mapping objects that are backed by the operating system paging file
(the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>). This
attribute is not supported for file mapping objects that are backed by executable image files or data files
(the <i>hFile</i> parameter is a handle to an executable image or data file).</para>
            <para>The maximum size of the file mapping object must be a multiple of the minimum size of a large page returned
by the <see cref="GetLargePageMinimum" /> function. If it is
not, <b>CreateFileMapping</b> fails. When mapping a
view of a file mapping object created with <b>SEC_LARGE_PAGES</b>, the base address and
view size must also be multiples of the minimum large page size.</para>
            <para>
              <b>SEC_LARGE_PAGES</b> requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a></para>
            <para>privilege to be enabled in the caller's token.</para>
            <para>If <b>SEC_LARGE_PAGES</b> is specified, <b>SEC_COMMIT</b> must also
be specified.</para>
            <para>
              <b>Windows Server 2003:  </b>This value is not supported until Windows Server 2003 with SP1.</para>
            <para>
              <b>Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_NOCACHE</b>
                </description>
              </item>
              <item>
                <description>0x10000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to be non-cacheable.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_NOCACHE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_NOCACHE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x4000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file mapping object is backed by the operating system paging file (the
<i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that
when a view of the file is mapped into a process address space, the entire range of pages is reserved for
later use by the process rather than committed.</para>
            <para>Reserved pages can be committed in subsequent calls to the
<see cref="VirtualAlloc" /> function. After the pages are
committed, they cannot be freed or decommitted with the
<see cref="VirtualFree" /> function.</para>
            <para>This attribute has no effect for file mapping objects that are backed by executable image files or data
files (the <i>hfile</i> parameter is a handle to a file).</para>
            <para>
              <b>SEC_RESERVE</b> cannot be combined with <b>SEC_COMMIT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_WRITECOMBINE</b>
                </description>
              </item>
              <item>
                <description>0x40000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to  be write-combined.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_WRITECOMBINE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This flag is not supported until Windows Vista.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwMaximumSizeHigh">
      <para>The high-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
    </param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and <i>dwMaximumSizeHigh</i> are 0 (zero), the maximum size of the file
mapping object is equal to the current size of the file that  <i>hFile</i> identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of
<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and
reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing mapping object, the function requests access to the
object with the protection that <i>flProtect</i> specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or
job object, the function fails, and the <see cref="GetLastError" /></para>
      <para>function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the
same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the
object in the global or session namespace. The remainder of the name can contain any character except the
backslash character (\). Creating a file mapping object in the global namespace from a session other than
session zero requires the
<a href="https://docs.microsoft.com//windows/win32/secauthz/privilege-constants#constants">SeCreateGlobalPrivilege</a></para>
      <para>privilege. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session
0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the
guidelines that are outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its
current size, not the specified size), and <see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>After a file mapping object is created, the size of the file must not exceed the size of the file mapping
object; if it does, not all of the file contents are available for sharing.</para>
      <para>If an application specifies a size for the file mapping object that is larger than the size of the actual named
file on disk and if the page protection allows write access (that is, the <i>flProtect</i></para>
      <para>parameter specifies  <b>PAGE_READWRITE</b> or
<b>PAGE_EXECUTE_READWRITE</b>), then the file on disk is increased to match the specified size
of the file mapping object. If the file is extended, the contents of the file between the old end of the file and
the new end of the file are not guaranteed to be zero; the behavior is defined by the file system. If the file
on disk cannot be increased, <b>CreateFileMapping</b> fails
and <see cref="GetLastError" />  returns
<b>ERROR_DISK_FULL</b>.</para>
      <para>The initial contents of the pages in a file mapping object backed by the operating system paging file are 0
(zero).</para>
      <para>The handle that <b>CreateFileMapping</b> returns has
full access to a new file mapping object, and can be used with any function that requires a handle to a file
mapping object.</para>
      <para>Multiple processes can share a view of the same file   by either using a single shared file mapping object or
creating separate file mapping objects backed by the same file. A single file mapping object can be shared by
multiple processes through inheriting the handle at process creation, duplicating the handle, or opening the file
mapping object by name. For more information, see the
<see cref="CreateProcess" />,
<see cref="DuplicateHandle" /> and
<see cref="OpenFileMapping" /> functions.</para>
      <para>Creating a file mapping object does not actually map the view into a process address space. The
<see cref="MapViewOfFile" /> and
<see cref="MapViewOfFileEx" /> functions map a view of a file into a
process address space.</para>
      <para>With one important exception, file views derived from any file mapping object that is backed by the same file
are coherent or identical at a specific time. Coherency is guaranteed for views within a process and for views
that are mapped by different processes.</para>
      <para>The exception is related to remote files. Although
<b>CreateFileMapping</b> works with remote files, it does
not keep them coherent. For example, if two computers both map a file as writable, and both change the same page,
each computer only sees its own writes to the page. When the data gets updated on the disk, it is not merged.</para>
      <para>A mapped file and a file that is accessed by using the input and output (I/O) functions
(<see cref="ReadFile" /> and
<see cref="WriteFile" />) are not necessarily coherent.</para>
      <para>Mapped views of a file mapping object maintain internal references to the object, and a file mapping object
does not close until all references to it are released. Therefore, to fully close a file mapping object, an
application must unmap all mapped views of the file mapping object by calling
<see cref="UnmapViewOfFile" /> and  close the file mapping object
handle by calling <see cref="CloseHandle" />. These functions can be
called in any order.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>Creating a file mapping object in the global namespace from a session other than session zero requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a> privilege.
Note that this privilege check is limited to the creation of file mapping objects and does not apply to opening
existing ones. For example, if a service or the system creates a file mapping object in the global namespace, any
process running in any session can access that file mapping object provided that the caller has the required
access rights.</para>
      <para>
        <b>Windows XP:  </b>The requirement described in the previous paragraph was introduced with Windows Server 2003
and Windows XP with SP2</para>
      <para>Use structured exception handling to protect any code that writes to or reads from a file view. For more
information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/reading-and-writing-from-a-file-view">Reading and Writing From a File View</a>.</para>
      <para>To have a mapping with executable permissions, an application must call
<b>CreateFileMapping</b> with either
<b>PAGE_EXECUTE_READWRITE</b> or <b>PAGE_EXECUTE_READ</b>, and then
call <see cref="MapViewOfFile" /> with
<code>FILE_MAP_EXECUTE | FILE_MAP_WRITE</code> or
<code>FILE_MAP_EXECUTE | FILE_MAP_READ</code>.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-named-shared-memory">Creating Named Shared Memory</a> or
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-a-file-mapping-using-large-pages">Creating a File Mapping Using Large Pages</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFileMappingNuma" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/creating-a-file-mapping-object">Creating a File Mapping Object</seealso>
    <seealso cref="DuplicateHandle" />
    <seealso cref="MapViewOfFile" />
    <seealso cref="MapViewOfFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso cref="OpenFileMapping" />
    <seealso cref="ReadFile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="UnmapViewOfFile" />
    <seealso cref="VirtualAlloc" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.CreateFileMappingA">
    <summary>
      <para>Creates or opens a named or unnamed file mapping object for a specified file.</para>
      <para>To specify the NUMA node for the physical memory, see
<see cref="CreateFileMappingNuma" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the
<i>flProtect</i> parameter specifies. It is not required, but it is recommended that files
you intend to map be opened for exclusive access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process
must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and
<i>dwMaximumSizeLow</i> parameters. In this scenario,
<b>CreateFileMapping</b> creates a file mapping object
of a specified size  that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure that determines whether a returned handle can be inherited by child processes. The
<b>lpSecurityDescriptor</b> member of the
<b>SECURITY_ATTRIBUTES</b> structure specifies a
security descriptor for a new file mapping object.</para>
      <para>If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle cannot be inherited
and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default
security descriptor for a file mapping object come from the primary or impersonation token of the creator. For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible
with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READ</b>
                </description>
              </item>
              <item>
                <description>0x20</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access.</para>
            <para>The file handle specified by  the <i>hFile</i> parameter must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and
Windows Server 2003 with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x40</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, read/write, or execute access.</para>
            <para>The file   handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and
<b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and
Windows Server 2003 with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x80</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to
<b>PAGE_EXECUTE_READ</b>.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READONLY</b>
                </description>
              </item>
              <item>
                <description>0x02</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific
region results in an access violation.</para>
            <para>The file handle that  the <i>hFile</i> parameter
specifies must be created with the <b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x04</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or read/write access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and
<b>GENERIC_WRITE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x08</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to
<b>PAGE_READONLY</b>.</para>
            <para>The file handle that  the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
      </list>
      <para>An application can specify one or more of the following attributes for the file mapping object by combining
them with one of the preceding page protection values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_COMMIT</b>
                </description>
              </item>
              <item>
                <description>0x8000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file mapping object is backed by the operating system paging file (the
<i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that
when  a view of the file is mapped into a process address space, the entire range of pages is committed
rather than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise,
<b>CreateFileMapping</b> fails.</para>
            <para>This attribute has no effect for file mapping objects that are backed by executable image files or data
files (the <i>hfile</i> parameter is a handle to a file).</para>
            <para>
              <b>SEC_COMMIT</b> cannot be combined with <b>SEC_RESERVE</b>.</para>
            <para>If no attribute is specified, <b>SEC_COMMIT</b> is assumed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE</b>
                </description>
              </item>
              <item>
                <description>0x1000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file.</para>
            <para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as
<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the
executable image file. Page protection for views of an executable image file is determined by the executable
file itself.</para>
            <para>No other attributes are valid with <b>SEC_IMAGE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE_NO_EXECUTE</b>
                </description>
              </item>
              <item>
                <description>0x11000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file that will not be executed and the loaded image file will have no forced integrity checks run.
Additionally, mapping a view of a file mapping object created with the
<b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using
the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a></para>
            <para>kernel API.</para>
            <para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the
<b>PAGE_READONLY</b> page protection value. No other attributes are valid with
<b>SEC_IMAGE_NO_EXECUTE</b>.</para>
            <para>
              <b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x80000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables large pages to be used for file mapping objects that are backed by the operating system paging file
(the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>). This
attribute is not supported for file mapping objects that are backed by executable image files or data files
(the <i>hFile</i> parameter is a handle to an executable image or data file).</para>
            <para>The maximum size of the file mapping object must be a multiple of the minimum size of a large page returned
by the <see cref="GetLargePageMinimum" /> function. If it is
not, <b>CreateFileMapping</b> fails. When mapping a
view of a file mapping object created with <b>SEC_LARGE_PAGES</b>, the base address and
view size must also be multiples of the minimum large page size.</para>
            <para>
              <b>SEC_LARGE_PAGES</b> requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a></para>
            <para>privilege to be enabled in the caller's token.</para>
            <para>If <b>SEC_LARGE_PAGES</b> is specified, <b>SEC_COMMIT</b> must also
be specified.</para>
            <para>
              <b>Windows Server 2003:  </b>This value is not supported until Windows Server 2003 with SP1.</para>
            <para>
              <b>Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_NOCACHE</b>
                </description>
              </item>
              <item>
                <description>0x10000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to be non-cacheable.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_NOCACHE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_NOCACHE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x4000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file mapping object is backed by the operating system paging file (the
<i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that
when a view of the file is mapped into a process address space, the entire range of pages is reserved for
later use by the process rather than committed.</para>
            <para>Reserved pages can be committed in subsequent calls to the
<see cref="VirtualAlloc" /> function. After the pages are
committed, they cannot be freed or decommitted with the
<see cref="VirtualFree" /> function.</para>
            <para>This attribute has no effect for file mapping objects that are backed by executable image files or data
files (the <i>hfile</i> parameter is a handle to a file).</para>
            <para>
              <b>SEC_RESERVE</b> cannot be combined with <b>SEC_COMMIT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_WRITECOMBINE</b>
                </description>
              </item>
              <item>
                <description>0x40000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to  be write-combined.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_WRITECOMBINE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This flag is not supported until Windows Vista.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwMaximumSizeHigh">
      <para>The high-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
    </param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and <i>dwMaximumSizeHigh</i> are 0 (zero), the maximum size of the file
mapping object is equal to the current size of the file that  <i>hFile</i> identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of
<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and
reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing mapping object, the function requests access to the
object with the protection that <i>flProtect</i> specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or
job object, the function fails, and the <see cref="GetLastError" /></para>
      <para>function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the
same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the
object in the global or session namespace. The remainder of the name can contain any character except the
backslash character (\). Creating a file mapping object in the global namespace from a session other than
session zero requires the
<a href="https://docs.microsoft.com//windows/win32/secauthz/privilege-constants#constants">SeCreateGlobalPrivilege</a></para>
      <para>privilege. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session
0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the
guidelines that are outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its
current size, not the specified size), and <see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>After a file mapping object is created, the size of the file must not exceed the size of the file mapping
object; if it does, not all of the file contents are available for sharing.</para>
      <para>If an application specifies a size for the file mapping object that is larger than the size of the actual named
file on disk and if the page protection allows write access (that is, the <i>flProtect</i></para>
      <para>parameter specifies  <b>PAGE_READWRITE</b> or
<b>PAGE_EXECUTE_READWRITE</b>), then the file on disk is increased to match the specified size
of the file mapping object. If the file is extended, the contents of the file between the old end of the file and
the new end of the file are not guaranteed to be zero; the behavior is defined by the file system. If the file
on disk cannot be increased, <b>CreateFileMapping</b> fails
and <see cref="GetLastError" />  returns
<b>ERROR_DISK_FULL</b>.</para>
      <para>The initial contents of the pages in a file mapping object backed by the operating system paging file are 0
(zero).</para>
      <para>The handle that <b>CreateFileMapping</b> returns has
full access to a new file mapping object, and can be used with any function that requires a handle to a file
mapping object.</para>
      <para>Multiple processes can share a view of the same file   by either using a single shared file mapping object or
creating separate file mapping objects backed by the same file. A single file mapping object can be shared by
multiple processes through inheriting the handle at process creation, duplicating the handle, or opening the file
mapping object by name. For more information, see the
<see cref="CreateProcess" />,
<see cref="DuplicateHandle" /> and
<see cref="OpenFileMapping" /> functions.</para>
      <para>Creating a file mapping object does not actually map the view into a process address space. The
<see cref="MapViewOfFile" /> and
<see cref="MapViewOfFileEx" /> functions map a view of a file into a
process address space.</para>
      <para>With one important exception, file views derived from any file mapping object that is backed by the same file
are coherent or identical at a specific time. Coherency is guaranteed for views within a process and for views
that are mapped by different processes.</para>
      <para>The exception is related to remote files. Although
<b>CreateFileMapping</b> works with remote files, it does
not keep them coherent. For example, if two computers both map a file as writable, and both change the same page,
each computer only sees its own writes to the page. When the data gets updated on the disk, it is not merged.</para>
      <para>A mapped file and a file that is accessed by using the input and output (I/O) functions
(<see cref="ReadFile" /> and
<see cref="WriteFile" />) are not necessarily coherent.</para>
      <para>Mapped views of a file mapping object maintain internal references to the object, and a file mapping object
does not close until all references to it are released. Therefore, to fully close a file mapping object, an
application must unmap all mapped views of the file mapping object by calling
<see cref="UnmapViewOfFile" /> and  close the file mapping object
handle by calling <see cref="CloseHandle" />. These functions can be
called in any order.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>Creating a file mapping object in the global namespace from a session other than session zero requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a> privilege.
Note that this privilege check is limited to the creation of file mapping objects and does not apply to opening
existing ones. For example, if a service or the system creates a file mapping object in the global namespace, any
process running in any session can access that file mapping object provided that the caller has the required
access rights.</para>
      <para>
        <b>Windows XP:  </b>The requirement described in the previous paragraph was introduced with Windows Server 2003
and Windows XP with SP2</para>
      <para>Use structured exception handling to protect any code that writes to or reads from a file view. For more
information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/reading-and-writing-from-a-file-view">Reading and Writing From a File View</a>.</para>
      <para>To have a mapping with executable permissions, an application must call
<b>CreateFileMapping</b> with either
<b>PAGE_EXECUTE_READWRITE</b> or <b>PAGE_EXECUTE_READ</b>, and then
call <see cref="MapViewOfFile" /> with
<code>FILE_MAP_EXECUTE | FILE_MAP_WRITE</code> or
<code>FILE_MAP_EXECUTE | FILE_MAP_READ</code>.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-named-shared-memory">Creating Named Shared Memory</a> or
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-a-file-mapping-using-large-pages">Creating a File Mapping Using Large Pages</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFileMappingNuma" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/creating-a-file-mapping-object">Creating a File Mapping Object</seealso>
    <seealso cref="DuplicateHandle" />
    <seealso cref="MapViewOfFile" />
    <seealso cref="MapViewOfFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso cref="OpenFileMapping" />
    <seealso cref="ReadFile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="UnmapViewOfFile" />
    <seealso cref="VirtualAlloc" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.CreateFileMappingW">
    <summary>
      <para>Creates or opens a named or unnamed file mapping object for a specified file.</para>
      <para>To specify the NUMA node for the physical memory, see
<see cref="CreateFileMappingNuma" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the
<i>flProtect</i> parameter specifies. It is not required, but it is recommended that files
you intend to map be opened for exclusive access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process
must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and
<i>dwMaximumSizeLow</i> parameters. In this scenario,
<b>CreateFileMapping</b> creates a file mapping object
of a specified size  that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure that determines whether a returned handle can be inherited by child processes. The
<b>lpSecurityDescriptor</b> member of the
<b>SECURITY_ATTRIBUTES</b> structure specifies a
security descriptor for a new file mapping object.</para>
      <para>If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle cannot be inherited
and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default
security descriptor for a file mapping object come from the primary or impersonation token of the creator. For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible
with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READ</b>
                </description>
              </item>
              <item>
                <description>0x20</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access.</para>
            <para>The file handle specified by  the <i>hFile</i> parameter must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and
Windows Server 2003 with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x40</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, read/write, or execute access.</para>
            <para>The file   handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and
<b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and
Windows Server 2003 with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x80</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to
<b>PAGE_EXECUTE_READ</b>.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READONLY</b>
                </description>
              </item>
              <item>
                <description>0x02</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific
region results in an access violation.</para>
            <para>The file handle that  the <i>hFile</i> parameter
specifies must be created with the <b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x04</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or read/write access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and
<b>GENERIC_WRITE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x08</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to
<b>PAGE_READONLY</b>.</para>
            <para>The file handle that  the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
      </list>
      <para>An application can specify one or more of the following attributes for the file mapping object by combining
them with one of the preceding page protection values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_COMMIT</b>
                </description>
              </item>
              <item>
                <description>0x8000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file mapping object is backed by the operating system paging file (the
<i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that
when  a view of the file is mapped into a process address space, the entire range of pages is committed
rather than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise,
<b>CreateFileMapping</b> fails.</para>
            <para>This attribute has no effect for file mapping objects that are backed by executable image files or data
files (the <i>hfile</i> parameter is a handle to a file).</para>
            <para>
              <b>SEC_COMMIT</b> cannot be combined with <b>SEC_RESERVE</b>.</para>
            <para>If no attribute is specified, <b>SEC_COMMIT</b> is assumed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE</b>
                </description>
              </item>
              <item>
                <description>0x1000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file.</para>
            <para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as
<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the
executable image file. Page protection for views of an executable image file is determined by the executable
file itself.</para>
            <para>No other attributes are valid with <b>SEC_IMAGE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE_NO_EXECUTE</b>
                </description>
              </item>
              <item>
                <description>0x11000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file that will not be executed and the loaded image file will have no forced integrity checks run.
Additionally, mapping a view of a file mapping object created with the
<b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using
the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a></para>
            <para>kernel API.</para>
            <para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the
<b>PAGE_READONLY</b> page protection value. No other attributes are valid with
<b>SEC_IMAGE_NO_EXECUTE</b>.</para>
            <para>
              <b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x80000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables large pages to be used for file mapping objects that are backed by the operating system paging file
(the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>). This
attribute is not supported for file mapping objects that are backed by executable image files or data files
(the <i>hFile</i> parameter is a handle to an executable image or data file).</para>
            <para>The maximum size of the file mapping object must be a multiple of the minimum size of a large page returned
by the <see cref="GetLargePageMinimum" /> function. If it is
not, <b>CreateFileMapping</b> fails. When mapping a
view of a file mapping object created with <b>SEC_LARGE_PAGES</b>, the base address and
view size must also be multiples of the minimum large page size.</para>
            <para>
              <b>SEC_LARGE_PAGES</b> requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a></para>
            <para>privilege to be enabled in the caller's token.</para>
            <para>If <b>SEC_LARGE_PAGES</b> is specified, <b>SEC_COMMIT</b> must also
be specified.</para>
            <para>
              <b>Windows Server 2003:  </b>This value is not supported until Windows Server 2003 with SP1.</para>
            <para>
              <b>Windows XP:  </b>This value is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_NOCACHE</b>
                </description>
              </item>
              <item>
                <description>0x10000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to be non-cacheable.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_NOCACHE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_NOCACHE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x4000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file mapping object is backed by the operating system paging file (the
<i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that
when a view of the file is mapped into a process address space, the entire range of pages is reserved for
later use by the process rather than committed.</para>
            <para>Reserved pages can be committed in subsequent calls to the
<see cref="VirtualAlloc" /> function. After the pages are
committed, they cannot be freed or decommitted with the
<see cref="VirtualFree" /> function.</para>
            <para>This attribute has no effect for file mapping objects that are backed by executable image files or data
files (the <i>hfile</i> parameter is a handle to a file).</para>
            <para>
              <b>SEC_RESERVE</b> cannot be combined with <b>SEC_COMMIT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_WRITECOMBINE</b>
                </description>
              </item>
              <item>
                <description>0x40000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to  be write-combined.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_WRITECOMBINE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This flag is not supported until Windows Vista.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwMaximumSizeHigh">
      <para>The high-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
    </param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and <i>dwMaximumSizeHigh</i> are 0 (zero), the maximum size of the file
mapping object is equal to the current size of the file that  <i>hFile</i> identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of
<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and
reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing mapping object, the function requests access to the
object with the protection that <i>flProtect</i> specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or
job object, the function fails, and the <see cref="GetLastError" /></para>
      <para>function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the
same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the
object in the global or session namespace. The remainder of the name can contain any character except the
backslash character (\). Creating a file mapping object in the global namespace from a session other than
session zero requires the
<a href="https://docs.microsoft.com//windows/win32/secauthz/privilege-constants#constants">SeCreateGlobalPrivilege</a></para>
      <para>privilege. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session
0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the
guidelines that are outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its
current size, not the specified size), and <see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>After a file mapping object is created, the size of the file must not exceed the size of the file mapping
object; if it does, not all of the file contents are available for sharing.</para>
      <para>If an application specifies a size for the file mapping object that is larger than the size of the actual named
file on disk and if the page protection allows write access (that is, the <i>flProtect</i></para>
      <para>parameter specifies  <b>PAGE_READWRITE</b> or
<b>PAGE_EXECUTE_READWRITE</b>), then the file on disk is increased to match the specified size
of the file mapping object. If the file is extended, the contents of the file between the old end of the file and
the new end of the file are not guaranteed to be zero; the behavior is defined by the file system. If the file
on disk cannot be increased, <b>CreateFileMapping</b> fails
and <see cref="GetLastError" />  returns
<b>ERROR_DISK_FULL</b>.</para>
      <para>The initial contents of the pages in a file mapping object backed by the operating system paging file are 0
(zero).</para>
      <para>The handle that <b>CreateFileMapping</b> returns has
full access to a new file mapping object, and can be used with any function that requires a handle to a file
mapping object.</para>
      <para>Multiple processes can share a view of the same file   by either using a single shared file mapping object or
creating separate file mapping objects backed by the same file. A single file mapping object can be shared by
multiple processes through inheriting the handle at process creation, duplicating the handle, or opening the file
mapping object by name. For more information, see the
<see cref="CreateProcess" />,
<see cref="DuplicateHandle" /> and
<see cref="OpenFileMapping" /> functions.</para>
      <para>Creating a file mapping object does not actually map the view into a process address space. The
<see cref="MapViewOfFile" /> and
<see cref="MapViewOfFileEx" /> functions map a view of a file into a
process address space.</para>
      <para>With one important exception, file views derived from any file mapping object that is backed by the same file
are coherent or identical at a specific time. Coherency is guaranteed for views within a process and for views
that are mapped by different processes.</para>
      <para>The exception is related to remote files. Although
<b>CreateFileMapping</b> works with remote files, it does
not keep them coherent. For example, if two computers both map a file as writable, and both change the same page,
each computer only sees its own writes to the page. When the data gets updated on the disk, it is not merged.</para>
      <para>A mapped file and a file that is accessed by using the input and output (I/O) functions
(<see cref="ReadFile" /> and
<see cref="WriteFile" />) are not necessarily coherent.</para>
      <para>Mapped views of a file mapping object maintain internal references to the object, and a file mapping object
does not close until all references to it are released. Therefore, to fully close a file mapping object, an
application must unmap all mapped views of the file mapping object by calling
<see cref="UnmapViewOfFile" /> and  close the file mapping object
handle by calling <see cref="CloseHandle" />. These functions can be
called in any order.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>Creating a file mapping object in the global namespace from a session other than session zero requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a> privilege.
Note that this privilege check is limited to the creation of file mapping objects and does not apply to opening
existing ones. For example, if a service or the system creates a file mapping object in the global namespace, any
process running in any session can access that file mapping object provided that the caller has the required
access rights.</para>
      <para>
        <b>Windows XP:  </b>The requirement described in the previous paragraph was introduced with Windows Server 2003
and Windows XP with SP2</para>
      <para>Use structured exception handling to protect any code that writes to or reads from a file view. For more
information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/reading-and-writing-from-a-file-view">Reading and Writing From a File View</a>.</para>
      <para>To have a mapping with executable permissions, an application must call
<b>CreateFileMapping</b> with either
<b>PAGE_EXECUTE_READWRITE</b> or <b>PAGE_EXECUTE_READ</b>, and then
call <see cref="MapViewOfFile" /> with
<code>FILE_MAP_EXECUTE | FILE_MAP_WRITE</code> or
<code>FILE_MAP_EXECUTE | FILE_MAP_READ</code>.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-named-shared-memory">Creating Named Shared Memory</a> or
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-a-file-mapping-using-large-pages">Creating a File Mapping Using Large Pages</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFileMappingNuma" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/creating-a-file-mapping-object">Creating a File Mapping Object</seealso>
    <seealso cref="DuplicateHandle" />
    <seealso cref="MapViewOfFile" />
    <seealso cref="MapViewOfFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
    <seealso cref="OpenFileMapping" />
    <seealso cref="ReadFile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="UnmapViewOfFile" />
    <seealso cref="VirtualAlloc" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.CreateFileMappingNuma">
    <summary>
      <para>Creates or opens a named or unnamed file mapping object for a specified file  and specifies the NUMA
node for the physical memory.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access
rights that are compatible with the protection flags that the <i>flProtect</i> parameter
specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive
access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process
must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and
<i>dwMaximumSizeLow</i> parameters. In this scenario,
<b>CreateFileMappingNuma</b> creates a file mapping
object of a specified size  that is backed by the system paging file instead of by a file in the file
system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure that determines whether a returned handle can be inherited by child processes. The
<b>lpSecurityDescriptor</b> member of the
<b>SECURITY_ATTRIBUTES</b> structure specifies a
security descriptor for a new file mapping object.</para>
      <para>If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle cannot be
inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the
default security descriptor for a file mapping object come from the primary or impersonation token of the
creator. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible
with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READ</b>
                </description>
              </item>
              <item>
                <description>0x20</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x40</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, read/write or execute access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and
<b>GENERIC_EXECUTE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x80</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to
<b>PAGE_EXECUTE_READ</b>.</para>
            <para>The file handle that the <i>hFile</i></para>
            <para>parameter specifies must be created with the <b>GENERIC_READ</b> and
<b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READONLY</b>
                </description>
              </item>
              <item>
                <description>0x02</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region
results in an access violation.</para>
            <para>The file handle that  the <i>hFile</i> parameter
specifies must be created with the <b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x04</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or read/write access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x08</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to
<b>PAGE_READONLY</b>.</para>
            <para>The file handle that  the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
      </list>
      <para>An application can specify one or more of the following attributes for the file mapping object by combining
them with one of the preceding page protection values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_COMMIT</b>
                </description>
              </item>
              <item>
                <description>0x8000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates physical storage in memory or the paging file for all pages.</para>
            <para>This is the
default setting.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE</b>
                </description>
              </item>
              <item>
                <description>0x1000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets the file that is specified to be an executable image file.</para>
            <para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as
<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the
executable image file. Page protection for views of an executable image file is determined by the executable
file itself.</para>
            <para>No other attributes are valid with <b>SEC_IMAGE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE_NO_EXECUTE</b>
                </description>
              </item>
              <item>
                <description>0x11000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file that will not be executed and the loaded image file will have no forced integrity checks run.
Additionally, mapping a view of a file mapping object created with the
<b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using
the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a></para>
            <para>kernel API.</para>
            <para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the
<b>PAGE_READONLY</b> page protection value. No other attributes are valid with
<b>SEC_IMAGE_NO_EXECUTE</b>.</para>
            <para>
              <b>Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x80000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables large pages to be used when mapping images or backing from the pagefile, but not when mapping data
for regular files. Be sure to specify the maximum size of the file mapping object as the minimum size of a
large page reported by the
<see cref="GetLargePageMinimum" /> function and to enable
the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a></para>
            <para>privilege.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_NOCACHE</b>
                </description>
              </item>
              <item>
                <description>0x10000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to noncachable.</para>
            <para>Applications should not use this flag except when explicitly required
for a device. Using the interlocked functions with memory mapped with <b>SEC_NOCACHE</b></para>
            <para>can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_NOCACHE</b> requires either <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> to be set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x4000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserves all pages without allocating physical storage.</para>
            <para>The reserved range of pages cannot be used by any other allocation operations until the range of pages is
released.</para>
            <para>Reserved pages can be identified in subsequent calls to the
<see cref="VirtualAllocExNuma" /> function. This attribute is
valid only if the <i>hFile</i> parameter is <b>INVALID_HANDLE_VALUE</b></para>
            <para>(that is, a file mapping object that is backed by the system paging file).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_WRITECOMBINE</b>
                </description>
              </item>
              <item>
                <description>0x40000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to  be write-combined.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_WRITECOMBINE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwMaximumSizeHigh">
      <para>The high-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
    </param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and the <i>dwMaximumSizeHigh</i> parameter are 0 (zero), the maximum
size of the file mapping object is equal to the current size of the file that the
<i>hFile</i> parameter identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of
<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and
reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing file mapping object, the function requests access to the
object with the protection that the <i>flProtect</i> parameter specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If the <i>lpName</i> parameter matches the name of an existing event, semaphore, mutex,
waitable timer, or job object, the function fails and the
<see cref="GetLastError" /> function returns
<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the
object in the global or session namespace. The remainder of the name can contain any character except the
backslash character (\). Creating a file mapping object in the global namespace requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a></para>
      <para>privilege. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses
session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the
guidelines so that applications can support multiple users.</para>
    </param>
    <param name="nndPreferred">
      <para>The NUMA node where the physical memory should reside.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NUMA_NO_PREFERRED_NODE</b>
                </description>
              </item>
              <item>
                <description>0xffffffff</description>
              </item>
            </list>
          </description>
          <description>
            <para>No NUMA node is preferred. This is the same as calling the
<see cref="CreateFileMapping" /> function.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the file mapping object.</para>
      <para>If the object exists
before the function call, the function returns a handle to the existing object (with its current size, not the
specified size) and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call the <see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>After a file mapping object is created, the size of the file must not exceed the size of the file mapping
object; if it does, not all of the file contents are available for sharing.</para>
      <para>The file mapping object can be shared by duplication, inheritance, or by name. The initial contents of the
pages in a file mapping object backed by the page file are 0 (zero).</para>
      <para>If an application specifies a size for the file mapping object that is larger than the size of the actual
named file on disk and if the page protection allows write access (that is, the
<i>flProtect</i> parameter specifies  <b>PAGE_READWRITE</b> or
<b>PAGE_EXECUTE_READWRITE</b>), then the file on disk is increased to match the specified size
of the file mapping object. If the file is extended, the contents of the file between the old end of the file and
the new end of the file are not guaranteed to be zero; the behavior is defined by the file system.</para>
      <para>If the file cannot be increased, the result is a failure to create the file mapping object and the
<see cref="GetLastError" /> function returns
<b>ERROR_DISK_FULL</b>.</para>
      <para>The handle that the <b>CreateFileMappingNuma</b></para>
      <para>function returns has full access to a new file mapping object and can be used with any function that requires a
handle to a file mapping object. A file mapping object can be shared through process creation, handle duplication,
or by name. For more information, see the
<see cref="DuplicateHandle" /> and
<see cref="OpenFileMapping" /> functions.</para>
      <para>Creating a file mapping object creates the potential for mapping a view of the file but does not map the view.
The <see cref="MapViewOfFileExNuma" /> function maps a view of a
file into a process address space.</para>
      <para>With one important exception, file views derived from a single file mapping object are coherent or identical
at a specific time. If multiple processes have handles of the same file mapping object, they see a coherent view
of the data when they map a view of the file.</para>
      <para>The exception is related to remote files. Although the
<b>CreateFileMappingNuma</b> function works with remote
files, it does not keep them coherent. For example, if two computers both map a file as writable and both change
the same page, each computer sees only its own writes to the page. When the data gets updated on the disk, the
page is not merged.</para>
      <para>A mapped file and a file that is accessed by using the input and output (I/O) functions
(<see cref="ReadFile" /> and
<see cref="WriteFile" />) are not necessarily coherent.</para>
      <para>To fully close a file mapping object, an application must unmap all mapped views of the file mapping object by
calling the <see cref="UnmapViewOfFile" /> function and then close
the file mapping object handle by calling the <see cref="CloseHandle" /></para>
      <para>function.</para>
      <para>These functions can be called in any order. The call to the
<see cref="UnmapViewOfFile" /> function is necessary, because mapped
views of a file mapping object maintain internal open handles to the object, and a file mapping object does not
close until all open handles to it are closed.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>Creating a file-mapping object from a session other than session zero requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a> privilege.
Note that this privilege check is limited to the creation of file mapping objects and does not apply to opening
existing ones. For example, if a service or the system creates a file mapping object, any process running in any
session can access that file mapping object provided that the caller has the required access rights.</para>
      <para>Use structured exception handling to protect any code that writes to or reads from a memory mapped view. For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/reading-and-writing-from-a-file-view">Reading and Writing From a File View</a>.</para>
      <para>To have a mapping with executable permissions, an application must call the
<b>CreateFileMappingNuma</b> function with either
<b>PAGE_EXECUTE_READWRITE</b> or <b>PAGE_EXECUTE_READ</b> and then call the
<see cref="MapViewOfFileExNuma" /> function with
<code>FILE_MAP_EXECUTE | FILE_MAP_WRITE</code> or
<code>FILE_MAP_EXECUTE | FILE_MAP_READ</code>.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFileMapping" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">File Mapping Functions</seealso>
    <seealso cref="MapViewOfFileExNuma" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/numa-support">NUMA Support</seealso>
    <seealso cref="OpenFileMapping" />
    <seealso cref="ReadFile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="UnmapViewOfFile" />
    <seealso cref="VirtualAllocExNuma" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.CreateFileMappingNumaA">
    <summary>
      <para>Creates or opens a named or unnamed file mapping object for a specified file  and specifies the NUMA
node for the physical memory.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access
rights that are compatible with the protection flags that the <i>flProtect</i> parameter
specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive
access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process
must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and
<i>dwMaximumSizeLow</i> parameters. In this scenario,
<b>CreateFileMappingNuma</b> creates a file mapping
object of a specified size  that is backed by the system paging file instead of by a file in the file
system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure that determines whether a returned handle can be inherited by child processes. The
<b>lpSecurityDescriptor</b> member of the
<b>SECURITY_ATTRIBUTES</b> structure specifies a
security descriptor for a new file mapping object.</para>
      <para>If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle cannot be
inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the
default security descriptor for a file mapping object come from the primary or impersonation token of the
creator. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible
with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READ</b>
                </description>
              </item>
              <item>
                <description>0x20</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x40</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, read/write or execute access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and
<b>GENERIC_EXECUTE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x80</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to
<b>PAGE_EXECUTE_READ</b>.</para>
            <para>The file handle that the <i>hFile</i></para>
            <para>parameter specifies must be created with the <b>GENERIC_READ</b> and
<b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READONLY</b>
                </description>
              </item>
              <item>
                <description>0x02</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region
results in an access violation.</para>
            <para>The file handle that  the <i>hFile</i> parameter
specifies must be created with the <b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x04</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or read/write access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x08</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to
<b>PAGE_READONLY</b>.</para>
            <para>The file handle that  the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
      </list>
      <para>An application can specify one or more of the following attributes for the file mapping object by combining
them with one of the preceding page protection values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_COMMIT</b>
                </description>
              </item>
              <item>
                <description>0x8000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates physical storage in memory or the paging file for all pages.</para>
            <para>This is the
default setting.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE</b>
                </description>
              </item>
              <item>
                <description>0x1000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets the file that is specified to be an executable image file.</para>
            <para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as
<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the
executable image file. Page protection for views of an executable image file is determined by the executable
file itself.</para>
            <para>No other attributes are valid with <b>SEC_IMAGE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE_NO_EXECUTE</b>
                </description>
              </item>
              <item>
                <description>0x11000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file that will not be executed and the loaded image file will have no forced integrity checks run.
Additionally, mapping a view of a file mapping object created with the
<b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using
the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a></para>
            <para>kernel API.</para>
            <para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the
<b>PAGE_READONLY</b> page protection value. No other attributes are valid with
<b>SEC_IMAGE_NO_EXECUTE</b>.</para>
            <para>
              <b>Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x80000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables large pages to be used when mapping images or backing from the pagefile, but not when mapping data
for regular files. Be sure to specify the maximum size of the file mapping object as the minimum size of a
large page reported by the
<see cref="GetLargePageMinimum" /> function and to enable
the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a></para>
            <para>privilege.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_NOCACHE</b>
                </description>
              </item>
              <item>
                <description>0x10000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to noncachable.</para>
            <para>Applications should not use this flag except when explicitly required
for a device. Using the interlocked functions with memory mapped with <b>SEC_NOCACHE</b></para>
            <para>can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_NOCACHE</b> requires either <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> to be set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x4000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserves all pages without allocating physical storage.</para>
            <para>The reserved range of pages cannot be used by any other allocation operations until the range of pages is
released.</para>
            <para>Reserved pages can be identified in subsequent calls to the
<see cref="VirtualAllocExNuma" /> function. This attribute is
valid only if the <i>hFile</i> parameter is <b>INVALID_HANDLE_VALUE</b></para>
            <para>(that is, a file mapping object that is backed by the system paging file).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_WRITECOMBINE</b>
                </description>
              </item>
              <item>
                <description>0x40000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to  be write-combined.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_WRITECOMBINE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwMaximumSizeHigh">
      <para>The high-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
    </param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and the <i>dwMaximumSizeHigh</i> parameter are 0 (zero), the maximum
size of the file mapping object is equal to the current size of the file that the
<i>hFile</i> parameter identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of
<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and
reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing file mapping object, the function requests access to the
object with the protection that the <i>flProtect</i> parameter specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If the <i>lpName</i> parameter matches the name of an existing event, semaphore, mutex,
waitable timer, or job object, the function fails and the
<see cref="GetLastError" /> function returns
<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the
object in the global or session namespace. The remainder of the name can contain any character except the
backslash character (\). Creating a file mapping object in the global namespace requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a></para>
      <para>privilege. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses
session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the
guidelines so that applications can support multiple users.</para>
    </param>
    <param name="nndPreferred">
      <para>The NUMA node where the physical memory should reside.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NUMA_NO_PREFERRED_NODE</b>
                </description>
              </item>
              <item>
                <description>0xffffffff</description>
              </item>
            </list>
          </description>
          <description>
            <para>No NUMA node is preferred. This is the same as calling the
<see cref="CreateFileMapping" /> function.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the file mapping object.</para>
      <para>If the object exists
before the function call, the function returns a handle to the existing object (with its current size, not the
specified size) and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call the <see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>After a file mapping object is created, the size of the file must not exceed the size of the file mapping
object; if it does, not all of the file contents are available for sharing.</para>
      <para>The file mapping object can be shared by duplication, inheritance, or by name. The initial contents of the
pages in a file mapping object backed by the page file are 0 (zero).</para>
      <para>If an application specifies a size for the file mapping object that is larger than the size of the actual
named file on disk and if the page protection allows write access (that is, the
<i>flProtect</i> parameter specifies  <b>PAGE_READWRITE</b> or
<b>PAGE_EXECUTE_READWRITE</b>), then the file on disk is increased to match the specified size
of the file mapping object. If the file is extended, the contents of the file between the old end of the file and
the new end of the file are not guaranteed to be zero; the behavior is defined by the file system.</para>
      <para>If the file cannot be increased, the result is a failure to create the file mapping object and the
<see cref="GetLastError" /> function returns
<b>ERROR_DISK_FULL</b>.</para>
      <para>The handle that the <b>CreateFileMappingNuma</b></para>
      <para>function returns has full access to a new file mapping object and can be used with any function that requires a
handle to a file mapping object. A file mapping object can be shared through process creation, handle duplication,
or by name. For more information, see the
<see cref="DuplicateHandle" /> and
<see cref="OpenFileMapping" /> functions.</para>
      <para>Creating a file mapping object creates the potential for mapping a view of the file but does not map the view.
The <see cref="MapViewOfFileExNuma" /> function maps a view of a
file into a process address space.</para>
      <para>With one important exception, file views derived from a single file mapping object are coherent or identical
at a specific time. If multiple processes have handles of the same file mapping object, they see a coherent view
of the data when they map a view of the file.</para>
      <para>The exception is related to remote files. Although the
<b>CreateFileMappingNuma</b> function works with remote
files, it does not keep them coherent. For example, if two computers both map a file as writable and both change
the same page, each computer sees only its own writes to the page. When the data gets updated on the disk, the
page is not merged.</para>
      <para>A mapped file and a file that is accessed by using the input and output (I/O) functions
(<see cref="ReadFile" /> and
<see cref="WriteFile" />) are not necessarily coherent.</para>
      <para>To fully close a file mapping object, an application must unmap all mapped views of the file mapping object by
calling the <see cref="UnmapViewOfFile" /> function and then close
the file mapping object handle by calling the <see cref="CloseHandle" /></para>
      <para>function.</para>
      <para>These functions can be called in any order. The call to the
<see cref="UnmapViewOfFile" /> function is necessary, because mapped
views of a file mapping object maintain internal open handles to the object, and a file mapping object does not
close until all open handles to it are closed.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>Creating a file-mapping object from a session other than session zero requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a> privilege.
Note that this privilege check is limited to the creation of file mapping objects and does not apply to opening
existing ones. For example, if a service or the system creates a file mapping object, any process running in any
session can access that file mapping object provided that the caller has the required access rights.</para>
      <para>Use structured exception handling to protect any code that writes to or reads from a memory mapped view. For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/reading-and-writing-from-a-file-view">Reading and Writing From a File View</a>.</para>
      <para>To have a mapping with executable permissions, an application must call the
<b>CreateFileMappingNuma</b> function with either
<b>PAGE_EXECUTE_READWRITE</b> or <b>PAGE_EXECUTE_READ</b> and then call the
<see cref="MapViewOfFileExNuma" /> function with
<code>FILE_MAP_EXECUTE | FILE_MAP_WRITE</code> or
<code>FILE_MAP_EXECUTE | FILE_MAP_READ</code>.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFileMapping" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">File Mapping Functions</seealso>
    <seealso cref="MapViewOfFileExNuma" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/numa-support">NUMA Support</seealso>
    <seealso cref="OpenFileMapping" />
    <seealso cref="ReadFile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="UnmapViewOfFile" />
    <seealso cref="VirtualAllocExNuma" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.CreateFileMappingNumaW">
    <summary>
      <para>Creates or opens a named or unnamed file mapping object for a specified file  and specifies the NUMA
node for the physical memory.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access
rights that are compatible with the protection flags that the <i>flProtect</i> parameter
specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive
access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process
must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and
<i>dwMaximumSizeLow</i> parameters. In this scenario,
<b>CreateFileMappingNuma</b> creates a file mapping
object of a specified size  that is backed by the system paging file instead of by a file in the file
system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure that determines whether a returned handle can be inherited by child processes. The
<b>lpSecurityDescriptor</b> member of the
<b>SECURITY_ATTRIBUTES</b> structure specifies a
security descriptor for a new file mapping object.</para>
      <para>If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle cannot be
inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the
default security descriptor for a file mapping object come from the primary or impersonation token of the
creator. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible
with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READ</b>
                </description>
              </item>
              <item>
                <description>0x20</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x40</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, read/write or execute access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and
<b>GENERIC_EXECUTE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x80</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to
<b>PAGE_EXECUTE_READ</b>.</para>
            <para>The file handle that the <i>hFile</i></para>
            <para>parameter specifies must be created with the <b>GENERIC_READ</b> and
<b>GENERIC_EXECUTE</b> access rights.</para>
            <para>
              <b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READONLY</b>
                </description>
              </item>
              <item>
                <description>0x02</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region
results in an access violation.</para>
            <para>The file handle that  the <i>hFile</i> parameter
specifies must be created with the <b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x04</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only, copy-on-write, or read/write access.</para>
            <para>The file handle that the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access rights.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PAGE_WRITECOPY</b>
                </description>
              </item>
              <item>
                <description>0x08</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to
<b>PAGE_READONLY</b>.</para>
            <para>The file handle that  the <i>hFile</i> parameter specifies must be created with the
<b>GENERIC_READ</b> access right.</para>
          </description>
        </item>
      </list>
      <para>An application can specify one or more of the following attributes for the file mapping object by combining
them with one of the preceding page protection values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_COMMIT</b>
                </description>
              </item>
              <item>
                <description>0x8000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates physical storage in memory or the paging file for all pages.</para>
            <para>This is the
default setting.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE</b>
                </description>
              </item>
              <item>
                <description>0x1000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets the file that is specified to be an executable image file.</para>
            <para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as
<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the
executable image file. Page protection for views of an executable image file is determined by the executable
file itself.</para>
            <para>No other attributes are valid with <b>SEC_IMAGE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_IMAGE_NO_EXECUTE</b>
                </description>
              </item>
              <item>
                <description>0x11000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specifies that the file that the  <i>hFile</i> parameter specifies is an executable
image file that will not be executed and the loaded image file will have no forced integrity checks run.
Additionally, mapping a view of a file mapping object created with the
<b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using
the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a></para>
            <para>kernel API.</para>
            <para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the
<b>PAGE_READONLY</b> page protection value. No other attributes are valid with
<b>SEC_IMAGE_NO_EXECUTE</b>.</para>
            <para>
              <b>Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_LARGE_PAGES</b>
                </description>
              </item>
              <item>
                <description>0x80000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables large pages to be used when mapping images or backing from the pagefile, but not when mapping data
for regular files. Be sure to specify the maximum size of the file mapping object as the minimum size of a
large page reported by the
<see cref="GetLargePageMinimum" /> function and to enable
the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a></para>
            <para>privilege.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_NOCACHE</b>
                </description>
              </item>
              <item>
                <description>0x10000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to noncachable.</para>
            <para>Applications should not use this flag except when explicitly required
for a device. Using the interlocked functions with memory mapped with <b>SEC_NOCACHE</b></para>
            <para>can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_NOCACHE</b> requires either <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> to be set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_RESERVE</b>
                </description>
              </item>
              <item>
                <description>0x4000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserves all pages without allocating physical storage.</para>
            <para>The reserved range of pages cannot be used by any other allocation operations until the range of pages is
released.</para>
            <para>Reserved pages can be identified in subsequent calls to the
<see cref="VirtualAllocExNuma" /> function. This attribute is
valid only if the <i>hFile</i> parameter is <b>INVALID_HANDLE_VALUE</b></para>
            <para>(that is, a file mapping object that is backed by the system paging file).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SEC_WRITECOMBINE</b>
                </description>
              </item>
              <item>
                <description>0x40000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets all pages to  be write-combined.</para>
            <para>Applications should not use this attribute except when
explicitly required for a device. Using the interlocked functions with memory that is mapped with
<b>SEC_WRITECOMBINE</b> can result in an
<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para>
            <para>
              <b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or
<b>SEC_COMMIT</b> attribute to be set.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwMaximumSizeHigh">
      <para>The high-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
    </param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and the <i>dwMaximumSizeHigh</i> parameter are 0 (zero), the maximum
size of the file mapping object is equal to the current size of the file that the
<i>hFile</i> parameter identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of
<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and
reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing file mapping object, the function requests access to the
object with the protection that the <i>flProtect</i> parameter specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If the <i>lpName</i> parameter matches the name of an existing event, semaphore, mutex,
waitable timer, or job object, the function fails and the
<see cref="GetLastError" /> function returns
<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the
object in the global or session namespace. The remainder of the name can contain any character except the
backslash character (\). Creating a file mapping object in the global namespace requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a></para>
      <para>privilege. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses
session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the
guidelines so that applications can support multiple users.</para>
    </param>
    <param name="nndPreferred">
      <para>The NUMA node where the physical memory should reside.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NUMA_NO_PREFERRED_NODE</b>
                </description>
              </item>
              <item>
                <description>0xffffffff</description>
              </item>
            </list>
          </description>
          <description>
            <para>No NUMA node is preferred. This is the same as calling the
<see cref="CreateFileMapping" /> function.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the file mapping object.</para>
      <para>If the object exists
before the function call, the function returns a handle to the existing object (with its current size, not the
specified size) and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call the <see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>After a file mapping object is created, the size of the file must not exceed the size of the file mapping
object; if it does, not all of the file contents are available for sharing.</para>
      <para>The file mapping object can be shared by duplication, inheritance, or by name. The initial contents of the
pages in a file mapping object backed by the page file are 0 (zero).</para>
      <para>If an application specifies a size for the file mapping object that is larger than the size of the actual
named file on disk and if the page protection allows write access (that is, the
<i>flProtect</i> parameter specifies  <b>PAGE_READWRITE</b> or
<b>PAGE_EXECUTE_READWRITE</b>), then the file on disk is increased to match the specified size
of the file mapping object. If the file is extended, the contents of the file between the old end of the file and
the new end of the file are not guaranteed to be zero; the behavior is defined by the file system.</para>
      <para>If the file cannot be increased, the result is a failure to create the file mapping object and the
<see cref="GetLastError" /> function returns
<b>ERROR_DISK_FULL</b>.</para>
      <para>The handle that the <b>CreateFileMappingNuma</b></para>
      <para>function returns has full access to a new file mapping object and can be used with any function that requires a
handle to a file mapping object. A file mapping object can be shared through process creation, handle duplication,
or by name. For more information, see the
<see cref="DuplicateHandle" /> and
<see cref="OpenFileMapping" /> functions.</para>
      <para>Creating a file mapping object creates the potential for mapping a view of the file but does not map the view.
The <see cref="MapViewOfFileExNuma" /> function maps a view of a
file into a process address space.</para>
      <para>With one important exception, file views derived from a single file mapping object are coherent or identical
at a specific time. If multiple processes have handles of the same file mapping object, they see a coherent view
of the data when they map a view of the file.</para>
      <para>The exception is related to remote files. Although the
<b>CreateFileMappingNuma</b> function works with remote
files, it does not keep them coherent. For example, if two computers both map a file as writable and both change
the same page, each computer sees only its own writes to the page. When the data gets updated on the disk, the
page is not merged.</para>
      <para>A mapped file and a file that is accessed by using the input and output (I/O) functions
(<see cref="ReadFile" /> and
<see cref="WriteFile" />) are not necessarily coherent.</para>
      <para>To fully close a file mapping object, an application must unmap all mapped views of the file mapping object by
calling the <see cref="UnmapViewOfFile" /> function and then close
the file mapping object handle by calling the <see cref="CloseHandle" /></para>
      <para>function.</para>
      <para>These functions can be called in any order. The call to the
<see cref="UnmapViewOfFile" /> function is necessary, because mapped
views of a file mapping object maintain internal open handles to the object, and a file mapping object does not
close until all open handles to it are closed.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>Creating a file-mapping object from a session other than session zero requires the
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a> privilege.
Note that this privilege check is limited to the creation of file mapping objects and does not apply to opening
existing ones. For example, if a service or the system creates a file mapping object, any process running in any
session can access that file mapping object provided that the caller has the required access rights.</para>
      <para>Use structured exception handling to protect any code that writes to or reads from a memory mapped view. For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/reading-and-writing-from-a-file-view">Reading and Writing From a File View</a>.</para>
      <para>To have a mapping with executable permissions, an application must call the
<b>CreateFileMappingNuma</b> function with either
<b>PAGE_EXECUTE_READWRITE</b> or <b>PAGE_EXECUTE_READ</b> and then call the
<see cref="MapViewOfFileExNuma" /> function with
<code>FILE_MAP_EXECUTE | FILE_MAP_WRITE</code> or
<code>FILE_MAP_EXECUTE | FILE_MAP_READ</code>.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFileMapping" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">File Mapping Functions</seealso>
    <seealso cref="MapViewOfFileExNuma" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/numa-support">NUMA Support</seealso>
    <seealso cref="OpenFileMapping" />
    <seealso cref="ReadFile" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="UnmapViewOfFile" />
    <seealso cref="VirtualAllocExNuma" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.CreateHardLink">
    <summary>
      <para>Establishes a hard link between an existing file and a new file. This function is only
supported on the NTFS file system, and only for files, not directories.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CreateHardLinkTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the new file.</para>
      <para>This parameter may include the path but cannot specify the name of a directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpExistingFileName">
      <para>The name of the existing file.</para>
      <para>This parameter may include the path cannot specify the name of a directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>Reserved; must be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call <see cref="GetLastError" />.</para>
      <para>The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 links are created for a file, an error results.</para>
      <para>If you pass a name longer than MAX_PATH characters to the <i>lpFileName</i> or <i>lpExistingFileName</i> parameter of the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
    </returns>
    <remarks>
      <para>Any directory entry for a file that is created with
<see cref="CreateFile" /> or
<b>CreateHardLink</b> is a hard link to an associated file.
An additional hard link that is created with the
<b>CreateHardLink</b></para>
      <para>function allows you to have multiple directory entries for a file, that is, multiple hard links to the same file,
which can be different names in the same directory, or the same or different names in different directories.
However, all hard links to a file must be on the same volume.</para>
      <para>Because hard links are only directory entries for a file, many changes to that file are instantly visible to
applications that access it through the hard links that reference it. However, the directory entry size and
attribute information is updated only for the link through which the change was made.</para>
      <para>The security descriptor belongs to the file to which a hard link points. The link itself is only a directory
entry, and does not have a security descriptor. Therefore, when you change the security descriptor of a hard link,
you a change the security descriptor of the underlying file, and all hard links that point to the file allow the
newly specified access. You cannot give a file different security descriptors on a per-hard-link basis.</para>
      <para>This function does not modify the security descriptor of the file to be linked to, even if security descriptor
information is passed in the <i>lpSecurityAttributes</i> parameter.</para>
      <para>Use <see cref="DeleteFile" /> to delete hard links. You can delete
them in any order regardless of the order in which they are created.</para>
      <para>Flags, attributes, access, and sharing that are specified in
<see cref="CreateFile" /> operate on a per-file basis. That is, if you
open a file that does not allow sharing, another application cannot share the file by creating a new hard link to
the file.</para>
      <para>When you create a hard link on the NTFS file system, the file attribute information in the directory entry is
refreshed only when the file is opened, or when
<see cref="GetFileInformationByHandle" /> is called with
the handle of a specific file.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function creates a hard
link to the target.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>Note that SMB 3.0 does not support creation of hard links on shares with continuous availability capability.</para>
      <h4>Examples</h4>
      <para>The following code snippet shows you how to call
<b>CreateHardLink</b> so that it does not modify the security
descriptor of a file. The <i>pszExistingFileName</i> parameter can be the original file name,
or any existing link to a file. After this code is executed, <i>pszNewLinkName</i> refers to
the file.</para>
      <code>  BOOL fCreatedLink = CreateHardLink( pszNewLinkName,
                                      pszExistingFileName,
                                      NULL ); // reserved, must be NULL

  if ( fCreatedLink == FALSE )
   {
    ;// handle error condition
   }

</code>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateHardLink as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="CreateHardLinkTransacted" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CreateHardLinkA">
    <summary>
      <para>Establishes a hard link between an existing file and a new file. This function is only
supported on the NTFS file system, and only for files, not directories.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CreateHardLinkTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the new file.</para>
      <para>This parameter may include the path but cannot specify the name of a directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpExistingFileName">
      <para>The name of the existing file.</para>
      <para>This parameter may include the path cannot specify the name of a directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>Reserved; must be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call <see cref="GetLastError" />.</para>
      <para>The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 links are created for a file, an error results.</para>
      <para>If you pass a name longer than MAX_PATH characters to the <i>lpFileName</i> or <i>lpExistingFileName</i> parameter of the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
    </returns>
    <remarks>
      <para>Any directory entry for a file that is created with
<see cref="CreateFile" /> or
<b>CreateHardLink</b> is a hard link to an associated file.
An additional hard link that is created with the
<b>CreateHardLink</b></para>
      <para>function allows you to have multiple directory entries for a file, that is, multiple hard links to the same file,
which can be different names in the same directory, or the same or different names in different directories.
However, all hard links to a file must be on the same volume.</para>
      <para>Because hard links are only directory entries for a file, many changes to that file are instantly visible to
applications that access it through the hard links that reference it. However, the directory entry size and
attribute information is updated only for the link through which the change was made.</para>
      <para>The security descriptor belongs to the file to which a hard link points. The link itself is only a directory
entry, and does not have a security descriptor. Therefore, when you change the security descriptor of a hard link,
you a change the security descriptor of the underlying file, and all hard links that point to the file allow the
newly specified access. You cannot give a file different security descriptors on a per-hard-link basis.</para>
      <para>This function does not modify the security descriptor of the file to be linked to, even if security descriptor
information is passed in the <i>lpSecurityAttributes</i> parameter.</para>
      <para>Use <see cref="DeleteFile" /> to delete hard links. You can delete
them in any order regardless of the order in which they are created.</para>
      <para>Flags, attributes, access, and sharing that are specified in
<see cref="CreateFile" /> operate on a per-file basis. That is, if you
open a file that does not allow sharing, another application cannot share the file by creating a new hard link to
the file.</para>
      <para>When you create a hard link on the NTFS file system, the file attribute information in the directory entry is
refreshed only when the file is opened, or when
<see cref="GetFileInformationByHandle" /> is called with
the handle of a specific file.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function creates a hard
link to the target.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>Note that SMB 3.0 does not support creation of hard links on shares with continuous availability capability.</para>
      <h4>Examples</h4>
      <para>The following code snippet shows you how to call
<b>CreateHardLink</b> so that it does not modify the security
descriptor of a file. The <i>pszExistingFileName</i> parameter can be the original file name,
or any existing link to a file. After this code is executed, <i>pszNewLinkName</i> refers to
the file.</para>
      <code>  BOOL fCreatedLink = CreateHardLink( pszNewLinkName,
                                      pszExistingFileName,
                                      NULL ); // reserved, must be NULL

  if ( fCreatedLink == FALSE )
   {
    ;// handle error condition
   }

</code>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateHardLink as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="CreateHardLinkTransacted" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CreateHardLinkW">
    <summary>
      <para>Establishes a hard link between an existing file and a new file. This function is only
supported on the NTFS file system, and only for files, not directories.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CreateHardLinkTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the new file.</para>
      <para>This parameter may include the path but cannot specify the name of a directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpExistingFileName">
      <para>The name of the existing file.</para>
      <para>This parameter may include the path cannot specify the name of a directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>Reserved; must be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call <see cref="GetLastError" />.</para>
      <para>The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 links are created for a file, an error results.</para>
      <para>If you pass a name longer than MAX_PATH characters to the <i>lpFileName</i> or <i>lpExistingFileName</i> parameter of the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
    </returns>
    <remarks>
      <para>Any directory entry for a file that is created with
<see cref="CreateFile" /> or
<b>CreateHardLink</b> is a hard link to an associated file.
An additional hard link that is created with the
<b>CreateHardLink</b></para>
      <para>function allows you to have multiple directory entries for a file, that is, multiple hard links to the same file,
which can be different names in the same directory, or the same or different names in different directories.
However, all hard links to a file must be on the same volume.</para>
      <para>Because hard links are only directory entries for a file, many changes to that file are instantly visible to
applications that access it through the hard links that reference it. However, the directory entry size and
attribute information is updated only for the link through which the change was made.</para>
      <para>The security descriptor belongs to the file to which a hard link points. The link itself is only a directory
entry, and does not have a security descriptor. Therefore, when you change the security descriptor of a hard link,
you a change the security descriptor of the underlying file, and all hard links that point to the file allow the
newly specified access. You cannot give a file different security descriptors on a per-hard-link basis.</para>
      <para>This function does not modify the security descriptor of the file to be linked to, even if security descriptor
information is passed in the <i>lpSecurityAttributes</i> parameter.</para>
      <para>Use <see cref="DeleteFile" /> to delete hard links. You can delete
them in any order regardless of the order in which they are created.</para>
      <para>Flags, attributes, access, and sharing that are specified in
<see cref="CreateFile" /> operate on a per-file basis. That is, if you
open a file that does not allow sharing, another application cannot share the file by creating a new hard link to
the file.</para>
      <para>When you create a hard link on the NTFS file system, the file attribute information in the directory entry is
refreshed only when the file is opened, or when
<see cref="GetFileInformationByHandle" /> is called with
the handle of a specific file.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function creates a hard
link to the target.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>Note that SMB 3.0 does not support creation of hard links on shares with continuous availability capability.</para>
      <h4>Examples</h4>
      <para>The following code snippet shows you how to call
<b>CreateHardLink</b> so that it does not modify the security
descriptor of a file. The <i>pszExistingFileName</i> parameter can be the original file name,
or any existing link to a file. After this code is executed, <i>pszNewLinkName</i> refers to
the file.</para>
      <code>  BOOL fCreatedLink = CreateHardLink( pszNewLinkName,
                                      pszExistingFileName,
                                      NULL ); // reserved, must be NULL

  if ( fCreatedLink == FALSE )
   {
    ;// handle error condition
   }

</code>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateHardLink as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="CreateHardLinkTransacted" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CreateHardLink">
    <summary>
      <para>Establishes a hard link between an existing file and a new file. This function is only
supported on the NTFS file system, and only for files, not directories.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CreateHardLinkTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the new file.</para>
      <para>This parameter may include the path but cannot specify the name of a directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpExistingFileName">
      <para>The name of the existing file.</para>
      <para>This parameter may include the path cannot specify the name of a directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>Reserved; must be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call <see cref="GetLastError" />.</para>
      <para>The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 links are created for a file, an error results.</para>
      <para>If you pass a name longer than MAX_PATH characters to the <i>lpFileName</i> or <i>lpExistingFileName</i> parameter of the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
    </returns>
    <remarks>
      <para>Any directory entry for a file that is created with
<see cref="CreateFile" /> or
<b>CreateHardLink</b> is a hard link to an associated file.
An additional hard link that is created with the
<b>CreateHardLink</b></para>
      <para>function allows you to have multiple directory entries for a file, that is, multiple hard links to the same file,
which can be different names in the same directory, or the same or different names in different directories.
However, all hard links to a file must be on the same volume.</para>
      <para>Because hard links are only directory entries for a file, many changes to that file are instantly visible to
applications that access it through the hard links that reference it. However, the directory entry size and
attribute information is updated only for the link through which the change was made.</para>
      <para>The security descriptor belongs to the file to which a hard link points. The link itself is only a directory
entry, and does not have a security descriptor. Therefore, when you change the security descriptor of a hard link,
you a change the security descriptor of the underlying file, and all hard links that point to the file allow the
newly specified access. You cannot give a file different security descriptors on a per-hard-link basis.</para>
      <para>This function does not modify the security descriptor of the file to be linked to, even if security descriptor
information is passed in the <i>lpSecurityAttributes</i> parameter.</para>
      <para>Use <see cref="DeleteFile" /> to delete hard links. You can delete
them in any order regardless of the order in which they are created.</para>
      <para>Flags, attributes, access, and sharing that are specified in
<see cref="CreateFile" /> operate on a per-file basis. That is, if you
open a file that does not allow sharing, another application cannot share the file by creating a new hard link to
the file.</para>
      <para>When you create a hard link on the NTFS file system, the file attribute information in the directory entry is
refreshed only when the file is opened, or when
<see cref="GetFileInformationByHandle" /> is called with
the handle of a specific file.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function creates a hard
link to the target.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>Note that SMB 3.0 does not support creation of hard links on shares with continuous availability capability.</para>
      <h4>Examples</h4>
      <para>The following code snippet shows you how to call
<b>CreateHardLink</b> so that it does not modify the security
descriptor of a file. The <i>pszExistingFileName</i> parameter can be the original file name,
or any existing link to a file. After this code is executed, <i>pszNewLinkName</i> refers to
the file.</para>
      <code>  BOOL fCreatedLink = CreateHardLink( pszNewLinkName,
                                      pszExistingFileName,
                                      NULL ); // reserved, must be NULL

  if ( fCreatedLink == FALSE )
   {
    ;// handle error condition
   }

</code>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateHardLink as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="CreateHardLinkTransacted" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CreateHardLinkA">
    <summary>
      <para>Establishes a hard link between an existing file and a new file. This function is only
supported on the NTFS file system, and only for files, not directories.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CreateHardLinkTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the new file.</para>
      <para>This parameter may include the path but cannot specify the name of a directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpExistingFileName">
      <para>The name of the existing file.</para>
      <para>This parameter may include the path cannot specify the name of a directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>Reserved; must be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call <see cref="GetLastError" />.</para>
      <para>The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 links are created for a file, an error results.</para>
      <para>If you pass a name longer than MAX_PATH characters to the <i>lpFileName</i> or <i>lpExistingFileName</i> parameter of the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
    </returns>
    <remarks>
      <para>Any directory entry for a file that is created with
<see cref="CreateFile" /> or
<b>CreateHardLink</b> is a hard link to an associated file.
An additional hard link that is created with the
<b>CreateHardLink</b></para>
      <para>function allows you to have multiple directory entries for a file, that is, multiple hard links to the same file,
which can be different names in the same directory, or the same or different names in different directories.
However, all hard links to a file must be on the same volume.</para>
      <para>Because hard links are only directory entries for a file, many changes to that file are instantly visible to
applications that access it through the hard links that reference it. However, the directory entry size and
attribute information is updated only for the link through which the change was made.</para>
      <para>The security descriptor belongs to the file to which a hard link points. The link itself is only a directory
entry, and does not have a security descriptor. Therefore, when you change the security descriptor of a hard link,
you a change the security descriptor of the underlying file, and all hard links that point to the file allow the
newly specified access. You cannot give a file different security descriptors on a per-hard-link basis.</para>
      <para>This function does not modify the security descriptor of the file to be linked to, even if security descriptor
information is passed in the <i>lpSecurityAttributes</i> parameter.</para>
      <para>Use <see cref="DeleteFile" /> to delete hard links. You can delete
them in any order regardless of the order in which they are created.</para>
      <para>Flags, attributes, access, and sharing that are specified in
<see cref="CreateFile" /> operate on a per-file basis. That is, if you
open a file that does not allow sharing, another application cannot share the file by creating a new hard link to
the file.</para>
      <para>When you create a hard link on the NTFS file system, the file attribute information in the directory entry is
refreshed only when the file is opened, or when
<see cref="GetFileInformationByHandle" /> is called with
the handle of a specific file.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function creates a hard
link to the target.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>Note that SMB 3.0 does not support creation of hard links on shares with continuous availability capability.</para>
      <h4>Examples</h4>
      <para>The following code snippet shows you how to call
<b>CreateHardLink</b> so that it does not modify the security
descriptor of a file. The <i>pszExistingFileName</i> parameter can be the original file name,
or any existing link to a file. After this code is executed, <i>pszNewLinkName</i> refers to
the file.</para>
      <code>  BOOL fCreatedLink = CreateHardLink( pszNewLinkName,
                                      pszExistingFileName,
                                      NULL ); // reserved, must be NULL

  if ( fCreatedLink == FALSE )
   {
    ;// handle error condition
   }

</code>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateHardLink as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="CreateHardLinkTransacted" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CreateHardLinkW">
    <summary>
      <para>Establishes a hard link between an existing file and a new file. This function is only
supported on the NTFS file system, and only for files, not directories.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CreateHardLinkTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the new file.</para>
      <para>This parameter may include the path but cannot specify the name of a directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpExistingFileName">
      <para>The name of the existing file.</para>
      <para>This parameter may include the path cannot specify the name of a directory.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>Reserved; must be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call <see cref="GetLastError" />.</para>
      <para>The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 links are created for a file, an error results.</para>
      <para>If you pass a name longer than MAX_PATH characters to the <i>lpFileName</i> or <i>lpExistingFileName</i> parameter of the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
    </returns>
    <remarks>
      <para>Any directory entry for a file that is created with
<see cref="CreateFile" /> or
<b>CreateHardLink</b> is a hard link to an associated file.
An additional hard link that is created with the
<b>CreateHardLink</b></para>
      <para>function allows you to have multiple directory entries for a file, that is, multiple hard links to the same file,
which can be different names in the same directory, or the same or different names in different directories.
However, all hard links to a file must be on the same volume.</para>
      <para>Because hard links are only directory entries for a file, many changes to that file are instantly visible to
applications that access it through the hard links that reference it. However, the directory entry size and
attribute information is updated only for the link through which the change was made.</para>
      <para>The security descriptor belongs to the file to which a hard link points. The link itself is only a directory
entry, and does not have a security descriptor. Therefore, when you change the security descriptor of a hard link,
you a change the security descriptor of the underlying file, and all hard links that point to the file allow the
newly specified access. You cannot give a file different security descriptors on a per-hard-link basis.</para>
      <para>This function does not modify the security descriptor of the file to be linked to, even if security descriptor
information is passed in the <i>lpSecurityAttributes</i> parameter.</para>
      <para>Use <see cref="DeleteFile" /> to delete hard links. You can delete
them in any order regardless of the order in which they are created.</para>
      <para>Flags, attributes, access, and sharing that are specified in
<see cref="CreateFile" /> operate on a per-file basis. That is, if you
open a file that does not allow sharing, another application cannot share the file by creating a new hard link to
the file.</para>
      <para>When you create a hard link on the NTFS file system, the file attribute information in the directory entry is
refreshed only when the file is opened, or when
<see cref="GetFileInformationByHandle" /> is called with
the handle of a specific file.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the function creates a hard
link to the target.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>Note that SMB 3.0 does not support creation of hard links on shares with continuous availability capability.</para>
      <h4>Examples</h4>
      <para>The following code snippet shows you how to call
<b>CreateHardLink</b> so that it does not modify the security
descriptor of a file. The <i>pszExistingFileName</i> parameter can be the original file name,
or any existing link to a file. After this code is executed, <i>pszNewLinkName</i> refers to
the file.</para>
      <code>  BOOL fCreatedLink = CreateHardLink( pszNewLinkName,
                                      pszExistingFileName,
                                      NULL ); // reserved, must be NULL

  if ( fCreatedLink == FALSE )
   {
    ;// handle error condition
   }

</code>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateHardLink as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="CreateHardLinkTransacted" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CreateJobObject">
    <summary>
      <para>Creates or opens a job object.</para>
    </summary>
    <param name="lpJobAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies the security descriptor for the job object and determines whether child processes can inherit the returned handle. If <i>lpJobAttributes</i> is <b>NULL</b>, the job object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a job object come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lpName">
      <para>The name of the job. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case-sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the job is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the job object. The handle has the <b>JOB_OBJECT_ALL_ACCESS</b> access right. If the object existed before the function call, the function returns a handle to the existing job object and
<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When a job is created, its accounting information is initialized to zero, all limits are inactive, and there are no associated processes. To assign a process to  a job object, use the
<see cref="AssignProcessToJobObject" /> function. To set limits for a job, use the
<see cref="SetInformationJobObject" /> function. To query accounting information, use the
<see cref="QueryInformationJobObject" /> function.</para>
      <para>All processes associated with a job must run in the same session. A job is associated with the session of the first process to be assigned to the job.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>A job is associated with the session of the  process that created it.</para>
      <para>To close a job object handle, use the
<see cref="CloseHandle" /> function. The job is destroyed when its last handle has been closed and all associated processes have exited. However, if the job has the <b>JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE</b> flag specified, closing the last job object handle terminates all associated processes and then destroys the job object itself.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="AssignProcessToJobObject" />
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/job-objects">Job Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso cref="QueryInformationJobObject" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SetInformationJobObject" />
  </member>
  <member name="Windows.CreateJobObjectA">
    <summary>
      <para>Creates or opens a job object.</para>
    </summary>
    <param name="lpJobAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies the security descriptor for the job object and determines whether child processes can inherit the returned handle. If <i>lpJobAttributes</i> is <b>NULL</b>, the job object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a job object come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lpName">
      <para>The name of the job. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case-sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the job is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the job object. The handle has the <b>JOB_OBJECT_ALL_ACCESS</b> access right. If the object existed before the function call, the function returns a handle to the existing job object and
<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When a job is created, its accounting information is initialized to zero, all limits are inactive, and there are no associated processes. To assign a process to  a job object, use the
<see cref="AssignProcessToJobObject" /> function. To set limits for a job, use the
<see cref="SetInformationJobObject" /> function. To query accounting information, use the
<see cref="QueryInformationJobObject" /> function.</para>
      <para>All processes associated with a job must run in the same session. A job is associated with the session of the first process to be assigned to the job.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>A job is associated with the session of the  process that created it.</para>
      <para>To close a job object handle, use the
<see cref="CloseHandle" /> function. The job is destroyed when its last handle has been closed and all associated processes have exited. However, if the job has the <b>JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE</b> flag specified, closing the last job object handle terminates all associated processes and then destroys the job object itself.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="AssignProcessToJobObject" />
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/job-objects">Job Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso cref="QueryInformationJobObject" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SetInformationJobObject" />
  </member>
  <member name="Windows.CreateJobObjectW">
    <summary>
      <para>Creates or opens a job object.</para>
    </summary>
    <param name="lpJobAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies the security descriptor for the job object and determines whether child processes can inherit the returned handle. If <i>lpJobAttributes</i> is <b>NULL</b>, the job object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a job object come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lpName">
      <para>The name of the job. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case-sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the job is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the job object. The handle has the <b>JOB_OBJECT_ALL_ACCESS</b> access right. If the object existed before the function call, the function returns a handle to the existing job object and
<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When a job is created, its accounting information is initialized to zero, all limits are inactive, and there are no associated processes. To assign a process to  a job object, use the
<see cref="AssignProcessToJobObject" /> function. To set limits for a job, use the
<see cref="SetInformationJobObject" /> function. To query accounting information, use the
<see cref="QueryInformationJobObject" /> function.</para>
      <para>All processes associated with a job must run in the same session. A job is associated with the session of the first process to be assigned to the job.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>A job is associated with the session of the  process that created it.</para>
      <para>To close a job object handle, use the
<see cref="CloseHandle" /> function. The job is destroyed when its last handle has been closed and all associated processes have exited. However, if the job has the <b>JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE</b> flag specified, closing the last job object handle terminates all associated processes and then destroys the job object itself.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="AssignProcessToJobObject" />
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/job-objects">Job Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso cref="QueryInformationJobObject" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SetInformationJobObject" />
  </member>
  <member name="Windows.CreateMailslot">
    <summary>
      <para>Creates a mailslot with the specified name and returns  a handle that a mailslot server can use to perform operations on the mailslot. The mailslot is local to the computer that creates it. An error occurs if a mailslot with the specified name already exists.</para>
    </summary>
    <param name="lpName">
      <para>The name of the mailslot. This name must have the following form:</para>
      <para>\\.\mailslot\[<i>path</i>]<i>name</i></para>
      <para>The name field must be unique. The name may include multiple levels of pseudo directories separated by backslashes. For example, both \\.\mailslot\example_mailslot_name and \\.\mailslot\abc\def\ghi are valid names.</para>
    </param>
    <param name="nMaxMessageSize">
      <para>The maximum size of a single message that can be written to the mailslot, in bytes. To specify that the message can be of any size, set this value to zero.</para>
    </param>
    <param name="lReadTimeout">
      <para>The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in milliseconds. The following values have special meanings.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>Returns immediately if no message is present. (The system does not treat an immediate return as an error.)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MAILSLOT_WAIT_FOREVER</b>
                </description>
              </item>
              <item>
                <description>((DWORD)-1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>Waits forever for a message.</para>
          </description>
        </item>
      </list>
      <para>This time-out value applies to all subsequent read operations and all inherited mailslot handles.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. The <b>bInheritHandle</b> member of the structure determines whether the returned handle can be inherited by child processes. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the mailslot, for use in server mailslot operations.  The handle returned by this function is asynchronous, or overlapped.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The mailslot exists until one of the following conditions is true:</para>
      <list type="bullet">
        <item>
          <description>The last (possibly inherited or duplicated) handle to it is closed using the
<see cref="CloseHandle" /> function.</description>
        </item>
        <item>
          <description>The process owning the last (possibly inherited or duplicated) handle exits.</description>
        </item>
      </list>
      <para>The system uses the second method to destroy mailslots.</para>
      <para>To write a message to a mailslot, a process uses the
<see cref="CreateFile" /> function, specifying the mailslot name by using one of the following formats.</para>
      <list type="table">
        <listheader>
          <description>Format</description>
          <description>Usage</description>
        </listheader>
        <item>
          <description>\\.\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to a local mailslot.</description>
        </item>
        <item>
          <description>\\<i>computername</i>\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to a remote mailslot.</description>
        </item>
        <item>
          <description>\\<i>domainname</i>\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to all mailslots with the specified name in the specified domain.</description>
        </item>
        <item>
          <description>\\*\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to all mailslots with the specified name in the system's primary domain.</description>
        </item>
      </list>
      <para>If <see cref="CreateFile" /> specifies a domain or uses the asterisk format to specify the system's primary domain, the application cannot write more than 424 bytes at a time to the mailslot. If the application attempts to do so, the <see cref="WriteFile" /> function fails and
<see cref="GetLastError" /> returns <b>ERROR_BAD_NETPATH</b>.</para>
      <para>An application must specify the <b>FILE_SHARE_READ</b> flag when using <see cref="CreateFile" /> to retrieve a client handle to a mailslot.</para>
      <para>If <see cref="CreateFile" /> is called to access a non-existent mailslot, the  <b>ERROR_FILE_NOT_FOUND</b> error code will be set.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/creating-a-mailslot">Creating a Mailslot</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateMailslot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFile" />
    <seealso cref="GetMailslotInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/mailslot-functions">Mailslot Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/mailslots">Mailslots Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SetMailslotInfo" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.CreateMailslotA">
    <summary>
      <para>Creates a mailslot with the specified name and returns  a handle that a mailslot server can use to perform operations on the mailslot. The mailslot is local to the computer that creates it. An error occurs if a mailslot with the specified name already exists.</para>
    </summary>
    <param name="lpName">
      <para>The name of the mailslot. This name must have the following form:</para>
      <para>\\.\mailslot\[<i>path</i>]<i>name</i></para>
      <para>The name field must be unique. The name may include multiple levels of pseudo directories separated by backslashes. For example, both \\.\mailslot\example_mailslot_name and \\.\mailslot\abc\def\ghi are valid names.</para>
    </param>
    <param name="nMaxMessageSize">
      <para>The maximum size of a single message that can be written to the mailslot, in bytes. To specify that the message can be of any size, set this value to zero.</para>
    </param>
    <param name="lReadTimeout">
      <para>The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in milliseconds. The following values have special meanings.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>Returns immediately if no message is present. (The system does not treat an immediate return as an error.)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MAILSLOT_WAIT_FOREVER</b>
                </description>
              </item>
              <item>
                <description>((DWORD)-1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>Waits forever for a message.</para>
          </description>
        </item>
      </list>
      <para>This time-out value applies to all subsequent read operations and all inherited mailslot handles.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. The <b>bInheritHandle</b> member of the structure determines whether the returned handle can be inherited by child processes. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the mailslot, for use in server mailslot operations.  The handle returned by this function is asynchronous, or overlapped.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The mailslot exists until one of the following conditions is true:</para>
      <list type="bullet">
        <item>
          <description>The last (possibly inherited or duplicated) handle to it is closed using the
<see cref="CloseHandle" /> function.</description>
        </item>
        <item>
          <description>The process owning the last (possibly inherited or duplicated) handle exits.</description>
        </item>
      </list>
      <para>The system uses the second method to destroy mailslots.</para>
      <para>To write a message to a mailslot, a process uses the
<see cref="CreateFile" /> function, specifying the mailslot name by using one of the following formats.</para>
      <list type="table">
        <listheader>
          <description>Format</description>
          <description>Usage</description>
        </listheader>
        <item>
          <description>\\.\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to a local mailslot.</description>
        </item>
        <item>
          <description>\\<i>computername</i>\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to a remote mailslot.</description>
        </item>
        <item>
          <description>\\<i>domainname</i>\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to all mailslots with the specified name in the specified domain.</description>
        </item>
        <item>
          <description>\\*\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to all mailslots with the specified name in the system's primary domain.</description>
        </item>
      </list>
      <para>If <see cref="CreateFile" /> specifies a domain or uses the asterisk format to specify the system's primary domain, the application cannot write more than 424 bytes at a time to the mailslot. If the application attempts to do so, the <see cref="WriteFile" /> function fails and
<see cref="GetLastError" /> returns <b>ERROR_BAD_NETPATH</b>.</para>
      <para>An application must specify the <b>FILE_SHARE_READ</b> flag when using <see cref="CreateFile" /> to retrieve a client handle to a mailslot.</para>
      <para>If <see cref="CreateFile" /> is called to access a non-existent mailslot, the  <b>ERROR_FILE_NOT_FOUND</b> error code will be set.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/creating-a-mailslot">Creating a Mailslot</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateMailslot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFile" />
    <seealso cref="GetMailslotInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/mailslot-functions">Mailslot Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/mailslots">Mailslots Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SetMailslotInfo" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.CreateMailslotW">
    <summary>
      <para>Creates a mailslot with the specified name and returns  a handle that a mailslot server can use to perform operations on the mailslot. The mailslot is local to the computer that creates it. An error occurs if a mailslot with the specified name already exists.</para>
    </summary>
    <param name="lpName">
      <para>The name of the mailslot. This name must have the following form:</para>
      <para>\\.\mailslot\[<i>path</i>]<i>name</i></para>
      <para>The name field must be unique. The name may include multiple levels of pseudo directories separated by backslashes. For example, both \\.\mailslot\example_mailslot_name and \\.\mailslot\abc\def\ghi are valid names.</para>
    </param>
    <param name="nMaxMessageSize">
      <para>The maximum size of a single message that can be written to the mailslot, in bytes. To specify that the message can be of any size, set this value to zero.</para>
    </param>
    <param name="lReadTimeout">
      <para>The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in milliseconds. The following values have special meanings.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>Returns immediately if no message is present. (The system does not treat an immediate return as an error.)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MAILSLOT_WAIT_FOREVER</b>
                </description>
              </item>
              <item>
                <description>((DWORD)-1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>Waits forever for a message.</para>
          </description>
        </item>
      </list>
      <para>This time-out value applies to all subsequent read operations and all inherited mailslot handles.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. The <b>bInheritHandle</b> member of the structure determines whether the returned handle can be inherited by child processes. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the mailslot, for use in server mailslot operations.  The handle returned by this function is asynchronous, or overlapped.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The mailslot exists until one of the following conditions is true:</para>
      <list type="bullet">
        <item>
          <description>The last (possibly inherited or duplicated) handle to it is closed using the
<see cref="CloseHandle" /> function.</description>
        </item>
        <item>
          <description>The process owning the last (possibly inherited or duplicated) handle exits.</description>
        </item>
      </list>
      <para>The system uses the second method to destroy mailslots.</para>
      <para>To write a message to a mailslot, a process uses the
<see cref="CreateFile" /> function, specifying the mailslot name by using one of the following formats.</para>
      <list type="table">
        <listheader>
          <description>Format</description>
          <description>Usage</description>
        </listheader>
        <item>
          <description>\\.\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to a local mailslot.</description>
        </item>
        <item>
          <description>\\<i>computername</i>\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to a remote mailslot.</description>
        </item>
        <item>
          <description>\\<i>domainname</i>\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to all mailslots with the specified name in the specified domain.</description>
        </item>
        <item>
          <description>\\*\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to all mailslots with the specified name in the system's primary domain.</description>
        </item>
      </list>
      <para>If <see cref="CreateFile" /> specifies a domain or uses the asterisk format to specify the system's primary domain, the application cannot write more than 424 bytes at a time to the mailslot. If the application attempts to do so, the <see cref="WriteFile" /> function fails and
<see cref="GetLastError" /> returns <b>ERROR_BAD_NETPATH</b>.</para>
      <para>An application must specify the <b>FILE_SHARE_READ</b> flag when using <see cref="CreateFile" /> to retrieve a client handle to a mailslot.</para>
      <para>If <see cref="CreateFile" /> is called to access a non-existent mailslot, the  <b>ERROR_FILE_NOT_FOUND</b> error code will be set.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/creating-a-mailslot">Creating a Mailslot</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateMailslot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFile" />
    <seealso cref="GetMailslotInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/mailslot-functions">Mailslot Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/mailslots">Mailslots Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SetMailslotInfo" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.CreateMailslot">
    <summary>
      <para>Creates a mailslot with the specified name and returns  a handle that a mailslot server can use to perform operations on the mailslot. The mailslot is local to the computer that creates it. An error occurs if a mailslot with the specified name already exists.</para>
    </summary>
    <param name="lpName">
      <para>The name of the mailslot. This name must have the following form:</para>
      <para>\\.\mailslot\[<i>path</i>]<i>name</i></para>
      <para>The name field must be unique. The name may include multiple levels of pseudo directories separated by backslashes. For example, both \\.\mailslot\example_mailslot_name and \\.\mailslot\abc\def\ghi are valid names.</para>
    </param>
    <param name="nMaxMessageSize">
      <para>The maximum size of a single message that can be written to the mailslot, in bytes. To specify that the message can be of any size, set this value to zero.</para>
    </param>
    <param name="lReadTimeout">
      <para>The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in milliseconds. The following values have special meanings.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>Returns immediately if no message is present. (The system does not treat an immediate return as an error.)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MAILSLOT_WAIT_FOREVER</b>
                </description>
              </item>
              <item>
                <description>((DWORD)-1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>Waits forever for a message.</para>
          </description>
        </item>
      </list>
      <para>This time-out value applies to all subsequent read operations and all inherited mailslot handles.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. The <b>bInheritHandle</b> member of the structure determines whether the returned handle can be inherited by child processes. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the mailslot, for use in server mailslot operations.  The handle returned by this function is asynchronous, or overlapped.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The mailslot exists until one of the following conditions is true:</para>
      <list type="bullet">
        <item>
          <description>The last (possibly inherited or duplicated) handle to it is closed using the
<see cref="CloseHandle" /> function.</description>
        </item>
        <item>
          <description>The process owning the last (possibly inherited or duplicated) handle exits.</description>
        </item>
      </list>
      <para>The system uses the second method to destroy mailslots.</para>
      <para>To write a message to a mailslot, a process uses the
<see cref="CreateFile" /> function, specifying the mailslot name by using one of the following formats.</para>
      <list type="table">
        <listheader>
          <description>Format</description>
          <description>Usage</description>
        </listheader>
        <item>
          <description>\\.\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to a local mailslot.</description>
        </item>
        <item>
          <description>\\<i>computername</i>\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to a remote mailslot.</description>
        </item>
        <item>
          <description>\\<i>domainname</i>\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to all mailslots with the specified name in the specified domain.</description>
        </item>
        <item>
          <description>\\*\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to all mailslots with the specified name in the system's primary domain.</description>
        </item>
      </list>
      <para>If <see cref="CreateFile" /> specifies a domain or uses the asterisk format to specify the system's primary domain, the application cannot write more than 424 bytes at a time to the mailslot. If the application attempts to do so, the <see cref="WriteFile" /> function fails and
<see cref="GetLastError" /> returns <b>ERROR_BAD_NETPATH</b>.</para>
      <para>An application must specify the <b>FILE_SHARE_READ</b> flag when using <see cref="CreateFile" /> to retrieve a client handle to a mailslot.</para>
      <para>If <see cref="CreateFile" /> is called to access a non-existent mailslot, the  <b>ERROR_FILE_NOT_FOUND</b> error code will be set.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/creating-a-mailslot">Creating a Mailslot</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateMailslot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFile" />
    <seealso cref="GetMailslotInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/mailslot-functions">Mailslot Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/mailslots">Mailslots Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SetMailslotInfo" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.CreateMailslotA">
    <summary>
      <para>Creates a mailslot with the specified name and returns  a handle that a mailslot server can use to perform operations on the mailslot. The mailslot is local to the computer that creates it. An error occurs if a mailslot with the specified name already exists.</para>
    </summary>
    <param name="lpName">
      <para>The name of the mailslot. This name must have the following form:</para>
      <para>\\.\mailslot\[<i>path</i>]<i>name</i></para>
      <para>The name field must be unique. The name may include multiple levels of pseudo directories separated by backslashes. For example, both \\.\mailslot\example_mailslot_name and \\.\mailslot\abc\def\ghi are valid names.</para>
    </param>
    <param name="nMaxMessageSize">
      <para>The maximum size of a single message that can be written to the mailslot, in bytes. To specify that the message can be of any size, set this value to zero.</para>
    </param>
    <param name="lReadTimeout">
      <para>The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in milliseconds. The following values have special meanings.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>Returns immediately if no message is present. (The system does not treat an immediate return as an error.)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MAILSLOT_WAIT_FOREVER</b>
                </description>
              </item>
              <item>
                <description>((DWORD)-1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>Waits forever for a message.</para>
          </description>
        </item>
      </list>
      <para>This time-out value applies to all subsequent read operations and all inherited mailslot handles.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. The <b>bInheritHandle</b> member of the structure determines whether the returned handle can be inherited by child processes. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the mailslot, for use in server mailslot operations.  The handle returned by this function is asynchronous, or overlapped.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The mailslot exists until one of the following conditions is true:</para>
      <list type="bullet">
        <item>
          <description>The last (possibly inherited or duplicated) handle to it is closed using the
<see cref="CloseHandle" /> function.</description>
        </item>
        <item>
          <description>The process owning the last (possibly inherited or duplicated) handle exits.</description>
        </item>
      </list>
      <para>The system uses the second method to destroy mailslots.</para>
      <para>To write a message to a mailslot, a process uses the
<see cref="CreateFile" /> function, specifying the mailslot name by using one of the following formats.</para>
      <list type="table">
        <listheader>
          <description>Format</description>
          <description>Usage</description>
        </listheader>
        <item>
          <description>\\.\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to a local mailslot.</description>
        </item>
        <item>
          <description>\\<i>computername</i>\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to a remote mailslot.</description>
        </item>
        <item>
          <description>\\<i>domainname</i>\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to all mailslots with the specified name in the specified domain.</description>
        </item>
        <item>
          <description>\\*\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to all mailslots with the specified name in the system's primary domain.</description>
        </item>
      </list>
      <para>If <see cref="CreateFile" /> specifies a domain or uses the asterisk format to specify the system's primary domain, the application cannot write more than 424 bytes at a time to the mailslot. If the application attempts to do so, the <see cref="WriteFile" /> function fails and
<see cref="GetLastError" /> returns <b>ERROR_BAD_NETPATH</b>.</para>
      <para>An application must specify the <b>FILE_SHARE_READ</b> flag when using <see cref="CreateFile" /> to retrieve a client handle to a mailslot.</para>
      <para>If <see cref="CreateFile" /> is called to access a non-existent mailslot, the  <b>ERROR_FILE_NOT_FOUND</b> error code will be set.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/creating-a-mailslot">Creating a Mailslot</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateMailslot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFile" />
    <seealso cref="GetMailslotInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/mailslot-functions">Mailslot Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/mailslots">Mailslots Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SetMailslotInfo" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.CreateMailslotW">
    <summary>
      <para>Creates a mailslot with the specified name and returns  a handle that a mailslot server can use to perform operations on the mailslot. The mailslot is local to the computer that creates it. An error occurs if a mailslot with the specified name already exists.</para>
    </summary>
    <param name="lpName">
      <para>The name of the mailslot. This name must have the following form:</para>
      <para>\\.\mailslot\[<i>path</i>]<i>name</i></para>
      <para>The name field must be unique. The name may include multiple levels of pseudo directories separated by backslashes. For example, both \\.\mailslot\example_mailslot_name and \\.\mailslot\abc\def\ghi are valid names.</para>
    </param>
    <param name="nMaxMessageSize">
      <para>The maximum size of a single message that can be written to the mailslot, in bytes. To specify that the message can be of any size, set this value to zero.</para>
    </param>
    <param name="lReadTimeout">
      <para>The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in milliseconds. The following values have special meanings.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>Returns immediately if no message is present. (The system does not treat an immediate return as an error.)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MAILSLOT_WAIT_FOREVER</b>
                </description>
              </item>
              <item>
                <description>((DWORD)-1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>Waits forever for a message.</para>
          </description>
        </item>
      </list>
      <para>This time-out value applies to all subsequent read operations and all inherited mailslot handles.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. The <b>bInheritHandle</b> member of the structure determines whether the returned handle can be inherited by child processes. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the mailslot, for use in server mailslot operations.  The handle returned by this function is asynchronous, or overlapped.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The mailslot exists until one of the following conditions is true:</para>
      <list type="bullet">
        <item>
          <description>The last (possibly inherited or duplicated) handle to it is closed using the
<see cref="CloseHandle" /> function.</description>
        </item>
        <item>
          <description>The process owning the last (possibly inherited or duplicated) handle exits.</description>
        </item>
      </list>
      <para>The system uses the second method to destroy mailslots.</para>
      <para>To write a message to a mailslot, a process uses the
<see cref="CreateFile" /> function, specifying the mailslot name by using one of the following formats.</para>
      <list type="table">
        <listheader>
          <description>Format</description>
          <description>Usage</description>
        </listheader>
        <item>
          <description>\\.\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to a local mailslot.</description>
        </item>
        <item>
          <description>\\<i>computername</i>\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to a remote mailslot.</description>
        </item>
        <item>
          <description>\\<i>domainname</i>\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to all mailslots with the specified name in the specified domain.</description>
        </item>
        <item>
          <description>\\*\mailslot\<i>name</i></description>
          <description>Retrieves a client handle to all mailslots with the specified name in the system's primary domain.</description>
        </item>
      </list>
      <para>If <see cref="CreateFile" /> specifies a domain or uses the asterisk format to specify the system's primary domain, the application cannot write more than 424 bytes at a time to the mailslot. If the application attempts to do so, the <see cref="WriteFile" /> function fails and
<see cref="GetLastError" /> returns <b>ERROR_BAD_NETPATH</b>.</para>
      <para>An application must specify the <b>FILE_SHARE_READ</b> flag when using <see cref="CreateFile" /> to retrieve a client handle to a mailslot.</para>
      <para>If <see cref="CreateFile" /> is called to access a non-existent mailslot, the  <b>ERROR_FILE_NOT_FOUND</b> error code will be set.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/creating-a-mailslot">Creating a Mailslot</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateMailslot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFile" />
    <seealso cref="GetMailslotInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/mailslot-functions">Mailslot Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/mailslots">Mailslots Overview</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="SetMailslotInfo" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.CreateNamedPipe">
    <summary>
      <para>Creates an instance of a named pipe and returns a handle for subsequent pipe operations. A named pipe server process uses this function either to create the first instance of a specific named pipe and establish its basic attributes or to create a new instance of an existing named pipe.</para>
    </summary>
    <param name="lpName">
      <para>The unique pipe name. This string must have the following form:</para>
      <para>\\.\pipe\<i>pipename</i></para>
      <para>The pipename part of the name can include any character other than a backslash, including numbers and special characters. The entire pipe name string can be up to 256 characters long. Pipe names are not case sensitive.</para>
    </param>
    <param name="dwOpenMode">
      <para>The open mode.</para>
      <para>The function fails if <i>dwOpenMode</i> specifies anything other than 0 or the flags listed in the following tables.</para>
      <para>This parameter must specify one of the following pipe access modes. The same mode must be specified for each instance of the pipe.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_ACCESS_DUPLEX</b>
                </description>
              </item>
              <item>
                <description>0x00000003</description>
              </item>
            </list>
          </description>
          <description>
            <para>The pipe is bi-directional; both server and client processes can read from and write to the pipe. This mode gives the server the equivalent of <b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access to the pipe. The client can specify <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b>, or both, when it connects to the pipe using the
<see cref="CreateFile" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_ACCESS_INBOUND</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The flow of data in the pipe goes from client to server only. This mode gives the server the equivalent of <b>GENERIC_READ</b> access to the pipe. The client must specify <b>GENERIC_WRITE</b> access when connecting to the pipe. If the client must read pipe settings by calling the <see cref="GetNamedPipeInfo" /> or <see cref="GetNamedPipeHandleState" /> functions, the client must specify <b>GENERIC_WRITE</b> and <b>FILE_READ_ATTRIBUTES</b> access when connecting to the pipe.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_ACCESS_OUTBOUND</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The flow of data in the pipe goes from server to client only. This mode gives the server the equivalent of <b>GENERIC_WRITE</b> access to the pipe. The client must specify <b>GENERIC_READ</b> access when connecting to the pipe. If the client must change pipe settings by calling the <see cref="SetNamedPipeHandleState" /> function, the client must specify <b>GENERIC_READ</b> and <b>FILE_WRITE_ATTRIBUTES</b> access when connecting to the pipe.</para>
          </description>
        </item>
      </list>
      <para>This parameter can also include one or more of the following flags, which enable the write-through and overlapped modes. These modes can be different for different instances of the same pipe.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_FIRST_PIPE_INSTANCE</b>
                </description>
              </item>
              <item>
                <description>0x00080000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If you attempt to create multiple instances of a pipe with this flag, creation of the first instance succeeds, but creation of the next instance fails with <b>ERROR_ACCESS_DENIED</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_WRITE_THROUGH</b>
                </description>
              </item>
              <item>
                <description>0x80000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Write-through mode is enabled. This mode affects only write operations on byte-type pipes and, then, only when the client and server processes are on different computers. If this mode is enabled, functions writing to a named pipe do not return until the data written is transmitted across the network and is in the pipe's buffer on the remote computer. If this mode is not enabled, the system enhances the efficiency of network operations by buffering data until a minimum number of bytes accumulate or until a maximum time elapses.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_OVERLAPPED</b>
                </description>
              </item>
              <item>
                <description>0x40000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Overlapped mode is enabled. If this mode is enabled, functions performing read, write, and connect operations that may take a significant time to be completed can return immediately. This mode enables the thread that started the operation to perform other operations while the time-consuming operation executes in the background. For example, in overlapped mode, a thread can handle simultaneous input and output (I/O) operations on multiple instances of a pipe or perform simultaneous read and write operations on the same pipe handle. If overlapped mode is not enabled, functions performing read, write, and connect operations on the pipe handle do not return until the operation is finished. The
<see cref="ReadFileEx" /> and
<see cref="WriteFileEx" /> functions can only be used with a pipe handle in overlapped mode. The
<see cref="ReadFile" />,
<see cref="WriteFile" />,
<see cref="ConnectNamedPipe" />, and
<see cref="TransactNamedPipe" /> functions can execute either synchronously or as overlapped operations.</para>
          </description>
        </item>
      </list>
      <para>This parameter can include any combination of the following security access modes. These modes can be different for different instances of the same pipe.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WRITE_DAC</b>
                </description>
              </item>
              <item>
                <description>0x00040000L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The caller will have write access to the named pipe's discretionary access control list (ACL).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WRITE_OWNER</b>
                </description>
              </item>
              <item>
                <description>0x00080000L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The caller will have write access to the named pipe's owner.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ACCESS_SYSTEM_SECURITY</b>
                </description>
              </item>
              <item>
                <description>0x01000000L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The caller will have write access to the named pipe's SACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control-lists">Access-Control Lists (ACLs)</a> and
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/sacl-access-right">SACL Access Right</a>.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwPipeMode">
      <para>The pipe mode.</para>
      <para>The function fails if <i>dwPipeMode</i> specifies anything other than 0 or the flags listed in the following tables.</para>
      <para>One of the following type modes can be specified. The same type mode must be specified for each instance of the pipe.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_TYPE_BYTE</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Data is written to the pipe as a stream of bytes. This mode cannot be used with PIPE_READMODE_MESSAGE. The pipe does not distinguish bytes written during different write operations.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_TYPE_MESSAGE</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Data is written to the pipe as a stream of messages. The pipe treats the bytes written during each write operation as a message unit. The <see cref="GetLastError" /> function returns <b>ERROR_MORE_DATA</b> when a message is not read completely. This mode can be used with either <b>PIPE_READMODE_MESSAGE</b> or <b>PIPE_READMODE_BYTE</b>.</para>
          </description>
        </item>
      </list>
      <para>One of the following read modes can be specified. Different instances of the same pipe can specify different read modes.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_READMODE_BYTE</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Data is read from the pipe as a stream of bytes. This mode can be used with either <b>PIPE_TYPE_MESSAGE</b> or <b>PIPE_TYPE_BYTE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_READMODE_MESSAGE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Data is read from the pipe as a stream of messages. This mode can be only used if <b>PIPE_TYPE_MESSAGE</b> is also specified.</para>
          </description>
        </item>
      </list>
      <para>One of the following wait modes can be specified. Different instances of the same pipe can specify different wait modes.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_WAIT</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Blocking mode is enabled. When the pipe handle is specified in the
<see cref="ReadFile" />,
<see cref="WriteFile" />, or
<see cref="ConnectNamedPipe" /> function, the operations are not completed until there is data to read, all data is written, or a client is connected. Use of this mode can mean waiting indefinitely in some situations for a client process to perform an action.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_NOWAIT</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Nonblocking mode is enabled. In this mode, <see cref="ReadFile" />, <see cref="WriteFile" />, and
<see cref="ConnectNamedPipe" /> always return immediately.</para>
            <para>Note that nonblocking mode is supported for compatibility with Microsoft LAN Manager version 2.0 and should not be used to achieve asynchronous I/O with named pipes. For more information on asynchronous pipe I/O, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/synchronous-and-overlapped-input-and-output">Synchronous and Overlapped Input and Output</a>.</para>
          </description>
        </item>
      </list>
      <para>One of the following remote-client modes can be specified. Different instances of the same pipe can specify different remote-client modes.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_ACCEPT_REMOTE_CLIENTS</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Connections from remote clients can be accepted and checked against the security descriptor for the pipe.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_REJECT_REMOTE_CLIENTS</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Connections from remote clients are automatically rejected.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="nMaxInstances">
      <para>The maximum number of instances that can be created for this pipe. The first instance of the pipe can specify this value; the same number must be specified for other instances of the pipe. Acceptable values are in the range 1 through <b>PIPE_UNLIMITED_INSTANCES</b> (255).</para>
      <para>If this parameter is <b>PIPE_UNLIMITED_INSTANCES</b>, the number of pipe instances that can be created is limited only by the availability of system resources. If <i>nMaxInstances</i> is greater than <b>PIPE_UNLIMITED_INSTANCES</b>, the return value is <b>INVALID_HANDLE_VALUE</b> and <see cref="GetLastError" /> returns <b>ERROR_INVALID_PARAMETER</b>.</para>
    </param>
    <param name="nOutBufferSize">
      <para>The number of bytes to reserve for the output buffer. For a discussion on sizing named pipe buffers, see the following Remarks section.</para>
    </param>
    <param name="nInBufferSize">
      <para>The number of bytes to reserve for the input buffer. For a discussion on sizing named pipe buffers, see the following Remarks section.</para>
    </param>
    <param name="nDefaultTimeOut">
      <para>The default time-out value, in milliseconds, if the
<see cref="WaitNamedPipe" /> function specifies <b>NMPWAIT_USE_DEFAULT_WAIT</b>. Each instance of a named pipe must specify the same value.</para>
      <para>A value of zero will result in a default time-out of 50 milliseconds.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new named pipe and determines whether child processes can inherit the returned handle. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the named pipe gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a named pipe grant full control to the LocalSystem account, administrators, and the creator owner. They also grant read access to members of the Everyone group and the anonymous account.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the server end of a named pipe instance.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To create an instance of a named pipe by using
<b>CreateNamedPipe</b>, the user must have <b>FILE_CREATE_PIPE_INSTANCE</b> access to the named pipe object. If a new named pipe is being created, the access control list (ACL) from the security attributes parameter defines the discretionary access control for the named pipe.</para>
      <para>All instances of a named pipe must specify the same pipe type (byte-type or message-type), pipe access (duplex, inbound, or outbound), instance count, and time-out value. If different values are used, this function fails and <see cref="GetLastError" /> returns <b>ERROR_ACCESS_DENIED</b>.</para>
      <para>A client process connects to a named pipe by using the <see cref="CreateFile" /> or <see cref="CallNamedPipe" /> function. The client side of a named pipe starts out in byte mode, even if the server side is in message mode. To avoid problems receiving data, set the client side to message mode as well. To change the mode of the pipe, the pipe client must open a read-only pipe with <b>GENERIC_READ</b> and  <b>FILE_WRITE_ATTRIBUTES</b> access.</para>
      <para>The pipe server should not perform a blocking read operation until the pipe client has started. Otherwise, a race condition can occur. This typically occurs when initialization code, such as the C run-time, needs to lock and examine inherited handles.</para>
      <para>Every time a named pipe is created, the system creates the inbound and/or outbound buffers using nonpaged pool, which is the physical memory used by the kernel. The number of pipe instances (as well as objects such as threads and processes) that you can create is limited by the available nonpaged pool. Each read or write request requires space in the buffer for the read or write data, plus additional space for the internal data structures.</para>
      <para>The input and output buffer sizes are advisory. The actual buffer size reserved for each end of the named pipe is either the system default, the system minimum or maximum, or the specified size rounded up to the next allocation boundary. The buffer size specified should be small enough that your process will not run out of nonpaged pool, but large enough to accommodate typical requests.</para>
      <para>Whenever a pipe write operation occurs, the system first tries to charge the memory against the pipe write quota. If the remaining pipe write quota is enough to fulfill the request, the write operation completes immediately. If the remaining pipe write quota is too small to fulfill the request, the system will try to expand the buffers to accommodate the data using nonpaged pool reserved for the process. The write operation will block until the data is read from the pipe so that the additional buffer quota can be released. Therefore, if your specified buffer size is too small, the system will grow the buffer as needed, but the downside is that the operation will block. If the operation is overlapped, a system thread is blocked; otherwise, the application thread is blocked.</para>
      <para>To free resources used by a named pipe, the application should always close handles when they are no longer needed, which is accomplished either by calling the <see cref="CloseHandle" /> function or when the process associated with the instance handles ends. Note that an instance of a named pipe may have more than one handle associated with it. An instance of a named pipe is always deleted when the last handle to the instance of the named pipe is closed.</para>
      <para>
        <b>Windows 10, version 1709:  </b>Pipes are only supported within an app-container; ie, from one UWP process to another UWP process that's part of the same app. Also, named pipes must use the syntax "\.\pipe\LOCAL" for the pipe name.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/multithreaded-pipe-server">Multithreaded Pipe Server</a>.</para>
    </remarks>
    <seealso cref="ConnectNamedPipe" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipe-functions">Pipe Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipes">Pipes Overview</seealso>
    <seealso cref="ReadFile" />
    <seealso cref="ReadFileEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="TransactNamedPipe" />
    <seealso cref="WaitNamedPipe" />
    <seealso cref="WriteFile" />
    <seealso cref="WriteFileEx" />
  </member>
  <member name="Windows.CreateNamedPipeA">
    <summary>
      <para>Creates an instance of a named pipe and returns a handle for subsequent pipe operations. A named pipe server process uses this function either to create the first instance of a specific named pipe and establish its basic attributes or to create a new instance of an existing named pipe.</para>
    </summary>
    <param name="lpName">
      <para>The unique pipe name. This string must have the following form:</para>
      <para>\\.\pipe\<i>pipename</i></para>
      <para>The pipename part of the name can include any character other than a backslash, including numbers and special characters. The entire pipe name string can be up to 256 characters long. Pipe names are not case sensitive.</para>
    </param>
    <param name="dwOpenMode">
      <para>The open mode.</para>
      <para>The function fails if <i>dwOpenMode</i> specifies anything other than 0 or the flags listed in the following tables.</para>
      <para>This parameter must specify one of the following pipe access modes. The same mode must be specified for each instance of the pipe.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_ACCESS_DUPLEX</b>
                </description>
              </item>
              <item>
                <description>0x00000003</description>
              </item>
            </list>
          </description>
          <description>
            <para>The pipe is bi-directional; both server and client processes can read from and write to the pipe. This mode gives the server the equivalent of <b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access to the pipe. The client can specify <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b>, or both, when it connects to the pipe using the
<see cref="CreateFile" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_ACCESS_INBOUND</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The flow of data in the pipe goes from client to server only. This mode gives the server the equivalent of <b>GENERIC_READ</b> access to the pipe. The client must specify <b>GENERIC_WRITE</b> access when connecting to the pipe. If the client must read pipe settings by calling the <see cref="GetNamedPipeInfo" /> or <see cref="GetNamedPipeHandleState" /> functions, the client must specify <b>GENERIC_WRITE</b> and <b>FILE_READ_ATTRIBUTES</b> access when connecting to the pipe.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_ACCESS_OUTBOUND</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The flow of data in the pipe goes from server to client only. This mode gives the server the equivalent of <b>GENERIC_WRITE</b> access to the pipe. The client must specify <b>GENERIC_READ</b> access when connecting to the pipe. If the client must change pipe settings by calling the <see cref="SetNamedPipeHandleState" /> function, the client must specify <b>GENERIC_READ</b> and <b>FILE_WRITE_ATTRIBUTES</b> access when connecting to the pipe.</para>
          </description>
        </item>
      </list>
      <para>This parameter can also include one or more of the following flags, which enable the write-through and overlapped modes. These modes can be different for different instances of the same pipe.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_FIRST_PIPE_INSTANCE</b>
                </description>
              </item>
              <item>
                <description>0x00080000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If you attempt to create multiple instances of a pipe with this flag, creation of the first instance succeeds, but creation of the next instance fails with <b>ERROR_ACCESS_DENIED</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_WRITE_THROUGH</b>
                </description>
              </item>
              <item>
                <description>0x80000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Write-through mode is enabled. This mode affects only write operations on byte-type pipes and, then, only when the client and server processes are on different computers. If this mode is enabled, functions writing to a named pipe do not return until the data written is transmitted across the network and is in the pipe's buffer on the remote computer. If this mode is not enabled, the system enhances the efficiency of network operations by buffering data until a minimum number of bytes accumulate or until a maximum time elapses.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_OVERLAPPED</b>
                </description>
              </item>
              <item>
                <description>0x40000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Overlapped mode is enabled. If this mode is enabled, functions performing read, write, and connect operations that may take a significant time to be completed can return immediately. This mode enables the thread that started the operation to perform other operations while the time-consuming operation executes in the background. For example, in overlapped mode, a thread can handle simultaneous input and output (I/O) operations on multiple instances of a pipe or perform simultaneous read and write operations on the same pipe handle. If overlapped mode is not enabled, functions performing read, write, and connect operations on the pipe handle do not return until the operation is finished. The
<see cref="ReadFileEx" /> and
<see cref="WriteFileEx" /> functions can only be used with a pipe handle in overlapped mode. The
<see cref="ReadFile" />,
<see cref="WriteFile" />,
<see cref="ConnectNamedPipe" />, and
<see cref="TransactNamedPipe" /> functions can execute either synchronously or as overlapped operations.</para>
          </description>
        </item>
      </list>
      <para>This parameter can include any combination of the following security access modes. These modes can be different for different instances of the same pipe.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WRITE_DAC</b>
                </description>
              </item>
              <item>
                <description>0x00040000L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The caller will have write access to the named pipe's discretionary access control list (ACL).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WRITE_OWNER</b>
                </description>
              </item>
              <item>
                <description>0x00080000L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The caller will have write access to the named pipe's owner.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ACCESS_SYSTEM_SECURITY</b>
                </description>
              </item>
              <item>
                <description>0x01000000L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The caller will have write access to the named pipe's SACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control-lists">Access-Control Lists (ACLs)</a> and
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/sacl-access-right">SACL Access Right</a>.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwPipeMode">
      <para>The pipe mode.</para>
      <para>The function fails if <i>dwPipeMode</i> specifies anything other than 0 or the flags listed in the following tables.</para>
      <para>One of the following type modes can be specified. The same type mode must be specified for each instance of the pipe.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_TYPE_BYTE</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Data is written to the pipe as a stream of bytes. This mode cannot be used with PIPE_READMODE_MESSAGE. The pipe does not distinguish bytes written during different write operations.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_TYPE_MESSAGE</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Data is written to the pipe as a stream of messages. The pipe treats the bytes written during each write operation as a message unit. The <see cref="GetLastError" /> function returns <b>ERROR_MORE_DATA</b> when a message is not read completely. This mode can be used with either <b>PIPE_READMODE_MESSAGE</b> or <b>PIPE_READMODE_BYTE</b>.</para>
          </description>
        </item>
      </list>
      <para>One of the following read modes can be specified. Different instances of the same pipe can specify different read modes.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_READMODE_BYTE</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Data is read from the pipe as a stream of bytes. This mode can be used with either <b>PIPE_TYPE_MESSAGE</b> or <b>PIPE_TYPE_BYTE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_READMODE_MESSAGE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Data is read from the pipe as a stream of messages. This mode can be only used if <b>PIPE_TYPE_MESSAGE</b> is also specified.</para>
          </description>
        </item>
      </list>
      <para>One of the following wait modes can be specified. Different instances of the same pipe can specify different wait modes.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_WAIT</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Blocking mode is enabled. When the pipe handle is specified in the
<see cref="ReadFile" />,
<see cref="WriteFile" />, or
<see cref="ConnectNamedPipe" /> function, the operations are not completed until there is data to read, all data is written, or a client is connected. Use of this mode can mean waiting indefinitely in some situations for a client process to perform an action.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_NOWAIT</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Nonblocking mode is enabled. In this mode, <see cref="ReadFile" />, <see cref="WriteFile" />, and
<see cref="ConnectNamedPipe" /> always return immediately.</para>
            <para>Note that nonblocking mode is supported for compatibility with Microsoft LAN Manager version 2.0 and should not be used to achieve asynchronous I/O with named pipes. For more information on asynchronous pipe I/O, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/synchronous-and-overlapped-input-and-output">Synchronous and Overlapped Input and Output</a>.</para>
          </description>
        </item>
      </list>
      <para>One of the following remote-client modes can be specified. Different instances of the same pipe can specify different remote-client modes.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_ACCEPT_REMOTE_CLIENTS</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Connections from remote clients can be accepted and checked against the security descriptor for the pipe.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_REJECT_REMOTE_CLIENTS</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Connections from remote clients are automatically rejected.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="nMaxInstances">
      <para>The maximum number of instances that can be created for this pipe. The first instance of the pipe can specify this value; the same number must be specified for other instances of the pipe. Acceptable values are in the range 1 through <b>PIPE_UNLIMITED_INSTANCES</b> (255).</para>
      <para>If this parameter is <b>PIPE_UNLIMITED_INSTANCES</b>, the number of pipe instances that can be created is limited only by the availability of system resources. If <i>nMaxInstances</i> is greater than <b>PIPE_UNLIMITED_INSTANCES</b>, the return value is <b>INVALID_HANDLE_VALUE</b> and <see cref="GetLastError" /> returns <b>ERROR_INVALID_PARAMETER</b>.</para>
    </param>
    <param name="nOutBufferSize">
      <para>The number of bytes to reserve for the output buffer. For a discussion on sizing named pipe buffers, see the following Remarks section.</para>
    </param>
    <param name="nInBufferSize">
      <para>The number of bytes to reserve for the input buffer. For a discussion on sizing named pipe buffers, see the following Remarks section.</para>
    </param>
    <param name="nDefaultTimeOut">
      <para>The default time-out value, in milliseconds, if the
<see cref="WaitNamedPipe" /> function specifies <b>NMPWAIT_USE_DEFAULT_WAIT</b>. Each instance of a named pipe must specify the same value.</para>
      <para>A value of zero will result in a default time-out of 50 milliseconds.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new named pipe and determines whether child processes can inherit the returned handle. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the named pipe gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a named pipe grant full control to the LocalSystem account, administrators, and the creator owner. They also grant read access to members of the Everyone group and the anonymous account.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the server end of a named pipe instance.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To create an instance of a named pipe by using
<b>CreateNamedPipe</b>, the user must have <b>FILE_CREATE_PIPE_INSTANCE</b> access to the named pipe object. If a new named pipe is being created, the access control list (ACL) from the security attributes parameter defines the discretionary access control for the named pipe.</para>
      <para>All instances of a named pipe must specify the same pipe type (byte-type or message-type), pipe access (duplex, inbound, or outbound), instance count, and time-out value. If different values are used, this function fails and <see cref="GetLastError" /> returns <b>ERROR_ACCESS_DENIED</b>.</para>
      <para>A client process connects to a named pipe by using the <see cref="CreateFile" /> or <see cref="CallNamedPipe" /> function. The client side of a named pipe starts out in byte mode, even if the server side is in message mode. To avoid problems receiving data, set the client side to message mode as well. To change the mode of the pipe, the pipe client must open a read-only pipe with <b>GENERIC_READ</b> and  <b>FILE_WRITE_ATTRIBUTES</b> access.</para>
      <para>The pipe server should not perform a blocking read operation until the pipe client has started. Otherwise, a race condition can occur. This typically occurs when initialization code, such as the C run-time, needs to lock and examine inherited handles.</para>
      <para>Every time a named pipe is created, the system creates the inbound and/or outbound buffers using nonpaged pool, which is the physical memory used by the kernel. The number of pipe instances (as well as objects such as threads and processes) that you can create is limited by the available nonpaged pool. Each read or write request requires space in the buffer for the read or write data, plus additional space for the internal data structures.</para>
      <para>The input and output buffer sizes are advisory. The actual buffer size reserved for each end of the named pipe is either the system default, the system minimum or maximum, or the specified size rounded up to the next allocation boundary. The buffer size specified should be small enough that your process will not run out of nonpaged pool, but large enough to accommodate typical requests.</para>
      <para>Whenever a pipe write operation occurs, the system first tries to charge the memory against the pipe write quota. If the remaining pipe write quota is enough to fulfill the request, the write operation completes immediately. If the remaining pipe write quota is too small to fulfill the request, the system will try to expand the buffers to accommodate the data using nonpaged pool reserved for the process. The write operation will block until the data is read from the pipe so that the additional buffer quota can be released. Therefore, if your specified buffer size is too small, the system will grow the buffer as needed, but the downside is that the operation will block. If the operation is overlapped, a system thread is blocked; otherwise, the application thread is blocked.</para>
      <para>To free resources used by a named pipe, the application should always close handles when they are no longer needed, which is accomplished either by calling the <see cref="CloseHandle" /> function or when the process associated with the instance handles ends. Note that an instance of a named pipe may have more than one handle associated with it. An instance of a named pipe is always deleted when the last handle to the instance of the named pipe is closed.</para>
      <para>
        <b>Windows 10, version 1709:  </b>Pipes are only supported within an app-container; ie, from one UWP process to another UWP process that's part of the same app. Also, named pipes must use the syntax "\.\pipe\LOCAL" for the pipe name.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/multithreaded-pipe-server">Multithreaded Pipe Server</a>.</para>
    </remarks>
    <seealso cref="ConnectNamedPipe" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipe-functions">Pipe Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipes">Pipes Overview</seealso>
    <seealso cref="ReadFile" />
    <seealso cref="ReadFileEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="TransactNamedPipe" />
    <seealso cref="WaitNamedPipe" />
    <seealso cref="WriteFile" />
    <seealso cref="WriteFileEx" />
  </member>
  <member name="Windows.CreateNamedPipeW">
    <summary>
      <para>Creates an instance of a named pipe and returns a handle for subsequent pipe operations. A named pipe server process uses this function either to create the first instance of a specific named pipe and establish its basic attributes or to create a new instance of an existing named pipe.</para>
    </summary>
    <param name="lpName">
      <para>The unique pipe name. This string must have the following form:</para>
      <para>\\.\pipe\<i>pipename</i></para>
      <para>The pipename part of the name can include any character other than a backslash, including numbers and special characters. The entire pipe name string can be up to 256 characters long. Pipe names are not case sensitive.</para>
    </param>
    <param name="dwOpenMode">
      <para>The open mode.</para>
      <para>The function fails if <i>dwOpenMode</i> specifies anything other than 0 or the flags listed in the following tables.</para>
      <para>This parameter must specify one of the following pipe access modes. The same mode must be specified for each instance of the pipe.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_ACCESS_DUPLEX</b>
                </description>
              </item>
              <item>
                <description>0x00000003</description>
              </item>
            </list>
          </description>
          <description>
            <para>The pipe is bi-directional; both server and client processes can read from and write to the pipe. This mode gives the server the equivalent of <b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access to the pipe. The client can specify <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b>, or both, when it connects to the pipe using the
<see cref="CreateFile" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_ACCESS_INBOUND</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The flow of data in the pipe goes from client to server only. This mode gives the server the equivalent of <b>GENERIC_READ</b> access to the pipe. The client must specify <b>GENERIC_WRITE</b> access when connecting to the pipe. If the client must read pipe settings by calling the <see cref="GetNamedPipeInfo" /> or <see cref="GetNamedPipeHandleState" /> functions, the client must specify <b>GENERIC_WRITE</b> and <b>FILE_READ_ATTRIBUTES</b> access when connecting to the pipe.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_ACCESS_OUTBOUND</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The flow of data in the pipe goes from server to client only. This mode gives the server the equivalent of <b>GENERIC_WRITE</b> access to the pipe. The client must specify <b>GENERIC_READ</b> access when connecting to the pipe. If the client must change pipe settings by calling the <see cref="SetNamedPipeHandleState" /> function, the client must specify <b>GENERIC_READ</b> and <b>FILE_WRITE_ATTRIBUTES</b> access when connecting to the pipe.</para>
          </description>
        </item>
      </list>
      <para>This parameter can also include one or more of the following flags, which enable the write-through and overlapped modes. These modes can be different for different instances of the same pipe.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_FIRST_PIPE_INSTANCE</b>
                </description>
              </item>
              <item>
                <description>0x00080000</description>
              </item>
            </list>
          </description>
          <description>
            <para>If you attempt to create multiple instances of a pipe with this flag, creation of the first instance succeeds, but creation of the next instance fails with <b>ERROR_ACCESS_DENIED</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_WRITE_THROUGH</b>
                </description>
              </item>
              <item>
                <description>0x80000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Write-through mode is enabled. This mode affects only write operations on byte-type pipes and, then, only when the client and server processes are on different computers. If this mode is enabled, functions writing to a named pipe do not return until the data written is transmitted across the network and is in the pipe's buffer on the remote computer. If this mode is not enabled, the system enhances the efficiency of network operations by buffering data until a minimum number of bytes accumulate or until a maximum time elapses.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_OVERLAPPED</b>
                </description>
              </item>
              <item>
                <description>0x40000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Overlapped mode is enabled. If this mode is enabled, functions performing read, write, and connect operations that may take a significant time to be completed can return immediately. This mode enables the thread that started the operation to perform other operations while the time-consuming operation executes in the background. For example, in overlapped mode, a thread can handle simultaneous input and output (I/O) operations on multiple instances of a pipe or perform simultaneous read and write operations on the same pipe handle. If overlapped mode is not enabled, functions performing read, write, and connect operations on the pipe handle do not return until the operation is finished. The
<see cref="ReadFileEx" /> and
<see cref="WriteFileEx" /> functions can only be used with a pipe handle in overlapped mode. The
<see cref="ReadFile" />,
<see cref="WriteFile" />,
<see cref="ConnectNamedPipe" />, and
<see cref="TransactNamedPipe" /> functions can execute either synchronously or as overlapped operations.</para>
          </description>
        </item>
      </list>
      <para>This parameter can include any combination of the following security access modes. These modes can be different for different instances of the same pipe.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WRITE_DAC</b>
                </description>
              </item>
              <item>
                <description>0x00040000L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The caller will have write access to the named pipe's discretionary access control list (ACL).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WRITE_OWNER</b>
                </description>
              </item>
              <item>
                <description>0x00080000L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The caller will have write access to the named pipe's owner.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ACCESS_SYSTEM_SECURITY</b>
                </description>
              </item>
              <item>
                <description>0x01000000L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The caller will have write access to the named pipe's SACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control-lists">Access-Control Lists (ACLs)</a> and
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/sacl-access-right">SACL Access Right</a>.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwPipeMode">
      <para>The pipe mode.</para>
      <para>The function fails if <i>dwPipeMode</i> specifies anything other than 0 or the flags listed in the following tables.</para>
      <para>One of the following type modes can be specified. The same type mode must be specified for each instance of the pipe.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_TYPE_BYTE</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Data is written to the pipe as a stream of bytes. This mode cannot be used with PIPE_READMODE_MESSAGE. The pipe does not distinguish bytes written during different write operations.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_TYPE_MESSAGE</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Data is written to the pipe as a stream of messages. The pipe treats the bytes written during each write operation as a message unit. The <see cref="GetLastError" /> function returns <b>ERROR_MORE_DATA</b> when a message is not read completely. This mode can be used with either <b>PIPE_READMODE_MESSAGE</b> or <b>PIPE_READMODE_BYTE</b>.</para>
          </description>
        </item>
      </list>
      <para>One of the following read modes can be specified. Different instances of the same pipe can specify different read modes.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_READMODE_BYTE</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Data is read from the pipe as a stream of bytes. This mode can be used with either <b>PIPE_TYPE_MESSAGE</b> or <b>PIPE_TYPE_BYTE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_READMODE_MESSAGE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Data is read from the pipe as a stream of messages. This mode can be only used if <b>PIPE_TYPE_MESSAGE</b> is also specified.</para>
          </description>
        </item>
      </list>
      <para>One of the following wait modes can be specified. Different instances of the same pipe can specify different wait modes.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_WAIT</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Blocking mode is enabled. When the pipe handle is specified in the
<see cref="ReadFile" />,
<see cref="WriteFile" />, or
<see cref="ConnectNamedPipe" /> function, the operations are not completed until there is data to read, all data is written, or a client is connected. Use of this mode can mean waiting indefinitely in some situations for a client process to perform an action.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_NOWAIT</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Nonblocking mode is enabled. In this mode, <see cref="ReadFile" />, <see cref="WriteFile" />, and
<see cref="ConnectNamedPipe" /> always return immediately.</para>
            <para>Note that nonblocking mode is supported for compatibility with Microsoft LAN Manager version 2.0 and should not be used to achieve asynchronous I/O with named pipes. For more information on asynchronous pipe I/O, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/synchronous-and-overlapped-input-and-output">Synchronous and Overlapped Input and Output</a>.</para>
          </description>
        </item>
      </list>
      <para>One of the following remote-client modes can be specified. Different instances of the same pipe can specify different remote-client modes.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_ACCEPT_REMOTE_CLIENTS</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Connections from remote clients can be accepted and checked against the security descriptor for the pipe.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_REJECT_REMOTE_CLIENTS</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Connections from remote clients are automatically rejected.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="nMaxInstances">
      <para>The maximum number of instances that can be created for this pipe. The first instance of the pipe can specify this value; the same number must be specified for other instances of the pipe. Acceptable values are in the range 1 through <b>PIPE_UNLIMITED_INSTANCES</b> (255).</para>
      <para>If this parameter is <b>PIPE_UNLIMITED_INSTANCES</b>, the number of pipe instances that can be created is limited only by the availability of system resources. If <i>nMaxInstances</i> is greater than <b>PIPE_UNLIMITED_INSTANCES</b>, the return value is <b>INVALID_HANDLE_VALUE</b> and <see cref="GetLastError" /> returns <b>ERROR_INVALID_PARAMETER</b>.</para>
    </param>
    <param name="nOutBufferSize">
      <para>The number of bytes to reserve for the output buffer. For a discussion on sizing named pipe buffers, see the following Remarks section.</para>
    </param>
    <param name="nInBufferSize">
      <para>The number of bytes to reserve for the input buffer. For a discussion on sizing named pipe buffers, see the following Remarks section.</para>
    </param>
    <param name="nDefaultTimeOut">
      <para>The default time-out value, in milliseconds, if the
<see cref="WaitNamedPipe" /> function specifies <b>NMPWAIT_USE_DEFAULT_WAIT</b>. Each instance of a named pipe must specify the same value.</para>
      <para>A value of zero will result in a default time-out of 50 milliseconds.</para>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new named pipe and determines whether child processes can inherit the returned handle. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the named pipe gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a named pipe grant full control to the LocalSystem account, administrators, and the creator owner. They also grant read access to members of the Everyone group and the anonymous account.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the server end of a named pipe instance.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To create an instance of a named pipe by using
<b>CreateNamedPipe</b>, the user must have <b>FILE_CREATE_PIPE_INSTANCE</b> access to the named pipe object. If a new named pipe is being created, the access control list (ACL) from the security attributes parameter defines the discretionary access control for the named pipe.</para>
      <para>All instances of a named pipe must specify the same pipe type (byte-type or message-type), pipe access (duplex, inbound, or outbound), instance count, and time-out value. If different values are used, this function fails and <see cref="GetLastError" /> returns <b>ERROR_ACCESS_DENIED</b>.</para>
      <para>A client process connects to a named pipe by using the <see cref="CreateFile" /> or <see cref="CallNamedPipe" /> function. The client side of a named pipe starts out in byte mode, even if the server side is in message mode. To avoid problems receiving data, set the client side to message mode as well. To change the mode of the pipe, the pipe client must open a read-only pipe with <b>GENERIC_READ</b> and  <b>FILE_WRITE_ATTRIBUTES</b> access.</para>
      <para>The pipe server should not perform a blocking read operation until the pipe client has started. Otherwise, a race condition can occur. This typically occurs when initialization code, such as the C run-time, needs to lock and examine inherited handles.</para>
      <para>Every time a named pipe is created, the system creates the inbound and/or outbound buffers using nonpaged pool, which is the physical memory used by the kernel. The number of pipe instances (as well as objects such as threads and processes) that you can create is limited by the available nonpaged pool. Each read or write request requires space in the buffer for the read or write data, plus additional space for the internal data structures.</para>
      <para>The input and output buffer sizes are advisory. The actual buffer size reserved for each end of the named pipe is either the system default, the system minimum or maximum, or the specified size rounded up to the next allocation boundary. The buffer size specified should be small enough that your process will not run out of nonpaged pool, but large enough to accommodate typical requests.</para>
      <para>Whenever a pipe write operation occurs, the system first tries to charge the memory against the pipe write quota. If the remaining pipe write quota is enough to fulfill the request, the write operation completes immediately. If the remaining pipe write quota is too small to fulfill the request, the system will try to expand the buffers to accommodate the data using nonpaged pool reserved for the process. The write operation will block until the data is read from the pipe so that the additional buffer quota can be released. Therefore, if your specified buffer size is too small, the system will grow the buffer as needed, but the downside is that the operation will block. If the operation is overlapped, a system thread is blocked; otherwise, the application thread is blocked.</para>
      <para>To free resources used by a named pipe, the application should always close handles when they are no longer needed, which is accomplished either by calling the <see cref="CloseHandle" /> function or when the process associated with the instance handles ends. Note that an instance of a named pipe may have more than one handle associated with it. An instance of a named pipe is always deleted when the last handle to the instance of the named pipe is closed.</para>
      <para>
        <b>Windows 10, version 1709:  </b>Pipes are only supported within an app-container; ie, from one UWP process to another UWP process that's part of the same app. Also, named pipes must use the syntax "\.\pipe\LOCAL" for the pipe name.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/multithreaded-pipe-server">Multithreaded Pipe Server</a>.</para>
    </remarks>
    <seealso cref="ConnectNamedPipe" />
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipe-functions">Pipe Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipes">Pipes Overview</seealso>
    <seealso cref="ReadFile" />
    <seealso cref="ReadFileEx" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso cref="TransactNamedPipe" />
    <seealso cref="WaitNamedPipe" />
    <seealso cref="WriteFile" />
    <seealso cref="WriteFileEx" />
  </member>
  <member name="Windows.CreatePrivateNamespace">
    <summary>
      <para>Creates a private namespace.</para>
    </summary>
    <param name="lpPrivateNamespaceAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies the security attributes of the namespace object.</para>
    </param>
    <param name="lpBoundaryDescriptor">
      <para>A descriptor that defines how the namespace is to be isolated. The caller must be within this boundary. The <see cref="CreateBoundaryDescriptor" /> function creates a boundary descriptor.</para>
    </param>
    <param name="lpAliasPrefix">
      <para>The prefix for the namespace. To create an object in this namespace, specify the object name as <i>prefix</i>\<i>objectname</i>.</para>
      <para>The system supports multiple private namespaces with the same name, as long as they define different boundaries.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a handle to the new namespace.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Other applications can access the namespace using the <see cref="OpenPrivateNamespace" /> function.</para>
      <para>The application that created the namespace can use the <see cref="ClosePrivateNamespace" /> function to close the handle to the namespace. The handle is also closed when the creating process terminates. After the namespace handle is closed, subsequent calls to <see cref="OpenPrivateNamespace" /> fail, but all operations on objects in the namespace succeed.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0600 or later.</para>
    </remarks>
    <seealso cref="ClosePrivateNamespace" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</seealso>
    <seealso cref="OpenPrivateNamespace" />
  </member>
  <member name="Windows.CreatePrivateNamespaceA">
    <summary>
      <para>Creates a private namespace.</para>
    </summary>
    <param name="lpPrivateNamespaceAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies the security attributes of the namespace object.</para>
    </param>
    <param name="lpBoundaryDescriptor">
      <para>A descriptor that defines how the namespace is to be isolated. The caller must be within this boundary. The <see cref="CreateBoundaryDescriptor" /> function creates a boundary descriptor.</para>
    </param>
    <param name="lpAliasPrefix">
      <para>The prefix for the namespace. To create an object in this namespace, specify the object name as <i>prefix</i>\<i>objectname</i>.</para>
      <para>The system supports multiple private namespaces with the same name, as long as they define different boundaries.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a handle to the new namespace.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Other applications can access the namespace using the <see cref="OpenPrivateNamespace" /> function.</para>
      <para>The application that created the namespace can use the <see cref="ClosePrivateNamespace" /> function to close the handle to the namespace. The handle is also closed when the creating process terminates. After the namespace handle is closed, subsequent calls to <see cref="OpenPrivateNamespace" /> fail, but all operations on objects in the namespace succeed.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0600 or later.</para>
    </remarks>
    <seealso cref="ClosePrivateNamespace" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</seealso>
    <seealso cref="OpenPrivateNamespace" />
  </member>
  <member name="Windows.CreatePrivateNamespaceW">
    <summary>
      <para>Creates a private namespace.</para>
    </summary>
    <param name="lpPrivateNamespaceAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies the security attributes of the namespace object.</para>
    </param>
    <param name="lpBoundaryDescriptor">
      <para>A descriptor that defines how the namespace is to be isolated. The caller must be within this boundary. The <see cref="CreateBoundaryDescriptor" /> function creates a boundary descriptor.</para>
    </param>
    <param name="lpAliasPrefix">
      <para>The prefix for the namespace. To create an object in this namespace, specify the object name as <i>prefix</i>\<i>objectname</i>.</para>
      <para>The system supports multiple private namespaces with the same name, as long as they define different boundaries.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a handle to the new namespace.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Other applications can access the namespace using the <see cref="OpenPrivateNamespace" /> function.</para>
      <para>The application that created the namespace can use the <see cref="ClosePrivateNamespace" /> function to close the handle to the namespace. The handle is also closed when the creating process terminates. After the namespace handle is closed, subsequent calls to <see cref="OpenPrivateNamespace" /> fail, but all operations on objects in the namespace succeed.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0600 or later.</para>
    </remarks>
    <seealso cref="ClosePrivateNamespace" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</seealso>
    <seealso cref="OpenPrivateNamespace" />
  </member>
  <member name="Windows.CreateProcessWithTokenW">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the specified token. It can optionally load the user profile for the specified user.</para>
      <para>The process that calls <b>CreateProcessWithTokenW</b> must have the SE_IMPERSONATE_NAME privilege. If this function fails with ERROR_PRIVILEGE_NOT_HELD (1314), use the <see cref="CreateProcessAsUser" /> or <see cref="CreateProcessWithLogonW" /> function instead. Typically, the process that calls
<b>CreateProcessAsUser</b>  must have the SE_INCREASE_QUOTA_NAME privilege and may require the SE_ASSIGNPRIMARYTOKEN_NAME privilege if the token is  not assignable.    <b>CreateProcessWithLogonW</b> requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use <b>CreateProcessWithLogonW</b> to create a process with alternate credentials.</para>
    </summary>
    <param name="hToken">
      <para>A handle to the primary token that represents a user. The handle must have the TOKEN_QUERY, TOKEN_DUPLICATE, and TOKEN_ASSIGN_PRIMARY access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>. The user represented by the token must have read and execute access to the application specified by the <i>lpApplicationName</i> or the <i>lpCommandLine</i> parameter.</para>
      <para>To get a primary token that represents the specified user, call the
<see cref="LogonUser" /> function. Alternatively, you can call the
<see cref="DuplicateTokenEx" /> function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.</para>
      <para>
        <b>Terminal Services:  </b>The caller's process always runs in the caller's session, not in the session specified in the token. To run a process in the session specified in the token, use the CreateProcessAsUser function.</para>
    </param>
    <param name="dwLogonFlags">
      <para>The logon option. This parameter can be zero or one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOGON_WITH_PROFILE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Log on, then load the user's profile in the <b>HKEY_USERS</b> registry key. The function returns after the profile has been loaded. Loading the profile can be time-consuming, so it is best to use this value only if you must access the information in the <b>HKEY_CURRENT_USER</b> registry key.</para>
            <para>
              <b>Windows Server 2003:  </b>The profile is unloaded after the new process has been terminated, regardless of whether it has created child processes.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LOGON_NETCREDENTIALS_ONLY</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Log on, but use the specified credentials on the network only. The new process uses the same token as the caller, but the system creates a new logon session within LSA, and the process uses the specified credentials as the default credentials.</para>
            <para>This value can be used to create a process that uses a different set of credentials locally than it does remotely. This is useful in inter-domain scenarios where there is no trust relationship.</para>
            <para>The system does not validate the specified credentials. Therefore, the process can start, but it may not have access to network resources.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be NULL. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <para>
        <b>c:\program.exe</b>
        <b>c:\program files\sub.exe</b>
        <b>c:\program files\sub dir\program.exe</b>
        <b>c:\program files\sub dir\program name.exe</b>
      </para>
      <para>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be NULL, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments.</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed.</para>
      <para>The maximum length of this string is 1024 characters. If <i>lpApplicationName</i> is NULL, the module name portion of <i>lpCommandLine</i> is limited to MAX_PATH characters.</para>
      <para>The function can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be NULL. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-NULL, *<i>lpApplicationName</i> specifies the module to execute, and *<i>lpCommandLine</i> specifies the command line. The new process can use
<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched.</description>
        </item>
        <item>
          <description>The Windows directory. Use the
<see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>
      <para>The system adds a null character to the command line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</para>
    </param>
    <param name="dwCreationFlags">
      <para>The flags that control how the process is created. The CREATE_DEFAULT_ERROR_MODE, CREATE_NEW_CONSOLE, and CREATE_NEW_PROCESS_GROUP flags are enabled by default. For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see
<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process gets the default error mode, creates a new console and creates a new process group.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to an environment block for the new process. If this parameter is NULL, the new process uses an environment created from the profile of the user specified by <i>lpUsername</i>.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i></para>
      <para>Because the equal sign (=) is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes CREATE_UNICODE_ENVIRONMENT.  If this parameter is NULL and the environment block of the parent process contains Unicode characters, you must also ensure that <i>dwCreationFlags</i> includes CREATE_UNICODE_ENVIRONMENT.</para>
      <para>An ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string and two more to terminate the block.</para>
      <para>To retrieve a copy of the environment block for a specific user, use the
<see cref="CreateEnvironmentBlock" /> function.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>If the <b>lpDesktop</b> member is NULL or an empty string, the new process inherits the desktop and window station of its parent process. The function adds permission for the specified user account to the inherited window station and desktop. Otherwise, if this member specifies a desktop, it is the responsibility of the application to add permission for the specified user account to the specified window station and desktop, even for WinSta0\Default.</para>
      <para>Handles in
<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with
<see cref="CloseHandle" /> when they are no longer needed.</para>
      <para>
        <b>Important</b>  If the <b>dwFlags</b> member of the  <see cref="STARTUPINFO" /> structure specifies <b>STARTF_USESTDHANDLES</b>, the standard handle fields are copied unchanged to the child process without validation. The caller is responsible for ensuring that these fields contain valid handle values.  Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</para>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a
<see cref="PROCESS_INFORMATION" /> structure that receives identification information for the new process, including a handle to the process.</para>
      <para>Handles in
<see cref="PROCESS_INFORMATION" /> must be closed with the
<see cref="CloseHandle" /> function when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
    <remarks>
      <para>By default,
<b>CreateProcessWithTokenW</b> does not load the specified user's profile into the <b>HKEY_USERS</b> registry key. This means that access to information in the  <b>HKEY_CURRENT_USER</b> registry key may not produce results consistent with a normal interactive logon. It is your responsibility to load the user's registry hive into <b>HKEY_USERS</b>  by either using LOGON_WITH_PROFILE, or by calling the
<see cref="LoadUserProfile" /> function before calling this function.</para>
      <para>If the <i>lpEnvironment</i> parameter is NULL, the new process uses an environment block created from the profile of the user specified by <i>lpUserName</i>. If the HOMEDRIVE and HOMEPATH variables are not set, <b>CreateProcessWithTokenW</b> modifies the environment block to use the drive and path of the user's working directory.</para>
      <para>When created, the new process and thread handles receive full access rights (PROCESS_ALL_ACCESS and THREAD_ALL_ACCESS). For either handle, if a security descriptor is not provided, the handle can be used in any function that requires an object handle of that type. When a security descriptor is provided, an access check is performed on all subsequent uses of the handle before access is granted. If access is denied, the requesting process cannot use the handle to gain access to the process or thread.</para>
      <para>To retrieve a security token, pass the process handle in the
<see cref="PROCESS_INFORMATION" /> structure to the
<see cref="OpenProcessToken" /> function.</para>
      <para>The process is assigned a process identifier. The identifier is valid until the process terminates. It can be used to identify the process, or specified in the
<see cref="OpenProcess" /> function to open a handle to the process. The initial thread in the process is also assigned a thread identifier. It can be specified in the
<see cref="OpenThread" /> function to open a handle to the thread. The identifier is valid until the thread terminates and can be used to uniquely identify the thread within the system. These identifiers are returned in
<see cref="PROCESS_INFORMATION" />.</para>
      <para>The calling thread can use the
<see cref="WaitForInputIdle" /> function to wait until the new process has finished its initialization and is waiting for user input with no input pending. This can be useful for synchronization between parent and child processes, because
<b>CreateProcessWithTokenW</b> returns without waiting for the new process to finish its initialization. For example, the creating process would use
<b>WaitForInputIdle</b> before trying to find a window associated with the new process.</para>
      <para>The preferred way to shut down a process is by using the
<see cref="ExitProcess" /> function, because this function sends notification of approaching termination to all DLLs attached to the process. Other means of shutting down a process do not notify the attached DLLs. Note that when a thread calls
<b>ExitProcess</b>, other threads of the process are terminated without an opportunity to execute any additional code (including the thread termination code of attached DLLs). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/terminating-a-process">Terminating a Process</a>.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h3>Security Remarks</h3>
      <para>The <i>lpApplicationName</i> parameter can be NULL, in which case the executable name must be the first white space–delimited string in <i>lpCommandLine</i>. If the executable or path name has a space in it, there is a risk that a different executable could be run because of the way the function parses spaces. The following example is dangerous because the function will attempt to run "Program.exe", if it exists, instead of "MyApp.exe".</para>
      <code>    LPTSTR szCmdline = L"C:\\Program Files\\MyApp";
    CreateProcessWithTokenW(/*...*/, szCmdline, /*...*/);
</code>
      <para>If a malicious user were to create an application called "Program.exe" on a system, any program that incorrectly calls
<b>CreateProcessWithTokenW</b> using the Program Files directory will run this application instead of the intended application.</para>
      <para>To avoid this problem, do not pass NULL for <i>lpApplicationName</i>. If you do pass NULL for <i>lpApplicationName</i>, use quotation marks around the executable path in <i>lpCommandLine</i>, as shown in the example below.</para>
      <code>    LPTSTR szCmdline = L"\"C:\\Program Files\\MyApp\"";
    CreateProcessWithTokenW(/*...*/, szCmdline, /*...*/);
</code>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateEnvironmentBlock" />
    <seealso cref="ExitProcess" />
    <seealso cref="GetEnvironmentStrings" />
    <seealso cref="GetExitCodeProcess" />
    <seealso cref="OpenProcess" />
    <seealso cref="PROCESS_INFORMATION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso cref="STARTUPINFO" />
    <seealso cref="SetErrorMode" />
    <seealso cref="WaitForInputIdle" />
  </member>
  <member name="Windows.CreateSemaphoreA">
    <summary>
      <para>Creates or opens a named or unnamed semaphore object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateSemaphoreEx" /> function.</para>
    </summary>
    <param name="lpSemaphoreAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child
processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor
for the new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lInitialCount">
      <para>The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the
<see cref="ReleaseSemaphore" /> function.</para>
    </param>
    <param name="lMaximumCount">
      <para>The maximum count for the semaphore object. This value must be greater than zero.</para>
    </param>
    <param name="lpName">
      <para>The name of the semaphore object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named semaphore object, this function requests the <b>SEMAPHORE_ALL_ACCESS</b> access right. In this case, the <i>lInitialCount</i> and <i>lMaximumCount</i> parameters are ignored because they have already been set by the creating process. If the <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the semaphore object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object existed before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle returned by CreateSemaphore has the <b>SEMAPHORE_ALL_ACCESS</b> access right; it can be used in any function that requires a handle to a semaphore object, provided that the caller has been granted access. If a semaphore is created from a service or a thread that is impersonating a different user, you can either apply a security descriptor to the semaphore when you create it, or change the default security descriptor for the creating process by changing its default DACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
      <para>The state of a semaphore object is signaled when its count is greater than zero, and nonsignaled when its count is equal to zero. The <i>lInitialCount</i> parameter specifies the initial count. The count can never be less than zero or greater than the value specified in the <i>lMaximumCount</i> parameter.</para>
      <para>Any thread of the calling process can specify the semaphore-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution. Each time a thread completes a wait for a semaphore object, the count of the semaphore object is decremented by one. When the thread has finished, it calls the <see cref="ReleaseSemaphore" /> function, which increments the count of the semaphore object.</para>
      <para>Multiple processes can have handles of the same semaphore object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the
<see cref="CreateProcess" /> function can inherit a handle to a semaphore object if the <i>lpSemaphoreAttributes</i> parameter of
CreateSemaphore enabled inheritance.</description>
        </item>
        <item>
          <description>A process can specify the semaphore-object handle in a call to the
<see cref="DuplicateHandle" /> function to create a duplicate handle that can be used by another process.</description>
        </item>
        <item>
          <description>A process can specify the name of a semaphore object in a call to the
[OpenSemaphore](/windows/win32/api/synchapi/nf-synchapi-opensemaphorew) or CreateSemaphore function.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The semaphore object is destroyed when its last handle has been closed.</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>CreateSemaphore</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-semaphore-objects">Using Semaphore Objects</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcess" />
    <seealso cref="CreateSemaphoreEx" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="OpenSemaphore" />
    <seealso cref="ReleaseSemaphore" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/semaphore-objects">Semaphore Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateSemaphoreW">
    <summary>
      <para>Creates or opens a named or unnamed semaphore object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateSemaphoreEx" /> function.</para>
    </summary>
    <param name="lpSemaphoreAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a></para>
      <para>structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child
processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor
for the new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lInitialCount">
      <para>The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the
<see cref="ReleaseSemaphore" /> function.</para>
    </param>
    <param name="lMaximumCount">
      <para>The maximum count for the semaphore object. This value must be greater than zero.</para>
    </param>
    <param name="lpName">
      <para>The name of the semaphore object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named semaphore object, this function requests the <b>SEMAPHORE_ALL_ACCESS</b> access right. In this case, the <i>lInitialCount</i> and <i>lMaximumCount</i> parameters are ignored because they have already been set by the creating process. If the <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the semaphore object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object existed before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle returned by CreateSemaphore has the <b>SEMAPHORE_ALL_ACCESS</b> access right; it can be used in any function that requires a handle to a semaphore object, provided that the caller has been granted access. If a semaphore is created from a service or a thread that is impersonating a different user, you can either apply a security descriptor to the semaphore when you create it, or change the default security descriptor for the creating process by changing its default DACL. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
      <para>The state of a semaphore object is signaled when its count is greater than zero, and nonsignaled when its count is equal to zero. The <i>lInitialCount</i> parameter specifies the initial count. The count can never be less than zero or greater than the value specified in the <i>lMaximumCount</i> parameter.</para>
      <para>Any thread of the calling process can specify the semaphore-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution. Each time a thread completes a wait for a semaphore object, the count of the semaphore object is decremented by one. When the thread has finished, it calls the <see cref="ReleaseSemaphore" /> function, which increments the count of the semaphore object.</para>
      <para>Multiple processes can have handles of the same semaphore object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the
<see cref="CreateProcess" /> function can inherit a handle to a semaphore object if the <i>lpSemaphoreAttributes</i> parameter of
CreateSemaphore enabled inheritance.</description>
        </item>
        <item>
          <description>A process can specify the semaphore-object handle in a call to the
<see cref="DuplicateHandle" /> function to create a duplicate handle that can be used by another process.</description>
        </item>
        <item>
          <description>A process can specify the name of a semaphore object in a call to the
[OpenSemaphore](/windows/win32/api/synchapi/nf-synchapi-opensemaphorew) or CreateSemaphore function.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The semaphore object is destroyed when its last handle has been closed.</para>
      <h4>Examples</h4>
      <para>For an example that uses
<b>CreateSemaphore</b>, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/using-semaphore-objects">Using Semaphore Objects</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcess" />
    <seealso cref="CreateSemaphoreEx" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-names">Object Names</seealso>
    <seealso cref="OpenSemaphore" />
    <seealso cref="ReleaseSemaphore" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/semaphore-objects">Semaphore Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateSemaphoreExA">
    <summary>
      <para>Creates or opens a named or unnamed semaphore object and returns a handle to the object.</para>
    </summary>
    <param name="lpSemaphoreAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the semaphore handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lInitialCount">
      <para>The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the
<see cref="ReleaseSemaphore" /> function.</para>
    </param>
    <param name="lMaximumCount">
      <para>The maximum count for the semaphore object. This value must be greater than zero.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a null-terminated string specifying the name of the semaphore object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named semaphore object, the <i>lInitialCount</i> and <i>lMaximumCount</i> parameters are ignored because they have already been set by the creating process. If the <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the semaphore object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter is reserved and must be 0.</para>
    </param>
    <param name="dwDesiredAccess">
      <para>The access mask for the semaphore object. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object existed before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The state of a semaphore object is signaled when its count is greater than zero, and nonsignaled when its count is equal to zero. The <i>lInitialCount</i> parameter specifies the initial count. The count can never be less than zero or greater than the value specified in the <i>lMaximumCount</i> parameter.</para>
      <para>Any thread of the calling process can specify the semaphore-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution. Each time a thread completes a wait for a semaphore object, the count of the semaphore object is decremented by one. When the thread has finished, it calls the <see cref="ReleaseSemaphore" /> function, which increments the count of the semaphore object.</para>
      <para>Multiple processes can have handles of the same semaphore object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the
<see cref="CreateProcess" /> function can inherit a handle to a semaphore object if the <i>lpSemaphoreAttributes</i> parameter of
<see cref="CreateSemaphoreEx" /> enabled inheritance.</description>
        </item>
        <item>
          <description>A process can specify the semaphore-object handle in a call to the
<see cref="DuplicateHandle" /> function to create a duplicate handle that can be used by another process.</description>
        </item>
        <item>
          <description>A process can specify the name of a semaphore object in a call to the
[OpenSemaphore](../synchapi/nf-synchapi-signalobjectandwait.md) or
<see cref="CreateSemaphoreEx" /> function.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The semaphore object is destroyed when its last handle has been closed.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/semaphore-objects">Semaphore Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateSemaphoreExW">
    <summary>
      <para>Creates or opens a named or unnamed semaphore object and returns a handle to the object.</para>
    </summary>
    <param name="lpSemaphoreAttributes">
      <para>A pointer to a
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the semaphore handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lInitialCount">
      <para>The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the
<see cref="ReleaseSemaphore" /> function.</para>
    </param>
    <param name="lMaximumCount">
      <para>The maximum count for the semaphore object. This value must be greater than zero.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a null-terminated string specifying the name of the semaphore object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named semaphore object, the <i>lInitialCount</i> and <i>lMaximumCount</i> parameters are ignored because they have already been set by the creating process. If the <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the semaphore object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the
<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter is reserved and must be 0.</para>
    </param>
    <param name="dwDesiredAccess">
      <para>The access mask for the semaphore object. For a list of access rights, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object existed before the function call, the function returns a handle to the existing object and
<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The state of a semaphore object is signaled when its count is greater than zero, and nonsignaled when its count is equal to zero. The <i>lInitialCount</i> parameter specifies the initial count. The count can never be less than zero or greater than the value specified in the <i>lMaximumCount</i> parameter.</para>
      <para>Any thread of the calling process can specify the semaphore-object handle in a call to one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a>. The single-object wait functions return when the state of the specified object is signaled. The multiple-object wait functions can be instructed to return either when any one or when all of the specified objects are signaled. When a wait function returns, the waiting thread is released to continue its execution. Each time a thread completes a wait for a semaphore object, the count of the semaphore object is decremented by one. When the thread has finished, it calls the <see cref="ReleaseSemaphore" /> function, which increments the count of the semaphore object.</para>
      <para>Multiple processes can have handles of the same semaphore object, enabling use of the object for interprocess synchronization. The following object-sharing mechanisms are available:</para>
      <list type="bullet">
        <item>
          <description>A child process created by the
<see cref="CreateProcess" /> function can inherit a handle to a semaphore object if the <i>lpSemaphoreAttributes</i> parameter of
<see cref="CreateSemaphoreEx" /> enabled inheritance.</description>
        </item>
        <item>
          <description>A process can specify the semaphore-object handle in a call to the
<see cref="DuplicateHandle" /> function to create a duplicate handle that can be used by another process.</description>
        </item>
        <item>
          <description>A process can specify the name of a semaphore object in a call to the
[OpenSemaphore](../synchapi/nf-synchapi-signalobjectandwait.md) or
<see cref="CreateSemaphoreEx" /> function.</description>
        </item>
      </list>
      <para>Use the <see cref="CloseHandle" /> function to close the handle. The system closes the handle automatically when the process terminates. The semaphore object is destroyed when its last handle has been closed.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/semaphore-objects">Semaphore Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.CreateSymbolicLink">
    <summary>
      <para>Creates a symbolic link.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CreateSymbolicLinkTransacted" /> function.</para>
    </summary>
    <param name="lpSymlinkFileName">
      <para>The symbolic link to be created.</para>
      <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpTargetFileName">
      <para>The name of the target for the symbolic link to be created.</para>
      <para>If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as
an absolute link; otherwise, the link is treated as a relative link.</para>
      <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="dwFlags">
      <para>Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0x0</para>
          </description>
          <description>
            <para>The link target is a file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SYMBOLIC_LINK_FLAG_DIRECTORY</b>
                </description>
              </item>
              <item>
                <description>0x1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The link target is a directory.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE</b>
                </description>
              </item>
              <item>
                <description>0x2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specify this flag to allow creation of symbolic links when the process is not elevated. <a href="https://docs.microsoft.com//windows/uwp/get-started/enable-your-device-for-development">Developer Mode</a> must first be enabled on the machine before  this option will function.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Symbolic links can either be absolute or relative links. Absolute links are links that specify each portion of
the path name; relative links are determined relative to where relative–link specifiers are
in a specified path. Relative links are specified using the following conventions:</para>
      <list type="bullet">
        <item>
          <description>Dot (. and ..) conventions—for example,
"..\" resolves the path relative to the parent directory.</description>
        </item>
        <item>
          <description>Names with no slashes (\\)—for example, "tmp" resolves
the path relative to the current directory.</description>
        </item>
        <item>
          <description>Root relative—for example, "\Windows\System32" resolves
to "<i>current drive</i>:\Windows\System32".</description>
        </item>
        <item>
          <description>Current working directory–relative—for example, if the current
working directory is C:\Windows\System32, "C:File.txt" resolves to
"C:\Windows\System32\File.txt".
<b>Note</b>  If you specify a current working directory–relative link, it is created as an
absolute link, due to the way the current working directory is processed based on the user and the
thread.
</description>
        </item>
      </list>
      <para>To remove a symbolic link, delete the file (using
<see cref="DeleteFile" /> or similar APIs) or remove the directory (using
<see cref="RemoveDirectory" /> or similar APIs) depending on what type
of symbolic link is used.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>CsvFs does not support soft link or any other reparse points.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateSymbolicLink as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateSymbolicLinkTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CreateSymbolicLinkA">
    <summary>
      <para>Creates a symbolic link.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CreateSymbolicLinkTransacted" /> function.</para>
    </summary>
    <param name="lpSymlinkFileName">
      <para>The symbolic link to be created.</para>
      <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpTargetFileName">
      <para>The name of the target for the symbolic link to be created.</para>
      <para>If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as
an absolute link; otherwise, the link is treated as a relative link.</para>
      <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="dwFlags">
      <para>Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0x0</para>
          </description>
          <description>
            <para>The link target is a file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SYMBOLIC_LINK_FLAG_DIRECTORY</b>
                </description>
              </item>
              <item>
                <description>0x1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The link target is a directory.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE</b>
                </description>
              </item>
              <item>
                <description>0x2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specify this flag to allow creation of symbolic links when the process is not elevated. <a href="https://docs.microsoft.com//windows/uwp/get-started/enable-your-device-for-development">Developer Mode</a> must first be enabled on the machine before  this option will function.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Symbolic links can either be absolute or relative links. Absolute links are links that specify each portion of
the path name; relative links are determined relative to where relative–link specifiers are
in a specified path. Relative links are specified using the following conventions:</para>
      <list type="bullet">
        <item>
          <description>Dot (. and ..) conventions—for example,
"..\" resolves the path relative to the parent directory.</description>
        </item>
        <item>
          <description>Names with no slashes (\\)—for example, "tmp" resolves
the path relative to the current directory.</description>
        </item>
        <item>
          <description>Root relative—for example, "\Windows\System32" resolves
to "<i>current drive</i>:\Windows\System32".</description>
        </item>
        <item>
          <description>Current working directory–relative—for example, if the current
working directory is C:\Windows\System32, "C:File.txt" resolves to
"C:\Windows\System32\File.txt".
<b>Note</b>  If you specify a current working directory–relative link, it is created as an
absolute link, due to the way the current working directory is processed based on the user and the
thread.
</description>
        </item>
      </list>
      <para>To remove a symbolic link, delete the file (using
<see cref="DeleteFile" /> or similar APIs) or remove the directory (using
<see cref="RemoveDirectory" /> or similar APIs) depending on what type
of symbolic link is used.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>CsvFs does not support soft link or any other reparse points.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateSymbolicLink as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateSymbolicLinkTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CreateSymbolicLinkW">
    <summary>
      <para>Creates a symbolic link.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CreateSymbolicLinkTransacted" /> function.</para>
    </summary>
    <param name="lpSymlinkFileName">
      <para>The symbolic link to be created.</para>
      <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpTargetFileName">
      <para>The name of the target for the symbolic link to be created.</para>
      <para>If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as
an absolute link; otherwise, the link is treated as a relative link.</para>
      <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="dwFlags">
      <para>Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0x0</para>
          </description>
          <description>
            <para>The link target is a file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SYMBOLIC_LINK_FLAG_DIRECTORY</b>
                </description>
              </item>
              <item>
                <description>0x1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The link target is a directory.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE</b>
                </description>
              </item>
              <item>
                <description>0x2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specify this flag to allow creation of symbolic links when the process is not elevated. <a href="https://docs.microsoft.com//windows/uwp/get-started/enable-your-device-for-development">Developer Mode</a> must first be enabled on the machine before  this option will function.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Symbolic links can either be absolute or relative links. Absolute links are links that specify each portion of
the path name; relative links are determined relative to where relative–link specifiers are
in a specified path. Relative links are specified using the following conventions:</para>
      <list type="bullet">
        <item>
          <description>Dot (. and ..) conventions—for example,
"..\" resolves the path relative to the parent directory.</description>
        </item>
        <item>
          <description>Names with no slashes (\\)—for example, "tmp" resolves
the path relative to the current directory.</description>
        </item>
        <item>
          <description>Root relative—for example, "\Windows\System32" resolves
to "<i>current drive</i>:\Windows\System32".</description>
        </item>
        <item>
          <description>Current working directory–relative—for example, if the current
working directory is C:\Windows\System32, "C:File.txt" resolves to
"C:\Windows\System32\File.txt".
<b>Note</b>  If you specify a current working directory–relative link, it is created as an
absolute link, due to the way the current working directory is processed based on the user and the
thread.
</description>
        </item>
      </list>
      <para>To remove a symbolic link, delete the file (using
<see cref="DeleteFile" /> or similar APIs) or remove the directory (using
<see cref="RemoveDirectory" /> or similar APIs) depending on what type
of symbolic link is used.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>CsvFs does not support soft link or any other reparse points.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateSymbolicLink as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateSymbolicLinkTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CreateSymbolicLink">
    <summary>
      <para>Creates a symbolic link.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CreateSymbolicLinkTransacted" /> function.</para>
    </summary>
    <param name="lpSymlinkFileName">
      <para>The symbolic link to be created.</para>
      <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpTargetFileName">
      <para>The name of the target for the symbolic link to be created.</para>
      <para>If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as
an absolute link; otherwise, the link is treated as a relative link.</para>
      <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="dwFlags">
      <para>Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0x0</para>
          </description>
          <description>
            <para>The link target is a file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SYMBOLIC_LINK_FLAG_DIRECTORY</b>
                </description>
              </item>
              <item>
                <description>0x1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The link target is a directory.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE</b>
                </description>
              </item>
              <item>
                <description>0x2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specify this flag to allow creation of symbolic links when the process is not elevated. <a href="https://docs.microsoft.com//windows/uwp/get-started/enable-your-device-for-development">Developer Mode</a> must first be enabled on the machine before  this option will function.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Symbolic links can either be absolute or relative links. Absolute links are links that specify each portion of
the path name; relative links are determined relative to where relative–link specifiers are
in a specified path. Relative links are specified using the following conventions:</para>
      <list type="bullet">
        <item>
          <description>Dot (. and ..) conventions—for example,
"..\" resolves the path relative to the parent directory.</description>
        </item>
        <item>
          <description>Names with no slashes (\\)—for example, "tmp" resolves
the path relative to the current directory.</description>
        </item>
        <item>
          <description>Root relative—for example, "\Windows\System32" resolves
to "<i>current drive</i>:\Windows\System32".</description>
        </item>
        <item>
          <description>Current working directory–relative—for example, if the current
working directory is C:\Windows\System32, "C:File.txt" resolves to
"C:\Windows\System32\File.txt".
<b>Note</b>  If you specify a current working directory–relative link, it is created as an
absolute link, due to the way the current working directory is processed based on the user and the
thread.
</description>
        </item>
      </list>
      <para>To remove a symbolic link, delete the file (using
<see cref="DeleteFile" /> or similar APIs) or remove the directory (using
<see cref="RemoveDirectory" /> or similar APIs) depending on what type
of symbolic link is used.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>CsvFs does not support soft link or any other reparse points.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateSymbolicLink as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateSymbolicLinkTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CreateSymbolicLinkA">
    <summary>
      <para>Creates a symbolic link.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CreateSymbolicLinkTransacted" /> function.</para>
    </summary>
    <param name="lpSymlinkFileName">
      <para>The symbolic link to be created.</para>
      <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpTargetFileName">
      <para>The name of the target for the symbolic link to be created.</para>
      <para>If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as
an absolute link; otherwise, the link is treated as a relative link.</para>
      <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="dwFlags">
      <para>Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0x0</para>
          </description>
          <description>
            <para>The link target is a file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SYMBOLIC_LINK_FLAG_DIRECTORY</b>
                </description>
              </item>
              <item>
                <description>0x1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The link target is a directory.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE</b>
                </description>
              </item>
              <item>
                <description>0x2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specify this flag to allow creation of symbolic links when the process is not elevated. <a href="https://docs.microsoft.com//windows/uwp/get-started/enable-your-device-for-development">Developer Mode</a> must first be enabled on the machine before  this option will function.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Symbolic links can either be absolute or relative links. Absolute links are links that specify each portion of
the path name; relative links are determined relative to where relative–link specifiers are
in a specified path. Relative links are specified using the following conventions:</para>
      <list type="bullet">
        <item>
          <description>Dot (. and ..) conventions—for example,
"..\" resolves the path relative to the parent directory.</description>
        </item>
        <item>
          <description>Names with no slashes (\\)—for example, "tmp" resolves
the path relative to the current directory.</description>
        </item>
        <item>
          <description>Root relative—for example, "\Windows\System32" resolves
to "<i>current drive</i>:\Windows\System32".</description>
        </item>
        <item>
          <description>Current working directory–relative—for example, if the current
working directory is C:\Windows\System32, "C:File.txt" resolves to
"C:\Windows\System32\File.txt".
<b>Note</b>  If you specify a current working directory–relative link, it is created as an
absolute link, due to the way the current working directory is processed based on the user and the
thread.
</description>
        </item>
      </list>
      <para>To remove a symbolic link, delete the file (using
<see cref="DeleteFile" /> or similar APIs) or remove the directory (using
<see cref="RemoveDirectory" /> or similar APIs) depending on what type
of symbolic link is used.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>CsvFs does not support soft link or any other reparse points.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateSymbolicLink as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateSymbolicLinkTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CreateSymbolicLinkW">
    <summary>
      <para>Creates a symbolic link.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="CreateSymbolicLinkTransacted" /> function.</para>
    </summary>
    <param name="lpSymlinkFileName">
      <para>The symbolic link to be created.</para>
      <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpTargetFileName">
      <para>The name of the target for the symbolic link to be created.</para>
      <para>If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as
an absolute link; otherwise, the link is treated as a relative link.</para>
      <para>This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="dwFlags">
      <para>Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0x0</para>
          </description>
          <description>
            <para>The link target is a file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SYMBOLIC_LINK_FLAG_DIRECTORY</b>
                </description>
              </item>
              <item>
                <description>0x1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The link target is a directory.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE</b>
                </description>
              </item>
              <item>
                <description>0x2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Specify this flag to allow creation of symbolic links when the process is not elevated. <a href="https://docs.microsoft.com//windows/uwp/get-started/enable-your-device-for-development">Developer Mode</a> must first be enabled on the machine before  this option will function.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Symbolic links can either be absolute or relative links. Absolute links are links that specify each portion of
the path name; relative links are determined relative to where relative–link specifiers are
in a specified path. Relative links are specified using the following conventions:</para>
      <list type="bullet">
        <item>
          <description>Dot (. and ..) conventions—for example,
"..\" resolves the path relative to the parent directory.</description>
        </item>
        <item>
          <description>Names with no slashes (\\)—for example, "tmp" resolves
the path relative to the current directory.</description>
        </item>
        <item>
          <description>Root relative—for example, "\Windows\System32" resolves
to "<i>current drive</i>:\Windows\System32".</description>
        </item>
        <item>
          <description>Current working directory–relative—for example, if the current
working directory is C:\Windows\System32, "C:File.txt" resolves to
"C:\Windows\System32\File.txt".
<b>Note</b>  If you specify a current working directory–relative link, it is created as an
absolute link, due to the way the current working directory is processed based on the user and the
thread.
</description>
        </item>
      </list>
      <para>To remove a symbolic link, delete the file (using
<see cref="DeleteFile" /> or similar APIs) or remove the directory (using
<see cref="RemoveDirectory" /> or similar APIs) depending on what type
of symbolic link is used.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>CsvFs does not support soft link or any other reparse points.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines CreateSymbolicLink as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateSymbolicLinkTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.CreateTapePartition">
    <summary>
      <para>The
<b>CreateTapePartition</b> function reformats a tape.</para>
    </summary>
    <param name="hDevice">
      <para>Handle to the device where the new partition is to be created. This handle is created by using the
<see cref="CreateFile" /> function.</para>
    </param>
    <param name="dwPartitionMethod">
      <para>Type of partition to create. To determine what type of partitions your device supports, see the documentation for your hardware. This parameter can have one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_FIXED_PARTITIONS</b>
                </description>
              </item>
              <item>
                <description>0L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Partitions the tape based on the device's default definition of partitions. The <i>dwCount</i> and <i>dwSize</i> parameters are ignored.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_INITIATOR_PARTITIONS</b>
                </description>
              </item>
              <item>
                <description>2L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Partitions the tape into the number and size of partitions specified by <i>dwCount</i> and <i>dwSize</i>, respectively, except for the last partition. The size of the last partition is the remainder of the tape.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_SELECT_PARTITIONS</b>
                </description>
              </item>
              <item>
                <description>1L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Partitions the tape into the number of partitions specified by <i>dwCount</i>. The <i>dwSize</i> parameter is ignored. The size of the partitions is determined by the device's default partition size. For more specific information, see the documentation for your tape device.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwCount">
      <para>Number of partitions to create. The
<see cref="GetTapeParameters" /> function provides the maximum number of partitions a tape can support.</para>
    </param>
    <param name="dwSize">
      <para>Size of each partition, in megabytes. This value is ignored if the <i>dwPartitionMethod</i> parameter is <b>TAPE_SELECT_PARTITIONS</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, it can return one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_BEGINNING_OF_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1102L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to access data before the beginning-of-medium marker failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_BUS_RESET</b>
                </description>
              </item>
              <item>
                <description>1111L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A reset condition was detected on the bus.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_END_OF_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1100L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The end-of-tape marker was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_FILEMARK_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1101L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A filemark was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_SETMARK_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1103L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A setmark was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NO_DATA_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1104L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The end-of-data marker was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_PARTITION_FAILURE</b>
                </description>
              </item>
              <item>
                <description>1105L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape could not be partitioned.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_INVALID_BLOCK_LENGTH</b>
                </description>
              </item>
              <item>
                <description>1106L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The block size is incorrect on a new tape in a multivolume partition.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_DEVICE_NOT_PARTITIONED</b>
                </description>
              </item>
              <item>
                <description>1107L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The partition information could not be found when a tape was being loaded.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_MEDIA_CHANGED</b>
                </description>
              </item>
              <item>
                <description>1110L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape that was in the drive has been replaced or removed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NO_MEDIA_IN_DRIVE</b>
                </description>
              </item>
              <item>
                <description>1112L</description>
              </item>
            </list>
          </description>
          <description>
            <para>There is no media in the drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NOT_SUPPORTED</b>
                </description>
              </item>
              <item>
                <description>50L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape driver does not support a requested function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_UNABLE_TO_LOCK_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1108L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to lock the ejection mechanism failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1109L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to unload the tape failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_WRITE_PROTECT</b>
                </description>
              </item>
              <item>
                <description>19L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The media is write protected.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Creating partitions reformats the tape. All previous information recorded on the tape is destroyed.</para>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="GetTapeParameters" />
  </member>
  <member name="Windows.CreateUmsCompletionList">
    <summary>
      <para>Creates a user-mode scheduling (UMS) completion list.</para>
    </summary>
    <param name="UmsCompletionList">
      <para>A <b>PUMS_COMPLETION_LIST</b> variable. On output, this parameter receives a pointer
to an empty UMS completion list.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error values include the
following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory is available to create the completion list.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>A completion list is associated with a UMS scheduler thread when the
<see cref="EnterUmsSchedulingMode" /> function is called to
create the scheduler thread. The system queues newly created UMS worker threads to the completion list. It also
queues previously blocked UMS worker threads to the completion list when the threads are no longer blocked.</para>
      <para>When an application's <a href="https://docs.microsoft.com//windows/desktop/api/winnt/nc-winnt-rtl_ums_scheduler_entry_point">UmsSchedulerProc</a> entry
point function is called, the application's scheduler should retrieve items from the completion list by calling
<see cref="DequeueUmsCompletionListItems" />.</para>
      <para>Each completion list has an associated completion list event which is signaled whenever the system queues
items to an empty list. Use the
<see cref="GetUmsCompletionListEvent" /> to obtain a
handle to the event for a specified completion list.</para>
      <para>When a completion list is no longer needed, use the
<see cref="DeleteUmsCompletionList" /> to release the list.
The list must be empty before it can be released.</para>
    </remarks>
    <seealso cref="DequeueUmsCompletionListItems" />
    <seealso cref="EnterUmsSchedulingMode" />
    <seealso cref="GetUmsCompletionListEvent" />
  </member>
  <member name="Windows.CreateUmsThreadContext">
    <summary>
      <para>Creates a user-mode scheduling (UMS) thread context to represent a UMS worker thread.</para>
    </summary>
    <param name="lpUmsThread">
      <para>A PUMS_CONTEXT variable. On output, this parameter receives a pointer to a UMS thread context.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. Possible error values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Not enough memory is available to create the UMS thread context.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>A UMS thread context represents the state of a UMS worker thread. Thread contexts are used to specify UMS worker threads in function calls.</para>
      <para>A UMS worker thread is created by calling the <see cref="CreateRemoteThreadEx" /> function after using <see cref="InitializeProcThreadAttributeList" /> and <see cref="UpdateProcThreadAttribute" /> to prepare a list of UMS attributes for the thread.</para>
      <para>The underlying structures for a UMS thread context are managed by the system and should not be modified directly. To get and set information about a UMS worker thread, use the <see cref="QueryUmsThreadInformation" /> and <see cref="SetUmsThreadInformation" /> functions.</para>
      <para>After a UMS worker thread terminates, its thread context should be released by calling <see cref="DeleteUmsThreadContext" />.</para>
    </remarks>
    <seealso cref="CreateRemoteThreadEx" />
    <seealso cref="DeleteUmsThreadContext" />
    <seealso cref="InitializeProcThreadAttributeList" />
    <seealso cref="QueryUmsThreadInformation" />
    <seealso cref="SetUmsThreadInformation" />
    <seealso cref="UpdateProcThreadAttribute" />
  </member>
  <member name="Windows.DeactivateActCtx">
    <summary>
      <para>The
<b>DeactivateActCtx</b> function deactivates the activation context corresponding to the specified cookie.</para>
    </summary>
    <param name="dwFlags">
      <para>Flags that indicate how the deactivation is to occur.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>0</b>
          </description>
          <description>
            <para>If this value is set and the cookie specified in the <i>ulCookie</i> parameter is in the top frame of the activation stack, the activation context is popped from the stack and thereby deactivated.</para>
            <para>If this value is set and the cookie specified in the <i>ulCookie</i> parameter is not in the top frame of the activation stack, this function  searches down the stack for the cookie.</para>
            <para>If the cookie is found, a STATUS_SXS_EARLY_DEACTIVATION exception is thrown.</para>
            <para>If the cookie is not found, a STATUS_SXS_INVALID_DEACTIVATION exception is thrown.</para>
            <para>This value should be specified in most cases.</para>
          </description>
        </item>
        <item>
          <description>
            <b>DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION</b>
          </description>
          <description>
            <para>If this value is set and the cookie specified in the <i>ulCookie</i> parameter is in the top frame of the activation stack, the function  returns an ERROR_INVALID_PARAMETER error code. Call
<see cref="GetLastError" /> to obtain this code.</para>
            <para>If this value is set and the cookie is not on the activation stack, a STATUS_SXS_INVALID_DEACTIVATION exception will be thrown.</para>
            <para>If this value is set and the cookie is in a lower frame of the activation stack, all of the frames down to and including the frame the cookie is in is popped from the stack.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="ulCookie">
      <para>The ULONG_PTR that was passed into the call to
<see cref="ActivateActCtx" />. This value is used as a cookie to identify a specific activated activation context.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling
<see cref="GetLastError" />. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
    <remarks>
      <para>The deactivation of activation contexts must occur in the reverse order of activation. It can be understood as popping an activation context from a stack.</para>
    </remarks>
    <seealso cref="ActivateActCtx" />
  </member>
  <member name="Windows.DebugBreakProcess">
    <summary>
      <para>Causes a breakpoint exception to occur in the specified process. This allows the calling thread to signal the debugger to handle the exception.</para>
    </summary>
    <param name="Process">
      <para>A handle to the process.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the process is not being debugged, the function uses the search logic of a standard exception handler. In most cases, this causes the process to terminate because of an unhandled breakpoint exception.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/communicating-with-the-debugger">Communicating with the Debugger</seealso>
    <seealso cref="DebugBreak" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/debugging-functions">Debugging Functions</seealso>
  </member>
  <member name="Windows.DebugSetProcessKillOnExit">
    <summary>
      <para>Sets the action to be performed when the calling thread exits.</para>
    </summary>
    <param name="KillOnExit">
      <para>If this parameter is <b>TRUE</b>, the thread terminates all attached processes on exit (note that this is the default). Otherwise, the thread detaches from all processes being debugged on exit.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The calling thread must have established at least one debugging connection using the <see cref="CreateProcess" /> or <see cref="DebugActiveProcess" /> function before calling this function. <b>DebugSetProcessKillOnExit</b> affects all current and future debuggees connected to the calling thread. A thread can call this function multiple times to change the action as needed.</para>
    </remarks>
    <seealso cref="DebugActiveProcessStop" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/debugging-functions">Debugging Functions</seealso>
  </member>
  <member name="Windows.DecryptFile">
    <summary>
      <para>Decrypts an encrypted file or directory.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be decrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and <b>SYNCHRONIZE</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="dwReserved">
      <para>Reserved; must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>DecryptFile</b> function requires exclusive access to the file being decrypted, and will fail if another process is using the file. If the file is not encrypted,
<b>DecryptFile</b> simply returns a nonzero value, which indicates success.</para>
      <para>If <i>lpFileName</i> specifies a read-only file, the function fails and <see cref="GetLastError" /> returns <b>ERROR_FILE_READ_ONLY</b>. If <i>lpFileName</i> specifies a directory that contains a read-only file, the functions succeeds but the directory is not decrypted.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines DecryptFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="EncryptFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.DecryptFileA">
    <summary>
      <para>Decrypts an encrypted file or directory.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be decrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and <b>SYNCHRONIZE</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="dwReserved">
      <para>Reserved; must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>DecryptFile</b> function requires exclusive access to the file being decrypted, and will fail if another process is using the file. If the file is not encrypted,
<b>DecryptFile</b> simply returns a nonzero value, which indicates success.</para>
      <para>If <i>lpFileName</i> specifies a read-only file, the function fails and <see cref="GetLastError" /> returns <b>ERROR_FILE_READ_ONLY</b>. If <i>lpFileName</i> specifies a directory that contains a read-only file, the functions succeeds but the directory is not decrypted.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines DecryptFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="EncryptFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.DecryptFileW">
    <summary>
      <para>Decrypts an encrypted file or directory.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be decrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and <b>SYNCHRONIZE</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="dwReserved">
      <para>Reserved; must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>DecryptFile</b> function requires exclusive access to the file being decrypted, and will fail if another process is using the file. If the file is not encrypted,
<b>DecryptFile</b> simply returns a nonzero value, which indicates success.</para>
      <para>If <i>lpFileName</i> specifies a read-only file, the function fails and <see cref="GetLastError" /> returns <b>ERROR_FILE_READ_ONLY</b>. If <i>lpFileName</i> specifies a directory that contains a read-only file, the functions succeeds but the directory is not decrypted.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines DecryptFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="EncryptFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.DecryptFile">
    <summary>
      <para>Decrypts an encrypted file or directory.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be decrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and <b>SYNCHRONIZE</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="dwReserved">
      <para>Reserved; must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>DecryptFile</b> function requires exclusive access to the file being decrypted, and will fail if another process is using the file. If the file is not encrypted,
<b>DecryptFile</b> simply returns a nonzero value, which indicates success.</para>
      <para>If <i>lpFileName</i> specifies a read-only file, the function fails and <see cref="GetLastError" /> returns <b>ERROR_FILE_READ_ONLY</b>. If <i>lpFileName</i> specifies a directory that contains a read-only file, the functions succeeds but the directory is not decrypted.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines DecryptFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="EncryptFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.DecryptFileA">
    <summary>
      <para>Decrypts an encrypted file or directory.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be decrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and <b>SYNCHRONIZE</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="dwReserved">
      <para>Reserved; must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>DecryptFile</b> function requires exclusive access to the file being decrypted, and will fail if another process is using the file. If the file is not encrypted,
<b>DecryptFile</b> simply returns a nonzero value, which indicates success.</para>
      <para>If <i>lpFileName</i> specifies a read-only file, the function fails and <see cref="GetLastError" /> returns <b>ERROR_FILE_READ_ONLY</b>. If <i>lpFileName</i> specifies a directory that contains a read-only file, the functions succeeds but the directory is not decrypted.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines DecryptFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="EncryptFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.DecryptFileW">
    <summary>
      <para>Decrypts an encrypted file or directory.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be decrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and <b>SYNCHRONIZE</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="dwReserved">
      <para>Reserved; must be zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>DecryptFile</b> function requires exclusive access to the file being decrypted, and will fail if another process is using the file. If the file is not encrypted,
<b>DecryptFile</b> simply returns a nonzero value, which indicates success.</para>
      <para>If <i>lpFileName</i> specifies a read-only file, the function fails and <see cref="GetLastError" /> returns <b>ERROR_FILE_READ_ONLY</b>. If <i>lpFileName</i> specifies a directory that contains a read-only file, the functions succeeds but the directory is not decrypted.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines DecryptFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="EncryptFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.DefineDosDevice">
    <summary>
      <para>Defines, redefines, or deletes MS-DOS device names.</para>
    </summary>
    <param name="dwFlags">
      <para>The controllable aspects of the <b>DefineDosDevice</b> function. This parameter
can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_EXACT_MATCH_ON_REMOVE</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is specified along with <b>DDD_REMOVE_DEFINITION</b>, the function will
use an exact match to determine which mapping to remove. Use this value to ensure that you do not delete
something that you did not define.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_NO_BROADCAST_SYSTEM</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Do not broadcast the <a href="https://docs.microsoft.com//windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message.
By default, this message is broadcast to notify the shell and applications of the change.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_RAW_TARGET_PATH</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Uses the <i>lpTargetPath</i> string as is. Otherwise, it is converted from an MS-DOS
path to a path.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_REMOVE_DEFINITION</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Removes the specified definition for the specified device. To determine which definition to remove, the
function walks the list of mappings for the device, looking for a match of
<i>lpTargetPath</i> against a prefix of each mapping associated with this device. The
first mapping that matches is the one removed, and then the function returns.</para>
            <para>If <i>lpTargetPath</i> is <b>NULL</b> or a pointer to a
<b>NULL</b> string, the function will remove the first mapping associated with the device
and pop the most recent one pushed. If there is nothing left to pop, the device name will be removed.</para>
            <para>If this value is not specified, the string pointed to by the <i>lpTargetPath</i></para>
            <para>parameter will become the new mapping for this device.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpDeviceName">
      <para>A pointer to an MS-DOS device name string specifying the device the function is defining, redefining, or
deleting. The device name string must not have a colon as the last character, unless a drive letter is being
defined, redefined, or deleted. For example, drive C  would be the string "C:". In no case is a
trailing backslash ("") allowed.</para>
    </param>
    <param name="lpTargetPath">
      <para>A pointer to a path string that will implement this device. The string is an MS-DOS path string unless the
<b>DDD_RAW_TARGET_PATH</b> flag is specified, in which case this string is a path
string.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path
into a corresponding path uses these junctions to map MS-DOS devices and drive letters. The
<b>DefineDosDevice</b> function enables an application to modify the junctions used to
implement the MS-DOS device namespace.</para>
      <para>To retrieve the current mapping for a particular MS-DOS device name or to obtain a list of all MS-DOS devices
known to the system, use the <see cref="QueryDosDevice" /></para>
      <para>function.</para>
      <para>To define a drive letter assignment that is persistent across boots and not a network share, use the
<see cref="SetVolumeMountPoint" /> function. If the volume to
be mounted already has a drive letter assigned to it, use the
<see cref="DeleteVolumeMountPoint" /> function to remove the
assignment.</para>
      <para>Drive letters and device names defined at system boot time are protected from redefinition and deletion unless
the user is an administrator.</para>
      <para>Starting with Windows XP, this function creates a device name for a caller that is not running in
the "LocalSystem" context in its own Local MS-DOS device namespace. If the caller  is running in
the "LocalSystem" context, the function creates the device name in the Global MS-DOS device
namespace. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a> and
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. For CsvFs, a new name will not be replicated to the other nodes on the cluster.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/editing-drive-letter-assignments">Editing Drive Letter Assignments</a>.</para>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="QueryDosDevice" />
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.DefineDosDeviceA">
    <summary>
      <para>Defines, redefines, or deletes MS-DOS device names.</para>
    </summary>
    <param name="dwFlags">
      <para>The controllable aspects of the <b>DefineDosDevice</b> function. This parameter
can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_EXACT_MATCH_ON_REMOVE</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is specified along with <b>DDD_REMOVE_DEFINITION</b>, the function will
use an exact match to determine which mapping to remove. Use this value to ensure that you do not delete
something that you did not define.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_NO_BROADCAST_SYSTEM</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Do not broadcast the <a href="https://docs.microsoft.com//windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message.
By default, this message is broadcast to notify the shell and applications of the change.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_RAW_TARGET_PATH</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Uses the <i>lpTargetPath</i> string as is. Otherwise, it is converted from an MS-DOS
path to a path.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_REMOVE_DEFINITION</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Removes the specified definition for the specified device. To determine which definition to remove, the
function walks the list of mappings for the device, looking for a match of
<i>lpTargetPath</i> against a prefix of each mapping associated with this device. The
first mapping that matches is the one removed, and then the function returns.</para>
            <para>If <i>lpTargetPath</i> is <b>NULL</b> or a pointer to a
<b>NULL</b> string, the function will remove the first mapping associated with the device
and pop the most recent one pushed. If there is nothing left to pop, the device name will be removed.</para>
            <para>If this value is not specified, the string pointed to by the <i>lpTargetPath</i></para>
            <para>parameter will become the new mapping for this device.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpDeviceName">
      <para>A pointer to an MS-DOS device name string specifying the device the function is defining, redefining, or
deleting. The device name string must not have a colon as the last character, unless a drive letter is being
defined, redefined, or deleted. For example, drive C  would be the string "C:". In no case is a
trailing backslash ("") allowed.</para>
    </param>
    <param name="lpTargetPath">
      <para>A pointer to a path string that will implement this device. The string is an MS-DOS path string unless the
<b>DDD_RAW_TARGET_PATH</b> flag is specified, in which case this string is a path
string.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path
into a corresponding path uses these junctions to map MS-DOS devices and drive letters. The
<b>DefineDosDevice</b> function enables an application to modify the junctions used to
implement the MS-DOS device namespace.</para>
      <para>To retrieve the current mapping for a particular MS-DOS device name or to obtain a list of all MS-DOS devices
known to the system, use the <see cref="QueryDosDevice" /></para>
      <para>function.</para>
      <para>To define a drive letter assignment that is persistent across boots and not a network share, use the
<see cref="SetVolumeMountPoint" /> function. If the volume to
be mounted already has a drive letter assigned to it, use the
<see cref="DeleteVolumeMountPoint" /> function to remove the
assignment.</para>
      <para>Drive letters and device names defined at system boot time are protected from redefinition and deletion unless
the user is an administrator.</para>
      <para>Starting with Windows XP, this function creates a device name for a caller that is not running in
the "LocalSystem" context in its own Local MS-DOS device namespace. If the caller  is running in
the "LocalSystem" context, the function creates the device name in the Global MS-DOS device
namespace. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a> and
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. For CsvFs, a new name will not be replicated to the other nodes on the cluster.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/editing-drive-letter-assignments">Editing Drive Letter Assignments</a>.</para>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="QueryDosDevice" />
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.DefineDosDeviceW">
    <summary>
      <para>Defines, redefines, or deletes MS-DOS device names.</para>
    </summary>
    <param name="dwFlags">
      <para>The controllable aspects of the <b>DefineDosDevice</b> function. This parameter
can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_EXACT_MATCH_ON_REMOVE</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>If this value is specified along with <b>DDD_REMOVE_DEFINITION</b>, the function will
use an exact match to determine which mapping to remove. Use this value to ensure that you do not delete
something that you did not define.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_NO_BROADCAST_SYSTEM</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Do not broadcast the <a href="https://docs.microsoft.com//windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message.
By default, this message is broadcast to notify the shell and applications of the change.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_RAW_TARGET_PATH</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Uses the <i>lpTargetPath</i> string as is. Otherwise, it is converted from an MS-DOS
path to a path.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>DDD_REMOVE_DEFINITION</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Removes the specified definition for the specified device. To determine which definition to remove, the
function walks the list of mappings for the device, looking for a match of
<i>lpTargetPath</i> against a prefix of each mapping associated with this device. The
first mapping that matches is the one removed, and then the function returns.</para>
            <para>If <i>lpTargetPath</i> is <b>NULL</b> or a pointer to a
<b>NULL</b> string, the function will remove the first mapping associated with the device
and pop the most recent one pushed. If there is nothing left to pop, the device name will be removed.</para>
            <para>If this value is not specified, the string pointed to by the <i>lpTargetPath</i></para>
            <para>parameter will become the new mapping for this device.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpDeviceName">
      <para>A pointer to an MS-DOS device name string specifying the device the function is defining, redefining, or
deleting. The device name string must not have a colon as the last character, unless a drive letter is being
defined, redefined, or deleted. For example, drive C  would be the string "C:". In no case is a
trailing backslash ("") allowed.</para>
    </param>
    <param name="lpTargetPath">
      <para>A pointer to a path string that will implement this device. The string is an MS-DOS path string unless the
<b>DDD_RAW_TARGET_PATH</b> flag is specified, in which case this string is a path
string.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path
into a corresponding path uses these junctions to map MS-DOS devices and drive letters. The
<b>DefineDosDevice</b> function enables an application to modify the junctions used to
implement the MS-DOS device namespace.</para>
      <para>To retrieve the current mapping for a particular MS-DOS device name or to obtain a list of all MS-DOS devices
known to the system, use the <see cref="QueryDosDevice" /></para>
      <para>function.</para>
      <para>To define a drive letter assignment that is persistent across boots and not a network share, use the
<see cref="SetVolumeMountPoint" /> function. If the volume to
be mounted already has a drive letter assigned to it, use the
<see cref="DeleteVolumeMountPoint" /> function to remove the
assignment.</para>
      <para>Drive letters and device names defined at system boot time are protected from redefinition and deletion unless
the user is an administrator.</para>
      <para>Starting with Windows XP, this function creates a device name for a caller that is not running in
the "LocalSystem" context in its own Local MS-DOS device namespace. If the caller  is running in
the "LocalSystem" context, the function creates the device name in the Global MS-DOS device
namespace. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a> and
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. For CsvFs, a new name will not be replicated to the other nodes on the cluster.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/editing-drive-letter-assignments">Editing Drive Letter Assignments</a>.</para>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="QueryDosDevice" />
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.DeleteAtom">
    <summary>
      <para>Decrements the reference count of a local string atom. If the atom's reference count is reduced to zero, <b>DeleteAtom</b> removes the string associated with the atom from the local atom table.</para>
    </summary>
    <param name="nAtom">
      <para>Type: <b>ATOM</b></para>
      <para>The atom to be deleted.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is zero.</para>
      <para>If the function fails, the return value is the
<i>nAtom</i> parameter. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>A string atom's reference count specifies the number of times the atom has been added to the atom table. The <see cref="AddAtom" /> function increments the count on each call. The <b>DeleteAtom</b> function decrements the count on each call but removes the string only if the atom's reference count is zero.</para>
      <para>Each call to <see cref="AddAtom" /> should have a corresponding call to <b>DeleteAtom</b>. Do not call <b>DeleteAtom</b> more times than you call <b>AddAtom</b>, or you may delete the atom while other clients are using it.</para>
      <para>The <b>DeleteAtom</b> function has no effect on an integer atom (an atom whose value is in the range 0x0001 to 0xBFFF). The function always returns zero for an integer atom.</para>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.DeleteFiber">
    <summary>
      <para>Deletes an existing fiber.</para>
    </summary>
    <param name="lpFiber">
      <para>The address of the fiber to be deleted.</para>
    </param>
    <remarks>
      <para>The
<b>DeleteFiber</b> function deletes all data associated with the fiber. This data includes the stack, a subset of the registers, and the fiber data.</para>
      <para>If the currently running fiber calls
<b>DeleteFiber</b>, its thread calls
<see cref="ExitThread" /> and terminates. However, if a currently running fiber is deleted by another fiber, the thread running the deleted fiber is likely to terminate abnormally because the fiber stack has been freed.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/using-fibers">Using Fibers</a>.</para>
    </remarks>
    <seealso cref="ExitThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/fibers">Fibers</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
  </member>
  <member name="Windows.DeleteFile">
    <summary>
      <para>Deletes an existing file.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="DeleteFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be deleted.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>DeleteFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If an application attempts to delete a file that does not exist, the
<b>DeleteFile</b> function fails with
<b>ERROR_FILE_NOT_FOUND</b>. If the file is a read-only file, the function fails with
<b>ERROR_ACCESS_DENIED</b>.</para>
      <para>The following list identifies some tips for deleting, removing, or closing files:</para>
      <list type="bullet">
        <item>
          <description>To delete a read-only file, first you must remove the read-only attribute.</description>
        </item>
        <item>
          <description>To delete or rename a file, you must have either delete permission on the file, or delete child permission
in the parent directory.</description>
        </item>
        <item>
          <description>To recursively delete the files in a directory, use the
<see cref="SHFileOperation" /> function.</description>
        </item>
        <item>
          <description>To remove an empty directory, use the
<see cref="RemoveDirectory" /> function.</description>
        </item>
        <item>
          <description>To close an open file, use the
<see cref="CloseHandle" /> function.</description>
        </item>
      </list>
      <para>If you set up a directory with all access except delete and delete child, and the access control lists (ACL) of
new files are inherited, then you can create a file without being able to delete it. However, then you can create
a file, and then get all the access you request on the handle that is returned to you at the time you create the
file.</para>
      <para>If you request delete permission at the time you create a file, you can delete or rename the file with that
handle, but not with any other handle. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>The <b>DeleteFile</b> function fails if an application attempts
to delete a file that has other handles open for normal I/O or as a memory-mapped file
(<b>FILE_SHARE_DELETE</b> must have been specified when other handles were opened).</para>
      <para>The <b>DeleteFile</b> function marks a file for deletion on
close. Therefore, the file deletion does not occur until the last handle to the file is closed. Subsequent calls
to <see cref="CreateFile" /> to open the file fail with
<b>ERROR_ACCESS_DENIED</b>.</para>
      <para>Symbolic link behavior—</para>
      <para>If the path points to a symbolic link, the symbolic link is deleted, not the target. To delete a target, you
must call <see cref="CreateFile" /> and specify
<b>FILE_FLAG_DELETE_ON_CLOSE</b>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/locking-and-unlocking-byte-ranges-in-files">Locking and Unlocking Byte Ranges in Files</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFile" />
    <seealso cref="DeleteFileTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.DeleteFileA">
    <summary>
      <para>Deletes an existing file.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="DeleteFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be deleted.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>DeleteFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If an application attempts to delete a file that does not exist, the
<b>DeleteFile</b> function fails with
<b>ERROR_FILE_NOT_FOUND</b>. If the file is a read-only file, the function fails with
<b>ERROR_ACCESS_DENIED</b>.</para>
      <para>The following list identifies some tips for deleting, removing, or closing files:</para>
      <list type="bullet">
        <item>
          <description>To delete a read-only file, first you must remove the read-only attribute.</description>
        </item>
        <item>
          <description>To delete or rename a file, you must have either delete permission on the file, or delete child permission
in the parent directory.</description>
        </item>
        <item>
          <description>To recursively delete the files in a directory, use the
<see cref="SHFileOperation" /> function.</description>
        </item>
        <item>
          <description>To remove an empty directory, use the
<see cref="RemoveDirectory" /> function.</description>
        </item>
        <item>
          <description>To close an open file, use the
<see cref="CloseHandle" /> function.</description>
        </item>
      </list>
      <para>If you set up a directory with all access except delete and delete child, and the access control lists (ACL) of
new files are inherited, then you can create a file without being able to delete it. However, then you can create
a file, and then get all the access you request on the handle that is returned to you at the time you create the
file.</para>
      <para>If you request delete permission at the time you create a file, you can delete or rename the file with that
handle, but not with any other handle. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>The <b>DeleteFile</b> function fails if an application attempts
to delete a file that has other handles open for normal I/O or as a memory-mapped file
(<b>FILE_SHARE_DELETE</b> must have been specified when other handles were opened).</para>
      <para>The <b>DeleteFile</b> function marks a file for deletion on
close. Therefore, the file deletion does not occur until the last handle to the file is closed. Subsequent calls
to <see cref="CreateFile" /> to open the file fail with
<b>ERROR_ACCESS_DENIED</b>.</para>
      <para>Symbolic link behavior—</para>
      <para>If the path points to a symbolic link, the symbolic link is deleted, not the target. To delete a target, you
must call <see cref="CreateFile" /> and specify
<b>FILE_FLAG_DELETE_ON_CLOSE</b>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/locking-and-unlocking-byte-ranges-in-files">Locking and Unlocking Byte Ranges in Files</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFile" />
    <seealso cref="DeleteFileTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.DeleteFileW">
    <summary>
      <para>Deletes an existing file.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="DeleteFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be deleted.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>DeleteFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\?". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If an application attempts to delete a file that does not exist, the
<b>DeleteFile</b> function fails with
<b>ERROR_FILE_NOT_FOUND</b>. If the file is a read-only file, the function fails with
<b>ERROR_ACCESS_DENIED</b>.</para>
      <para>The following list identifies some tips for deleting, removing, or closing files:</para>
      <list type="bullet">
        <item>
          <description>To delete a read-only file, first you must remove the read-only attribute.</description>
        </item>
        <item>
          <description>To delete or rename a file, you must have either delete permission on the file, or delete child permission
in the parent directory.</description>
        </item>
        <item>
          <description>To recursively delete the files in a directory, use the
<see cref="SHFileOperation" /> function.</description>
        </item>
        <item>
          <description>To remove an empty directory, use the
<see cref="RemoveDirectory" /> function.</description>
        </item>
        <item>
          <description>To close an open file, use the
<see cref="CloseHandle" /> function.</description>
        </item>
      </list>
      <para>If you set up a directory with all access except delete and delete child, and the access control lists (ACL) of
new files are inherited, then you can create a file without being able to delete it. However, then you can create
a file, and then get all the access you request on the handle that is returned to you at the time you create the
file.</para>
      <para>If you request delete permission at the time you create a file, you can delete or rename the file with that
handle, but not with any other handle. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>The <b>DeleteFile</b> function fails if an application attempts
to delete a file that has other handles open for normal I/O or as a memory-mapped file
(<b>FILE_SHARE_DELETE</b> must have been specified when other handles were opened).</para>
      <para>The <b>DeleteFile</b> function marks a file for deletion on
close. Therefore, the file deletion does not occur until the last handle to the file is closed. Subsequent calls
to <see cref="CreateFile" /> to open the file fail with
<b>ERROR_ACCESS_DENIED</b>.</para>
      <para>Symbolic link behavior—</para>
      <para>If the path points to a symbolic link, the symbolic link is deleted, not the target. To delete a target, you
must call <see cref="CreateFile" /> and specify
<b>FILE_FLAG_DELETE_ON_CLOSE</b>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/locking-and-unlocking-byte-ranges-in-files">Locking and Unlocking Byte Ranges in Files</a>.</para>
    </remarks>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFile" />
    <seealso cref="DeleteFileTransacted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.DeleteUmsCompletionList">
    <summary>
      <para>Deletes the specified user-mode scheduling (UMS) completion list. The list must be empty.</para>
    </summary>
    <param name="UmsCompletionList">
      <para>A pointer to the UMS completion list to be deleted. The <see cref="CreateUmsCompletionList" /> function provides this pointer.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the completion list is shared, the caller is responsible for ensuring that no active UMS thread holds a reference to the list before deleting it.</para>
    </remarks>
  </member>
  <member name="Windows.DeleteUmsThreadContext">
    <summary>
      <para>Deletes  the specified user-mode scheduling (UMS) thread context. The thread must be terminated.</para>
    </summary>
    <param name="UmsThread">
      <para>A pointer to the UMS thread context to be deleted. The <see cref="CreateUmsThreadContext" /> function provides this pointer.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>A UMS thread context cannot be deleted until the associated thread has terminated.</para>
      <para>When a UMS worker thread finishes running (for example, by returning from its thread entry point function),   the system terminates the thread,  sets the  termination status in the thread's UMS thread context, and queues the UMS thread context to the associated completion list.</para>
      <para>Any attempt to execute the  UMS thread will fail because the thread is already terminated.</para>
      <para>To check the termination status of a thread, the application's scheduler should call <see cref="QueryUmsThreadInformation" /> with the <b>UmsIsThreadTerminated</b> information class.</para>
    </remarks>
    <seealso cref="CreateUmsThreadContext" />
    <seealso cref="QueryUmsThreadInformation" />
  </member>
  <member name="Windows.DeleteVolumeMountPoint">
    <summary>
      <para>Deletes a drive letter or mounted folder.</para>
    </summary>
    <param name="lpszVolumeMountPoint">
      <para>The drive letter or mounted folder to be deleted. A trailing backslash is required, for example,
"X:" or "Y:\MountX".</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Deleting a mounted folder does not cause the underlying directory to be deleted.</para>
      <para>If the <i>lpszVolumeMountPoint</i> parameter is a directory that is not a mounted folder,
the function does nothing. The directory is not deleted.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. For CsvFs, a new mount point will not be replicated to the other nodes on the cluster.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/unmounting-a-volume-at-a-mount-point">Unmounting a Volume at a Mount Point</a>.</para>
    </remarks>
    <seealso cref="GetVolumeNameForVolumeMountPoint" />
    <seealso cref="GetVolumePathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.DeleteVolumeMountPointA">
    <summary>
      <para>Deletes a drive letter or mounted folder.</para>
    </summary>
    <param name="lpszVolumeMountPoint">
      <para>The drive letter or mounted folder to be deleted. A trailing backslash is required, for example,
"X:" or "Y:\MountX".</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Deleting a mounted folder does not cause the underlying directory to be deleted.</para>
      <para>If the <i>lpszVolumeMountPoint</i> parameter is a directory that is not a mounted folder,
the function does nothing. The directory is not deleted.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. For CsvFs, a new mount point will not be replicated to the other nodes on the cluster.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/unmounting-a-volume-at-a-mount-point">Unmounting a Volume at a Mount Point</a>.</para>
    </remarks>
    <seealso cref="GetVolumeNameForVolumeMountPoint" />
    <seealso cref="GetVolumePathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.DeleteVolumeMountPointW">
    <summary>
      <para>Deletes a drive letter or mounted folder.</para>
    </summary>
    <param name="lpszVolumeMountPoint">
      <para>The drive letter or mounted folder to be deleted. A trailing backslash is required, for example,
"X:" or "Y:\MountX".</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Deleting a mounted folder does not cause the underlying directory to be deleted.</para>
      <para>If the <i>lpszVolumeMountPoint</i> parameter is a directory that is not a mounted folder,
the function does nothing. The directory is not deleted.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. For CsvFs, a new mount point will not be replicated to the other nodes on the cluster.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/unmounting-a-volume-at-a-mount-point">Unmounting a Volume at a Mount Point</a>.</para>
    </remarks>
    <seealso cref="GetVolumeNameForVolumeMountPoint" />
    <seealso cref="GetVolumePathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.DequeueUmsCompletionListItems">
    <summary>
      <para>Retrieves user-mode scheduling (UMS) worker threads from the specified UMS completion list.</para>
    </summary>
    <param name="UmsCompletionList">
      <para>A pointer to the completion list from which to retrieve worker threads.</para>
    </param>
    <param name="WaitTimeOut">
      <para>The time-out interval for the retrieval operation, in milliseconds. The function returns if the interval elapses, even if no worker threads are queued to the completion list.</para>
      <para>If the <i>WaitTimeOut</i> parameter is zero, the completion list is checked for available worker threads without waiting for worker threads to become available. If the <i>WaitTimeOut</i> parameter is INFINITE, the function's time-out interval never elapses. This is not recommended, however, because it causes the function to block until one or more worker threads become available.</para>
    </param>
    <param name="UmsThreadList">
      <para>A pointer to a UMS_CONTEXT variable. On output, this parameter receives a pointer to the first UMS thread context in a list of UMS thread contexts.</para>
      <para>If no worker threads are available before the time-out specified by the <i>WaitTimeOut</i> parameter, this parameter is set to NULL.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. Possible error values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_TIMEOUT</b>
            </para>
          </description>
          <description>
            <para>No threads became available before the specified time-out interval elapsed.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The system queues a UMS worker thread to a completion list when the worker thread is created or when a previously blocked worker thread becomes unblocked. The <b>DequeueUmsCompletionListItems</b> function retrieves a pointer to a list of all thread contexts in the specified completion list. The <see cref="GetNextUmsListItem" /> function can be used to pop UMS thread contexts off the list into the scheduler's own ready thread queue. The scheduler is responsible for selecting threads to run based on priorities chosen by the application.</para>
      <para>Do not run UMS threads directly from the list provided by <b>DequeueUmsCompletionListItems</b>, or run a thread transferred from the list to  the ready thread queue before the list is completely empty. This can cause unpredictable behavior in the application.</para>
      <para>If more than one caller attempts to retrieve threads from a shared completion list, only the first caller retrieves the threads. For subsequent callers,  the <b>DequeueUmsCompletionListItems</b> function returns success but the <i>UmsThreadList</i> parameter is set to NULL.</para>
    </remarks>
    <seealso cref="GetNextUmsListItem" />
  </member>
  <member name="Windows.DeregisterEventSource">
    <summary>
      <para>Closes the specified event log.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log. The
<see cref="RegisterEventSource" /> function returns this handle.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-sources">Event Sources</seealso>
    <seealso cref="RegisterEventSource" />
  </member>
  <member name="Windows.DestroyThreadpoolEnvironment">
    <summary>
      <para>Deletes the specified callback environment. Call this function when the callback environment is no longer needed for creating new thread pool objects.</para>
    </summary>
    <param name="pcbe">
      <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="InitializeThreadpoolEnvironment" /> function returns this structure.</para>
    </param>
    <remarks>
      <para>This function is implemented as an inline function.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
    </remarks>
    <seealso cref="InitializeThreadpoolEnvironment" />
    <seealso cref="SetThreadpoolCallbackCleanupGroup" />
    <seealso cref="SetThreadpoolCallbackLibrary" />
    <seealso cref="SetThreadpoolCallbackPool" />
    <seealso cref="SetThreadpoolCallbackPriority" />
    <seealso cref="SetThreadpoolCallbackRunsLong" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-pools">Thread Pools</seealso>
  </member>
  <member name="Windows.DisableThreadProfiling">
    <summary>
      <para>Disables thread profiling.</para>
    </summary>
    <param name="PerformanceDataHandle">
      <para>The handle that the <see cref="EnableThreadProfiling" /> function returned.</para>
    </param>
    <returns>
      <para>Returns ERROR_SUCCESS if the call is successful; otherwise, a system error code (see Winerror.h).</para>
    </returns>
    <remarks>
      <para>You must call this function from the same thread that enabled profiling for the specified handle. You must call this function before exiting the thread; otherwise, you will leak resources (the resources are not reclaimed until the process exits).</para>
    </remarks>
    <seealso cref="EnableThreadProfiling" />
    <seealso cref="QueryThreadProfiling" />
  </member>
  <member name="Windows.DnsHostnameToComputerName">
    <summary>
      <para>Converts a DNS-style host name to a NetBIOS-style computer name.</para>
    </summary>
    <param name="Hostname">
      <para>The DNS name. If the DNS name is not a valid, translatable name, the function fails. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</a>.</para>
    </param>
    <param name="ComputerName">
      <para>A pointer to a buffer that receives the computer name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</para>
    </param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, receives the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails, <see cref="GetLastError" /> returns ERROR_MORE_DATA, and <i>nSize</i> receives the required buffer size, not including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_MORE_DATA</b>
            </para>
          </description>
          <description>
            <para>The <i>ComputerName</i> buffer is too small. The <i>nSize</i> parameter contains the number of bytes required to receive the name.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function performs a textual mapping of the name. This convention limits the names of computers to be the common subset of the names. (Specifically, the leftmost label of the DNS name is truncated to 15-bytes of OEM characters.) Therefore, do not use this function to convert a DNS domain name to a NetBIOS domain name. There is no textual mapping for domain names.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines DnsHostnameToComputerName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.DnsHostnameToComputerNameA">
    <summary>
      <para>Converts a DNS-style host name to a NetBIOS-style computer name.</para>
    </summary>
    <param name="Hostname">
      <para>The DNS name. If the DNS name is not a valid, translatable name, the function fails. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</a>.</para>
    </param>
    <param name="ComputerName">
      <para>A pointer to a buffer that receives the computer name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</para>
    </param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, receives the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails, <see cref="GetLastError" /> returns ERROR_MORE_DATA, and <i>nSize</i> receives the required buffer size, not including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_MORE_DATA</b>
            </para>
          </description>
          <description>
            <para>The <i>ComputerName</i> buffer is too small. The <i>nSize</i> parameter contains the number of bytes required to receive the name.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function performs a textual mapping of the name. This convention limits the names of computers to be the common subset of the names. (Specifically, the leftmost label of the DNS name is truncated to 15-bytes of OEM characters.) Therefore, do not use this function to convert a DNS domain name to a NetBIOS domain name. There is no textual mapping for domain names.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines DnsHostnameToComputerName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.DnsHostnameToComputerNameW">
    <summary>
      <para>Converts a DNS-style host name to a NetBIOS-style computer name.</para>
    </summary>
    <param name="Hostname">
      <para>The DNS name. If the DNS name is not a valid, translatable name, the function fails. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</a>.</para>
    </param>
    <param name="ComputerName">
      <para>A pointer to a buffer that receives the computer name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</para>
    </param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, receives the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails, <see cref="GetLastError" /> returns ERROR_MORE_DATA, and <i>nSize</i> receives the required buffer size, not including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_MORE_DATA</b>
            </para>
          </description>
          <description>
            <para>The <i>ComputerName</i> buffer is too small. The <i>nSize</i> parameter contains the number of bytes required to receive the name.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function performs a textual mapping of the name. This convention limits the names of computers to be the common subset of the names. (Specifically, the leftmost label of the DNS name is truncated to 15-bytes of OEM characters.) Therefore, do not use this function to convert a DNS domain name to a NetBIOS domain name. There is no textual mapping for domain names.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines DnsHostnameToComputerName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.DnsHostnameToComputerName">
    <summary>
      <para>Converts a DNS-style host name to a NetBIOS-style computer name.</para>
    </summary>
    <param name="Hostname">
      <para>The DNS name. If the DNS name is not a valid, translatable name, the function fails. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</a>.</para>
    </param>
    <param name="ComputerName">
      <para>A pointer to a buffer that receives the computer name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</para>
    </param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, receives the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails, <see cref="GetLastError" /> returns ERROR_MORE_DATA, and <i>nSize</i> receives the required buffer size, not including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_MORE_DATA</b>
            </para>
          </description>
          <description>
            <para>The <i>ComputerName</i> buffer is too small. The <i>nSize</i> parameter contains the number of bytes required to receive the name.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function performs a textual mapping of the name. This convention limits the names of computers to be the common subset of the names. (Specifically, the leftmost label of the DNS name is truncated to 15-bytes of OEM characters.) Therefore, do not use this function to convert a DNS domain name to a NetBIOS domain name. There is no textual mapping for domain names.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines DnsHostnameToComputerName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.DnsHostnameToComputerNameA">
    <summary>
      <para>Converts a DNS-style host name to a NetBIOS-style computer name.</para>
    </summary>
    <param name="Hostname">
      <para>The DNS name. If the DNS name is not a valid, translatable name, the function fails. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</a>.</para>
    </param>
    <param name="ComputerName">
      <para>A pointer to a buffer that receives the computer name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</para>
    </param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, receives the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails, <see cref="GetLastError" /> returns ERROR_MORE_DATA, and <i>nSize</i> receives the required buffer size, not including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_MORE_DATA</b>
            </para>
          </description>
          <description>
            <para>The <i>ComputerName</i> buffer is too small. The <i>nSize</i> parameter contains the number of bytes required to receive the name.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function performs a textual mapping of the name. This convention limits the names of computers to be the common subset of the names. (Specifically, the leftmost label of the DNS name is truncated to 15-bytes of OEM characters.) Therefore, do not use this function to convert a DNS domain name to a NetBIOS domain name. There is no textual mapping for domain names.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines DnsHostnameToComputerName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.DnsHostnameToComputerNameW">
    <summary>
      <para>Converts a DNS-style host name to a NetBIOS-style computer name.</para>
    </summary>
    <param name="Hostname">
      <para>The DNS name. If the DNS name is not a valid, translatable name, the function fails. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</a>.</para>
    </param>
    <param name="ComputerName">
      <para>A pointer to a buffer that receives the computer name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</para>
    </param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, receives the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails, <see cref="GetLastError" /> returns ERROR_MORE_DATA, and <i>nSize</i> receives the required buffer size, not including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_MORE_DATA</b>
            </para>
          </description>
          <description>
            <para>The <i>ComputerName</i> buffer is too small. The <i>nSize</i> parameter contains the number of bytes required to receive the name.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function performs a textual mapping of the name. This convention limits the names of computers to be the common subset of the names. (Specifically, the leftmost label of the DNS name is truncated to 15-bytes of OEM characters.) Therefore, do not use this function to convert a DNS domain name to a NetBIOS domain name. There is no textual mapping for domain names.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines DnsHostnameToComputerName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.DosDateTimeToFileTime">
    <summary>
      <para>Converts MS-DOS date and time values to a file time.</para>
    </summary>
    <param name="wFatDate">
      <para>The MS-DOS date. The date is a packed value with the following format.</para>
      <list type="table">
        <listheader>
          <description>Bits</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>0-4</description>
          <description>Day of the month (1–31)</description>
        </item>
        <item>
          <description>5-8</description>
          <description>Month (1 = January, 2 = February, and so on)</description>
        </item>
        <item>
          <description>9-15</description>
          <description>Year offset from 1980 (add 1980 to get actual year)</description>
        </item>
      </list>
    </param>
    <param name="wFatTime">
      <para>The MS-DOS time. The time is a packed value with the following format.</para>
      <list type="table">
        <listheader>
          <description>Bits</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>0-4</description>
          <description>Second divided by 2</description>
        </item>
        <item>
          <description>5-10</description>
          <description>Minute (0–59)</description>
        </item>
        <item>
          <description>11-15</description>
          <description>Hour (0–23 on a 24-hour clock)</description>
        </item>
      </list>
    </param>
    <param name="lpFileTime">
      <para>A pointer to a
<see cref="FILETIME" /> structure that receives the converted file time.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="FILETIME" />
    <seealso cref="FileTimeToDosDateTime" />
    <seealso cref="FileTimeToSystemTime" />
    <seealso cref="SystemTimeToFileTime" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/time-functions">Time Functions</seealso>
  </member>
  <member name="Windows.EnableThreadProfiling">
    <summary>
      <para>Enables thread profiling on the specified thread.</para>
    </summary>
    <param name="ThreadHandle">
      <para>The handle to the thread on which you want to enable profiling. This must be the current thread.</para>
    </param>
    <param name="Flags">
      <para>To receive thread profiling data such as context switch count, set this parameter to THREAD_PROFILING_FLAG_DISPATCH; otherwise, set to 0.</para>
    </param>
    <param name="HardwareCounters">
      <para>To receive hardware performance counter data, set this parameter to a bitmask that identifies the hardware counters to collect. You can specify up to 16 performance counters. Each bit relates directly to the zero-based hardware counter index for the hardware performance counters that you configured. Set to zero if you are not collecting hardware counter data. If you set a bit for a hardware counter that has not been configured, the counter value that is read for that counter is zero.</para>
    </param>
    <param name="PerformanceDataHandle">
      <para>An opaque handle that you use when calling the <see cref="ReadThreadProfilingData" /> and <see cref="DisableThreadProfiling" /> functions.</para>
    </param>
    <returns>
      <para>Returns ERROR_SUCCESS if the call is successful; otherwise, a system error code (see Winerror.h).</para>
    </returns>
    <remarks>
      <para>You must call the <see cref="DisableThreadProfiling" /> function before exiting the thread.</para>
      <para>To profile hardware performance counters, you need a driver to configure the counters. The performance counters are configured globally for the system, so every thread has access to the same hardware counter data. The counters must be configured before you enable profiling. For information on configuring hardware performance counters, see the <b>KeSetHardwareCounterConfiguration</b> function in the Windows Driver Kit (WDK).</para>
    </remarks>
    <seealso cref="DisableThreadProfiling" />
    <seealso cref="QueryThreadProfiling" />
    <seealso cref="ReadThreadProfilingData" />
  </member>
  <member name="Windows.EncryptFile">
    <summary>
      <para>Encrypts a file or directory.  All data streams in a file are encrypted. All new files
created in an encrypted directory are encrypted.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be encrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>,
<b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and
<b>SYNCHRONIZE</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>EncryptFile</b> function requires exclusive access to
the file being encrypted, and will fail if another process is using the file.</para>
      <para>If the file is already encrypted, <b>EncryptFile</b> simply
returns a nonzero value, which indicates success. If the file is compressed,
<b>EncryptFile</b> will decompress the file before encrypting
it.</para>
      <para>If <i>lpFileName</i> specifies a read-only file, the function fails and
<see cref="GetLastError" /> returns
<b>ERROR_FILE_READ_ONLY</b>. If <i>lpFileName</i> specifies a directory that
contains a read-only file, the functions succeeds but the directory is not encrypted.</para>
      <para>To decrypt an encrypted file, use the
<see cref="DecryptFile" /> function.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EncryptFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DecryptFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.EncryptFileA">
    <summary>
      <para>Encrypts a file or directory.  All data streams in a file are encrypted. All new files
created in an encrypted directory are encrypted.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be encrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>,
<b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and
<b>SYNCHRONIZE</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>EncryptFile</b> function requires exclusive access to
the file being encrypted, and will fail if another process is using the file.</para>
      <para>If the file is already encrypted, <b>EncryptFile</b> simply
returns a nonzero value, which indicates success. If the file is compressed,
<b>EncryptFile</b> will decompress the file before encrypting
it.</para>
      <para>If <i>lpFileName</i> specifies a read-only file, the function fails and
<see cref="GetLastError" /> returns
<b>ERROR_FILE_READ_ONLY</b>. If <i>lpFileName</i> specifies a directory that
contains a read-only file, the functions succeeds but the directory is not encrypted.</para>
      <para>To decrypt an encrypted file, use the
<see cref="DecryptFile" /> function.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EncryptFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DecryptFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.EncryptFileW">
    <summary>
      <para>Encrypts a file or directory.  All data streams in a file are encrypted. All new files
created in an encrypted directory are encrypted.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be encrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>,
<b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and
<b>SYNCHRONIZE</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>EncryptFile</b> function requires exclusive access to
the file being encrypted, and will fail if another process is using the file.</para>
      <para>If the file is already encrypted, <b>EncryptFile</b> simply
returns a nonzero value, which indicates success. If the file is compressed,
<b>EncryptFile</b> will decompress the file before encrypting
it.</para>
      <para>If <i>lpFileName</i> specifies a read-only file, the function fails and
<see cref="GetLastError" /> returns
<b>ERROR_FILE_READ_ONLY</b>. If <i>lpFileName</i> specifies a directory that
contains a read-only file, the functions succeeds but the directory is not encrypted.</para>
      <para>To decrypt an encrypted file, use the
<see cref="DecryptFile" /> function.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EncryptFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DecryptFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.EncryptFile">
    <summary>
      <para>Encrypts a file or directory.  All data streams in a file are encrypted. All new files
created in an encrypted directory are encrypted.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be encrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>,
<b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and
<b>SYNCHRONIZE</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>EncryptFile</b> function requires exclusive access to
the file being encrypted, and will fail if another process is using the file.</para>
      <para>If the file is already encrypted, <b>EncryptFile</b> simply
returns a nonzero value, which indicates success. If the file is compressed,
<b>EncryptFile</b> will decompress the file before encrypting
it.</para>
      <para>If <i>lpFileName</i> specifies a read-only file, the function fails and
<see cref="GetLastError" /> returns
<b>ERROR_FILE_READ_ONLY</b>. If <i>lpFileName</i> specifies a directory that
contains a read-only file, the functions succeeds but the directory is not encrypted.</para>
      <para>To decrypt an encrypted file, use the
<see cref="DecryptFile" /> function.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EncryptFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DecryptFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.EncryptFileA">
    <summary>
      <para>Encrypts a file or directory.  All data streams in a file are encrypted. All new files
created in an encrypted directory are encrypted.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be encrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>,
<b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and
<b>SYNCHRONIZE</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>EncryptFile</b> function requires exclusive access to
the file being encrypted, and will fail if another process is using the file.</para>
      <para>If the file is already encrypted, <b>EncryptFile</b> simply
returns a nonzero value, which indicates success. If the file is compressed,
<b>EncryptFile</b> will decompress the file before encrypting
it.</para>
      <para>If <i>lpFileName</i> specifies a read-only file, the function fails and
<see cref="GetLastError" /> returns
<b>ERROR_FILE_READ_ONLY</b>. If <i>lpFileName</i> specifies a directory that
contains a read-only file, the functions succeeds but the directory is not encrypted.</para>
      <para>To decrypt an encrypted file, use the
<see cref="DecryptFile" /> function.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EncryptFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DecryptFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.EncryptFileW">
    <summary>
      <para>Encrypts a file or directory.  All data streams in a file are encrypted. All new files
created in an encrypted directory are encrypted.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be encrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>,
<b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and
<b>SYNCHRONIZE</b> access rights. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>EncryptFile</b> function requires exclusive access to
the file being encrypted, and will fail if another process is using the file.</para>
      <para>If the file is already encrypted, <b>EncryptFile</b> simply
returns a nonzero value, which indicates success. If the file is compressed,
<b>EncryptFile</b> will decompress the file before encrypting
it.</para>
      <para>If <i>lpFileName</i> specifies a read-only file, the function fails and
<see cref="GetLastError" /> returns
<b>ERROR_FILE_READ_ONLY</b>. If <i>lpFileName</i> specifies a directory that
contains a read-only file, the functions succeeds but the directory is not encrypted.</para>
      <para>To decrypt an encrypted file, use the
<see cref="DecryptFile" /> function.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EncryptFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DecryptFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.EndUpdateResource">
    <summary>
      <para>Commits or discards changes made prior to a call to <see cref="UpdateResource" />.</para>
    </summary>
    <param name="hUpdate">
      <para>Type: <b>HANDLE</b></para>
      <para>A module handle returned by the <see cref="BeginUpdateResource" /> function, and used by <see cref="UpdateResource" />, referencing the file to be updated.</para>
    </param>
    <param name="fDiscard">
      <para>Type: <b>BOOL</b></para>
      <para>Indicates whether to write the resource updates to the file. If this parameter is <b>TRUE</b>, no changes are made. If it is <b>FALSE</b>, the changes are made: the resource updates will take effect.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the function succeeds; <b>FALSE</b> otherwise. If the function succeeds and <i>fDiscard</i> is <b>TRUE</b>, then no resource updates are made to the file; otherwise all successful resource updates are made to the file. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Before you call this function, make sure all file handles other than the one returned by <see cref="BeginUpdateResource" /> are closed.</para>
      <para>This function can update resources within modules that contain both code and resources. There are restrictions on resource updates in LN files and .mui files, both of which contain Resource Configuration data; details of the restrictions are in the reference for the <see cref="UpdateResource" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EndUpdateResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BeginUpdateResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="UpdateResource" />
  </member>
  <member name="Windows.EndUpdateResourceA">
    <summary>
      <para>Commits or discards changes made prior to a call to <see cref="UpdateResource" />.</para>
    </summary>
    <param name="hUpdate">
      <para>Type: <b>HANDLE</b></para>
      <para>A module handle returned by the <see cref="BeginUpdateResource" /> function, and used by <see cref="UpdateResource" />, referencing the file to be updated.</para>
    </param>
    <param name="fDiscard">
      <para>Type: <b>BOOL</b></para>
      <para>Indicates whether to write the resource updates to the file. If this parameter is <b>TRUE</b>, no changes are made. If it is <b>FALSE</b>, the changes are made: the resource updates will take effect.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the function succeeds; <b>FALSE</b> otherwise. If the function succeeds and <i>fDiscard</i> is <b>TRUE</b>, then no resource updates are made to the file; otherwise all successful resource updates are made to the file. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Before you call this function, make sure all file handles other than the one returned by <see cref="BeginUpdateResource" /> are closed.</para>
      <para>This function can update resources within modules that contain both code and resources. There are restrictions on resource updates in LN files and .mui files, both of which contain Resource Configuration data; details of the restrictions are in the reference for the <see cref="UpdateResource" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EndUpdateResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BeginUpdateResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="UpdateResource" />
  </member>
  <member name="Windows.EndUpdateResourceW">
    <summary>
      <para>Commits or discards changes made prior to a call to <see cref="UpdateResource" />.</para>
    </summary>
    <param name="hUpdate">
      <para>Type: <b>HANDLE</b></para>
      <para>A module handle returned by the <see cref="BeginUpdateResource" /> function, and used by <see cref="UpdateResource" />, referencing the file to be updated.</para>
    </param>
    <param name="fDiscard">
      <para>Type: <b>BOOL</b></para>
      <para>Indicates whether to write the resource updates to the file. If this parameter is <b>TRUE</b>, no changes are made. If it is <b>FALSE</b>, the changes are made: the resource updates will take effect.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the function succeeds; <b>FALSE</b> otherwise. If the function succeeds and <i>fDiscard</i> is <b>TRUE</b>, then no resource updates are made to the file; otherwise all successful resource updates are made to the file. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Before you call this function, make sure all file handles other than the one returned by <see cref="BeginUpdateResource" /> are closed.</para>
      <para>This function can update resources within modules that contain both code and resources. There are restrictions on resource updates in LN files and .mui files, both of which contain Resource Configuration data; details of the restrictions are in the reference for the <see cref="UpdateResource" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EndUpdateResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BeginUpdateResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="UpdateResource" />
  </member>
  <member name="Windows.EndUpdateResource">
    <summary>
      <para>Commits or discards changes made prior to a call to <see cref="UpdateResource" />.</para>
    </summary>
    <param name="hUpdate">
      <para>Type: <b>HANDLE</b></para>
      <para>A module handle returned by the <see cref="BeginUpdateResource" /> function, and used by <see cref="UpdateResource" />, referencing the file to be updated.</para>
    </param>
    <param name="fDiscard">
      <para>Type: <b>BOOL</b></para>
      <para>Indicates whether to write the resource updates to the file. If this parameter is <b>TRUE</b>, no changes are made. If it is <b>FALSE</b>, the changes are made: the resource updates will take effect.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the function succeeds; <b>FALSE</b> otherwise. If the function succeeds and <i>fDiscard</i> is <b>TRUE</b>, then no resource updates are made to the file; otherwise all successful resource updates are made to the file. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Before you call this function, make sure all file handles other than the one returned by <see cref="BeginUpdateResource" /> are closed.</para>
      <para>This function can update resources within modules that contain both code and resources. There are restrictions on resource updates in LN files and .mui files, both of which contain Resource Configuration data; details of the restrictions are in the reference for the <see cref="UpdateResource" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EndUpdateResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BeginUpdateResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="UpdateResource" />
  </member>
  <member name="Windows.EndUpdateResourceA">
    <summary>
      <para>Commits or discards changes made prior to a call to <see cref="UpdateResource" />.</para>
    </summary>
    <param name="hUpdate">
      <para>Type: <b>HANDLE</b></para>
      <para>A module handle returned by the <see cref="BeginUpdateResource" /> function, and used by <see cref="UpdateResource" />, referencing the file to be updated.</para>
    </param>
    <param name="fDiscard">
      <para>Type: <b>BOOL</b></para>
      <para>Indicates whether to write the resource updates to the file. If this parameter is <b>TRUE</b>, no changes are made. If it is <b>FALSE</b>, the changes are made: the resource updates will take effect.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the function succeeds; <b>FALSE</b> otherwise. If the function succeeds and <i>fDiscard</i> is <b>TRUE</b>, then no resource updates are made to the file; otherwise all successful resource updates are made to the file. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Before you call this function, make sure all file handles other than the one returned by <see cref="BeginUpdateResource" /> are closed.</para>
      <para>This function can update resources within modules that contain both code and resources. There are restrictions on resource updates in LN files and .mui files, both of which contain Resource Configuration data; details of the restrictions are in the reference for the <see cref="UpdateResource" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EndUpdateResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BeginUpdateResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="UpdateResource" />
  </member>
  <member name="Windows.EndUpdateResourceW">
    <summary>
      <para>Commits or discards changes made prior to a call to <see cref="UpdateResource" />.</para>
    </summary>
    <param name="hUpdate">
      <para>Type: <b>HANDLE</b></para>
      <para>A module handle returned by the <see cref="BeginUpdateResource" /> function, and used by <see cref="UpdateResource" />, referencing the file to be updated.</para>
    </param>
    <param name="fDiscard">
      <para>Type: <b>BOOL</b></para>
      <para>Indicates whether to write the resource updates to the file. If this parameter is <b>TRUE</b>, no changes are made. If it is <b>FALSE</b>, the changes are made: the resource updates will take effect.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the function succeeds; <b>FALSE</b> otherwise. If the function succeeds and <i>fDiscard</i> is <b>TRUE</b>, then no resource updates are made to the file; otherwise all successful resource updates are made to the file. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Before you call this function, make sure all file handles other than the one returned by <see cref="BeginUpdateResource" /> are closed.</para>
      <para>This function can update resources within modules that contain both code and resources. There are restrictions on resource updates in LN files and .mui files, both of which contain Resource Configuration data; details of the restrictions are in the reference for the <see cref="UpdateResource" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EndUpdateResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BeginUpdateResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="UpdateResource" />
  </member>
  <member name="Windows.EnterUmsSchedulingMode">
    <summary>
      <para>Converts the calling thread into a user-mode scheduling (UMS) scheduler thread.</para>
    </summary>
    <param name="SchedulerStartupInfo">
      <para>A pointer to a <see cref="UMS_SCHEDULER_STARTUP_INFO" /> structure that specifies UMS attributes for the thread, including a completion list and a <a href="https://docs.microsoft.com//windows/desktop/api/winnt/nc-winnt-rtl_ums_scheduler_entry_point">UmsSchedulerProc</a>     entry point function.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>An application's UMS scheduler creates one UMS scheduler thread for each processor that will be used to run UMS threads. The scheduler typically sets the affinity of the scheduler thread for a single processor, effectively reserving the processor for the use of that scheduler thread. For more information about thread affinity, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-processors">Multiple Processors</a>.</para>
      <para>When a UMS scheduler thread is created, the system calls the <a href="https://docs.microsoft.com//windows/desktop/api/winnt/nc-winnt-rtl_ums_scheduler_entry_point">UmsSchedulerProc</a> entry point function specified with the <b>EnterUmsSchedulingMode</b> function call.  The application's scheduler is responsible for finishing any application-specific initialization of the scheduler thread and selecting a UMS worker thread to run.</para>
      <para>The application's scheduler selects a UMS worker thread to run by calling <see cref="ExecuteUmsThread" /> with the worker thread's UMS thread context. The worker thread runs until it yields control by calling <see cref="UmsThreadYield" />, blocks, or terminates. The scheduler thread is then available to run another worker thread.</para>
      <para>A scheduler thread should continue to run until all of its worker threads reach a natural stopping point: that is, all worker threads have yielded, blocked, or  terminated.</para>
    </remarks>
    <seealso cref="ExecuteUmsThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-processors">Multiple Processors</seealso>
    <seealso cref="UMS_SCHEDULER_STARTUP_INFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winnt/nc-winnt-rtl_ums_scheduler_entry_point">UmsSchedulerProc</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/user-mode-scheduling">User-Mode Scheduling</seealso>
  </member>
  <member name="Windows.EnumResourceLanguages">
    <summary>
      <para>Enumerates language-specific resources, of the specified type and name, associated with a binary module.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to be searched. Starting with Windows Vista, if this is a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), then appropriate .mui files (if any exist) are included in the search. If this is a specific .mui file, only that file is searched for resources.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The type of resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-types">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESLANGPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource language. For more information, see <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648033(v=vs.85)">EnumResLangProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpType</i>) is <b>TRUE</b>, then <i>lpType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>Similarly, if <see cref="IS_INTRESOURCE" />(<i>lpName</i>) is <b>TRUE</b>, then <i>lpName</i> specifies the integer identifier of the given resource. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource.</para>
      <para>Starting with Windows Vista, the binary module is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration will also include resources from the corresponding language-specific resource files (.mui files) that contain localizable language resources.</para>
      <para>For each resource found, <b>EnumResourceLanguages</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the language identifier (see <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">Language Identifiers</a>) of the language for which a resource was found, as well as the various other parameters that were passed to <b>EnumResourceLanguages</b>.</para>
      <para>Alternately, applications can call <see cref="EnumResourceLanguagesEx" />, which provides more precise control of what resources are enumerated.</para>
      <para>The <b>EnumResourceLanguages</b> function continues to enumerate resource languages until the callback function returns <b>FALSE</b> or all resource languages have been enumerated.</para>
      <para>In Windows Vista and later, if  <i>hModule</i> specifies an LN file, then the resources enumerated can reside either in the LN file or in an .mui file associated with it.  If no .mui files are found, only resources from the LN file are returned.  Unlike <see cref="EnumResourceNames" /> and <see cref="EnumResourceTypes" />, this search will look at multiple .mui files. The enumeration begins with .mui files in the folders associated with <see cref="EnumUILanguages" />. These are followed by any other .mui files whose paths conform to the scheme described at <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">MUI Resource Management</a>. Finally, the file designated by <i>hModule</i> is also searched.</para>
      <para>The enumeration never includes duplicates: if a resource with the same name, type, and language is contained in both the LN file and in an .mui file, the resource will only be enumerated once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EnumResourceLanguages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648033(v=vs.85)">EnumResLangProc</seealso>
    <seealso cref="EnumResourceLanguagesEx" />
    <seealso cref="EnumResourceNames" />
    <seealso cref="EnumResourceTypes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceLanguagesA">
    <summary>
      <para>Enumerates language-specific resources, of the specified type and name, associated with a binary module.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to be searched. Starting with Windows Vista, if this is a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), then appropriate .mui files (if any exist) are included in the search. If this is a specific .mui file, only that file is searched for resources.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The type of resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-types">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESLANGPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource language. For more information, see <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648033(v=vs.85)">EnumResLangProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpType</i>) is <b>TRUE</b>, then <i>lpType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>Similarly, if <see cref="IS_INTRESOURCE" />(<i>lpName</i>) is <b>TRUE</b>, then <i>lpName</i> specifies the integer identifier of the given resource. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource.</para>
      <para>Starting with Windows Vista, the binary module is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration will also include resources from the corresponding language-specific resource files (.mui files) that contain localizable language resources.</para>
      <para>For each resource found, <b>EnumResourceLanguages</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the language identifier (see <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">Language Identifiers</a>) of the language for which a resource was found, as well as the various other parameters that were passed to <b>EnumResourceLanguages</b>.</para>
      <para>Alternately, applications can call <see cref="EnumResourceLanguagesEx" />, which provides more precise control of what resources are enumerated.</para>
      <para>The <b>EnumResourceLanguages</b> function continues to enumerate resource languages until the callback function returns <b>FALSE</b> or all resource languages have been enumerated.</para>
      <para>In Windows Vista and later, if  <i>hModule</i> specifies an LN file, then the resources enumerated can reside either in the LN file or in an .mui file associated with it.  If no .mui files are found, only resources from the LN file are returned.  Unlike <see cref="EnumResourceNames" /> and <see cref="EnumResourceTypes" />, this search will look at multiple .mui files. The enumeration begins with .mui files in the folders associated with <see cref="EnumUILanguages" />. These are followed by any other .mui files whose paths conform to the scheme described at <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">MUI Resource Management</a>. Finally, the file designated by <i>hModule</i> is also searched.</para>
      <para>The enumeration never includes duplicates: if a resource with the same name, type, and language is contained in both the LN file and in an .mui file, the resource will only be enumerated once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EnumResourceLanguages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648033(v=vs.85)">EnumResLangProc</seealso>
    <seealso cref="EnumResourceLanguagesEx" />
    <seealso cref="EnumResourceNames" />
    <seealso cref="EnumResourceTypes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceLanguagesW">
    <summary>
      <para>Enumerates language-specific resources, of the specified type and name, associated with a binary module.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to be searched. Starting with Windows Vista, if this is a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), then appropriate .mui files (if any exist) are included in the search. If this is a specific .mui file, only that file is searched for resources.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The type of resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-types">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESLANGPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource language. For more information, see <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648033(v=vs.85)">EnumResLangProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpType</i>) is <b>TRUE</b>, then <i>lpType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>Similarly, if <see cref="IS_INTRESOURCE" />(<i>lpName</i>) is <b>TRUE</b>, then <i>lpName</i> specifies the integer identifier of the given resource. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource.</para>
      <para>Starting with Windows Vista, the binary module is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration will also include resources from the corresponding language-specific resource files (.mui files) that contain localizable language resources.</para>
      <para>For each resource found, <b>EnumResourceLanguages</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the language identifier (see <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">Language Identifiers</a>) of the language for which a resource was found, as well as the various other parameters that were passed to <b>EnumResourceLanguages</b>.</para>
      <para>Alternately, applications can call <see cref="EnumResourceLanguagesEx" />, which provides more precise control of what resources are enumerated.</para>
      <para>The <b>EnumResourceLanguages</b> function continues to enumerate resource languages until the callback function returns <b>FALSE</b> or all resource languages have been enumerated.</para>
      <para>In Windows Vista and later, if  <i>hModule</i> specifies an LN file, then the resources enumerated can reside either in the LN file or in an .mui file associated with it.  If no .mui files are found, only resources from the LN file are returned.  Unlike <see cref="EnumResourceNames" /> and <see cref="EnumResourceTypes" />, this search will look at multiple .mui files. The enumeration begins with .mui files in the folders associated with <see cref="EnumUILanguages" />. These are followed by any other .mui files whose paths conform to the scheme described at <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">MUI Resource Management</a>. Finally, the file designated by <i>hModule</i> is also searched.</para>
      <para>The enumeration never includes duplicates: if a resource with the same name, type, and language is contained in both the LN file and in an .mui file, the resource will only be enumerated once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EnumResourceLanguages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648033(v=vs.85)">EnumResLangProc</seealso>
    <seealso cref="EnumResourceLanguagesEx" />
    <seealso cref="EnumResourceNames" />
    <seealso cref="EnumResourceTypes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceLanguages">
    <summary>
      <para>Enumerates language-specific resources, of the specified type and name, associated with a binary module.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to be searched. Starting with Windows Vista, if this is a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), then appropriate .mui files (if any exist) are included in the search. If this is a specific .mui file, only that file is searched for resources.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The type of resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-types">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESLANGPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource language. For more information, see <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648033(v=vs.85)">EnumResLangProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpType</i>) is <b>TRUE</b>, then <i>lpType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>Similarly, if <see cref="IS_INTRESOURCE" />(<i>lpName</i>) is <b>TRUE</b>, then <i>lpName</i> specifies the integer identifier of the given resource. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource.</para>
      <para>Starting with Windows Vista, the binary module is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration will also include resources from the corresponding language-specific resource files (.mui files) that contain localizable language resources.</para>
      <para>For each resource found, <b>EnumResourceLanguages</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the language identifier (see <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">Language Identifiers</a>) of the language for which a resource was found, as well as the various other parameters that were passed to <b>EnumResourceLanguages</b>.</para>
      <para>Alternately, applications can call <see cref="EnumResourceLanguagesEx" />, which provides more precise control of what resources are enumerated.</para>
      <para>The <b>EnumResourceLanguages</b> function continues to enumerate resource languages until the callback function returns <b>FALSE</b> or all resource languages have been enumerated.</para>
      <para>In Windows Vista and later, if  <i>hModule</i> specifies an LN file, then the resources enumerated can reside either in the LN file or in an .mui file associated with it.  If no .mui files are found, only resources from the LN file are returned.  Unlike <see cref="EnumResourceNames" /> and <see cref="EnumResourceTypes" />, this search will look at multiple .mui files. The enumeration begins with .mui files in the folders associated with <see cref="EnumUILanguages" />. These are followed by any other .mui files whose paths conform to the scheme described at <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">MUI Resource Management</a>. Finally, the file designated by <i>hModule</i> is also searched.</para>
      <para>The enumeration never includes duplicates: if a resource with the same name, type, and language is contained in both the LN file and in an .mui file, the resource will only be enumerated once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EnumResourceLanguages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648033(v=vs.85)">EnumResLangProc</seealso>
    <seealso cref="EnumResourceLanguagesEx" />
    <seealso cref="EnumResourceNames" />
    <seealso cref="EnumResourceTypes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceLanguagesA">
    <summary>
      <para>Enumerates language-specific resources, of the specified type and name, associated with a binary module.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to be searched. Starting with Windows Vista, if this is a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), then appropriate .mui files (if any exist) are included in the search. If this is a specific .mui file, only that file is searched for resources.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The type of resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-types">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESLANGPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource language. For more information, see <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648033(v=vs.85)">EnumResLangProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpType</i>) is <b>TRUE</b>, then <i>lpType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>Similarly, if <see cref="IS_INTRESOURCE" />(<i>lpName</i>) is <b>TRUE</b>, then <i>lpName</i> specifies the integer identifier of the given resource. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource.</para>
      <para>Starting with Windows Vista, the binary module is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration will also include resources from the corresponding language-specific resource files (.mui files) that contain localizable language resources.</para>
      <para>For each resource found, <b>EnumResourceLanguages</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the language identifier (see <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">Language Identifiers</a>) of the language for which a resource was found, as well as the various other parameters that were passed to <b>EnumResourceLanguages</b>.</para>
      <para>Alternately, applications can call <see cref="EnumResourceLanguagesEx" />, which provides more precise control of what resources are enumerated.</para>
      <para>The <b>EnumResourceLanguages</b> function continues to enumerate resource languages until the callback function returns <b>FALSE</b> or all resource languages have been enumerated.</para>
      <para>In Windows Vista and later, if  <i>hModule</i> specifies an LN file, then the resources enumerated can reside either in the LN file or in an .mui file associated with it.  If no .mui files are found, only resources from the LN file are returned.  Unlike <see cref="EnumResourceNames" /> and <see cref="EnumResourceTypes" />, this search will look at multiple .mui files. The enumeration begins with .mui files in the folders associated with <see cref="EnumUILanguages" />. These are followed by any other .mui files whose paths conform to the scheme described at <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">MUI Resource Management</a>. Finally, the file designated by <i>hModule</i> is also searched.</para>
      <para>The enumeration never includes duplicates: if a resource with the same name, type, and language is contained in both the LN file and in an .mui file, the resource will only be enumerated once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EnumResourceLanguages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648033(v=vs.85)">EnumResLangProc</seealso>
    <seealso cref="EnumResourceLanguagesEx" />
    <seealso cref="EnumResourceNames" />
    <seealso cref="EnumResourceTypes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceLanguagesW">
    <summary>
      <para>Enumerates language-specific resources, of the specified type and name, associated with a binary module.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>The handle to a module to be searched. Starting with Windows Vista, if this is a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), then appropriate .mui files (if any exist) are included in the search. If this is a specific .mui file, only that file is searched for resources.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The type of resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-types">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESLANGPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource language. For more information, see <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648033(v=vs.85)">EnumResLangProc</a>.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function. This parameter can be used in error checking.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" />(<i>lpType</i>) is <b>TRUE</b>, then <i>lpType</i> specifies the integer identifier of the given resource type. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>Similarly, if <see cref="IS_INTRESOURCE" />(<i>lpName</i>) is <b>TRUE</b>, then <i>lpName</i> specifies the integer identifier of the given resource. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource.</para>
      <para>Starting with Windows Vista, the binary module is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration will also include resources from the corresponding language-specific resource files (.mui files) that contain localizable language resources.</para>
      <para>For each resource found, <b>EnumResourceLanguages</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing the language identifier (see <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">Language Identifiers</a>) of the language for which a resource was found, as well as the various other parameters that were passed to <b>EnumResourceLanguages</b>.</para>
      <para>Alternately, applications can call <see cref="EnumResourceLanguagesEx" />, which provides more precise control of what resources are enumerated.</para>
      <para>The <b>EnumResourceLanguages</b> function continues to enumerate resource languages until the callback function returns <b>FALSE</b> or all resource languages have been enumerated.</para>
      <para>In Windows Vista and later, if  <i>hModule</i> specifies an LN file, then the resources enumerated can reside either in the LN file or in an .mui file associated with it.  If no .mui files are found, only resources from the LN file are returned.  Unlike <see cref="EnumResourceNames" /> and <see cref="EnumResourceTypes" />, this search will look at multiple .mui files. The enumeration begins with .mui files in the folders associated with <see cref="EnumUILanguages" />. These are followed by any other .mui files whose paths conform to the scheme described at <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">MUI Resource Management</a>. Finally, the file designated by <i>hModule</i> is also searched.</para>
      <para>The enumeration never includes duplicates: if a resource with the same name, type, and language is contained in both the LN file and in an .mui file, the resource will only be enumerated once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EnumResourceLanguages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648033(v=vs.85)">EnumResLangProc</seealso>
    <seealso cref="EnumResourceLanguagesEx" />
    <seealso cref="EnumResourceNames" />
    <seealso cref="EnumResourceTypes" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceTypes">
    <summary>
      <para>Enumerates resource types within a binary module. Starting with Windows Vista, this is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration also includes resources from one of the corresponding language-specific resource files (.mui files)—if one exists—that contain localizable language resources. It is also possible to use <i>hModule</i> to specify a .mui file, in which case only that file is searched for resource types.</para>
      <para>Alternately, applications can call <see cref="EnumResourceTypesEx" />, which provides more precise control over which resource files to enumerate.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to a module to be searched. This handle must be obtained through <see cref="LoadLibrary" /> or <see cref="LoadLibraryEx" />.</para>
      <para>See Remarks for more information.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESTYPEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource type. For more information, see the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648041(v=vs.85)">EnumResTypeProc</a> function.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For each resource type found, <b>EnumResourceTypes</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing each resource type it finds, as well as the various other parameters that were passed to <b>EnumResourceTypes</b>.</para>
      <para>
        <b>EnumResourceTypes</b> continues to enumerate resource types until the callback function returns <b>FALSE</b> or all resource types have been enumerated.</para>
      <para>Starting with Windows Vista, if <i>hModule</i> specifies an LN file, then the types enumerated correspond to resources that reside in the LN file and in the .mui file associated with it. If no .mui files are found, only types from the LN file are returned. The order in which .mui files are searched is the usual Resource Loader search order; see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a> for details. After one appropriate .mui file is found, the search does not continue further to other .mui files associated with the LN file, because all .mui files that correspond to a single LN file have the same set of resource types.</para>
      <para>The enumeration never includes duplicates: if a given resource type is contained in both the LN file and in an .mui file, the type is enumerated only once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EnumResourceTypes as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648041(v=vs.85)">EnumResTypeProc</seealso>
    <seealso cref="EnumResourceLanguages" />
    <seealso cref="EnumResourceNames" />
    <seealso cref="EnumResourceTypesEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceTypesA">
    <summary>
      <para>Enumerates resource types within a binary module. Starting with Windows Vista, this is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration also includes resources from one of the corresponding language-specific resource files (.mui files)—if one exists—that contain localizable language resources. It is also possible to use <i>hModule</i> to specify a .mui file, in which case only that file is searched for resource types.</para>
      <para>Alternately, applications can call <see cref="EnumResourceTypesEx" />, which provides more precise control over which resource files to enumerate.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to a module to be searched. This handle must be obtained through <see cref="LoadLibrary" /> or <see cref="LoadLibraryEx" />.</para>
      <para>See Remarks for more information.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESTYPEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource type. For more information, see the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648041(v=vs.85)">EnumResTypeProc</a> function.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For each resource type found, <b>EnumResourceTypes</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing each resource type it finds, as well as the various other parameters that were passed to <b>EnumResourceTypes</b>.</para>
      <para>
        <b>EnumResourceTypes</b> continues to enumerate resource types until the callback function returns <b>FALSE</b> or all resource types have been enumerated.</para>
      <para>Starting with Windows Vista, if <i>hModule</i> specifies an LN file, then the types enumerated correspond to resources that reside in the LN file and in the .mui file associated with it. If no .mui files are found, only types from the LN file are returned. The order in which .mui files are searched is the usual Resource Loader search order; see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a> for details. After one appropriate .mui file is found, the search does not continue further to other .mui files associated with the LN file, because all .mui files that correspond to a single LN file have the same set of resource types.</para>
      <para>The enumeration never includes duplicates: if a given resource type is contained in both the LN file and in an .mui file, the type is enumerated only once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EnumResourceTypes as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648041(v=vs.85)">EnumResTypeProc</seealso>
    <seealso cref="EnumResourceLanguages" />
    <seealso cref="EnumResourceNames" />
    <seealso cref="EnumResourceTypesEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceTypesW">
    <summary>
      <para>Enumerates resource types within a binary module. Starting with Windows Vista, this is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration also includes resources from one of the corresponding language-specific resource files (.mui files)—if one exists—that contain localizable language resources. It is also possible to use <i>hModule</i> to specify a .mui file, in which case only that file is searched for resource types.</para>
      <para>Alternately, applications can call <see cref="EnumResourceTypesEx" />, which provides more precise control over which resource files to enumerate.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to a module to be searched. This handle must be obtained through <see cref="LoadLibrary" /> or <see cref="LoadLibraryEx" />.</para>
      <para>See Remarks for more information.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESTYPEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource type. For more information, see the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648041(v=vs.85)">EnumResTypeProc</a> function.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For each resource type found, <b>EnumResourceTypes</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing each resource type it finds, as well as the various other parameters that were passed to <b>EnumResourceTypes</b>.</para>
      <para>
        <b>EnumResourceTypes</b> continues to enumerate resource types until the callback function returns <b>FALSE</b> or all resource types have been enumerated.</para>
      <para>Starting with Windows Vista, if <i>hModule</i> specifies an LN file, then the types enumerated correspond to resources that reside in the LN file and in the .mui file associated with it. If no .mui files are found, only types from the LN file are returned. The order in which .mui files are searched is the usual Resource Loader search order; see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a> for details. After one appropriate .mui file is found, the search does not continue further to other .mui files associated with the LN file, because all .mui files that correspond to a single LN file have the same set of resource types.</para>
      <para>The enumeration never includes duplicates: if a given resource type is contained in both the LN file and in an .mui file, the type is enumerated only once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EnumResourceTypes as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648041(v=vs.85)">EnumResTypeProc</seealso>
    <seealso cref="EnumResourceLanguages" />
    <seealso cref="EnumResourceNames" />
    <seealso cref="EnumResourceTypesEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceTypes">
    <summary>
      <para>Enumerates resource types within a binary module. Starting with Windows Vista, this is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration also includes resources from one of the corresponding language-specific resource files (.mui files)—if one exists—that contain localizable language resources. It is also possible to use <i>hModule</i> to specify a .mui file, in which case only that file is searched for resource types.</para>
      <para>Alternately, applications can call <see cref="EnumResourceTypesEx" />, which provides more precise control over which resource files to enumerate.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to a module to be searched. This handle must be obtained through <see cref="LoadLibrary" /> or <see cref="LoadLibraryEx" />.</para>
      <para>See Remarks for more information.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESTYPEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource type. For more information, see the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648041(v=vs.85)">EnumResTypeProc</a> function.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For each resource type found, <b>EnumResourceTypes</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing each resource type it finds, as well as the various other parameters that were passed to <b>EnumResourceTypes</b>.</para>
      <para>
        <b>EnumResourceTypes</b> continues to enumerate resource types until the callback function returns <b>FALSE</b> or all resource types have been enumerated.</para>
      <para>Starting with Windows Vista, if <i>hModule</i> specifies an LN file, then the types enumerated correspond to resources that reside in the LN file and in the .mui file associated with it. If no .mui files are found, only types from the LN file are returned. The order in which .mui files are searched is the usual Resource Loader search order; see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a> for details. After one appropriate .mui file is found, the search does not continue further to other .mui files associated with the LN file, because all .mui files that correspond to a single LN file have the same set of resource types.</para>
      <para>The enumeration never includes duplicates: if a given resource type is contained in both the LN file and in an .mui file, the type is enumerated only once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EnumResourceTypes as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648041(v=vs.85)">EnumResTypeProc</seealso>
    <seealso cref="EnumResourceLanguages" />
    <seealso cref="EnumResourceNames" />
    <seealso cref="EnumResourceTypesEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceTypesA">
    <summary>
      <para>Enumerates resource types within a binary module. Starting with Windows Vista, this is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration also includes resources from one of the corresponding language-specific resource files (.mui files)—if one exists—that contain localizable language resources. It is also possible to use <i>hModule</i> to specify a .mui file, in which case only that file is searched for resource types.</para>
      <para>Alternately, applications can call <see cref="EnumResourceTypesEx" />, which provides more precise control over which resource files to enumerate.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to a module to be searched. This handle must be obtained through <see cref="LoadLibrary" /> or <see cref="LoadLibraryEx" />.</para>
      <para>See Remarks for more information.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESTYPEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource type. For more information, see the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648041(v=vs.85)">EnumResTypeProc</a> function.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For each resource type found, <b>EnumResourceTypes</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing each resource type it finds, as well as the various other parameters that were passed to <b>EnumResourceTypes</b>.</para>
      <para>
        <b>EnumResourceTypes</b> continues to enumerate resource types until the callback function returns <b>FALSE</b> or all resource types have been enumerated.</para>
      <para>Starting with Windows Vista, if <i>hModule</i> specifies an LN file, then the types enumerated correspond to resources that reside in the LN file and in the .mui file associated with it. If no .mui files are found, only types from the LN file are returned. The order in which .mui files are searched is the usual Resource Loader search order; see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a> for details. After one appropriate .mui file is found, the search does not continue further to other .mui files associated with the LN file, because all .mui files that correspond to a single LN file have the same set of resource types.</para>
      <para>The enumeration never includes duplicates: if a given resource type is contained in both the LN file and in an .mui file, the type is enumerated only once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EnumResourceTypes as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648041(v=vs.85)">EnumResTypeProc</seealso>
    <seealso cref="EnumResourceLanguages" />
    <seealso cref="EnumResourceNames" />
    <seealso cref="EnumResourceTypesEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
  </member>
  <member name="Windows.EnumResourceTypesW">
    <summary>
      <para>Enumerates resource types within a binary module. Starting with Windows Vista, this is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration also includes resources from one of the corresponding language-specific resource files (.mui files)—if one exists—that contain localizable language resources. It is also possible to use <i>hModule</i> to specify a .mui file, in which case only that file is searched for resource types.</para>
      <para>Alternately, applications can call <see cref="EnumResourceTypesEx" />, which provides more precise control over which resource files to enumerate.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to a module to be searched. This handle must be obtained through <see cref="LoadLibrary" /> or <see cref="LoadLibraryEx" />.</para>
      <para>See Remarks for more information.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpEnumFunc">
      <para>Type: <b>ENUMRESTYPEPROC</b></para>
      <para>A pointer to the callback function to be called for each enumerated resource type. For more information, see the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648041(v=vs.85)">EnumResTypeProc</a> function.</para>
    </param>
    <param name="lParam">
      <para>Type: <b>LONG_PTR</b></para>
      <para>An application-defined value passed to the callback function.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For each resource type found, <b>EnumResourceTypes</b> calls an application-defined callback function <i>lpEnumFunc</i>, passing each resource type it finds, as well as the various other parameters that were passed to <b>EnumResourceTypes</b>.</para>
      <para>
        <b>EnumResourceTypes</b> continues to enumerate resource types until the callback function returns <b>FALSE</b> or all resource types have been enumerated.</para>
      <para>Starting with Windows Vista, if <i>hModule</i> specifies an LN file, then the types enumerated correspond to resources that reside in the LN file and in the .mui file associated with it. If no .mui files are found, only types from the LN file are returned. The order in which .mui files are searched is the usual Resource Loader search order; see <a href="https://docs.microsoft.com//windows/desktop/Intl/user-interface-language-management">User Interface Language Management</a> for details. After one appropriate .mui file is found, the search does not continue further to other .mui files associated with the LN file, because all .mui files that correspond to a single LN file have the same set of resource types.</para>
      <para>The enumeration never includes duplicates: if a given resource type is contained in both the LN file and in an .mui file, the type is enumerated only once.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Creating a Resource List</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines EnumResourceTypes as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms648041(v=vs.85)">EnumResTypeProc</seealso>
    <seealso cref="EnumResourceLanguages" />
    <seealso cref="EnumResourceNames" />
    <seealso cref="EnumResourceTypesEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
  </member>
  <member name="Windows.EraseTape">
    <summary>
      <para>The
<b>EraseTape</b> function erases all or part of a tape.</para>
    </summary>
    <param name="hDevice">
      <para>Handle to the device where the tape is to be erased. This handle is created by using the
<see cref="CreateFile" /> function.</para>
    </param>
    <param name="dwEraseType">
      <para>Erasing technique. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_ERASE_LONG</b>
                </description>
              </item>
              <item>
                <description>1L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Erases the tape from the current position to the end of the current partition.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_ERASE_SHORT</b>
                </description>
              </item>
              <item>
                <description>0L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Writes an erase gap or end-of-data marker at the current position.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="bImmediate">
      <para>If this parameter is <b>TRUE</b>, the function returns immediately; if it is <b>FALSE</b>, the function does not return until the erase operation has been completed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, it can return one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_BEGINNING_OF_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1102L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to access data before the beginning-of-medium marker failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_BUS_RESET</b>
                </description>
              </item>
              <item>
                <description>1111L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A reset condition was detected on the bus.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_DEVICE_NOT_PARTITIONED</b>
                </description>
              </item>
              <item>
                <description>1107L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The partition information could not be found when a tape was being loaded.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_END_OF_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1100L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The end-of-tape marker was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_FILEMARK_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1101L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A filemark was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_INVALID_BLOCK_LENGTH</b>
                </description>
              </item>
              <item>
                <description>1106L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The block size is incorrect on a new tape in a multivolume partition.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_MEDIA_CHANGED</b>
                </description>
              </item>
              <item>
                <description>1110L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape that was in the drive has been replaced or removed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NO_DATA_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1104L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The end-of-data marker was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NO_MEDIA_IN_DRIVE</b>
                </description>
              </item>
              <item>
                <description>1112L</description>
              </item>
            </list>
          </description>
          <description>
            <para>There is no media in the drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NOT_SUPPORTED</b>
                </description>
              </item>
              <item>
                <description>50L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape driver does not support a requested function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_PARTITION_FAILURE</b>
                </description>
              </item>
              <item>
                <description>1105L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape could not be partitioned.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_SETMARK_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1103L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A setmark was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_UNABLE_TO_LOCK_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1108L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to lock the ejection mechanism failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1109L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to unload the tape failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_WRITE_PROTECT</b>
                </description>
              </item>
              <item>
                <description>19L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The media is write protected.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Some tape devices do not support certain tape operations. To determine your tape device's capabilities, see your tape device documentation and use the
<see cref="GetTapeParameters" /> function.</para>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="GetTapeParameters" />
  </member>
  <member name="Windows.EscapeCommFunction">
    <summary>
      <para>Directs the specified communications device to perform an extended function.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the communications device. The
<see cref="CreateFile" /> function returns this handle.</para>
    </param>
    <param name="dwFunc">
      <para>The extended function to be performed. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CLRBREAK</b>
                </description>
              </item>
              <item>
                <description>9</description>
              </item>
            </list>
          </description>
          <description>
            <para>Restores character transmission and places the transmission line in a nonbreak state. The CLRBREAK extended function code is identical to the
<see cref="ClearCommBreak" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CLRDTR</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>Clears the DTR (data-terminal-ready) signal.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CLRRTS</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Clears the RTS (request-to-send) signal.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SETBREAK</b>
                </description>
              </item>
              <item>
                <description>8</description>
              </item>
            </list>
          </description>
          <description>
            <para>Suspends character transmission and places the transmission line in a break state until the
<see cref="ClearCommBreak" /> function is called (or
<b>EscapeCommFunction</b> is called with the CLRBREAK extended function code). The SETBREAK extended function code is identical to the
<see cref="SetCommBreak" /> function. Note that this extended function does not flush data that has not been transmitted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SETDTR</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sends the DTR (data-terminal-ready) signal.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SETRTS</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sends the RTS (request-to-send) signal.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SETXOFF</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Causes transmission to act as if an XOFF character has been received.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SETXON</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Causes transmission to act as if an XON character has been received.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="ClearCommBreak" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="CreateFile" />
    <seealso cref="SetCommBreak" />
  </member>
  <member name="Windows.ExecuteUmsThread">
    <summary>
      <para>Runs the specified UMS worker thread.</para>
    </summary>
    <param name="UmsThread">
      <para>A pointer to the UMS thread context of the worker thread to run.</para>
    </param>
    <returns>
      <para>If the function succeeds, it does not return a value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. Possible error codes include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_RETRY</b>
            </para>
          </description>
          <description>
            <para>The specified UMS worker thread is temporarily locked by the system. The caller can retry the operation.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>ExecuteUmsThread</b> function loads the state of the specified UMS worker thread over the state of the calling UMS scheduler thread so that the worker thread can run. The worker thread runs until it yields by calling the <see cref="UmsThreadYield" /> function, blocks, or terminates.</para>
      <para>When a worker thread yields or blocks, the system calls the scheduler thread's <a href="https://docs.microsoft.com//windows/desktop/api/winnt/nc-winnt-rtl_ums_scheduler_entry_point">UmsSchedulerProc</a> entry point function. When a previously blocked worker thread becomes unblocked, the system queues the worker thread to the completion list specified with the <see cref="UpdateProcThreadAttribute" /> function when the worker thread was created.</para>
      <para>The <b>ExecuteUmsThread</b> function does not return unless an error occurs. If the function returns ERROR_RETRY, the error is transitory and the operation can be retried.</para>
      <para>If the function returns an error other than ERROR_RETRY, the application's scheduler should check whether the thread is suspended or terminated by calling <see cref="QueryUmsThreadInformation" /> with <b>UmsThreadIsSuspended</b> or <b>UmsThreadIsTerminated</b>, respectively. Other possible errors include calling the function on a thread that is not   a UMS scheduler thread, passing an invalid UMS worker thread context, or specifying a worker thread that is already executing on another scheduler thread.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winnt/nc-winnt-rtl_ums_scheduler_entry_point">UmsSchedulerProc</seealso>
    <seealso cref="UmsThreadYield" />
    <seealso cref="UpdateProcThreadAttribute" />
  </member>
  <member name="Windows.FatalExit">
    <summary>
      <para>Transfers execution control to the debugger. The behavior of the debugger thereafter is specific to the type of debugger used.</para>
    </summary>
    <param name="ExitCode">
      <para>The error code associated with the exit.</para>
    </param>
    <returns>
      <para>This function does not return a value.</para>
    </returns>
    <remarks>
      <para>An application should only use
<b>FatalExit</b> for debugging purposes. It should not call the function in a retail version of the application because doing so will terminate the application.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/communicating-with-the-debugger">Communicating with the Debugger</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/debugging-functions">Debugging Functions</seealso>
    <seealso cref="FatalAppExit" />
  </member>
  <member name="Windows.FileEncryptionStatus">
    <summary>
      <para>Retrieves the encryption status of the specified file.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
    </param>
    <param name="lpStatus">
      <para>A pointer to a variable that receives the encryption status of the file. This parameter can be one of the
following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ENCRYPTABLE</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file can be encrypted.</para>
            <para>
              <b>Home, Home Premium, Starter, and ARM Editions of Windows:  </b>
              <b>FILE_ENCRYPTABLE</b> may be returned but EFS does not support encrypting files on
these editions of Windows.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_IS_ENCRYPTED</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_READ_ONLY</b>
                </description>
              </item>
              <item>
                <description>8</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a read-only file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ROOT_DIR</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a root directory. Root directories cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SYSTEM_ATTR</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a system file. System files cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SYSTEM_DIR</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a system directory. System directories cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SYSTEM_NOT_SUPPORT</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file system does not support file encryption.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_UNKNOWN</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>The encryption status is unknown. The file may be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_USER_DISALLOWED</b>
                </description>
              </item>
              <item>
                <description>7</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserved for future use.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FileEncryptionStatus as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EncryptFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.FileEncryptionStatusA">
    <summary>
      <para>Retrieves the encryption status of the specified file.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
    </param>
    <param name="lpStatus">
      <para>A pointer to a variable that receives the encryption status of the file. This parameter can be one of the
following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ENCRYPTABLE</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file can be encrypted.</para>
            <para>
              <b>Home, Home Premium, Starter, and ARM Editions of Windows:  </b>
              <b>FILE_ENCRYPTABLE</b> may be returned but EFS does not support encrypting files on
these editions of Windows.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_IS_ENCRYPTED</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_READ_ONLY</b>
                </description>
              </item>
              <item>
                <description>8</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a read-only file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ROOT_DIR</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a root directory. Root directories cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SYSTEM_ATTR</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a system file. System files cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SYSTEM_DIR</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a system directory. System directories cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SYSTEM_NOT_SUPPORT</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file system does not support file encryption.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_UNKNOWN</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>The encryption status is unknown. The file may be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_USER_DISALLOWED</b>
                </description>
              </item>
              <item>
                <description>7</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserved for future use.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FileEncryptionStatus as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EncryptFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.FileEncryptionStatusW">
    <summary>
      <para>Retrieves the encryption status of the specified file.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
    </param>
    <param name="lpStatus">
      <para>A pointer to a variable that receives the encryption status of the file. This parameter can be one of the
following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ENCRYPTABLE</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file can be encrypted.</para>
            <para>
              <b>Home, Home Premium, Starter, and ARM Editions of Windows:  </b>
              <b>FILE_ENCRYPTABLE</b> may be returned but EFS does not support encrypting files on
these editions of Windows.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_IS_ENCRYPTED</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_READ_ONLY</b>
                </description>
              </item>
              <item>
                <description>8</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a read-only file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ROOT_DIR</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a root directory. Root directories cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SYSTEM_ATTR</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a system file. System files cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SYSTEM_DIR</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a system directory. System directories cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SYSTEM_NOT_SUPPORT</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file system does not support file encryption.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_UNKNOWN</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>The encryption status is unknown. The file may be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_USER_DISALLOWED</b>
                </description>
              </item>
              <item>
                <description>7</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserved for future use.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FileEncryptionStatus as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EncryptFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.FileEncryptionStatus">
    <summary>
      <para>Retrieves the encryption status of the specified file.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
    </param>
    <param name="lpStatus">
      <para>A pointer to a variable that receives the encryption status of the file. This parameter can be one of the
following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ENCRYPTABLE</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file can be encrypted.</para>
            <para>
              <b>Home, Home Premium, Starter, and ARM Editions of Windows:  </b>
              <b>FILE_ENCRYPTABLE</b> may be returned but EFS does not support encrypting files on
these editions of Windows.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_IS_ENCRYPTED</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_READ_ONLY</b>
                </description>
              </item>
              <item>
                <description>8</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a read-only file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ROOT_DIR</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a root directory. Root directories cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SYSTEM_ATTR</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a system file. System files cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SYSTEM_DIR</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a system directory. System directories cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SYSTEM_NOT_SUPPORT</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file system does not support file encryption.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_UNKNOWN</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>The encryption status is unknown. The file may be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_USER_DISALLOWED</b>
                </description>
              </item>
              <item>
                <description>7</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserved for future use.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FileEncryptionStatus as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EncryptFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.FileEncryptionStatusA">
    <summary>
      <para>Retrieves the encryption status of the specified file.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
    </param>
    <param name="lpStatus">
      <para>A pointer to a variable that receives the encryption status of the file. This parameter can be one of the
following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ENCRYPTABLE</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file can be encrypted.</para>
            <para>
              <b>Home, Home Premium, Starter, and ARM Editions of Windows:  </b>
              <b>FILE_ENCRYPTABLE</b> may be returned but EFS does not support encrypting files on
these editions of Windows.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_IS_ENCRYPTED</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_READ_ONLY</b>
                </description>
              </item>
              <item>
                <description>8</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a read-only file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ROOT_DIR</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a root directory. Root directories cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SYSTEM_ATTR</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a system file. System files cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SYSTEM_DIR</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a system directory. System directories cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SYSTEM_NOT_SUPPORT</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file system does not support file encryption.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_UNKNOWN</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>The encryption status is unknown. The file may be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_USER_DISALLOWED</b>
                </description>
              </item>
              <item>
                <description>7</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserved for future use.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FileEncryptionStatus as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EncryptFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.FileEncryptionStatusW">
    <summary>
      <para>Retrieves the encryption status of the specified file.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
    </param>
    <param name="lpStatus">
      <para>A pointer to a variable that receives the encryption status of the file. This parameter can be one of the
following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ENCRYPTABLE</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file can be encrypted.</para>
            <para>
              <b>Home, Home Premium, Starter, and ARM Editions of Windows:  </b>
              <b>FILE_ENCRYPTABLE</b> may be returned but EFS does not support encrypting files on
these editions of Windows.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_IS_ENCRYPTED</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_READ_ONLY</b>
                </description>
              </item>
              <item>
                <description>8</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a read-only file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_ROOT_DIR</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a root directory. Root directories cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SYSTEM_ATTR</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a system file. System files cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SYSTEM_DIR</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is a system directory. System directories cannot be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SYSTEM_NOT_SUPPORT</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file system does not support file encryption.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_UNKNOWN</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>The encryption status is unknown. The file may be encrypted.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_USER_DISALLOWED</b>
                </description>
              </item>
              <item>
                <description>7</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserved for future use.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FileEncryptionStatus as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="EncryptFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.FileTimeToDosDateTime">
    <summary>
      <para>Converts a file time to MS-DOS date and time values.</para>
    </summary>
    <param name="lpFileTime">
      <para>A pointer to a
<see cref="FILETIME" /> structure containing the file time to convert to MS-DOS date and time format.</para>
    </param>
    <param name="lpFatDate">
      <para>A pointer to a variable to receive the MS-DOS date. The date is a packed value with the following format.</para>
      <list type="table">
        <listheader>
          <description>Bits</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>0–4</description>
          <description>Day of the month (1–31)</description>
        </item>
        <item>
          <description>5–8</description>
          <description>Month (1 = January, 2 = February, etc.)</description>
        </item>
        <item>
          <description>9-15</description>
          <description>Year offset from 1980 (add 1980 to get actual year)</description>
        </item>
      </list>
    </param>
    <param name="lpFatTime">
      <para>A pointer to a variable to receive the MS-DOS time. The time is a packed value with the following format.</para>
      <list type="table">
        <listheader>
          <description>Bits</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>0–4</description>
          <description>Second divided by 2</description>
        </item>
        <item>
          <description>5–10</description>
          <description>Minute (0–59)</description>
        </item>
        <item>
          <description>11–15</description>
          <description>Hour (0–23 on a 24-hour clock)</description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The MS-DOS date format can represent only dates between 1/1/1980 and 12/31/2107; this conversion fails if the input file time is outside this range.</para>
    </remarks>
    <seealso cref="DosDateTimeToFileTime" />
    <seealso cref="FileTimeToSystemTime" />
    <seealso cref="SystemTimeToFileTime" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/time-functions">Time Functions</seealso>
  </member>
  <member name="Windows.FindActCtxSectionGuid">
    <summary>
      <para>The
<b>FindActCtxSectionGuid</b> function retrieves information on a specific GUID in the current activation context and returns a
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure.</para>
    </summary>
    <param name="dwFlags">
      <para>Flags that determine how this function is to operate. Only the following flag is currently defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX</b>
          </description>
          <description>
            <para>This function returns the activation context handle where the redirection data was found in the <b>hActCtx</b> member of the
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure. The caller must use
<see cref="ReleaseActCtx" /> to release this activation context.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpExtensionGuid">
      <para>Reserved; must be null.</para>
    </param>
    <param name="ulSectionId">
      <para>Identifier of the section of the activation context in which to search for the specified GUID.</para>
      <para>The following are valid GUID section identifiers:</para>
      <list type="bullet">
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION</description>
        </item>
      </list>
      <para>The following is a valid GUID section identifier beginning with Windows Server 2003 and Windows XP with SP1:</para>
      <list type="bullet">
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES</description>
        </item>
      </list>
    </param>
    <param name="lpGuidToFind">
      <para>Pointer to a GUID to be used as the search criteria.</para>
    </param>
    <param name="ReturnedData">
      <para>Pointer to an
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure to be filled out with the requested GUID information.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling
<see cref="GetLastError" />. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
    <remarks>
      <para>This function should only be called by the Side-by-side API functions or COM methods. Applications should not directly call this function.</para>
    </remarks>
    <seealso cref="ACTCTX_SECTION_KEYED_DATA" />
    <seealso cref="FindActCtxSectionString" />
  </member>
  <member name="Windows.FindActCtxSectionString">
    <summary>
      <para>The
<b>FindActCtxSectionString</b> function retrieves information on a specific string in the current activation context and returns a
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure.</para>
    </summary>
    <param name="dwFlags">
      <para>Flags that determine how this function is to operate. Only the following flag is currently defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX</b>
          </description>
          <description>
            <para>This function returns the activation context handle where the redirection data was found in the <b>hActCtx</b> member of the
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure. The caller must use
<see cref="ReleaseActCtx" /> to release this activation context.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpExtensionGuid">
      <para>Reserved; must be null.</para>
    </param>
    <param name="ulSectionId">
      <para>Identifier of the string section of the activation context in which to search for the specific string.</para>
      <para>The following are valid string section identifiers:</para>
      <list type="bullet">
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION</description>
        </item>
      </list>
    </param>
    <param name="lpStringToFind">
      <para>Pointer to a null-terminated string to be used as the search criteria.</para>
    </param>
    <param name="ReturnedData">
      <para>Pointer to an
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure to be filled out with the requested string information.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling
<see cref="GetLastError" />. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
    <remarks>
      <para>This function should only be called by the Side-by-side API functions or COM methods. Applications should not directly call this function.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindActCtxSectionString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ACTCTX_SECTION_KEYED_DATA" />
    <seealso cref="FindActCtxSectionGuid" />
  </member>
  <member name="Windows.FindActCtxSectionStringA">
    <summary>
      <para>The
<b>FindActCtxSectionString</b> function retrieves information on a specific string in the current activation context and returns a
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure.</para>
    </summary>
    <param name="dwFlags">
      <para>Flags that determine how this function is to operate. Only the following flag is currently defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX</b>
          </description>
          <description>
            <para>This function returns the activation context handle where the redirection data was found in the <b>hActCtx</b> member of the
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure. The caller must use
<see cref="ReleaseActCtx" /> to release this activation context.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpExtensionGuid">
      <para>Reserved; must be null.</para>
    </param>
    <param name="ulSectionId">
      <para>Identifier of the string section of the activation context in which to search for the specific string.</para>
      <para>The following are valid string section identifiers:</para>
      <list type="bullet">
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION</description>
        </item>
      </list>
    </param>
    <param name="lpStringToFind">
      <para>Pointer to a null-terminated string to be used as the search criteria.</para>
    </param>
    <param name="ReturnedData">
      <para>Pointer to an
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure to be filled out with the requested string information.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling
<see cref="GetLastError" />. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
    <remarks>
      <para>This function should only be called by the Side-by-side API functions or COM methods. Applications should not directly call this function.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindActCtxSectionString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ACTCTX_SECTION_KEYED_DATA" />
    <seealso cref="FindActCtxSectionGuid" />
  </member>
  <member name="Windows.FindActCtxSectionStringW">
    <summary>
      <para>The
<b>FindActCtxSectionString</b> function retrieves information on a specific string in the current activation context and returns a
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure.</para>
    </summary>
    <param name="dwFlags">
      <para>Flags that determine how this function is to operate. Only the following flag is currently defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX</b>
          </description>
          <description>
            <para>This function returns the activation context handle where the redirection data was found in the <b>hActCtx</b> member of the
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure. The caller must use
<see cref="ReleaseActCtx" /> to release this activation context.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpExtensionGuid">
      <para>Reserved; must be null.</para>
    </param>
    <param name="ulSectionId">
      <para>Identifier of the string section of the activation context in which to search for the specific string.</para>
      <para>The following are valid string section identifiers:</para>
      <list type="bullet">
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION</description>
        </item>
      </list>
    </param>
    <param name="lpStringToFind">
      <para>Pointer to a null-terminated string to be used as the search criteria.</para>
    </param>
    <param name="ReturnedData">
      <para>Pointer to an
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure to be filled out with the requested string information.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling
<see cref="GetLastError" />. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
    <remarks>
      <para>This function should only be called by the Side-by-side API functions or COM methods. Applications should not directly call this function.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindActCtxSectionString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ACTCTX_SECTION_KEYED_DATA" />
    <seealso cref="FindActCtxSectionGuid" />
  </member>
  <member name="Windows.FindActCtxSectionString">
    <summary>
      <para>The
<b>FindActCtxSectionString</b> function retrieves information on a specific string in the current activation context and returns a
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure.</para>
    </summary>
    <param name="dwFlags">
      <para>Flags that determine how this function is to operate. Only the following flag is currently defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX</b>
          </description>
          <description>
            <para>This function returns the activation context handle where the redirection data was found in the <b>hActCtx</b> member of the
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure. The caller must use
<see cref="ReleaseActCtx" /> to release this activation context.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpExtensionGuid">
      <para>Reserved; must be null.</para>
    </param>
    <param name="ulSectionId">
      <para>Identifier of the string section of the activation context in which to search for the specific string.</para>
      <para>The following are valid string section identifiers:</para>
      <list type="bullet">
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION</description>
        </item>
      </list>
    </param>
    <param name="lpStringToFind">
      <para>Pointer to a null-terminated string to be used as the search criteria.</para>
    </param>
    <param name="ReturnedData">
      <para>Pointer to an
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure to be filled out with the requested string information.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling
<see cref="GetLastError" />. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
    <remarks>
      <para>This function should only be called by the Side-by-side API functions or COM methods. Applications should not directly call this function.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindActCtxSectionString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ACTCTX_SECTION_KEYED_DATA" />
    <seealso cref="FindActCtxSectionGuid" />
  </member>
  <member name="Windows.FindActCtxSectionStringA">
    <summary>
      <para>The
<b>FindActCtxSectionString</b> function retrieves information on a specific string in the current activation context and returns a
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure.</para>
    </summary>
    <param name="dwFlags">
      <para>Flags that determine how this function is to operate. Only the following flag is currently defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX</b>
          </description>
          <description>
            <para>This function returns the activation context handle where the redirection data was found in the <b>hActCtx</b> member of the
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure. The caller must use
<see cref="ReleaseActCtx" /> to release this activation context.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpExtensionGuid">
      <para>Reserved; must be null.</para>
    </param>
    <param name="ulSectionId">
      <para>Identifier of the string section of the activation context in which to search for the specific string.</para>
      <para>The following are valid string section identifiers:</para>
      <list type="bullet">
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION</description>
        </item>
      </list>
    </param>
    <param name="lpStringToFind">
      <para>Pointer to a null-terminated string to be used as the search criteria.</para>
    </param>
    <param name="ReturnedData">
      <para>Pointer to an
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure to be filled out with the requested string information.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling
<see cref="GetLastError" />. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
    <remarks>
      <para>This function should only be called by the Side-by-side API functions or COM methods. Applications should not directly call this function.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindActCtxSectionString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ACTCTX_SECTION_KEYED_DATA" />
    <seealso cref="FindActCtxSectionGuid" />
  </member>
  <member name="Windows.FindActCtxSectionStringW">
    <summary>
      <para>The
<b>FindActCtxSectionString</b> function retrieves information on a specific string in the current activation context and returns a
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure.</para>
    </summary>
    <param name="dwFlags">
      <para>Flags that determine how this function is to operate. Only the following flag is currently defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX</b>
          </description>
          <description>
            <para>This function returns the activation context handle where the redirection data was found in the <b>hActCtx</b> member of the
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure. The caller must use
<see cref="ReleaseActCtx" /> to release this activation context.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpExtensionGuid">
      <para>Reserved; must be null.</para>
    </param>
    <param name="ulSectionId">
      <para>Identifier of the string section of the activation context in which to search for the specific string.</para>
      <para>The following are valid string section identifiers:</para>
      <list type="bullet">
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION</description>
        </item>
      </list>
    </param>
    <param name="lpStringToFind">
      <para>Pointer to a null-terminated string to be used as the search criteria.</para>
    </param>
    <param name="ReturnedData">
      <para>Pointer to an
<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure to be filled out with the requested string information.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling
<see cref="GetLastError" />. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
    <remarks>
      <para>This function should only be called by the Side-by-side API functions or COM methods. Applications should not directly call this function.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindActCtxSectionString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ACTCTX_SECTION_KEYED_DATA" />
    <seealso cref="FindActCtxSectionGuid" />
  </member>
  <member name="Windows.FindAtom">
    <summary>
      <para>Searches the local atom table for the specified character string and retrieves the atom associated with that string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Even though the system preserves the case of a string in an atom table, the search performed by the <b>FindAtom</b> function is not case sensitive.</para>
      <para>If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
  </member>
  <member name="Windows.FindAtomA">
    <summary>
      <para>Searches the local atom table for the specified character string and retrieves the atom associated with that string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Even though the system preserves the case of a string in an atom table, the search performed by the <b>FindAtom</b> function is not case sensitive.</para>
      <para>If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
  </member>
  <member name="Windows.FindAtomW">
    <summary>
      <para>Searches the local atom table for the specified character string and retrieves the atom associated with that string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Even though the system preserves the case of a string in an atom table, the search performed by the <b>FindAtom</b> function is not case sensitive.</para>
      <para>If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
  </member>
  <member name="Windows.FindAtom">
    <summary>
      <para>Searches the local atom table for the specified character string and retrieves the atom associated with that string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Even though the system preserves the case of a string in an atom table, the search performed by the <b>FindAtom</b> function is not case sensitive.</para>
      <para>If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
  </member>
  <member name="Windows.FindAtomA">
    <summary>
      <para>Searches the local atom table for the specified character string and retrieves the atom associated with that string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Even though the system preserves the case of a string in an atom table, the search performed by the <b>FindAtom</b> function is not case sensitive.</para>
      <para>If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
  </member>
  <member name="Windows.FindAtomW">
    <summary>
      <para>Searches the local atom table for the specified character string and retrieves the atom associated with that string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Even though the system preserves the case of a string in an atom table, the search performed by the <b>FindAtom</b> function is not case sensitive.</para>
      <para>If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
  </member>
  <member name="Windows.FindFirstVolume">
    <summary>
      <para>Retrieves the name of a volume on a computer. <b>FindFirstVolume</b> is used to begin scanning the volumes of a computer.</para>
    </summary>
    <param name="lpszVolumeName">
      <para>A pointer to a buffer that receives a null-terminated string that specifies a volume
<b>GUID</b> path for the first volume that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer to receive the volume <b>GUID</b> path, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the
<see cref="FindNextVolume" /> and
<see cref="FindVolumeClose" /> functions.</para>
      <para>If the function fails to find any volumes, the return value is the
<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstVolume</b> function opens a volume search handle and returns
information about the first volume found on a computer. After the search handle is established, you can use the
<see cref="FindNextVolume" /> function to search for other volumes. When
the search handle is no longer needed, close it by using the
<see cref="FindVolumeClose" /> function.</para>
      <para>You should not assume any correlation between the order of the volumes that are returned by these functions
and the order of the volumes that are on the computer. In particular, do not assume any correlation between volume
order and drive letters as assigned by the BIOS (if any) or the Disk Administrator.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso cref="FindNextVolume" />
    <seealso cref="FindVolumeClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindFirstVolumeA">
    <summary>
      <para>Retrieves the name of a volume on a computer. <b>FindFirstVolume</b> is used to begin scanning the volumes of a computer.</para>
    </summary>
    <param name="lpszVolumeName">
      <para>A pointer to a buffer that receives a null-terminated string that specifies a volume
<b>GUID</b> path for the first volume that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer to receive the volume <b>GUID</b> path, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the
<see cref="FindNextVolume" /> and
<see cref="FindVolumeClose" /> functions.</para>
      <para>If the function fails to find any volumes, the return value is the
<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstVolume</b> function opens a volume search handle and returns
information about the first volume found on a computer. After the search handle is established, you can use the
<see cref="FindNextVolume" /> function to search for other volumes. When
the search handle is no longer needed, close it by using the
<see cref="FindVolumeClose" /> function.</para>
      <para>You should not assume any correlation between the order of the volumes that are returned by these functions
and the order of the volumes that are on the computer. In particular, do not assume any correlation between volume
order and drive letters as assigned by the BIOS (if any) or the Disk Administrator.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso cref="FindNextVolume" />
    <seealso cref="FindVolumeClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindFirstVolumeW">
    <summary>
      <para>Retrieves the name of a volume on a computer. <b>FindFirstVolume</b> is used to begin scanning the volumes of a computer.</para>
    </summary>
    <param name="lpszVolumeName">
      <para>A pointer to a buffer that receives a null-terminated string that specifies a volume
<b>GUID</b> path for the first volume that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer to receive the volume <b>GUID</b> path, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the
<see cref="FindNextVolume" /> and
<see cref="FindVolumeClose" /> functions.</para>
      <para>If the function fails to find any volumes, the return value is the
<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstVolume</b> function opens a volume search handle and returns
information about the first volume found on a computer. After the search handle is established, you can use the
<see cref="FindNextVolume" /> function to search for other volumes. When
the search handle is no longer needed, close it by using the
<see cref="FindVolumeClose" /> function.</para>
      <para>You should not assume any correlation between the order of the volumes that are returned by these functions
and the order of the volumes that are on the computer. In particular, do not assume any correlation between volume
order and drive letters as assigned by the BIOS (if any) or the Disk Administrator.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso cref="FindNextVolume" />
    <seealso cref="FindVolumeClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindFirstVolumeMountPoint">
    <summary>
      <para>Retrieves the name of a mounted folder on the specified volume. <b>FindFirstVolumeMountPoint</b> is used to begin scanning the mounted folders on a
volume.</para>
    </summary>
    <param name="lpszRootPathName">
      <para>A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required.</para>
    </param>
    <param name="lpszVolumeMountPoint">
      <para>A pointer to a buffer that receives the name of the first mounted folder that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer that receives the path to the mounted folder, in
<b>TCHAR</b>s.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the
<see cref="FindNextVolumeMountPoint" /> and
<see cref="FindVolumeMountPointClose" /> functions.</para>
      <para>If the function fails to find a mounted folder on the volume, the return value is the
<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstVolumeMountPoint</b> function
opens a mounted folder search handle and returns information about the first mounted folder that is found on the
specified volume. After the search handle is established, you can use the
<see cref="FindNextVolumeMountPoint" /> function to search for
other mounted folders. When the search handle is no longer needed, close it with the
<see cref="FindVolumeMountPointClose" /> function.</para>
      <para>The <b>FindFirstVolumeMountPoint</b>,
<see cref="FindNextVolumeMountPoint" />, and
<see cref="FindVolumeMountPointClose" /> functions return
paths to mounted folders for a specified volume. They do not return drive letters or volume
<b>GUID</b> paths. For information about enumerating the volume
<b>GUID</b> paths for a volume, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/enumerating-unique-volume-names">Enumerating Volume GUID Paths</a>.</para>
      <para>You should not assume any correlation between the order of the mounted folders that are returned by these
functions and the order of the mounted folders that are returned by other functions or tools.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. CsvFS does not support adding mount point on a CSV volume.
ReFS does not index mount points.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindFirstVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="FindNextVolumeMountPoint" />
    <seealso cref="FindVolumeMountPointClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindFirstVolumeMountPointA">
    <summary>
      <para>Retrieves the name of a mounted folder on the specified volume. <b>FindFirstVolumeMountPoint</b> is used to begin scanning the mounted folders on a
volume.</para>
    </summary>
    <param name="lpszRootPathName">
      <para>A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required.</para>
    </param>
    <param name="lpszVolumeMountPoint">
      <para>A pointer to a buffer that receives the name of the first mounted folder that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer that receives the path to the mounted folder, in
<b>TCHAR</b>s.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the
<see cref="FindNextVolumeMountPoint" /> and
<see cref="FindVolumeMountPointClose" /> functions.</para>
      <para>If the function fails to find a mounted folder on the volume, the return value is the
<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstVolumeMountPoint</b> function
opens a mounted folder search handle and returns information about the first mounted folder that is found on the
specified volume. After the search handle is established, you can use the
<see cref="FindNextVolumeMountPoint" /> function to search for
other mounted folders. When the search handle is no longer needed, close it with the
<see cref="FindVolumeMountPointClose" /> function.</para>
      <para>The <b>FindFirstVolumeMountPoint</b>,
<see cref="FindNextVolumeMountPoint" />, and
<see cref="FindVolumeMountPointClose" /> functions return
paths to mounted folders for a specified volume. They do not return drive letters or volume
<b>GUID</b> paths. For information about enumerating the volume
<b>GUID</b> paths for a volume, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/enumerating-unique-volume-names">Enumerating Volume GUID Paths</a>.</para>
      <para>You should not assume any correlation between the order of the mounted folders that are returned by these
functions and the order of the mounted folders that are returned by other functions or tools.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. CsvFS does not support adding mount point on a CSV volume.
ReFS does not index mount points.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindFirstVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="FindNextVolumeMountPoint" />
    <seealso cref="FindVolumeMountPointClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindFirstVolumeMountPointW">
    <summary>
      <para>Retrieves the name of a mounted folder on the specified volume. <b>FindFirstVolumeMountPoint</b> is used to begin scanning the mounted folders on a
volume.</para>
    </summary>
    <param name="lpszRootPathName">
      <para>A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required.</para>
    </param>
    <param name="lpszVolumeMountPoint">
      <para>A pointer to a buffer that receives the name of the first mounted folder that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer that receives the path to the mounted folder, in
<b>TCHAR</b>s.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the
<see cref="FindNextVolumeMountPoint" /> and
<see cref="FindVolumeMountPointClose" /> functions.</para>
      <para>If the function fails to find a mounted folder on the volume, the return value is the
<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstVolumeMountPoint</b> function
opens a mounted folder search handle and returns information about the first mounted folder that is found on the
specified volume. After the search handle is established, you can use the
<see cref="FindNextVolumeMountPoint" /> function to search for
other mounted folders. When the search handle is no longer needed, close it with the
<see cref="FindVolumeMountPointClose" /> function.</para>
      <para>The <b>FindFirstVolumeMountPoint</b>,
<see cref="FindNextVolumeMountPoint" />, and
<see cref="FindVolumeMountPointClose" /> functions return
paths to mounted folders for a specified volume. They do not return drive letters or volume
<b>GUID</b> paths. For information about enumerating the volume
<b>GUID</b> paths for a volume, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/enumerating-unique-volume-names">Enumerating Volume GUID Paths</a>.</para>
      <para>You should not assume any correlation between the order of the mounted folders that are returned by these
functions and the order of the mounted folders that are returned by other functions or tools.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. CsvFS does not support adding mount point on a CSV volume.
ReFS does not index mount points.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindFirstVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="FindNextVolumeMountPoint" />
    <seealso cref="FindVolumeMountPointClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindFirstVolumeMountPoint">
    <summary>
      <para>Retrieves the name of a mounted folder on the specified volume. <b>FindFirstVolumeMountPoint</b> is used to begin scanning the mounted folders on a
volume.</para>
    </summary>
    <param name="lpszRootPathName">
      <para>A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required.</para>
    </param>
    <param name="lpszVolumeMountPoint">
      <para>A pointer to a buffer that receives the name of the first mounted folder that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer that receives the path to the mounted folder, in
<b>TCHAR</b>s.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the
<see cref="FindNextVolumeMountPoint" /> and
<see cref="FindVolumeMountPointClose" /> functions.</para>
      <para>If the function fails to find a mounted folder on the volume, the return value is the
<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstVolumeMountPoint</b> function
opens a mounted folder search handle and returns information about the first mounted folder that is found on the
specified volume. After the search handle is established, you can use the
<see cref="FindNextVolumeMountPoint" /> function to search for
other mounted folders. When the search handle is no longer needed, close it with the
<see cref="FindVolumeMountPointClose" /> function.</para>
      <para>The <b>FindFirstVolumeMountPoint</b>,
<see cref="FindNextVolumeMountPoint" />, and
<see cref="FindVolumeMountPointClose" /> functions return
paths to mounted folders for a specified volume. They do not return drive letters or volume
<b>GUID</b> paths. For information about enumerating the volume
<b>GUID</b> paths for a volume, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/enumerating-unique-volume-names">Enumerating Volume GUID Paths</a>.</para>
      <para>You should not assume any correlation between the order of the mounted folders that are returned by these
functions and the order of the mounted folders that are returned by other functions or tools.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. CsvFS does not support adding mount point on a CSV volume.
ReFS does not index mount points.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindFirstVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="FindNextVolumeMountPoint" />
    <seealso cref="FindVolumeMountPointClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindFirstVolumeMountPointA">
    <summary>
      <para>Retrieves the name of a mounted folder on the specified volume. <b>FindFirstVolumeMountPoint</b> is used to begin scanning the mounted folders on a
volume.</para>
    </summary>
    <param name="lpszRootPathName">
      <para>A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required.</para>
    </param>
    <param name="lpszVolumeMountPoint">
      <para>A pointer to a buffer that receives the name of the first mounted folder that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer that receives the path to the mounted folder, in
<b>TCHAR</b>s.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the
<see cref="FindNextVolumeMountPoint" /> and
<see cref="FindVolumeMountPointClose" /> functions.</para>
      <para>If the function fails to find a mounted folder on the volume, the return value is the
<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstVolumeMountPoint</b> function
opens a mounted folder search handle and returns information about the first mounted folder that is found on the
specified volume. After the search handle is established, you can use the
<see cref="FindNextVolumeMountPoint" /> function to search for
other mounted folders. When the search handle is no longer needed, close it with the
<see cref="FindVolumeMountPointClose" /> function.</para>
      <para>The <b>FindFirstVolumeMountPoint</b>,
<see cref="FindNextVolumeMountPoint" />, and
<see cref="FindVolumeMountPointClose" /> functions return
paths to mounted folders for a specified volume. They do not return drive letters or volume
<b>GUID</b> paths. For information about enumerating the volume
<b>GUID</b> paths for a volume, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/enumerating-unique-volume-names">Enumerating Volume GUID Paths</a>.</para>
      <para>You should not assume any correlation between the order of the mounted folders that are returned by these
functions and the order of the mounted folders that are returned by other functions or tools.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. CsvFS does not support adding mount point on a CSV volume.
ReFS does not index mount points.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindFirstVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="FindNextVolumeMountPoint" />
    <seealso cref="FindVolumeMountPointClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindFirstVolumeMountPointW">
    <summary>
      <para>Retrieves the name of a mounted folder on the specified volume. <b>FindFirstVolumeMountPoint</b> is used to begin scanning the mounted folders on a
volume.</para>
    </summary>
    <param name="lpszRootPathName">
      <para>A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required.</para>
    </param>
    <param name="lpszVolumeMountPoint">
      <para>A pointer to a buffer that receives the name of the first mounted folder that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer that receives the path to the mounted folder, in
<b>TCHAR</b>s.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the
<see cref="FindNextVolumeMountPoint" /> and
<see cref="FindVolumeMountPointClose" /> functions.</para>
      <para>If the function fails to find a mounted folder on the volume, the return value is the
<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>FindFirstVolumeMountPoint</b> function
opens a mounted folder search handle and returns information about the first mounted folder that is found on the
specified volume. After the search handle is established, you can use the
<see cref="FindNextVolumeMountPoint" /> function to search for
other mounted folders. When the search handle is no longer needed, close it with the
<see cref="FindVolumeMountPointClose" /> function.</para>
      <para>The <b>FindFirstVolumeMountPoint</b>,
<see cref="FindNextVolumeMountPoint" />, and
<see cref="FindVolumeMountPointClose" /> functions return
paths to mounted folders for a specified volume. They do not return drive letters or volume
<b>GUID</b> paths. For information about enumerating the volume
<b>GUID</b> paths for a volume, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/enumerating-unique-volume-names">Enumerating Volume GUID Paths</a>.</para>
      <para>You should not assume any correlation between the order of the mounted folders that are returned by these
functions and the order of the mounted folders that are returned by other functions or tools.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. CsvFS does not support adding mount point on a CSV volume.
ReFS does not index mount points.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindFirstVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="FindNextVolumeMountPoint" />
    <seealso cref="FindVolumeMountPointClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindNextVolume">
    <summary>
      <para>Continues a volume search started by a call to the
<see cref="FindFirstVolume" /> function. <b>FindNextVolume</b> finds one volume per call.</para>
    </summary>
    <param name="hFindVolume">
      <para>The volume search handle returned by a previous call to the
<see cref="FindFirstVolume" /> function.</para>
    </param>
    <param name="lpszVolumeName">
      <para>A pointer to a string that receives the volume <b>GUID</b> path that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer that receives the volume <b>GUID</b> path, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If no matching files can be found, the
<b>GetLastError</b> function returns the
<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the
<see cref="FindVolumeClose" /> function.</para>
    </returns>
    <remarks>
      <para>After the search handle is established by calling
<see cref="FindFirstVolume" />, you can use the
<b>FindNextVolume</b> function to search for other volumes.</para>
      <para>You should not assume any correlation between the order of the volumes that are returned by these functions
and the order of the volumes that are on the computer. In particular, do not assume any correlation between volume
order and drive letters as assigned by the BIOS (if any) or the Disk Administrator.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso cref="FindFirstVolume" />
    <seealso cref="FindVolumeClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindNextVolumeA">
    <summary>
      <para>Continues a volume search started by a call to the
<see cref="FindFirstVolume" /> function. <b>FindNextVolume</b> finds one volume per call.</para>
    </summary>
    <param name="hFindVolume">
      <para>The volume search handle returned by a previous call to the
<see cref="FindFirstVolume" /> function.</para>
    </param>
    <param name="lpszVolumeName">
      <para>A pointer to a string that receives the volume <b>GUID</b> path that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer that receives the volume <b>GUID</b> path, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If no matching files can be found, the
<b>GetLastError</b> function returns the
<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the
<see cref="FindVolumeClose" /> function.</para>
    </returns>
    <remarks>
      <para>After the search handle is established by calling
<see cref="FindFirstVolume" />, you can use the
<b>FindNextVolume</b> function to search for other volumes.</para>
      <para>You should not assume any correlation between the order of the volumes that are returned by these functions
and the order of the volumes that are on the computer. In particular, do not assume any correlation between volume
order and drive letters as assigned by the BIOS (if any) or the Disk Administrator.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso cref="FindFirstVolume" />
    <seealso cref="FindVolumeClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindNextVolumeW">
    <summary>
      <para>Continues a volume search started by a call to the
<see cref="FindFirstVolume" /> function. <b>FindNextVolume</b> finds one volume per call.</para>
    </summary>
    <param name="hFindVolume">
      <para>The volume search handle returned by a previous call to the
<see cref="FindFirstVolume" /> function.</para>
    </param>
    <param name="lpszVolumeName">
      <para>A pointer to a string that receives the volume <b>GUID</b> path that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer that receives the volume <b>GUID</b> path, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If no matching files can be found, the
<b>GetLastError</b> function returns the
<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the
<see cref="FindVolumeClose" /> function.</para>
    </returns>
    <remarks>
      <para>After the search handle is established by calling
<see cref="FindFirstVolume" />, you can use the
<b>FindNextVolume</b> function to search for other volumes.</para>
      <para>You should not assume any correlation between the order of the volumes that are returned by these functions
and the order of the volumes that are on the computer. In particular, do not assume any correlation between volume
order and drive letters as assigned by the BIOS (if any) or the Disk Administrator.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso cref="FindFirstVolume" />
    <seealso cref="FindVolumeClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindNextVolumeMountPoint">
    <summary>
      <para>Continues a mounted folder search started by a call to the
<see cref="FindFirstVolumeMountPoint" /></para>
      <para>function. <b>FindNextVolumeMountPoint</b> finds one mounted
folder per call.</para>
    </summary>
    <param name="hFindVolumeMountPoint">
      <para>A mounted folder search handle returned by a previous call to the
<see cref="FindFirstVolumeMountPoint" /> function.</para>
    </param>
    <param name="lpszVolumeMountPoint">
      <para>A pointer to a buffer that receives the name of the mounted folder that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer that receives the mounted folder name, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If no more mounted folders can be found,
the <b>GetLastError</b> function returns the
<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the
<see cref="FindVolumeMountPointClose" /> function.</para>
    </returns>
    <remarks>
      <para>After the search handle is established by calling
<see cref="FindFirstVolumeMountPoint" />, you can
use the <b>FindNextVolumeMountPoint</b> function to
search for other mounted folders.</para>
      <para>The <see cref="FindFirstVolumeMountPoint" />,
<b>FindNextVolumeMountPoint</b>, and
<see cref="FindVolumeMountPointClose" /> functions return
paths to mounted folders for a specified volume. They do not return drive letters or volume GUID paths. For
information about enumerating the volume <b>GUID</b> paths for a volume, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/enumerating-unique-volume-names">Enumerating Volume GUID Paths</a>.</para>
      <para>You should not assume any correlation between the order of the mounted folders that are returned with these
functions and the order of the mounted folders that are returned by other functions or tools.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. CsvFS does not support adding mount point on a CSV volume.
ReFS does not index mount points.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindNextVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="FindFirstVolumeMountPoint" />
    <seealso cref="FindVolumeMountPointClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindNextVolumeMountPointA">
    <summary>
      <para>Continues a mounted folder search started by a call to the
<see cref="FindFirstVolumeMountPoint" /></para>
      <para>function. <b>FindNextVolumeMountPoint</b> finds one mounted
folder per call.</para>
    </summary>
    <param name="hFindVolumeMountPoint">
      <para>A mounted folder search handle returned by a previous call to the
<see cref="FindFirstVolumeMountPoint" /> function.</para>
    </param>
    <param name="lpszVolumeMountPoint">
      <para>A pointer to a buffer that receives the name of the mounted folder that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer that receives the mounted folder name, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If no more mounted folders can be found,
the <b>GetLastError</b> function returns the
<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the
<see cref="FindVolumeMountPointClose" /> function.</para>
    </returns>
    <remarks>
      <para>After the search handle is established by calling
<see cref="FindFirstVolumeMountPoint" />, you can
use the <b>FindNextVolumeMountPoint</b> function to
search for other mounted folders.</para>
      <para>The <see cref="FindFirstVolumeMountPoint" />,
<b>FindNextVolumeMountPoint</b>, and
<see cref="FindVolumeMountPointClose" /> functions return
paths to mounted folders for a specified volume. They do not return drive letters or volume GUID paths. For
information about enumerating the volume <b>GUID</b> paths for a volume, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/enumerating-unique-volume-names">Enumerating Volume GUID Paths</a>.</para>
      <para>You should not assume any correlation between the order of the mounted folders that are returned with these
functions and the order of the mounted folders that are returned by other functions or tools.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. CsvFS does not support adding mount point on a CSV volume.
ReFS does not index mount points.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindNextVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="FindFirstVolumeMountPoint" />
    <seealso cref="FindVolumeMountPointClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindNextVolumeMountPointW">
    <summary>
      <para>Continues a mounted folder search started by a call to the
<see cref="FindFirstVolumeMountPoint" /></para>
      <para>function. <b>FindNextVolumeMountPoint</b> finds one mounted
folder per call.</para>
    </summary>
    <param name="hFindVolumeMountPoint">
      <para>A mounted folder search handle returned by a previous call to the
<see cref="FindFirstVolumeMountPoint" /> function.</para>
    </param>
    <param name="lpszVolumeMountPoint">
      <para>A pointer to a buffer that receives the name of the mounted folder that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer that receives the mounted folder name, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If no more mounted folders can be found,
the <b>GetLastError</b> function returns the
<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the
<see cref="FindVolumeMountPointClose" /> function.</para>
    </returns>
    <remarks>
      <para>After the search handle is established by calling
<see cref="FindFirstVolumeMountPoint" />, you can
use the <b>FindNextVolumeMountPoint</b> function to
search for other mounted folders.</para>
      <para>The <see cref="FindFirstVolumeMountPoint" />,
<b>FindNextVolumeMountPoint</b>, and
<see cref="FindVolumeMountPointClose" /> functions return
paths to mounted folders for a specified volume. They do not return drive letters or volume GUID paths. For
information about enumerating the volume <b>GUID</b> paths for a volume, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/enumerating-unique-volume-names">Enumerating Volume GUID Paths</a>.</para>
      <para>You should not assume any correlation between the order of the mounted folders that are returned with these
functions and the order of the mounted folders that are returned by other functions or tools.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. CsvFS does not support adding mount point on a CSV volume.
ReFS does not index mount points.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindNextVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="FindFirstVolumeMountPoint" />
    <seealso cref="FindVolumeMountPointClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindNextVolumeMountPoint">
    <summary>
      <para>Continues a mounted folder search started by a call to the
<see cref="FindFirstVolumeMountPoint" /></para>
      <para>function. <b>FindNextVolumeMountPoint</b> finds one mounted
folder per call.</para>
    </summary>
    <param name="hFindVolumeMountPoint">
      <para>A mounted folder search handle returned by a previous call to the
<see cref="FindFirstVolumeMountPoint" /> function.</para>
    </param>
    <param name="lpszVolumeMountPoint">
      <para>A pointer to a buffer that receives the name of the mounted folder that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer that receives the mounted folder name, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If no more mounted folders can be found,
the <b>GetLastError</b> function returns the
<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the
<see cref="FindVolumeMountPointClose" /> function.</para>
    </returns>
    <remarks>
      <para>After the search handle is established by calling
<see cref="FindFirstVolumeMountPoint" />, you can
use the <b>FindNextVolumeMountPoint</b> function to
search for other mounted folders.</para>
      <para>The <see cref="FindFirstVolumeMountPoint" />,
<b>FindNextVolumeMountPoint</b>, and
<see cref="FindVolumeMountPointClose" /> functions return
paths to mounted folders for a specified volume. They do not return drive letters or volume GUID paths. For
information about enumerating the volume <b>GUID</b> paths for a volume, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/enumerating-unique-volume-names">Enumerating Volume GUID Paths</a>.</para>
      <para>You should not assume any correlation between the order of the mounted folders that are returned with these
functions and the order of the mounted folders that are returned by other functions or tools.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. CsvFS does not support adding mount point on a CSV volume.
ReFS does not index mount points.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindNextVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="FindFirstVolumeMountPoint" />
    <seealso cref="FindVolumeMountPointClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindNextVolumeMountPointA">
    <summary>
      <para>Continues a mounted folder search started by a call to the
<see cref="FindFirstVolumeMountPoint" /></para>
      <para>function. <b>FindNextVolumeMountPoint</b> finds one mounted
folder per call.</para>
    </summary>
    <param name="hFindVolumeMountPoint">
      <para>A mounted folder search handle returned by a previous call to the
<see cref="FindFirstVolumeMountPoint" /> function.</para>
    </param>
    <param name="lpszVolumeMountPoint">
      <para>A pointer to a buffer that receives the name of the mounted folder that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer that receives the mounted folder name, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If no more mounted folders can be found,
the <b>GetLastError</b> function returns the
<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the
<see cref="FindVolumeMountPointClose" /> function.</para>
    </returns>
    <remarks>
      <para>After the search handle is established by calling
<see cref="FindFirstVolumeMountPoint" />, you can
use the <b>FindNextVolumeMountPoint</b> function to
search for other mounted folders.</para>
      <para>The <see cref="FindFirstVolumeMountPoint" />,
<b>FindNextVolumeMountPoint</b>, and
<see cref="FindVolumeMountPointClose" /> functions return
paths to mounted folders for a specified volume. They do not return drive letters or volume GUID paths. For
information about enumerating the volume <b>GUID</b> paths for a volume, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/enumerating-unique-volume-names">Enumerating Volume GUID Paths</a>.</para>
      <para>You should not assume any correlation between the order of the mounted folders that are returned with these
functions and the order of the mounted folders that are returned by other functions or tools.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. CsvFS does not support adding mount point on a CSV volume.
ReFS does not index mount points.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindNextVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="FindFirstVolumeMountPoint" />
    <seealso cref="FindVolumeMountPointClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindNextVolumeMountPointW">
    <summary>
      <para>Continues a mounted folder search started by a call to the
<see cref="FindFirstVolumeMountPoint" /></para>
      <para>function. <b>FindNextVolumeMountPoint</b> finds one mounted
folder per call.</para>
    </summary>
    <param name="hFindVolumeMountPoint">
      <para>A mounted folder search handle returned by a previous call to the
<see cref="FindFirstVolumeMountPoint" /> function.</para>
    </param>
    <param name="lpszVolumeMountPoint">
      <para>A pointer to a buffer that receives the name of the mounted folder that is found.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the buffer that receives the mounted folder name, in
<b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If no more mounted folders can be found,
the <b>GetLastError</b> function returns the
<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the
<see cref="FindVolumeMountPointClose" /> function.</para>
    </returns>
    <remarks>
      <para>After the search handle is established by calling
<see cref="FindFirstVolumeMountPoint" />, you can
use the <b>FindNextVolumeMountPoint</b> function to
search for other mounted folders.</para>
      <para>The <see cref="FindFirstVolumeMountPoint" />,
<b>FindNextVolumeMountPoint</b>, and
<see cref="FindVolumeMountPointClose" /> functions return
paths to mounted folders for a specified volume. They do not return drive letters or volume GUID paths. For
information about enumerating the volume <b>GUID</b> paths for a volume, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/enumerating-unique-volume-names">Enumerating Volume GUID Paths</a>.</para>
      <para>You should not assume any correlation between the order of the mounted folders that are returned with these
functions and the order of the mounted folders that are returned by other functions or tools.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. CsvFS does not support adding mount point on a CSV volume.
ReFS does not index mount points.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines FindNextVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="FindFirstVolumeMountPoint" />
    <seealso cref="FindVolumeMountPointClose" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.FindResource">
    <summary>
      <para>Determines the location of a resource with the specified type and name in the specified module.</para>
      <para>To specify a language, use the <see cref="FindResourceEx" /> function.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is <b>NULL</b>, the function searches the module used to create the current process.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The resource type. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the given resource type. For standard resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <returns>
      <para>Type: <b>HRSRC</b></para>
      <para>If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a handle to the resource, pass this handle to the <see cref="LoadResource" /> function.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" /> is <b>TRUE</b> for x = <i>lpName</i> or <i>lpType</i>, x specifies the integer identifier of the name or type of the given resource. Otherwise, those parameters are long pointers to null-terminated strings. If the first character of the string is a pound sign (#), the remaining characters represent a decimal number that specifies the integer identifier of the resource's name or type. For example, the string "#258" represents the integer identifier 258.</para>
      <para>To reduce the amount of memory required for a resource, an application should refer to it by integer identifier instead of by name.</para>
      <para>An application can use <b>FindResource</b> to find any type of resource, but this function should be used only if the application must access the binary resource data by making subsequent calls to <see cref="LoadResource" /> and then to <see cref="LockResource" />.</para>
      <para>To use a resource immediately, an application should use one of the following resource-specific functions to find the resource and convert the data into a more usable form.</para>
      <list type="table">
        <listheader>
          <description>Function</description>
          <description>Action</description>
        </listheader>
        <item>
          <description>
            <see cref="FormatMessage" />
          </description>
          <description>Loads and formats a message-table entry.</description>
        </item>
        <item>
          <description>
            <see cref="LoadAccelerators" />
          </description>
          <description>Loads an accelerator table.</description>
        </item>
        <item>
          <description>
            <see cref="LoadBitmap" />
          </description>
          <description>Loads a bitmap resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadCursor" />
          </description>
          <description>Loads a cursor resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadIcon" />
          </description>
          <description>Loads an icon resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadMenu" />
          </description>
          <description>Loads a menu resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadString" />
          </description>
          <description>Loads a string-table entry.</description>
        </item>
      </list>
      <para>For example, an application can use the <see cref="LoadIcon" /> function to load an icon for display on the screen. However, the application should use <b>FindResource</b> and <see cref="LoadResource" /> if it is loading the icon to copy its data to another application.</para>
      <para>String resources are stored in sections of up to 16 strings per section. The strings in each section are stored as a sequence of counted (not necessarily null-terminated) Unicode strings. The <see cref="LoadString" /> function will extract the string resource from its corresponding section.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
    </remarks>
    <seealso cref="FindResourceEx" />
    <seealso cref="FormatMessage" />
    <seealso cref="IS_INTRESOURCE" />
    <seealso cref="LoadAccelerators" />
    <seealso cref="LoadBitmap" />
    <seealso cref="LoadCursor" />
    <seealso cref="LoadIcon" />
    <seealso cref="LoadMenu" />
    <seealso cref="LoadResource" />
    <seealso cref="LoadString" />
    <seealso cref="LockResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="SizeofResource" />
  </member>
  <member name="Windows.FindResourceA">
    <summary>
      <para>Determines the location of a resource with the specified type and name in the specified module.</para>
      <para>To specify a language, use the <see cref="FindResourceEx" /> function.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is <b>NULL</b>, the function searches the module used to create the current process.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The resource type. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the given resource type. For standard resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <returns>
      <para>Type: <b>HRSRC</b></para>
      <para>If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a handle to the resource, pass this handle to the <see cref="LoadResource" /> function.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" /> is <b>TRUE</b> for x = <i>lpName</i> or <i>lpType</i>, x specifies the integer identifier of the name or type of the given resource. Otherwise, those parameters are long pointers to null-terminated strings. If the first character of the string is a pound sign (#), the remaining characters represent a decimal number that specifies the integer identifier of the resource's name or type. For example, the string "#258" represents the integer identifier 258.</para>
      <para>To reduce the amount of memory required for a resource, an application should refer to it by integer identifier instead of by name.</para>
      <para>An application can use <b>FindResource</b> to find any type of resource, but this function should be used only if the application must access the binary resource data by making subsequent calls to <see cref="LoadResource" /> and then to <see cref="LockResource" />.</para>
      <para>To use a resource immediately, an application should use one of the following resource-specific functions to find the resource and convert the data into a more usable form.</para>
      <list type="table">
        <listheader>
          <description>Function</description>
          <description>Action</description>
        </listheader>
        <item>
          <description>
            <see cref="FormatMessage" />
          </description>
          <description>Loads and formats a message-table entry.</description>
        </item>
        <item>
          <description>
            <see cref="LoadAccelerators" />
          </description>
          <description>Loads an accelerator table.</description>
        </item>
        <item>
          <description>
            <see cref="LoadBitmap" />
          </description>
          <description>Loads a bitmap resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadCursor" />
          </description>
          <description>Loads a cursor resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadIcon" />
          </description>
          <description>Loads an icon resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadMenu" />
          </description>
          <description>Loads a menu resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadString" />
          </description>
          <description>Loads a string-table entry.</description>
        </item>
      </list>
      <para>For example, an application can use the <see cref="LoadIcon" /> function to load an icon for display on the screen. However, the application should use <b>FindResource</b> and <see cref="LoadResource" /> if it is loading the icon to copy its data to another application.</para>
      <para>String resources are stored in sections of up to 16 strings per section. The strings in each section are stored as a sequence of counted (not necessarily null-terminated) Unicode strings. The <see cref="LoadString" /> function will extract the string resource from its corresponding section.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
    </remarks>
    <seealso cref="FindResourceEx" />
    <seealso cref="FormatMessage" />
    <seealso cref="IS_INTRESOURCE" />
    <seealso cref="LoadAccelerators" />
    <seealso cref="LoadBitmap" />
    <seealso cref="LoadCursor" />
    <seealso cref="LoadIcon" />
    <seealso cref="LoadMenu" />
    <seealso cref="LoadResource" />
    <seealso cref="LoadString" />
    <seealso cref="LockResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="SizeofResource" />
  </member>
  <member name="Windows.FindResourceW">
    <summary>
      <para>Determines the location of a resource with the specified type and name in the specified module.</para>
      <para>To specify a language, use the <see cref="FindResourceEx" /> function.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is <b>NULL</b>, the function searches the module used to create the current process.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The resource type. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the given resource type. For standard resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <returns>
      <para>Type: <b>HRSRC</b></para>
      <para>If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a handle to the resource, pass this handle to the <see cref="LoadResource" /> function.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" /> is <b>TRUE</b> for x = <i>lpName</i> or <i>lpType</i>, x specifies the integer identifier of the name or type of the given resource. Otherwise, those parameters are long pointers to null-terminated strings. If the first character of the string is a pound sign (#), the remaining characters represent a decimal number that specifies the integer identifier of the resource's name or type. For example, the string "#258" represents the integer identifier 258.</para>
      <para>To reduce the amount of memory required for a resource, an application should refer to it by integer identifier instead of by name.</para>
      <para>An application can use <b>FindResource</b> to find any type of resource, but this function should be used only if the application must access the binary resource data by making subsequent calls to <see cref="LoadResource" /> and then to <see cref="LockResource" />.</para>
      <para>To use a resource immediately, an application should use one of the following resource-specific functions to find the resource and convert the data into a more usable form.</para>
      <list type="table">
        <listheader>
          <description>Function</description>
          <description>Action</description>
        </listheader>
        <item>
          <description>
            <see cref="FormatMessage" />
          </description>
          <description>Loads and formats a message-table entry.</description>
        </item>
        <item>
          <description>
            <see cref="LoadAccelerators" />
          </description>
          <description>Loads an accelerator table.</description>
        </item>
        <item>
          <description>
            <see cref="LoadBitmap" />
          </description>
          <description>Loads a bitmap resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadCursor" />
          </description>
          <description>Loads a cursor resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadIcon" />
          </description>
          <description>Loads an icon resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadMenu" />
          </description>
          <description>Loads a menu resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadString" />
          </description>
          <description>Loads a string-table entry.</description>
        </item>
      </list>
      <para>For example, an application can use the <see cref="LoadIcon" /> function to load an icon for display on the screen. However, the application should use <b>FindResource</b> and <see cref="LoadResource" /> if it is loading the icon to copy its data to another application.</para>
      <para>String resources are stored in sections of up to 16 strings per section. The strings in each section are stored as a sequence of counted (not necessarily null-terminated) Unicode strings. The <see cref="LoadString" /> function will extract the string resource from its corresponding section.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
    </remarks>
    <seealso cref="FindResourceEx" />
    <seealso cref="FormatMessage" />
    <seealso cref="IS_INTRESOURCE" />
    <seealso cref="LoadAccelerators" />
    <seealso cref="LoadBitmap" />
    <seealso cref="LoadCursor" />
    <seealso cref="LoadIcon" />
    <seealso cref="LoadMenu" />
    <seealso cref="LoadResource" />
    <seealso cref="LoadString" />
    <seealso cref="LockResource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="SizeofResource" />
  </member>
  <member name="Windows.FindResourceEx">
    <summary>
      <para>Determines the location of the resource with the specified type, name, and language in the specified module.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is <b>NULL</b>, the function searches the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The resource type. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the given</para>
      <para>resource type. For standard resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="wLanguage">
      <para>Type: <b>WORD</b></para>
      <para>The language of the resource. If this parameter is <code>MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)</code>, the current language associated with the calling thread is used.</para>
      <para>To specify a language other than the current language, use the <see cref="MAKELANGID" /> macro to create this parameter. For more information, see <b>MAKELANGID</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRSRC</b></para>
      <para>If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a handle to the resource, pass this handle to the <see cref="LoadResource" /> function.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" /> is <b>TRUE</b> for x = <i>lpType</i> or <i>lpName</i>, x specifies the integer identifier of the type or name of the given resource. Otherwise, those parameters are long pointers to null-terminated strings. If the first character of the string is a pound sign (#), the remaining characters represent a decimal number that specifies the integer identifier of the resource's name or type. For example, the string "#258" represents the integer identifier 258.</para>
      <para>To reduce the amount of memory required for a resource, an application should refer to it by integer identifier instead of by name.</para>
      <para>An application can use <b>FindResourceEx</b> to find any type of resource, but this function should be used only if the application must access the binary resource data by making subsequent calls to <see cref="LoadResource" /> and then to <see cref="LockResource" />.</para>
      <para>To use a resource immediately, an application should use one of the following resource-specific functions to find the resource and convert the data into a more usable form.</para>
      <list type="table">
        <listheader>
          <description>Function</description>
          <description>Action</description>
        </listheader>
        <item>
          <description>
            <see cref="FormatMessage" />
          </description>
          <description>Loads and formats a message-table entry.</description>
        </item>
        <item>
          <description>
            <see cref="LoadAccelerators" />
          </description>
          <description>Loads an accelerator table.</description>
        </item>
        <item>
          <description>
            <see cref="LoadBitmap" />
          </description>
          <description>Loads a bitmap resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadCursor" />
          </description>
          <description>Loads a cursor resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadIcon" />
          </description>
          <description>Loads an icon resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadMenu" />
          </description>
          <description>Loads a menu resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadString" />
          </description>
          <description>Loads a string-table entry.</description>
        </item>
      </list>
      <para>For example, an application can use the <see cref="LoadIcon" /> function to load an icon for display on the screen. However, the application should use <b>FindResourceEx</b> and <see cref="LoadResource" /> if it is loading the icon to copy its data to another application.</para>
      <para>String resources are stored in sections of up to 16 strings per section. The strings in each section are stored as a sequence of counted (not necessarily null-terminated) Unicode strings. The <see cref="LoadString" /> function will extract the string resource from its corresponding section.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Creating a Resource List</a>.</para>
    </remarks>
    <seealso cref="FindResource" />
    <seealso cref="FormatMessage" />
    <seealso cref="IS_INTRESOURCE" />
    <seealso cref="LoadAccelerators" />
    <seealso cref="LoadBitmap" />
    <seealso cref="LoadCursor" />
    <seealso cref="LoadIcon" />
    <seealso cref="LoadMenu" />
    <seealso cref="LoadResource" />
    <seealso cref="LoadString" />
    <seealso cref="MAKELANGID" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
  </member>
  <member name="Windows.FindResourceExA">
    <summary>
      <para>Determines the location of the resource with the specified type, name, and language in the specified module.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is <b>NULL</b>, the function searches the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The resource type. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the given</para>
      <para>resource type. For standard resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="wLanguage">
      <para>Type: <b>WORD</b></para>
      <para>The language of the resource. If this parameter is <code>MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)</code>, the current language associated with the calling thread is used.</para>
      <para>To specify a language other than the current language, use the <see cref="MAKELANGID" /> macro to create this parameter. For more information, see <b>MAKELANGID</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRSRC</b></para>
      <para>If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a handle to the resource, pass this handle to the <see cref="LoadResource" /> function.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" /> is <b>TRUE</b> for x = <i>lpType</i> or <i>lpName</i>, x specifies the integer identifier of the type or name of the given resource. Otherwise, those parameters are long pointers to null-terminated strings. If the first character of the string is a pound sign (#), the remaining characters represent a decimal number that specifies the integer identifier of the resource's name or type. For example, the string "#258" represents the integer identifier 258.</para>
      <para>To reduce the amount of memory required for a resource, an application should refer to it by integer identifier instead of by name.</para>
      <para>An application can use <b>FindResourceEx</b> to find any type of resource, but this function should be used only if the application must access the binary resource data by making subsequent calls to <see cref="LoadResource" /> and then to <see cref="LockResource" />.</para>
      <para>To use a resource immediately, an application should use one of the following resource-specific functions to find the resource and convert the data into a more usable form.</para>
      <list type="table">
        <listheader>
          <description>Function</description>
          <description>Action</description>
        </listheader>
        <item>
          <description>
            <see cref="FormatMessage" />
          </description>
          <description>Loads and formats a message-table entry.</description>
        </item>
        <item>
          <description>
            <see cref="LoadAccelerators" />
          </description>
          <description>Loads an accelerator table.</description>
        </item>
        <item>
          <description>
            <see cref="LoadBitmap" />
          </description>
          <description>Loads a bitmap resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadCursor" />
          </description>
          <description>Loads a cursor resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadIcon" />
          </description>
          <description>Loads an icon resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadMenu" />
          </description>
          <description>Loads a menu resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadString" />
          </description>
          <description>Loads a string-table entry.</description>
        </item>
      </list>
      <para>For example, an application can use the <see cref="LoadIcon" /> function to load an icon for display on the screen. However, the application should use <b>FindResourceEx</b> and <see cref="LoadResource" /> if it is loading the icon to copy its data to another application.</para>
      <para>String resources are stored in sections of up to 16 strings per section. The strings in each section are stored as a sequence of counted (not necessarily null-terminated) Unicode strings. The <see cref="LoadString" /> function will extract the string resource from its corresponding section.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Creating a Resource List</a>.</para>
    </remarks>
    <seealso cref="FindResource" />
    <seealso cref="FormatMessage" />
    <seealso cref="IS_INTRESOURCE" />
    <seealso cref="LoadAccelerators" />
    <seealso cref="LoadBitmap" />
    <seealso cref="LoadCursor" />
    <seealso cref="LoadIcon" />
    <seealso cref="LoadMenu" />
    <seealso cref="LoadResource" />
    <seealso cref="LoadString" />
    <seealso cref="MAKELANGID" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
  </member>
  <member name="Windows.FindResourceExW">
    <summary>
      <para>Determines the location of the resource with the specified type, name, and language in the specified module.</para>
    </summary>
    <param name="hModule">
      <para>Type: <b>HMODULE</b></para>
      <para>A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is <b>NULL</b>, the function searches the module used to create the current process.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The resource type. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the given</para>
      <para>resource type. For standard resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</para>
    </param>
    <param name="wLanguage">
      <para>Type: <b>WORD</b></para>
      <para>The language of the resource. If this parameter is <code>MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)</code>, the current language associated with the calling thread is used.</para>
      <para>To specify a language other than the current language, use the <see cref="MAKELANGID" /> macro to create this parameter. For more information, see <b>MAKELANGID</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRSRC</b></para>
      <para>If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a handle to the resource, pass this handle to the <see cref="LoadResource" /> function.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <see cref="IS_INTRESOURCE" /> is <b>TRUE</b> for x = <i>lpType</i> or <i>lpName</i>, x specifies the integer identifier of the type or name of the given resource. Otherwise, those parameters are long pointers to null-terminated strings. If the first character of the string is a pound sign (#), the remaining characters represent a decimal number that specifies the integer identifier of the resource's name or type. For example, the string "#258" represents the integer identifier 258.</para>
      <para>To reduce the amount of memory required for a resource, an application should refer to it by integer identifier instead of by name.</para>
      <para>An application can use <b>FindResourceEx</b> to find any type of resource, but this function should be used only if the application must access the binary resource data by making subsequent calls to <see cref="LoadResource" /> and then to <see cref="LockResource" />.</para>
      <para>To use a resource immediately, an application should use one of the following resource-specific functions to find the resource and convert the data into a more usable form.</para>
      <list type="table">
        <listheader>
          <description>Function</description>
          <description>Action</description>
        </listheader>
        <item>
          <description>
            <see cref="FormatMessage" />
          </description>
          <description>Loads and formats a message-table entry.</description>
        </item>
        <item>
          <description>
            <see cref="LoadAccelerators" />
          </description>
          <description>Loads an accelerator table.</description>
        </item>
        <item>
          <description>
            <see cref="LoadBitmap" />
          </description>
          <description>Loads a bitmap resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadCursor" />
          </description>
          <description>Loads a cursor resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadIcon" />
          </description>
          <description>Loads an icon resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadMenu" />
          </description>
          <description>Loads a menu resource.</description>
        </item>
        <item>
          <description>
            <see cref="LoadString" />
          </description>
          <description>Loads a string-table entry.</description>
        </item>
      </list>
      <para>For example, an application can use the <see cref="LoadIcon" /> function to load an icon for display on the screen. However, the application should use <b>FindResourceEx</b> and <see cref="LoadResource" /> if it is loading the icon to copy its data to another application.</para>
      <para>String resources are stored in sections of up to 16 strings per section. The strings in each section are stored as a sequence of counted (not necessarily null-terminated) Unicode strings. The <see cref="LoadString" /> function will extract the string resource from its corresponding section.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Creating a Resource List</a>.</para>
    </remarks>
    <seealso cref="FindResource" />
    <seealso cref="FormatMessage" />
    <seealso cref="IS_INTRESOURCE" />
    <seealso cref="LoadAccelerators" />
    <seealso cref="LoadBitmap" />
    <seealso cref="LoadCursor" />
    <seealso cref="LoadIcon" />
    <seealso cref="LoadMenu" />
    <seealso cref="LoadResource" />
    <seealso cref="LoadString" />
    <seealso cref="MAKELANGID" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
  </member>
  <member name="Windows.FindVolumeMountPointClose">
    <summary>
      <para>Closes the specified mounted folder search handle. The
<see cref="FindFirstVolumeMountPoint" /> and
<see cref="FindNextVolumeMountPoint" /> functions use this search handle to locate mounted folders on a specified volume.</para>
    </summary>
    <param name="hFindVolumeMountPoint">
      <para>The mounted folder search handle to be closed. This handle must have been previously opened by the
<see cref="FindFirstVolumeMountPoint" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>After the
<b>FindVolumeMountPointClose</b> function is called, the handle <i>hFindVolumeMountPoint</i> cannot be used in subsequent calls to either
<see cref="FindNextVolumeMountPoint" /> or
<b>FindVolumeMountPointClose</b>.</para>
      <para>The <see cref="FindFirstVolumeMountPoint" />, <see cref="FindNextVolumeMountPoint" />, and <b>FindVolumeMountPointClose</b> functions return paths to mounted folders for a specified volume. They do not return drive letters or volume GUID paths. For information about enumerating the volume GUID paths for a volume, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/enumerating-unique-volume-names">Enumerating Volume GUID Paths</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. CsvFS does not support adding mount point on a CSV volume.</para>
    </remarks>
    <seealso cref="FindFirstVolumeMountPoint" />
    <seealso cref="FindNextVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume
Management Functions</seealso>
  </member>
  <member name="Windows.GetActiveProcessorCount">
    <summary>
      <para>Returns the number of active processors in a processor group or in the system.</para>
    </summary>
    <param name="GroupNumber">
      <para>The processor group number. If this parameter is ALL_PROCESSOR_GROUPS, the function returns the number of active processors in the system.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of active processors in the specified group.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, set _WIN32_WINNT &gt;= 0x0601. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
  </member>
  <member name="Windows.GetActiveProcessorGroupCount">
    <summary>
      <para>Returns the number of active processor groups in the system.</para>
    </summary>
    <returns>
      <para>If the function succeeds, the return value is the number of active processor groups in the system.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, set _WIN32_WINNT &gt;= 0x0601. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
  </member>
  <member name="Windows.GetApplicationRecoveryCallback">
    <summary>
      <para>Retrieves  a pointer to the callback routine registered for the specified process. The address returned is in the virtual address space of the process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. This handle must have the PROCESS_VM_READ access right.</para>
    </param>
    <param name="pRecoveryCallback">
      <para>A pointer to the recovery callback function. For more information, see <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa373202(v=vs.85)">ApplicationRecoveryCallback</a>.</para>
    </param>
    <param name="ppvParameter">
      <para>A pointer to the callback parameter.</para>
    </param>
    <param name="pdwPingInterval">
      <para>The recovery ping interval, in 100-nanosecond intervals.</para>
    </param>
    <param name="pdwFlags">
      <para>Reserved for future use.</para>
    </param>
    <returns>
      <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>The application did not register for recovery.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>One or more parameters are not valid.</para>
          </description>
        </item>
      </list>
    </returns>
    <seealso cref="RegisterApplicationRecoveryCallback" />
  </member>
  <member name="Windows.GetApplicationRestartSettings">
    <summary>
      <para>Retrieves  the restart information registered for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. This handle must have the PROCESS_VM_READ access right.</para>
    </param>
    <param name="pwzCommandline">
      <para>A pointer to a buffer that receives the restart command line specified by the application when it called the <see cref="RegisterApplicationRestart" /> function. The maximum size of the command line, in characters, is RESTART_MAX_CMD_LINE. Can be <b>NULL</b> if <i>pcchSize</i> is zero.</para>
    </param>
    <param name="pcchSize">
      <para>On input, specifies the size of the <i>pwzCommandLine</i> buffer, in characters.</para>
      <para>If the buffer is not large enough to receive the command line, the function fails with HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) and sets this parameter to the required buffer size, in characters.</para>
      <para>On output, specifies the size of the buffer that was used.</para>
      <para>To determine the required buffer size, set <i>pwzCommandLine</i> to <b>NULL</b> and this parameter to zero. The size includes one for the <b>null</b>-terminator character. Note that the function returns S_OK, not HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) in this case.</para>
    </param>
    <param name="pdwFlags">
      <para>A pointer to a variable that receives the flags specified by the application when it called the <see cref="RegisterApplicationRestart" /> function.</para>
    </param>
    <returns>
      <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>One or more parameters are not valid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>HRESULT_FROM_WIN32(ERROR_NOT_FOUND)</b>
            </para>
          </description>
          <description>
            <para>The application did not register for restart.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)</b>
            </para>
          </description>
          <description>
            <para>The <i>pwzCommandLine</i> buffer is too small. The function returns the required buffer size in <i>pcchSize</i>. Use the required size to reallocate the buffer.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This information is available only for the current process; you cannot call this function after your program is restarted to get the restart command line. To get the command line after a restart, access the <i>argv</i> parameter of your <b>main</b> function.</para>
      <h4>Examples</h4>
      <para>The following example shows how to get the restart settings specified when you called the <see cref="RegisterApplicationRestart" /> function.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;


void wmain(int argc, WCHAR* argv[])
{
    HRESULT hr = S_OK;
    WCHAR wsCommandLine[RESTART_MAX_CMD_LINE + 1];
    DWORD cchCmdLine = sizeof(wsCommandLine) / sizeof(WCHAR);
    DWORD dwFlags = 0;
    LPWSTR pwsCmdLine = NULL;
    UNREFERENCED_PARAMETER(argv);
    UNREFERENCED_PARAMETER(argc);

    wprintf(L"Registering for restart...\n");
    hr = RegisterApplicationRestart(L"/restart -f .\\filename.ext", 0);
    if (FAILED(hr))
    {
        wprintf(L"RegisterApplicationRestart failed, 0x%x\n", hr);
        goto cleanup;
    }

    wprintf(L"Get restart command line using static buffer...\n");
    hr = GetApplicationRestartSettings(GetCurrentProcess(), wsCommandLine, &amp;amp;amp;amp;amp;amp;cchCmdLine, &amp;amp;amp;amp;amp;amp;dwFlags);
    if (FAILED(hr))
    {
        wprintf(L"GetApplicationRestartSettings failed, 0x%x\n", hr);
        goto cleanup;
    }

    wprintf(L"Command line: %s\n", wsCommandLine);

    wprintf(L"\nGet settings using dynamic buffer...\n");

    cchCmdLine = 0;

    // Returns S_OK instead of ERROR_INSUFFICIENT_BUFFER when pBuffer is NULL and size is 0.
    hr = GetApplicationRestartSettings(GetCurrentProcess(), (PWSTR)pwsCmdLine, &amp;amp;amp;amp;amp;amp;cchCmdLine, &amp;amp;amp;amp;amp;amp;dwFlags);
    if (SUCCEEDED(hr))
    {
        pwsCmdLine = (LPWSTR)malloc(cchCmdLine * sizeof(WCHAR));

        if (pwsCmdLine)
        {
            hr = GetApplicationRestartSettings(GetCurrentProcess(), (PWSTR)pwsCmdLine, &amp;amp;amp;amp;amp;amp;cchCmdLine, &amp;amp;amp;amp;amp;amp;dwFlags);
            if (FAILED(hr))
            {
                wprintf(L"GetApplicationRestartSettings failed with 0x%x\n", hr);
                goto cleanup;
            }

            wprintf(L"Command line: %s\n", pwsCmdLine);
        }
        else
        {
            wprintf(L"Allocating the command-line buffer failed.\n");
        }
    }
    else
    {
        if (hr != HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) // Not a restart.
        {
            wprintf(L"GetApplicationRestartSettings failed with 0x%x\n", hr);
            goto cleanup;
        }
    }

cleanup:

    if (pwsCmdLine)
        free(pwsCmdLine);
}

</code>
    </remarks>
    <seealso cref="RegisterApplicationRestart" />
  </member>
  <member name="Windows.GetAtomName">
    <summary>
      <para>Retrieves a copy of the character string associated with the specified local atom.</para>
    </summary>
    <param name="nAtom">
      <para>Type: <b>ATOM</b></para>
      <para>The local atom that identifies the character string to be retrieved.</para>
    </param>
    <param name="lpBuffer">
      <para>Type: <b>LPTSTR</b></para>
      <para>The character string.</para>
    </param>
    <param name="nSize">
      <para>Type: <b>int</b></para>
      <para>The size, in
characters, of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in
characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The string returned for an integer atom (an atom whose value is in the range 0x0001 to 0xBFFF) is a null-terminated string in which the first character is a pound sign (#) and the remaining characters represent the unsigned integer atom value.</para>
      <h3>Security Considerations</h3>
      <para>Using this function incorrectly might compromise the security of your program. Incorrect use of this function includes not correctly specifying the size of the <i>lpBuffer</i> parameter.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetAtomName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="GlobalGetAtomName" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.GetAtomNameA">
    <summary>
      <para>Retrieves a copy of the character string associated with the specified local atom.</para>
    </summary>
    <param name="nAtom">
      <para>Type: <b>ATOM</b></para>
      <para>The local atom that identifies the character string to be retrieved.</para>
    </param>
    <param name="lpBuffer">
      <para>Type: <b>LPTSTR</b></para>
      <para>The character string.</para>
    </param>
    <param name="nSize">
      <para>Type: <b>int</b></para>
      <para>The size, in
characters, of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in
characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The string returned for an integer atom (an atom whose value is in the range 0x0001 to 0xBFFF) is a null-terminated string in which the first character is a pound sign (#) and the remaining characters represent the unsigned integer atom value.</para>
      <h3>Security Considerations</h3>
      <para>Using this function incorrectly might compromise the security of your program. Incorrect use of this function includes not correctly specifying the size of the <i>lpBuffer</i> parameter.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetAtomName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="GlobalGetAtomName" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.GetAtomNameW">
    <summary>
      <para>Retrieves a copy of the character string associated with the specified local atom.</para>
    </summary>
    <param name="nAtom">
      <para>Type: <b>ATOM</b></para>
      <para>The local atom that identifies the character string to be retrieved.</para>
    </param>
    <param name="lpBuffer">
      <para>Type: <b>LPTSTR</b></para>
      <para>The character string.</para>
    </param>
    <param name="nSize">
      <para>Type: <b>int</b></para>
      <para>The size, in
characters, of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in
characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The string returned for an integer atom (an atom whose value is in the range 0x0001 to 0xBFFF) is a null-terminated string in which the first character is a pound sign (#) and the remaining characters represent the unsigned integer atom value.</para>
      <h3>Security Considerations</h3>
      <para>Using this function incorrectly might compromise the security of your program. Incorrect use of this function includes not correctly specifying the size of the <i>lpBuffer</i> parameter.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetAtomName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="GlobalGetAtomName" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.GetAtomName">
    <summary>
      <para>Retrieves a copy of the character string associated with the specified local atom.</para>
    </summary>
    <param name="nAtom">
      <para>Type: <b>ATOM</b></para>
      <para>The local atom that identifies the character string to be retrieved.</para>
    </param>
    <param name="lpBuffer">
      <para>Type: <b>LPTSTR</b></para>
      <para>The character string.</para>
    </param>
    <param name="nSize">
      <para>Type: <b>int</b></para>
      <para>The size, in
characters, of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in
characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The string returned for an integer atom (an atom whose value is in the range 0x0001 to 0xBFFF) is a null-terminated string in which the first character is a pound sign (#) and the remaining characters represent the unsigned integer atom value.</para>
      <h3>Security Considerations</h3>
      <para>Using this function incorrectly might compromise the security of your program. Incorrect use of this function includes not correctly specifying the size of the <i>lpBuffer</i> parameter.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetAtomName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="GlobalGetAtomName" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.GetAtomNameA">
    <summary>
      <para>Retrieves a copy of the character string associated with the specified local atom.</para>
    </summary>
    <param name="nAtom">
      <para>Type: <b>ATOM</b></para>
      <para>The local atom that identifies the character string to be retrieved.</para>
    </param>
    <param name="lpBuffer">
      <para>Type: <b>LPTSTR</b></para>
      <para>The character string.</para>
    </param>
    <param name="nSize">
      <para>Type: <b>int</b></para>
      <para>The size, in
characters, of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in
characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The string returned for an integer atom (an atom whose value is in the range 0x0001 to 0xBFFF) is a null-terminated string in which the first character is a pound sign (#) and the remaining characters represent the unsigned integer atom value.</para>
      <h3>Security Considerations</h3>
      <para>Using this function incorrectly might compromise the security of your program. Incorrect use of this function includes not correctly specifying the size of the <i>lpBuffer</i> parameter.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetAtomName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="GlobalGetAtomName" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.GetAtomNameW">
    <summary>
      <para>Retrieves a copy of the character string associated with the specified local atom.</para>
    </summary>
    <param name="nAtom">
      <para>Type: <b>ATOM</b></para>
      <para>The local atom that identifies the character string to be retrieved.</para>
    </param>
    <param name="lpBuffer">
      <para>Type: <b>LPTSTR</b></para>
      <para>The character string.</para>
    </param>
    <param name="nSize">
      <para>Type: <b>int</b></para>
      <para>The size, in
characters, of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in
characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The string returned for an integer atom (an atom whose value is in the range 0x0001 to 0xBFFF) is a null-terminated string in which the first character is a pound sign (#) and the remaining characters represent the unsigned integer atom value.</para>
      <h3>Security Considerations</h3>
      <para>Using this function incorrectly might compromise the security of your program. Incorrect use of this function includes not correctly specifying the size of the <i>lpBuffer</i> parameter.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetAtomName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="GlobalGetAtomName" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.GetBinaryType">
    <summary>
      <para>Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable
file.</para>
    </summary>
    <param name="lpApplicationName">
      <para>The full path of the file whose executable type is to be determined.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </param>
    <param name="lpBinaryType">
      <para>A pointer to a variable to receive information about the executable type of the file specified by
<i>lpApplicationName</i>. The following constants are defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_32BIT_BINARY</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 32-bit Windows-based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_64BIT_BINARY</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 64-bit Windows-based application.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_DOS_BINARY</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>An MS-DOS – based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_OS216_BINARY</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 16-bit OS/2-based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_PIF_BINARY</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>A PIF file that executes an MS-DOS – based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_POSIX_BINARY</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>A POSIX – based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_WOW_BINARY</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 16-bit Windows-based application</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the file is executable, the return value is nonzero. The function sets the variable pointed to by
<i>lpBinaryType</i> to indicate the file's executable type.</para>
      <para>If the file is not executable, or if the function fails, the return value is zero. To get extended error
information, call <see cref="GetLastError" />. If the file is a DLL,
the last error code is <b>ERROR_BAD_EXE_FORMAT</b>.</para>
    </returns>
    <remarks>
      <para>As an alternative, you can obtain the same information by calling the
<see cref="SHGetFileInfo" /> function, passing the
<b>SHGFI_EXETYPE</b> flag in the <i>uFlags</i> parameter.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the target file is
used.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetBinaryType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="SHGetFileInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetBinaryTypeA">
    <summary>
      <para>Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable
file.</para>
    </summary>
    <param name="lpApplicationName">
      <para>The full path of the file whose executable type is to be determined.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </param>
    <param name="lpBinaryType">
      <para>A pointer to a variable to receive information about the executable type of the file specified by
<i>lpApplicationName</i>. The following constants are defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_32BIT_BINARY</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 32-bit Windows-based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_64BIT_BINARY</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 64-bit Windows-based application.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_DOS_BINARY</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>An MS-DOS – based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_OS216_BINARY</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 16-bit OS/2-based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_PIF_BINARY</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>A PIF file that executes an MS-DOS – based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_POSIX_BINARY</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>A POSIX – based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_WOW_BINARY</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 16-bit Windows-based application</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the file is executable, the return value is nonzero. The function sets the variable pointed to by
<i>lpBinaryType</i> to indicate the file's executable type.</para>
      <para>If the file is not executable, or if the function fails, the return value is zero. To get extended error
information, call <see cref="GetLastError" />. If the file is a DLL,
the last error code is <b>ERROR_BAD_EXE_FORMAT</b>.</para>
    </returns>
    <remarks>
      <para>As an alternative, you can obtain the same information by calling the
<see cref="SHGetFileInfo" /> function, passing the
<b>SHGFI_EXETYPE</b> flag in the <i>uFlags</i> parameter.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the target file is
used.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetBinaryType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="SHGetFileInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetBinaryTypeW">
    <summary>
      <para>Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable
file.</para>
    </summary>
    <param name="lpApplicationName">
      <para>The full path of the file whose executable type is to be determined.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </param>
    <param name="lpBinaryType">
      <para>A pointer to a variable to receive information about the executable type of the file specified by
<i>lpApplicationName</i>. The following constants are defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_32BIT_BINARY</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 32-bit Windows-based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_64BIT_BINARY</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 64-bit Windows-based application.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_DOS_BINARY</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>An MS-DOS – based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_OS216_BINARY</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 16-bit OS/2-based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_PIF_BINARY</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>A PIF file that executes an MS-DOS – based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_POSIX_BINARY</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>A POSIX – based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_WOW_BINARY</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 16-bit Windows-based application</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the file is executable, the return value is nonzero. The function sets the variable pointed to by
<i>lpBinaryType</i> to indicate the file's executable type.</para>
      <para>If the file is not executable, or if the function fails, the return value is zero. To get extended error
information, call <see cref="GetLastError" />. If the file is a DLL,
the last error code is <b>ERROR_BAD_EXE_FORMAT</b>.</para>
    </returns>
    <remarks>
      <para>As an alternative, you can obtain the same information by calling the
<see cref="SHGetFileInfo" /> function, passing the
<b>SHGFI_EXETYPE</b> flag in the <i>uFlags</i> parameter.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the target file is
used.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetBinaryType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="SHGetFileInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetBinaryType">
    <summary>
      <para>Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable
file.</para>
    </summary>
    <param name="lpApplicationName">
      <para>The full path of the file whose executable type is to be determined.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </param>
    <param name="lpBinaryType">
      <para>A pointer to a variable to receive information about the executable type of the file specified by
<i>lpApplicationName</i>. The following constants are defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_32BIT_BINARY</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 32-bit Windows-based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_64BIT_BINARY</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 64-bit Windows-based application.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_DOS_BINARY</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>An MS-DOS – based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_OS216_BINARY</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 16-bit OS/2-based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_PIF_BINARY</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>A PIF file that executes an MS-DOS – based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_POSIX_BINARY</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>A POSIX – based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_WOW_BINARY</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 16-bit Windows-based application</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the file is executable, the return value is nonzero. The function sets the variable pointed to by
<i>lpBinaryType</i> to indicate the file's executable type.</para>
      <para>If the file is not executable, or if the function fails, the return value is zero. To get extended error
information, call <see cref="GetLastError" />. If the file is a DLL,
the last error code is <b>ERROR_BAD_EXE_FORMAT</b>.</para>
    </returns>
    <remarks>
      <para>As an alternative, you can obtain the same information by calling the
<see cref="SHGetFileInfo" /> function, passing the
<b>SHGFI_EXETYPE</b> flag in the <i>uFlags</i> parameter.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the target file is
used.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetBinaryType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="SHGetFileInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetBinaryTypeA">
    <summary>
      <para>Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable
file.</para>
    </summary>
    <param name="lpApplicationName">
      <para>The full path of the file whose executable type is to be determined.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </param>
    <param name="lpBinaryType">
      <para>A pointer to a variable to receive information about the executable type of the file specified by
<i>lpApplicationName</i>. The following constants are defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_32BIT_BINARY</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 32-bit Windows-based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_64BIT_BINARY</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 64-bit Windows-based application.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_DOS_BINARY</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>An MS-DOS – based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_OS216_BINARY</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 16-bit OS/2-based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_PIF_BINARY</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>A PIF file that executes an MS-DOS – based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_POSIX_BINARY</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>A POSIX – based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_WOW_BINARY</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 16-bit Windows-based application</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the file is executable, the return value is nonzero. The function sets the variable pointed to by
<i>lpBinaryType</i> to indicate the file's executable type.</para>
      <para>If the file is not executable, or if the function fails, the return value is zero. To get extended error
information, call <see cref="GetLastError" />. If the file is a DLL,
the last error code is <b>ERROR_BAD_EXE_FORMAT</b>.</para>
    </returns>
    <remarks>
      <para>As an alternative, you can obtain the same information by calling the
<see cref="SHGetFileInfo" /> function, passing the
<b>SHGFI_EXETYPE</b> flag in the <i>uFlags</i> parameter.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the target file is
used.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetBinaryType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="SHGetFileInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetBinaryTypeW">
    <summary>
      <para>Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable
file.</para>
    </summary>
    <param name="lpApplicationName">
      <para>The full path of the file whose executable type is to be determined.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
    </param>
    <param name="lpBinaryType">
      <para>A pointer to a variable to receive information about the executable type of the file specified by
<i>lpApplicationName</i>. The following constants are defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_32BIT_BINARY</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 32-bit Windows-based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_64BIT_BINARY</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 64-bit Windows-based application.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_DOS_BINARY</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>An MS-DOS – based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_OS216_BINARY</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 16-bit OS/2-based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_PIF_BINARY</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>A PIF file that executes an MS-DOS – based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_POSIX_BINARY</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>A POSIX – based application</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SCS_WOW_BINARY</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>A 16-bit Windows-based application</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the file is executable, the return value is nonzero. The function sets the variable pointed to by
<i>lpBinaryType</i> to indicate the file's executable type.</para>
      <para>If the file is not executable, or if the function fails, the return value is zero. To get extended error
information, call <see cref="GetLastError" />. If the file is a DLL,
the last error code is <b>ERROR_BAD_EXE_FORMAT</b>.</para>
    </returns>
    <remarks>
      <para>As an alternative, you can obtain the same information by calling the
<see cref="SHGetFileInfo" /> function, passing the
<b>SHGFI_EXETYPE</b> flag in the <i>uFlags</i> parameter.</para>
      <para>Symbolic link behavior—If the path points to a symbolic link, the target file is
used.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetBinaryType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="SHGetFileInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/symbolic-links">Symbolic Links</seealso>
  </member>
  <member name="Windows.GetCommConfig">
    <summary>
      <para>Retrieves the current configuration of a communications device.</para>
      <para>To retrieve the default configuration settings from the device manager, use the <see cref="GetDefaultCommConfig" /> function.</para>
    </summary>
    <param name="hCommDev">
      <para>A handle to the open communications device. The
<see cref="CreateFile" /> function returns this handle.</para>
    </param>
    <param name="lpCC">
      <para>A pointer to a buffer that receives a
<see cref="COMMCONFIG" /> structure.</para>
    </param>
    <param name="lpdwSize">
      <para>The size, in bytes, of the buffer pointed to by <i>lpCC</i>. When the function returns, the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the buffer was too small.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the
<see cref="GetLastError" /> function.</para>
    </returns>
    <seealso cref="COMMCONFIG" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="CreateFile" />
    <seealso cref="GetDefaultCommConfig" />
    <seealso cref="SetCommConfig" />
  </member>
  <member name="Windows.GetCommMask">
    <summary>
      <para>Retrieves the value of the event mask for a specified communications device.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the communications device. The
<see cref="CreateFile" /> function returns this handle.</para>
    </param>
    <param name="lpEvtMask">
      <para>A pointer to the variable that receives a mask of events that are currently enabled. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_BREAK</b>
                </description>
              </item>
              <item>
                <description>0x0040</description>
              </item>
            </list>
          </description>
          <description>
            <para>A break was detected on input.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_CTS</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The CTS (clear-to-send) signal changed state.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_DSR</b>
                </description>
              </item>
              <item>
                <description>0x0010</description>
              </item>
            </list>
          </description>
          <description>
            <para>The DSR (data-set-ready) signal changed state.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_ERR</b>
                </description>
              </item>
              <item>
                <description>0x0080</description>
              </item>
            </list>
          </description>
          <description>
            <para>A line-status error occurred. Line-status errors are <b>CE_FRAME</b>, <b>CE_OVERRUN</b>, and <b>CE_RXPARITY</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_EVENT1</b>
                </description>
              </item>
              <item>
                <description>0x0800</description>
              </item>
            </list>
          </description>
          <description>
            <para>An event of the first provider-specific type occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_EVENT2</b>
                </description>
              </item>
              <item>
                <description>0x1000</description>
              </item>
            </list>
          </description>
          <description>
            <para>An event of the second provider-specific type occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_PERR</b>
                </description>
              </item>
              <item>
                <description>0x0200</description>
              </item>
            </list>
          </description>
          <description>
            <para>A printer error occurred.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_RING</b>
                </description>
              </item>
              <item>
                <description>0x0100</description>
              </item>
            </list>
          </description>
          <description>
            <para>A ring indicator was detected.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_RLSD</b>
                </description>
              </item>
              <item>
                <description>0x0020</description>
              </item>
            </list>
          </description>
          <description>
            <para>The RLSD (receive-line-signal-detect) signal changed state.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_RX80FULL</b>
                </description>
              </item>
              <item>
                <description>0x0400</description>
              </item>
            </list>
          </description>
          <description>
            <para>The receive buffer is 80 percent full.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_RXCHAR</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>A character was received and placed in the input buffer.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_RXFLAG</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The event character was received and placed in the input buffer. The event character is specified in the device's
<see cref="DCB" /> structure, which is applied to a serial port by using the
<see cref="SetCommState" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_TXEMPTY</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The last character in the output buffer was sent.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetCommMask</b> function uses a mask variable to indicate the set of events that can be monitored for a particular communications resource. A handle to the communications resource can be specified in a call to the
<see cref="WaitCommEvent" /> function, which waits for one of the events to occur. To modify the event mask of a communications resource, use the
<see cref="SetCommMask" /> function.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="CreateFile" />
    <seealso cref="DCB" />
    <seealso cref="SetCommMask" />
    <seealso cref="WaitCommEvent" />
  </member>
  <member name="Windows.GetCommModemStatus">
    <summary>
      <para>Retrieves the modem control-register values.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the communications device. The
<see cref="CreateFile" /> function returns this handle.</para>
    </param>
    <param name="lpModemStat">
      <para>A pointer to a variable that receives the current state of the modem control-register values. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MS_CTS_ON</b>
                </description>
              </item>
              <item>
                <description>0x0010</description>
              </item>
            </list>
          </description>
          <description>
            <para>The CTS (clear-to-send) signal is on.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MS_DSR_ON</b>
                </description>
              </item>
              <item>
                <description>0x0020</description>
              </item>
            </list>
          </description>
          <description>
            <para>The DSR (data-set-ready) signal is on.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MS_RING_ON</b>
                </description>
              </item>
              <item>
                <description>0x0040</description>
              </item>
            </list>
          </description>
          <description>
            <para>The ring indicator signal is on.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MS_RLSD_ON</b>
                </description>
              </item>
              <item>
                <description>0x0080</description>
              </item>
            </list>
          </description>
          <description>
            <para>The RLSD (receive-line-signal-detect) signal is on.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetCommModemStatus</b> function is useful when you are using the
<see cref="WaitCommEvent" /> function to monitor the CTS, RLSD, DSR, or ring indicator signals. To detect when these signals change state, use
<b>WaitCommEvent</b> and then use
<b>GetCommModemStatus</b> to determine the state after a change occurs.</para>
      <para>The function fails if the hardware does not support the control-register values.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="CreateFile" />
    <seealso cref="WaitCommEvent" />
  </member>
  <member name="Windows.GetCommPorts">
    <summary>
      <para>Gets an array that contains the well-formed COM ports.</para>
      <para>This function obtains the COM port numbers from the <b>HKLM\Hardware\DeviceMap\SERIALCOMM</b> registry key and then writes them to a caller-supplied array. If the array is too small, the function gets the necessary size.
<b>Note</b>  If new entries are added to the registry key, the necessary size can change between API calls.</para>
    </summary>
    <param name="lpPortNumbers">
      <para>An array for the port numbers.</para>
    </param>
    <param name="uPortNumbersCount">
      <para>The length of the array in the <i>lpPortNumbers</i> parameter.</para>
    </param>
    <param name="puPortNumbersFound">
      <para>The number of port numbers written to the <i>lpPortNumbers</i> or the length of the array required for the port numbers.</para>
    </param>
    <returns>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_SUCCESS</b>
            </para>
          </description>
          <description>
            <para>The call succeeded. The <i>lpPortNumbers</i> array was large enough for the result.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_MORE_DATA</b>
            </para>
          </description>
          <description>
            <para>The <i>lpPortNumbers</i> array was too small to contain all available port numbers.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_FILE_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>There are no comm ports available.</para>
          </description>
        </item>
      </list>
    </returns>
  </member>
  <member name="Windows.GetCommProperties">
    <summary>
      <para>Retrieves information about the communications properties for a specified communications device.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the communications device. The
<see cref="CreateFile" /> function returns this handle.</para>
    </param>
    <param name="lpCommProp">
      <para>A pointer to a
<see cref="COMMPROP" /> structure in which the communications properties information is returned. This information can be used in subsequent calls to the
<see cref="SetCommState" />,
<see cref="SetCommTimeouts" />, or
<see cref="SetupComm" /> function to configure the communications device.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetCommProperties</b> function returns information from a device driver about the configuration settings that are supported by the driver.</para>
    </remarks>
    <seealso cref="COMMPROP" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="CreateFile" />
    <seealso cref="SetCommState" />
    <seealso cref="SetCommTimeouts" />
    <seealso cref="SetupComm" />
  </member>
  <member name="Windows.GetCommState">
    <summary>
      <para>Retrieves the current control settings for a specified communications device.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the communications device. The
<see cref="CreateFile" /> function returns this handle.</para>
    </param>
    <param name="lpDCB">
      <para>A pointer to a
<see cref="DCB" /> structure that receives the control settings information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="CreateFile" />
    <seealso cref="DCB" />
    <seealso cref="SetCommState" />
  </member>
  <member name="Windows.GetCommTimeouts">
    <summary>
      <para>Retrieves the time-out parameters for all read and write operations on a specified communications device.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the communications device. The
<see cref="CreateFile" /> function returns this handle.</para>
    </param>
    <param name="lpCommTimeouts">
      <para>A pointer to a
<see cref="COMMTIMEOUTS" /> structure in which the time-out information is returned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>For more information about time-out values for communications devices, see the
<see cref="SetCommTimeouts" /> function.</para>
    </remarks>
    <seealso cref="COMMTIMEOUTS" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="CreateFile" />
    <seealso cref="SetCommTimeouts" />
  </member>
  <member name="Windows.GetComputerName">
    <summary>
      <para>Retrieves the NetBIOS name of the local computer. This name is established at system startup, when the system reads it from the registry.</para>
      <para>
        <b>GetComputerName</b> retrieves only the NetBIOS name of the local computer. To retrieve the DNS host name, DNS domain name, or the fully qualified DNS name, call the
<see cref="GetComputerNameEx" /> function. Additional information is provided by the
<see cref="IADsADSystemInfo" /> interface.</para>
      <para>The behavior of this function can be affected if the local computer is a node in a cluster. For more information, see <see cref="ResUtilGetEnvironmentWithNetName" /> and <a href="https://docs.microsoft.com//previous-versions/windows/desktop/mscs/generic-applications-usenetworkname">UseNetworkName</a>.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the computer name or the cluster virtual server name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</para>
    </param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails and <see cref="GetLastError" /> returns ERROR_BUFFER_OVERFLOW. The <i>lpnSize</i> parameter specifies the size of the buffer required, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetComputerName</b> function retrieves the NetBIOS name established at system startup. Name changes made by the
<see cref="SetComputerName" /> or
<see cref="SetComputerNameEx" /> functions do not take effect until the user restarts the computer.</para>
      <para>If the caller is running under a client session, this function returns the server name. To retrieve the client name, use the <see cref="WTSQuerySessionInformation" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetComputerName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerName" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetComputerNameA">
    <summary>
      <para>Retrieves the NetBIOS name of the local computer. This name is established at system startup, when the system reads it from the registry.</para>
      <para>
        <b>GetComputerName</b> retrieves only the NetBIOS name of the local computer. To retrieve the DNS host name, DNS domain name, or the fully qualified DNS name, call the
<see cref="GetComputerNameEx" /> function. Additional information is provided by the
<see cref="IADsADSystemInfo" /> interface.</para>
      <para>The behavior of this function can be affected if the local computer is a node in a cluster. For more information, see <see cref="ResUtilGetEnvironmentWithNetName" /> and <a href="https://docs.microsoft.com//previous-versions/windows/desktop/mscs/generic-applications-usenetworkname">UseNetworkName</a>.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the computer name or the cluster virtual server name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</para>
    </param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails and <see cref="GetLastError" /> returns ERROR_BUFFER_OVERFLOW. The <i>lpnSize</i> parameter specifies the size of the buffer required, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetComputerName</b> function retrieves the NetBIOS name established at system startup. Name changes made by the
<see cref="SetComputerName" /> or
<see cref="SetComputerNameEx" /> functions do not take effect until the user restarts the computer.</para>
      <para>If the caller is running under a client session, this function returns the server name. To retrieve the client name, use the <see cref="WTSQuerySessionInformation" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetComputerName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerName" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetComputerNameW">
    <summary>
      <para>Retrieves the NetBIOS name of the local computer. This name is established at system startup, when the system reads it from the registry.</para>
      <para>
        <b>GetComputerName</b> retrieves only the NetBIOS name of the local computer. To retrieve the DNS host name, DNS domain name, or the fully qualified DNS name, call the
<see cref="GetComputerNameEx" /> function. Additional information is provided by the
<see cref="IADsADSystemInfo" /> interface.</para>
      <para>The behavior of this function can be affected if the local computer is a node in a cluster. For more information, see <see cref="ResUtilGetEnvironmentWithNetName" /> and <a href="https://docs.microsoft.com//previous-versions/windows/desktop/mscs/generic-applications-usenetworkname">UseNetworkName</a>.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the computer name or the cluster virtual server name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</para>
    </param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails and <see cref="GetLastError" /> returns ERROR_BUFFER_OVERFLOW. The <i>lpnSize</i> parameter specifies the size of the buffer required, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetComputerName</b> function retrieves the NetBIOS name established at system startup. Name changes made by the
<see cref="SetComputerName" /> or
<see cref="SetComputerNameEx" /> functions do not take effect until the user restarts the computer.</para>
      <para>If the caller is running under a client session, this function returns the server name. To retrieve the client name, use the <see cref="WTSQuerySessionInformation" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetComputerName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerName" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetComputerName">
    <summary>
      <para>Retrieves the NetBIOS name of the local computer. This name is established at system startup, when the system reads it from the registry.</para>
      <para>
        <b>GetComputerName</b> retrieves only the NetBIOS name of the local computer. To retrieve the DNS host name, DNS domain name, or the fully qualified DNS name, call the
<see cref="GetComputerNameEx" /> function. Additional information is provided by the
<see cref="IADsADSystemInfo" /> interface.</para>
      <para>The behavior of this function can be affected if the local computer is a node in a cluster. For more information, see <see cref="ResUtilGetEnvironmentWithNetName" /> and <a href="https://docs.microsoft.com//previous-versions/windows/desktop/mscs/generic-applications-usenetworkname">UseNetworkName</a>.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the computer name or the cluster virtual server name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</para>
    </param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails and <see cref="GetLastError" /> returns ERROR_BUFFER_OVERFLOW. The <i>lpnSize</i> parameter specifies the size of the buffer required, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetComputerName</b> function retrieves the NetBIOS name established at system startup. Name changes made by the
<see cref="SetComputerName" /> or
<see cref="SetComputerNameEx" /> functions do not take effect until the user restarts the computer.</para>
      <para>If the caller is running under a client session, this function returns the server name. To retrieve the client name, use the <see cref="WTSQuerySessionInformation" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetComputerName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerName" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetComputerNameA">
    <summary>
      <para>Retrieves the NetBIOS name of the local computer. This name is established at system startup, when the system reads it from the registry.</para>
      <para>
        <b>GetComputerName</b> retrieves only the NetBIOS name of the local computer. To retrieve the DNS host name, DNS domain name, or the fully qualified DNS name, call the
<see cref="GetComputerNameEx" /> function. Additional information is provided by the
<see cref="IADsADSystemInfo" /> interface.</para>
      <para>The behavior of this function can be affected if the local computer is a node in a cluster. For more information, see <see cref="ResUtilGetEnvironmentWithNetName" /> and <a href="https://docs.microsoft.com//previous-versions/windows/desktop/mscs/generic-applications-usenetworkname">UseNetworkName</a>.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the computer name or the cluster virtual server name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</para>
    </param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails and <see cref="GetLastError" /> returns ERROR_BUFFER_OVERFLOW. The <i>lpnSize</i> parameter specifies the size of the buffer required, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetComputerName</b> function retrieves the NetBIOS name established at system startup. Name changes made by the
<see cref="SetComputerName" /> or
<see cref="SetComputerNameEx" /> functions do not take effect until the user restarts the computer.</para>
      <para>If the caller is running under a client session, this function returns the server name. To retrieve the client name, use the <see cref="WTSQuerySessionInformation" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetComputerName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerName" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetComputerNameW">
    <summary>
      <para>Retrieves the NetBIOS name of the local computer. This name is established at system startup, when the system reads it from the registry.</para>
      <para>
        <b>GetComputerName</b> retrieves only the NetBIOS name of the local computer. To retrieve the DNS host name, DNS domain name, or the fully qualified DNS name, call the
<see cref="GetComputerNameEx" /> function. Additional information is provided by the
<see cref="IADsADSystemInfo" /> interface.</para>
      <para>The behavior of this function can be affected if the local computer is a node in a cluster. For more information, see <see cref="ResUtilGetEnvironmentWithNetName" /> and <a href="https://docs.microsoft.com//previous-versions/windows/desktop/mscs/generic-applications-usenetworkname">UseNetworkName</a>.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the computer name or the cluster virtual server name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</para>
    </param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails and <see cref="GetLastError" /> returns ERROR_BUFFER_OVERFLOW. The <i>lpnSize</i> parameter specifies the size of the buffer required, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetComputerName</b> function retrieves the NetBIOS name established at system startup. Name changes made by the
<see cref="SetComputerName" /> or
<see cref="SetComputerNameEx" /> functions do not take effect until the user restarts the computer.</para>
      <para>If the caller is running under a client session, this function returns the server name. To retrieve the client name, use the <see cref="WTSQuerySessionInformation" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetComputerName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</seealso>
    <seealso cref="GetComputerNameEx" />
    <seealso cref="SetComputerName" />
    <seealso cref="SetComputerNameEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetCurrentActCtx">
    <summary>
      <para>The
<b>GetCurrentActCtx</b> function returns the handle to the active activation context of the calling thread.</para>
    </summary>
    <param name="lphActCtx">
      <para>Pointer to the returned
<see cref="ACTCTX" /> structure that contains information on the active activation context.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling
<see cref="GetLastError" />. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
    <remarks>
      <para>The calling thread is responsible for releasing the handle of the returned activation context. This function can return a null handle if no activation contexts have been activated by this thread. This is not an error.</para>
    </remarks>
    <seealso cref="ACTCTX" />
  </member>
  <member name="Windows.GetCurrentDirectory">
    <summary>
      <para>Retrieves the current directory for the current process.</para>
    </summary>
    <param name="nBufferLength">
      <para>The length of the buffer for the current directory string, in <b>TCHARs</b>. The
buffer length must include room for a terminating null character.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to the buffer that receives the current directory string. This null-terminated string specifies the
absolute path to the current directory.</para>
      <para>To determine the required buffer size, set this parameter to <b>NULL</b> and the
<i>nBufferLength</i> parameter to 0.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the number of characters that are written to the buffer,
not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the buffer that is pointed to by <i>lpBuffer</i> is not large enough, the return value
specifies the required size of the buffer, in characters, including the null-terminating character.</para>
    </returns>
    <remarks>
      <para>Each process has a single current directory that consists of two parts:</para>
      <list type="bullet">
        <item>
          <description>A disk designator that is either a drive letter followed by a colon, or a server name followed by a share
name (\\<i>servername</i>\<i>sharename</i>)</description>
        </item>
        <item>
          <description>A directory on the disk designator</description>
        </item>
      </list>
      <para>To set the current directory, use the
<see cref="SetCurrentDirectory" /> function.</para>
      <para>Multithreaded applications and shared library code should not use the
<b>GetCurrentDirectory</b> function and should avoid using relative path names. The current directory state written by the <see cref="SetCurrentDirectory" /> function is stored as a global variable in each process, therefore multithreaded applications cannot reliably use this value without possible data corruption from other threads that may also be reading or setting this value. This limitation also applies to the <b>SetCurrentDirectory</b> and <see cref="GetFullPathName" /> functions. The exception being when the application is guaranteed to be running in a single thread, for example parsing file names from the command line argument string in the main thread prior to creating any additional threads. Using relative path names in multithreaded applications or shared library code can yield unpredictable results and is not supported.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/changing-the-current-directory">Changing the Current Directory</a>.</para>
    </remarks>
    <seealso cref="CreateDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="RemoveDirectory" />
    <seealso cref="SetCurrentDirectory" />
  </member>
  <member name="Windows.GetCurrentDirectoryA">
    <summary>
      <para>Retrieves the current directory for the current process.</para>
    </summary>
    <param name="nBufferLength">
      <para>The length of the buffer for the current directory string, in <b>TCHARs</b>. The
buffer length must include room for a terminating null character.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to the buffer that receives the current directory string. This null-terminated string specifies the
absolute path to the current directory.</para>
      <para>To determine the required buffer size, set this parameter to <b>NULL</b> and the
<i>nBufferLength</i> parameter to 0.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the number of characters that are written to the buffer,
not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the buffer that is pointed to by <i>lpBuffer</i> is not large enough, the return value
specifies the required size of the buffer, in characters, including the null-terminating character.</para>
    </returns>
    <remarks>
      <para>Each process has a single current directory that consists of two parts:</para>
      <list type="bullet">
        <item>
          <description>A disk designator that is either a drive letter followed by a colon, or a server name followed by a share
name (\\<i>servername</i>\<i>sharename</i>)</description>
        </item>
        <item>
          <description>A directory on the disk designator</description>
        </item>
      </list>
      <para>To set the current directory, use the
<see cref="SetCurrentDirectory" /> function.</para>
      <para>Multithreaded applications and shared library code should not use the
<b>GetCurrentDirectory</b> function and should avoid using relative path names. The current directory state written by the <see cref="SetCurrentDirectory" /> function is stored as a global variable in each process, therefore multithreaded applications cannot reliably use this value without possible data corruption from other threads that may also be reading or setting this value. This limitation also applies to the <b>SetCurrentDirectory</b> and <see cref="GetFullPathName" /> functions. The exception being when the application is guaranteed to be running in a single thread, for example parsing file names from the command line argument string in the main thread prior to creating any additional threads. Using relative path names in multithreaded applications or shared library code can yield unpredictable results and is not supported.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/changing-the-current-directory">Changing the Current Directory</a>.</para>
    </remarks>
    <seealso cref="CreateDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="RemoveDirectory" />
    <seealso cref="SetCurrentDirectory" />
  </member>
  <member name="Windows.GetCurrentDirectoryW">
    <summary>
      <para>Retrieves the current directory for the current process.</para>
    </summary>
    <param name="nBufferLength">
      <para>The length of the buffer for the current directory string, in <b>TCHARs</b>. The
buffer length must include room for a terminating null character.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to the buffer that receives the current directory string. This null-terminated string specifies the
absolute path to the current directory.</para>
      <para>To determine the required buffer size, set this parameter to <b>NULL</b> and the
<i>nBufferLength</i> parameter to 0.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the number of characters that are written to the buffer,
not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the buffer that is pointed to by <i>lpBuffer</i> is not large enough, the return value
specifies the required size of the buffer, in characters, including the null-terminating character.</para>
    </returns>
    <remarks>
      <para>Each process has a single current directory that consists of two parts:</para>
      <list type="bullet">
        <item>
          <description>A disk designator that is either a drive letter followed by a colon, or a server name followed by a share
name (\\<i>servername</i>\<i>sharename</i>)</description>
        </item>
        <item>
          <description>A directory on the disk designator</description>
        </item>
      </list>
      <para>To set the current directory, use the
<see cref="SetCurrentDirectory" /> function.</para>
      <para>Multithreaded applications and shared library code should not use the
<b>GetCurrentDirectory</b> function and should avoid using relative path names. The current directory state written by the <see cref="SetCurrentDirectory" /> function is stored as a global variable in each process, therefore multithreaded applications cannot reliably use this value without possible data corruption from other threads that may also be reading or setting this value. This limitation also applies to the <b>SetCurrentDirectory</b> and <see cref="GetFullPathName" /> functions. The exception being when the application is guaranteed to be running in a single thread, for example parsing file names from the command line argument string in the main thread prior to creating any additional threads. Using relative path names in multithreaded applications or shared library code can yield unpredictable results and is not supported.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/changing-the-current-directory">Changing the Current Directory</a>.</para>
    </remarks>
    <seealso cref="CreateDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="RemoveDirectory" />
    <seealso cref="SetCurrentDirectory" />
  </member>
  <member name="Windows.GetCurrentHwProfile">
    <summary>
      <para>Retrieves information about the current hardware profile for the local computer.</para>
    </summary>
    <param name="lpHwProfileInfo">
      <para>A pointer to an
<see cref="HW_PROFILE_INFO" /> structure that receives information about the current hardware profile.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetCurrentHwProfile</b> function retrieves the display name and globally unique identifier (GUID) string for the hardware profile. The function also retrieves the reported docking state for portable computers with docking stations.</para>
      <para>The system generates a GUID for each hardware profile and stores it as a string in the registry. You can use
<b>GetCurrentHwProfile</b> to retrieve the GUID string to use as a registry subkey under your application's configuration settings key in <b>HKEY_CURRENT_USER</b>. This enables you to store each user's settings for each hardware profile. For example, the Colors control panel application could use the subkey to store each user's color preferences for different hardware profiles, such as profiles for the docked and undocked states. Applications that use this functionality can check the current hardware profile when they start up, and update their settings accordingly.</para>
      <para>Applications can also update their settings when a system device message, such as
<a href="https://docs.microsoft.com//windows/desktop/DevIO/dbt-configchanged">DBT_CONFIGCHANGED</a>, indicates that the hardware profile has changed.</para>
      <para>To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

void main(void)
{
   HW_PROFILE_INFO   HwProfInfo;
   if (!GetCurrentHwProfile(&amp;amp;amp;amp;amp;amp;HwProfInfo))
   {
      _tprintf(TEXT("GetCurrentHwProfile failed with error %lx\n"),
                 GetLastError());
      return;
   }
   _tprintf(TEXT("DockInfo = %d\n"), HwProfInfo.dwDockInfo);
   _tprintf(TEXT("Profile Guid = %s\n"), HwProfInfo.szHwProfileGuid);
   _tprintf(TEXT("Friendly Name = %s\n"), HwProfInfo.szHwProfileName);
}

</code>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetCurrentHwProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/dbt-configchanged">DBT_CONFIGCHANGED</seealso>
    <seealso cref="HW_PROFILE_INFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetCurrentHwProfileA">
    <summary>
      <para>Retrieves information about the current hardware profile for the local computer.</para>
    </summary>
    <param name="lpHwProfileInfo">
      <para>A pointer to an
<see cref="HW_PROFILE_INFO" /> structure that receives information about the current hardware profile.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetCurrentHwProfile</b> function retrieves the display name and globally unique identifier (GUID) string for the hardware profile. The function also retrieves the reported docking state for portable computers with docking stations.</para>
      <para>The system generates a GUID for each hardware profile and stores it as a string in the registry. You can use
<b>GetCurrentHwProfile</b> to retrieve the GUID string to use as a registry subkey under your application's configuration settings key in <b>HKEY_CURRENT_USER</b>. This enables you to store each user's settings for each hardware profile. For example, the Colors control panel application could use the subkey to store each user's color preferences for different hardware profiles, such as profiles for the docked and undocked states. Applications that use this functionality can check the current hardware profile when they start up, and update their settings accordingly.</para>
      <para>Applications can also update their settings when a system device message, such as
<a href="https://docs.microsoft.com//windows/desktop/DevIO/dbt-configchanged">DBT_CONFIGCHANGED</a>, indicates that the hardware profile has changed.</para>
      <para>To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

void main(void)
{
   HW_PROFILE_INFO   HwProfInfo;
   if (!GetCurrentHwProfile(&amp;amp;amp;amp;amp;amp;HwProfInfo))
   {
      _tprintf(TEXT("GetCurrentHwProfile failed with error %lx\n"),
                 GetLastError());
      return;
   }
   _tprintf(TEXT("DockInfo = %d\n"), HwProfInfo.dwDockInfo);
   _tprintf(TEXT("Profile Guid = %s\n"), HwProfInfo.szHwProfileGuid);
   _tprintf(TEXT("Friendly Name = %s\n"), HwProfInfo.szHwProfileName);
}

</code>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetCurrentHwProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/dbt-configchanged">DBT_CONFIGCHANGED</seealso>
    <seealso cref="HW_PROFILE_INFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetCurrentHwProfileW">
    <summary>
      <para>Retrieves information about the current hardware profile for the local computer.</para>
    </summary>
    <param name="lpHwProfileInfo">
      <para>A pointer to an
<see cref="HW_PROFILE_INFO" /> structure that receives information about the current hardware profile.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetCurrentHwProfile</b> function retrieves the display name and globally unique identifier (GUID) string for the hardware profile. The function also retrieves the reported docking state for portable computers with docking stations.</para>
      <para>The system generates a GUID for each hardware profile and stores it as a string in the registry. You can use
<b>GetCurrentHwProfile</b> to retrieve the GUID string to use as a registry subkey under your application's configuration settings key in <b>HKEY_CURRENT_USER</b>. This enables you to store each user's settings for each hardware profile. For example, the Colors control panel application could use the subkey to store each user's color preferences for different hardware profiles, such as profiles for the docked and undocked states. Applications that use this functionality can check the current hardware profile when they start up, and update their settings accordingly.</para>
      <para>Applications can also update their settings when a system device message, such as
<a href="https://docs.microsoft.com//windows/desktop/DevIO/dbt-configchanged">DBT_CONFIGCHANGED</a>, indicates that the hardware profile has changed.</para>
      <para>To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

void main(void)
{
   HW_PROFILE_INFO   HwProfInfo;
   if (!GetCurrentHwProfile(&amp;amp;amp;amp;amp;amp;HwProfInfo))
   {
      _tprintf(TEXT("GetCurrentHwProfile failed with error %lx\n"),
                 GetLastError());
      return;
   }
   _tprintf(TEXT("DockInfo = %d\n"), HwProfInfo.dwDockInfo);
   _tprintf(TEXT("Profile Guid = %s\n"), HwProfInfo.szHwProfileGuid);
   _tprintf(TEXT("Friendly Name = %s\n"), HwProfInfo.szHwProfileName);
}

</code>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetCurrentHwProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/dbt-configchanged">DBT_CONFIGCHANGED</seealso>
    <seealso cref="HW_PROFILE_INFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetCurrentHwProfile">
    <summary>
      <para>Retrieves information about the current hardware profile for the local computer.</para>
    </summary>
    <param name="lpHwProfileInfo">
      <para>A pointer to an
<see cref="HW_PROFILE_INFO" /> structure that receives information about the current hardware profile.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetCurrentHwProfile</b> function retrieves the display name and globally unique identifier (GUID) string for the hardware profile. The function also retrieves the reported docking state for portable computers with docking stations.</para>
      <para>The system generates a GUID for each hardware profile and stores it as a string in the registry. You can use
<b>GetCurrentHwProfile</b> to retrieve the GUID string to use as a registry subkey under your application's configuration settings key in <b>HKEY_CURRENT_USER</b>. This enables you to store each user's settings for each hardware profile. For example, the Colors control panel application could use the subkey to store each user's color preferences for different hardware profiles, such as profiles for the docked and undocked states. Applications that use this functionality can check the current hardware profile when they start up, and update their settings accordingly.</para>
      <para>Applications can also update their settings when a system device message, such as
<a href="https://docs.microsoft.com//windows/desktop/DevIO/dbt-configchanged">DBT_CONFIGCHANGED</a>, indicates that the hardware profile has changed.</para>
      <para>To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

void main(void)
{
   HW_PROFILE_INFO   HwProfInfo;
   if (!GetCurrentHwProfile(&amp;amp;amp;amp;amp;amp;HwProfInfo))
   {
      _tprintf(TEXT("GetCurrentHwProfile failed with error %lx\n"),
                 GetLastError());
      return;
   }
   _tprintf(TEXT("DockInfo = %d\n"), HwProfInfo.dwDockInfo);
   _tprintf(TEXT("Profile Guid = %s\n"), HwProfInfo.szHwProfileGuid);
   _tprintf(TEXT("Friendly Name = %s\n"), HwProfInfo.szHwProfileName);
}

</code>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetCurrentHwProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/dbt-configchanged">DBT_CONFIGCHANGED</seealso>
    <seealso cref="HW_PROFILE_INFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetCurrentHwProfileA">
    <summary>
      <para>Retrieves information about the current hardware profile for the local computer.</para>
    </summary>
    <param name="lpHwProfileInfo">
      <para>A pointer to an
<see cref="HW_PROFILE_INFO" /> structure that receives information about the current hardware profile.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetCurrentHwProfile</b> function retrieves the display name and globally unique identifier (GUID) string for the hardware profile. The function also retrieves the reported docking state for portable computers with docking stations.</para>
      <para>The system generates a GUID for each hardware profile and stores it as a string in the registry. You can use
<b>GetCurrentHwProfile</b> to retrieve the GUID string to use as a registry subkey under your application's configuration settings key in <b>HKEY_CURRENT_USER</b>. This enables you to store each user's settings for each hardware profile. For example, the Colors control panel application could use the subkey to store each user's color preferences for different hardware profiles, such as profiles for the docked and undocked states. Applications that use this functionality can check the current hardware profile when they start up, and update their settings accordingly.</para>
      <para>Applications can also update their settings when a system device message, such as
<a href="https://docs.microsoft.com//windows/desktop/DevIO/dbt-configchanged">DBT_CONFIGCHANGED</a>, indicates that the hardware profile has changed.</para>
      <para>To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

void main(void)
{
   HW_PROFILE_INFO   HwProfInfo;
   if (!GetCurrentHwProfile(&amp;amp;amp;amp;amp;amp;HwProfInfo))
   {
      _tprintf(TEXT("GetCurrentHwProfile failed with error %lx\n"),
                 GetLastError());
      return;
   }
   _tprintf(TEXT("DockInfo = %d\n"), HwProfInfo.dwDockInfo);
   _tprintf(TEXT("Profile Guid = %s\n"), HwProfInfo.szHwProfileGuid);
   _tprintf(TEXT("Friendly Name = %s\n"), HwProfInfo.szHwProfileName);
}

</code>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetCurrentHwProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/dbt-configchanged">DBT_CONFIGCHANGED</seealso>
    <seealso cref="HW_PROFILE_INFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetCurrentHwProfileW">
    <summary>
      <para>Retrieves information about the current hardware profile for the local computer.</para>
    </summary>
    <param name="lpHwProfileInfo">
      <para>A pointer to an
<see cref="HW_PROFILE_INFO" /> structure that receives information about the current hardware profile.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetCurrentHwProfile</b> function retrieves the display name and globally unique identifier (GUID) string for the hardware profile. The function also retrieves the reported docking state for portable computers with docking stations.</para>
      <para>The system generates a GUID for each hardware profile and stores it as a string in the registry. You can use
<b>GetCurrentHwProfile</b> to retrieve the GUID string to use as a registry subkey under your application's configuration settings key in <b>HKEY_CURRENT_USER</b>. This enables you to store each user's settings for each hardware profile. For example, the Colors control panel application could use the subkey to store each user's color preferences for different hardware profiles, such as profiles for the docked and undocked states. Applications that use this functionality can check the current hardware profile when they start up, and update their settings accordingly.</para>
      <para>Applications can also update their settings when a system device message, such as
<a href="https://docs.microsoft.com//windows/desktop/DevIO/dbt-configchanged">DBT_CONFIGCHANGED</a>, indicates that the hardware profile has changed.</para>
      <para>To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

void main(void)
{
   HW_PROFILE_INFO   HwProfInfo;
   if (!GetCurrentHwProfile(&amp;amp;amp;amp;amp;amp;HwProfInfo))
   {
      _tprintf(TEXT("GetCurrentHwProfile failed with error %lx\n"),
                 GetLastError());
      return;
   }
   _tprintf(TEXT("DockInfo = %d\n"), HwProfInfo.dwDockInfo);
   _tprintf(TEXT("Profile Guid = %s\n"), HwProfInfo.szHwProfileGuid);
   _tprintf(TEXT("Friendly Name = %s\n"), HwProfInfo.szHwProfileName);
}

</code>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetCurrentHwProfile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/dbt-configchanged">DBT_CONFIGCHANGED</seealso>
    <seealso cref="HW_PROFILE_INFO" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetCurrentUmsThread">
    <summary>
      <para>Returns the user-mode scheduling (UMS) thread context of the calling UMS thread.</para>
    </summary>
    <returns>
      <para>The function returns a pointer to the UMS thread context of the calling thread.</para>
      <para>If calling thread is not a UMS thread, the function returns NULL. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetCurrentUmsThread</b> function can be called for a UMS scheduler thread or UMS worker thread.</para>
    </remarks>
  </member>
  <member name="Windows.GetDefaultCommConfig">
    <summary>
      <para>Retrieves the default configuration for the specified communications device.</para>
    </summary>
    <param name="lpszName">
      <para>The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</para>
    </param>
    <param name="lpCC">
      <para>A pointer to a buffer that receives a
<see cref="COMMCONFIG" /> structure.</para>
    </param>
    <param name="lpdwSize">
      <para>A pointer to a variable that specifies the size of the buffer pointed to by <i>lpCC</i>, in bytes. Upon return, the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the buffer was too small.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetDefaultCommConfig as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMMCONFIG" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="SetDefaultCommConfig" />
  </member>
  <member name="Windows.GetDefaultCommConfigA">
    <summary>
      <para>Retrieves the default configuration for the specified communications device.</para>
    </summary>
    <param name="lpszName">
      <para>The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</para>
    </param>
    <param name="lpCC">
      <para>A pointer to a buffer that receives a
<see cref="COMMCONFIG" /> structure.</para>
    </param>
    <param name="lpdwSize">
      <para>A pointer to a variable that specifies the size of the buffer pointed to by <i>lpCC</i>, in bytes. Upon return, the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the buffer was too small.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetDefaultCommConfig as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMMCONFIG" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="SetDefaultCommConfig" />
  </member>
  <member name="Windows.GetDefaultCommConfigW">
    <summary>
      <para>Retrieves the default configuration for the specified communications device.</para>
    </summary>
    <param name="lpszName">
      <para>The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</para>
    </param>
    <param name="lpCC">
      <para>A pointer to a buffer that receives a
<see cref="COMMCONFIG" /> structure.</para>
    </param>
    <param name="lpdwSize">
      <para>A pointer to a variable that specifies the size of the buffer pointed to by <i>lpCC</i>, in bytes. Upon return, the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the buffer was too small.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetDefaultCommConfig as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMMCONFIG" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="SetDefaultCommConfig" />
  </member>
  <member name="Windows.GetDefaultCommConfig">
    <summary>
      <para>Retrieves the default configuration for the specified communications device.</para>
    </summary>
    <param name="lpszName">
      <para>The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</para>
    </param>
    <param name="lpCC">
      <para>A pointer to a buffer that receives a
<see cref="COMMCONFIG" /> structure.</para>
    </param>
    <param name="lpdwSize">
      <para>A pointer to a variable that specifies the size of the buffer pointed to by <i>lpCC</i>, in bytes. Upon return, the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the buffer was too small.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetDefaultCommConfig as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMMCONFIG" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="SetDefaultCommConfig" />
  </member>
  <member name="Windows.GetDefaultCommConfigA">
    <summary>
      <para>Retrieves the default configuration for the specified communications device.</para>
    </summary>
    <param name="lpszName">
      <para>The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</para>
    </param>
    <param name="lpCC">
      <para>A pointer to a buffer that receives a
<see cref="COMMCONFIG" /> structure.</para>
    </param>
    <param name="lpdwSize">
      <para>A pointer to a variable that specifies the size of the buffer pointed to by <i>lpCC</i>, in bytes. Upon return, the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the buffer was too small.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetDefaultCommConfig as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMMCONFIG" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="SetDefaultCommConfig" />
  </member>
  <member name="Windows.GetDefaultCommConfigW">
    <summary>
      <para>Retrieves the default configuration for the specified communications device.</para>
    </summary>
    <param name="lpszName">
      <para>The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</para>
    </param>
    <param name="lpCC">
      <para>A pointer to a buffer that receives a
<see cref="COMMCONFIG" /> structure.</para>
    </param>
    <param name="lpdwSize">
      <para>A pointer to a variable that specifies the size of the buffer pointed to by <i>lpCC</i>, in bytes. Upon return, the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the buffer was too small.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetDefaultCommConfig as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMMCONFIG" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="SetDefaultCommConfig" />
  </member>
  <member name="Windows.GetDevicePowerState">
    <summary>
      <para>Retrieves the current power state of the specified device. This function cannot be used to query the power state of a display device.</para>
    </summary>
    <param name="hDevice">
      <para>A handle to an object on the device, such as a file or socket, or a handle to the device itself.</para>
    </param>
    <param name="pfOn">
      <para>A pointer to the variable that receives the
<a href="https://docs.microsoft.com//windows/desktop/Power/system-power-states">power state</a>. This value is <b>TRUE</b> if the device is in the working state. Otherwise, it is <b>FALSE</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>An application can use
<b>GetDevicePowerState</b> to determine whether a device is in the working state or a low-power state. If the device is in a low-power state, accessing the device may cause it to either queue or fail any I/O requests, or transition the device into the working state. The exact behavior depends on the implementation of the device.</para>
      <para>To ensure maximum battery life on a laptop computer, use
<b>GetDevicePowerState</b> to reduce power consumption. For example, if a disk is currently powered down, accessing the disk will cause it to spin up, resulting in increased power consumption and reduced battery life.</para>
      <para>Applications should defer or limit access to devices wherever possible while the system is running on battery power. To determine whether the system is running on battery power, and the remaining battery life, use the
<see cref="GetSystemPowerStatus" /> function.</para>
    </remarks>
    <seealso cref="GetSystemPowerStatus" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Power/power-management-functions">Power Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Power/system-power-status">System Power Status</seealso>
  </member>
  <member name="Windows.GetDllDirectory">
    <summary>
      <para>Retrieves the application-specific portion of the search path used to locate DLLs for the
application.</para>
    </summary>
    <param name="nBufferLength">
      <para>The size of the output buffer, in characters.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the application-specific portion of the search path.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to
<i>lpBuffer</i>, in characters, not including the terminating null character. If the return
value is greater than <i>nBufferLength</i>, it specifies the size of the buffer required for
the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0502
or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetDllDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</seealso>
    <seealso cref="SetDllDirectory" />
  </member>
  <member name="Windows.GetDllDirectoryA">
    <summary>
      <para>Retrieves the application-specific portion of the search path used to locate DLLs for the
application.</para>
    </summary>
    <param name="nBufferLength">
      <para>The size of the output buffer, in characters.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the application-specific portion of the search path.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to
<i>lpBuffer</i>, in characters, not including the terminating null character. If the return
value is greater than <i>nBufferLength</i>, it specifies the size of the buffer required for
the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0502
or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetDllDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</seealso>
    <seealso cref="SetDllDirectory" />
  </member>
  <member name="Windows.GetDllDirectoryW">
    <summary>
      <para>Retrieves the application-specific portion of the search path used to locate DLLs for the
application.</para>
    </summary>
    <param name="nBufferLength">
      <para>The size of the output buffer, in characters.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the application-specific portion of the search path.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to
<i>lpBuffer</i>, in characters, not including the terminating null character. If the return
value is greater than <i>nBufferLength</i>, it specifies the size of the buffer required for
the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0502
or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetDllDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</seealso>
    <seealso cref="SetDllDirectory" />
  </member>
  <member name="Windows.GetDllDirectory">
    <summary>
      <para>Retrieves the application-specific portion of the search path used to locate DLLs for the
application.</para>
    </summary>
    <param name="nBufferLength">
      <para>The size of the output buffer, in characters.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the application-specific portion of the search path.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to
<i>lpBuffer</i>, in characters, not including the terminating null character. If the return
value is greater than <i>nBufferLength</i>, it specifies the size of the buffer required for
the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0502
or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetDllDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</seealso>
    <seealso cref="SetDllDirectory" />
  </member>
  <member name="Windows.GetDllDirectoryA">
    <summary>
      <para>Retrieves the application-specific portion of the search path used to locate DLLs for the
application.</para>
    </summary>
    <param name="nBufferLength">
      <para>The size of the output buffer, in characters.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the application-specific portion of the search path.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to
<i>lpBuffer</i>, in characters, not including the terminating null character. If the return
value is greater than <i>nBufferLength</i>, it specifies the size of the buffer required for
the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0502
or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetDllDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</seealso>
    <seealso cref="SetDllDirectory" />
  </member>
  <member name="Windows.GetDllDirectoryW">
    <summary>
      <para>Retrieves the application-specific portion of the search path used to locate DLLs for the
application.</para>
    </summary>
    <param name="nBufferLength">
      <para>The size of the output buffer, in characters.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the application-specific portion of the search path.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to
<i>lpBuffer</i>, in characters, not including the terminating null character. If the return
value is greater than <i>nBufferLength</i>, it specifies the size of the buffer required for
the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0502
or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetDllDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</seealso>
    <seealso cref="SetDllDirectory" />
  </member>
  <member name="Windows.GetEnabledXStateFeatures">
    <summary>
      <para>Gets a mask of enabled XState features on x86 or x64 processors.</para>
      <para>The definition of XState feature bits are processor vendor specific. Please refer to the relevant processor
reference manuals for additional information on a particular feature.</para>
    </summary>
    <returns>
      <para>This function returns a bitmask in which each bit represents an XState feature that is enabled on the
system.</para>
    </returns>
    <remarks>
      <para>An application should call this function to determine what features are present and enabled on the system
before using an XState processor feature or attempting to manipulate XState contexts. Bits 0 and 1 refer to the
X87 FPU and the presence of SSE registers, respectively. The meanings of specific feature bits beyond 0 and 1 are
defined in the Programmer Reference Manuals released by the processor vendors.
<b>Note</b>  Not all features supported by a processor may be enabled on the system. Using a feature which is not
enabled may result in exceptions or undefined behavior.</para>
      <para>
        <b>Windows 7 with SP1 and Windows Server 2008 R2 with SP1:  </b>The <a href="https://docs.microsoft.com//windows/desktop/Debug/avx-support-portal">AVX API</a> is first implemented on
Windows 7 with SP1 and Windows Server 2008 R2 with SP1 . Since there is no SDK for SP1, that means there are
no available headers and library files to work with. In this situation, a caller must declare the needed
functions from this documentation and get pointers to them using
<see cref="GetModuleHandle" /> on
"Kernel32.dll", followed by calls to
<see cref="GetProcAddress" />. See
<a href="https://docs.microsoft.com//windows/desktop/Debug/working-with-xstate-context">Working with XState Context</a> for
details.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/avx-support-portal">Intel AVX</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/working-with-xstate-context">Working with XState Context</seealso>
  </member>
  <member name="Windows.GetEnvironmentVariable">
    <summary>
      <para>Retrieves the contents of the specified variable from the environment block of the calling process.</para>
    </summary>
    <param name="lpName">
      <para>The name of the environment variable.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the contents of the specified environment variable as a null-terminated string. An environment variable has a maximum size limit of 32,767 characters, including the null-terminating character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpBuffer</i> parameter, including the null-terminating character, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of characters stored in the buffer pointed to by <i>lpBuffer</i>, not including the terminating null character.</para>
      <para>If <i>lpBuffer</i> is not large enough to hold the data, the return value is the buffer size, in characters, required to hold the string and its terminating null character and the contents of <i>lpBuffer</i> are undefined.</para>
      <para>If the function fails, the return value is zero. If the specified environment variable was not found in the environment block,
<see cref="GetLastError" /> returns ERROR_ENVVAR_NOT_FOUND.</para>
    </returns>
    <remarks>
      <para>This function can retrieve either a system environment variable or a user environment variable.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/changing-environment-variables">Changing Environment Variables</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/environment-variables">Environment Variables</seealso>
    <seealso cref="GetEnvironmentStrings" />
    <seealso cref="SetEnvironmentVariable" />
  </member>
  <member name="Windows.GetEnvironmentVariableA">
    <summary>
      <para>Retrieves the contents of the specified variable from the environment block of the calling process.</para>
    </summary>
    <param name="lpName">
      <para>The name of the environment variable.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the contents of the specified environment variable as a null-terminated string. An environment variable has a maximum size limit of 32,767 characters, including the null-terminating character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpBuffer</i> parameter, including the null-terminating character, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of characters stored in the buffer pointed to by <i>lpBuffer</i>, not including the terminating null character.</para>
      <para>If <i>lpBuffer</i> is not large enough to hold the data, the return value is the buffer size, in characters, required to hold the string and its terminating null character and the contents of <i>lpBuffer</i> are undefined.</para>
      <para>If the function fails, the return value is zero. If the specified environment variable was not found in the environment block,
<see cref="GetLastError" /> returns ERROR_ENVVAR_NOT_FOUND.</para>
    </returns>
    <remarks>
      <para>This function can retrieve either a system environment variable or a user environment variable.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/changing-environment-variables">Changing Environment Variables</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/environment-variables">Environment Variables</seealso>
    <seealso cref="GetEnvironmentStrings" />
    <seealso cref="SetEnvironmentVariable" />
  </member>
  <member name="Windows.GetEnvironmentVariableW">
    <summary>
      <para>Retrieves the contents of the specified variable from the environment block of the calling process.</para>
    </summary>
    <param name="lpName">
      <para>The name of the environment variable.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives the contents of the specified environment variable as a null-terminated string. An environment variable has a maximum size limit of 32,767 characters, including the null-terminating character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpBuffer</i> parameter, including the null-terminating character, in characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of characters stored in the buffer pointed to by <i>lpBuffer</i>, not including the terminating null character.</para>
      <para>If <i>lpBuffer</i> is not large enough to hold the data, the return value is the buffer size, in characters, required to hold the string and its terminating null character and the contents of <i>lpBuffer</i> are undefined.</para>
      <para>If the function fails, the return value is zero. If the specified environment variable was not found in the environment block,
<see cref="GetLastError" /> returns ERROR_ENVVAR_NOT_FOUND.</para>
    </returns>
    <remarks>
      <para>This function can retrieve either a system environment variable or a user environment variable.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/changing-environment-variables">Changing Environment Variables</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/environment-variables">Environment Variables</seealso>
    <seealso cref="GetEnvironmentStrings" />
    <seealso cref="SetEnvironmentVariable" />
  </member>
  <member name="Windows.GetEventLogInformation">
    <summary>
      <para>Retrieves information about the specified event log.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log. The
<see cref="OpenEventLog" /> or
<see cref="RegisterEventSource" /> function returns this handle.</para>
    </param>
    <param name="dwInfoLevel">
      <para>The level of event log information to return.</para>
      <para>This parameter can be the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>EVENTLOG_FULL_INFO</b>
          </description>
          <description>
            <para>Indicate whether the specified log is full. The <i>lpBuffer</i> parameter will contain an
<see cref="EVENTLOG_FULL_INFORMATION" /> structure.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpBuffer">
      <para>An application-allocated buffer that receives the event log information. The format of this data depends on the value of the <i>dwInfoLevel</i> parameter.</para>
    </param>
    <param name="cbBufSize">
      <para>The size of the <i>lpBuffer</i> buffer, in bytes.</para>
    </param>
    <param name="pcbBytesNeeded">
      <para>The function sets this parameter to the required buffer size for the requested information, regardless of whether the function succeeds. Use this value if the function fails with <b>ERROR_INSUFFICIENT_BUFFER</b> to allocate a buffer of the correct size.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="EVENTLOG_FULL_INFORMATION" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
    <seealso cref="RegisterEventSource" />
  </member>
  <member name="Windows.GetFileBandwidthReservation">
    <summary>
      <para>Retrieves the bandwidth reservation properties of the volume on which the specified file resides.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file.</para>
    </param>
    <param name="lpPeriodMilliseconds">
      <para>A pointer to a variable that receives the period of the reservation, in milliseconds. The period is the
time from which the I/O is issued to the kernel until the time the I/O should be completed. If no bandwidth has
been reserved for this handle, then the value returned is the minimum reservation period supported for this
volume.</para>
    </param>
    <param name="lpBytesPerPeriod">
      <para>A pointer to a variable that receives the maximum number of bytes per period that can be reserved on the
volume. If no bandwidth has been reserved for this handle, then the value returned is the maximum number of
bytes per period supported for the volume.</para>
    </param>
    <param name="pDiscardable">
      <para>
        <b>TRUE</b> if I/O should be completed with an error if a driver is unable to satisfy an
I/O operation before the period expires. <b>FALSE</b> if the underlying subsystem does not
support failing in this manner.</para>
    </param>
    <param name="lpTransferSize">
      <para>The minimum size of any individual I/O request that may be issued by the application. All I/O requests
should be multiples of <i>TransferSize</i>. If no bandwidth has been reserved for this
handle, then the value returned is the minimum transfer size supported for this volume.</para>
    </param>
    <param name="lpNumOutstandingRequests">
      <para>The number of <i>TransferSize</i> chunks  allowed to be outstanding with the operating
system.</para>
    </param>
    <returns>
      <para>Returns nonzero if successful or zero otherwise.</para>
      <para>To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="SetFileBandwidthReservation" />
  </member>
  <member name="Windows.GetFileInformationByHandleEx">
    <summary>
      <para>Retrieves file information for the specified file.</para>
      <para>For a more basic version of this function for desktop apps, see
<see cref="GetFileInformationByHandle" />.</para>
      <para>To set file information using a file handle, see
<see cref="SetFileInformationByHandle" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file that contains the information to be retrieved.</para>
      <para>This handle should not be a pipe handle.</para>
    </param>
    <param name="FileInformationClass">
      <para>A <see cref="FILE_INFO_BY_HANDLE_CLASS" /> enumeration
value that specifies the type of information to be retrieved.</para>
      <para>For a table of valid values, see the Remarks section.</para>
    </param>
    <param name="lpFileInformation">
      <para>A pointer to the buffer that receives the requested file information. The structure that is returned
corresponds to the class that is specified by <i>FileInformationClass</i>. For a table of
valid structure types, see the Remarks section.</para>
    </param>
    <param name="dwBufferSize">
      <para>The size of the <i>lpFileInformation</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero and file information data is contained in the buffer
pointed to by the <i>lpFileInformation</i> parameter.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If <i>FileInformationClass</i> is <b>FileStreamInfo</b> and the calls
succeed but no streams are returned, the error that is returned by
<see cref="GetLastError" /> is
<b>ERROR_HANDLE_EOF</b>.</para>
      <para>Certain file information classes behave slightly differently on different operating system releases. These
classes are supported by the underlying drivers, and any information they return is subject to change between
operating system releases.</para>
      <para>The following table shows the valid file information class types and their corresponding data structure types
for use with this function.</para>
      <list type="table">
        <listheader>
          <description>
            <i>FileInformationClass</i> value</description>
          <description>
            <i>lpFileInformation</i> type</description>
        </listheader>
        <item>
          <description>
            <b>FileBasicInfo</b> (0)</description>
          <description>
            <see cref="FILE_BASIC_INFO" />
          </description>
        </item>
        <item>
          <description>
            <b>FileStandardInfo</b> (1)</description>
          <description>
            <see cref="FILE_STANDARD_INFO" />
          </description>
        </item>
        <item>
          <description>
            <b>FileNameInfo</b> (2)</description>
          <description>
            <see cref="FILE_NAME_INFO" />
          </description>
        </item>
        <item>
          <description>
            <b>FileStreamInfo</b> (7)</description>
          <description>
            <see cref="FILE_STREAM_INFO" />
          </description>
        </item>
        <item>
          <description>
            <b>FileCompressionInfo</b> (8)</description>
          <description>
            <see cref="FILE_COMPRESSION_INFO" />
          </description>
        </item>
        <item>
          <description>
            <b>FileAttributeTagInfo</b> (9)</description>
          <description>
            <see cref="FILE_ATTRIBUTE_TAG_INFO" />
          </description>
        </item>
        <item>
          <description>
            <b>FileIdBothDirectoryInfo</b> (0xa)</description>
          <description>
            <see cref="FILE_ID_BOTH_DIR_INFO" />
          </description>
        </item>
        <item>
          <description>
            <b>FileIdBothDirectoryRestartInfo</b> (0xb)</description>
          <description>
            <see cref="FILE_ID_BOTH_DIR_INFO" />
          </description>
        </item>
        <item>
          <description>
            <b>FileRemoteProtocolInfo</b> (0xd)</description>
          <description>
            <see cref="FILE_REMOTE_PROTOCOL_INFO" />
          </description>
        </item>
        <item>
          <description>
            <b>FileFullDirectoryInfo</b> (0xe)</description>
          <description>
            <see cref="FILE_FULL_DIR_INFO" />
          </description>
        </item>
        <item>
          <description>
            <b>FileFullDirectoryRestartInfo</b> (0xf)</description>
          <description>
            <see cref="FILE_FULL_DIR_INFO" />
          </description>
        </item>
        <item>
          <description>
            <b>FileStorageInfo</b> (0x10)</description>
          <description>
            <see cref="FILE_STORAGE_INFO" />
          </description>
        </item>
        <item>
          <description>
            <b>FileAlignmentInfo</b> (0x11)</description>
          <description>
            <see cref="FILE_ALIGNMENT_INFO" />
          </description>
        </item>
        <item>
          <description>
            <b>FileIdInfo</b> (0x12)</description>
          <description>
            <see cref="FILE_ID_INFO" />
          </description>
        </item>
        <item>
          <description>
            <b>FileIdExtdDirectoryInfo</b> (0x13)</description>
          <description>
            <see cref="FILE_ID_EXTD_DIR_INFO" />
          </description>
        </item>
        <item>
          <description>
            <b>FileIdExtdDirectoryRestartInfo</b> (0x14)</description>
          <description>
            <see cref="FILE_ID_EXTD_DIR_INFO" />
          </description>
        </item>
      </list>
      <h3>Transacted Operations</h3>
      <para>If there is a transaction bound to the thread at the time of the call, then the function returns the
compressed file size of the isolated file view. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/about-transactional-ntfs">About Transactional NTFS</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso cref="FILE_INFO_BY_HANDLE_CLASS" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="SetFileInformationByHandle" />
  </member>
  <member name="Windows.GetFileSecurity">
    <summary>
      <para>The <b>GetFileSecurity</b> function obtains specified information about the security of a file or directory. The information obtained is constrained by the caller's access rights and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a>.</para>
      <para>The <see cref="GetNamedSecurityInfo" /> function provides functionality similar to <b>GetFileSecurity</b> for files as well as other types of objects.</para>
    </summary>
    <param name="lpFileName">
      <para>A pointer to a null-terminated string that specifies the file or directory for which security information is retrieved.</para>
    </param>
    <param name="RequestedInformation">
      <para>A
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</a> value that identifies the security information being requested.</para>
    </param>
    <param name="pSecurityDescriptor">
      <para>A pointer to a buffer that receives a copy of the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> of the object specified by the <i>lpFileName</i> parameter. The calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> must have permission to view the specified aspects of the object's security status. The
<see cref="SECURITY_DESCRIPTOR" /> structure is returned in <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">self-relative security descriptor</a> format.</para>
    </param>
    <param name="nLength">
      <para>Specifies the size, in bytes, of the buffer pointed to by the <i>pSecurityDescriptor</i> parameter.</para>
    </param>
    <param name="lpnLengthNeeded">
      <para>A pointer to the variable that receives the number of bytes necessary to store the complete <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a>. If the returned number of bytes is less than or equal to <i>nLength</i>, the entire security descriptor is returned in the output buffer; otherwise, none of the descriptor is returned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To read the owner, group, or <a href="https://docs.microsoft.com//windows/desktop/SecGloss/d-gly">DACL</a> from the security descriptor for the specified file or directory, the DACL for the file or directory must grant READ_CONTROL access to the caller, or the caller must be the owner of the file or directory.</para>
      <para>To read the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">SACL</a> of a file or directory, the SE_SECURITY_NAME privilege must be enabled for the calling process.</para>
    </remarks>
    <seealso cref="GetKernelObjectSecurity" />
    <seealso cref="GetNamedSecurityInfo" />
    <seealso cref="GetPrivateObjectSecurity" />
    <seealso cref="GetUserObjectSecurity" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/low-level-access-control">Low-level Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Low-level Access Control Functions</seealso>
    <seealso cref="SECURITY_DESCRIPTOR" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</seealso>
    <seealso cref="SetFileSecurity" />
  </member>
  <member name="Windows.GetFileSecurityA">
    <summary>
      <para>The <b>GetFileSecurity</b> function obtains specified information about the security of a file or directory. The information obtained is constrained by the caller's access rights and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a>.</para>
      <para>The <see cref="GetNamedSecurityInfo" /> function provides functionality similar to <b>GetFileSecurity</b> for files as well as other types of objects.</para>
    </summary>
    <param name="lpFileName">
      <para>A pointer to a null-terminated string that specifies the file or directory for which security information is retrieved.</para>
    </param>
    <param name="RequestedInformation">
      <para>A
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</a> value that identifies the security information being requested.</para>
    </param>
    <param name="pSecurityDescriptor">
      <para>A pointer to a buffer that receives a copy of the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> of the object specified by the <i>lpFileName</i> parameter. The calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> must have permission to view the specified aspects of the object's security status. The
<see cref="SECURITY_DESCRIPTOR" /> structure is returned in <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">self-relative security descriptor</a> format.</para>
    </param>
    <param name="nLength">
      <para>Specifies the size, in bytes, of the buffer pointed to by the <i>pSecurityDescriptor</i> parameter.</para>
    </param>
    <param name="lpnLengthNeeded">
      <para>A pointer to the variable that receives the number of bytes necessary to store the complete <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a>. If the returned number of bytes is less than or equal to <i>nLength</i>, the entire security descriptor is returned in the output buffer; otherwise, none of the descriptor is returned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To read the owner, group, or <a href="https://docs.microsoft.com//windows/desktop/SecGloss/d-gly">DACL</a> from the security descriptor for the specified file or directory, the DACL for the file or directory must grant READ_CONTROL access to the caller, or the caller must be the owner of the file or directory.</para>
      <para>To read the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">SACL</a> of a file or directory, the SE_SECURITY_NAME privilege must be enabled for the calling process.</para>
    </remarks>
    <seealso cref="GetKernelObjectSecurity" />
    <seealso cref="GetNamedSecurityInfo" />
    <seealso cref="GetPrivateObjectSecurity" />
    <seealso cref="GetUserObjectSecurity" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/low-level-access-control">Low-level Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Low-level Access Control Functions</seealso>
    <seealso cref="SECURITY_DESCRIPTOR" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</seealso>
    <seealso cref="SetFileSecurity" />
  </member>
  <member name="Windows.GetFileSecurityW">
    <summary>
      <para>The <b>GetFileSecurity</b> function obtains specified information about the security of a file or directory. The information obtained is constrained by the caller's access rights and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a>.</para>
      <para>The <see cref="GetNamedSecurityInfo" /> function provides functionality similar to <b>GetFileSecurity</b> for files as well as other types of objects.</para>
    </summary>
    <param name="lpFileName">
      <para>A pointer to a null-terminated string that specifies the file or directory for which security information is retrieved.</para>
    </param>
    <param name="RequestedInformation">
      <para>A
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</a> value that identifies the security information being requested.</para>
    </param>
    <param name="pSecurityDescriptor">
      <para>A pointer to a buffer that receives a copy of the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> of the object specified by the <i>lpFileName</i> parameter. The calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> must have permission to view the specified aspects of the object's security status. The
<see cref="SECURITY_DESCRIPTOR" /> structure is returned in <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">self-relative security descriptor</a> format.</para>
    </param>
    <param name="nLength">
      <para>Specifies the size, in bytes, of the buffer pointed to by the <i>pSecurityDescriptor</i> parameter.</para>
    </param>
    <param name="lpnLengthNeeded">
      <para>A pointer to the variable that receives the number of bytes necessary to store the complete <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a>. If the returned number of bytes is less than or equal to <i>nLength</i>, the entire security descriptor is returned in the output buffer; otherwise, none of the descriptor is returned.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To read the owner, group, or <a href="https://docs.microsoft.com//windows/desktop/SecGloss/d-gly">DACL</a> from the security descriptor for the specified file or directory, the DACL for the file or directory must grant READ_CONTROL access to the caller, or the caller must be the owner of the file or directory.</para>
      <para>To read the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">SACL</a> of a file or directory, the SE_SECURITY_NAME privilege must be enabled for the calling process.</para>
    </remarks>
    <seealso cref="GetKernelObjectSecurity" />
    <seealso cref="GetNamedSecurityInfo" />
    <seealso cref="GetPrivateObjectSecurity" />
    <seealso cref="GetUserObjectSecurity" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/low-level-access-control">Low-level Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Low-level Access Control Functions</seealso>
    <seealso cref="SECURITY_DESCRIPTOR" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</seealso>
    <seealso cref="SetFileSecurity" />
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariable">
    <summary>
      <para>Retrieves the value of the specified firmware environment variable.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be  a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value.</para>
    </param>
    <param name="pBuffer">
      <para>A pointer to a buffer that receives the value of the specified firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pBuffer</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pBuffer</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write Unified Extensible Firmware Interface (UEFI) firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>To read a firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>Starting with Windows 10, version 1803, reading Unified Extensible Firmware Interface (UEFI) variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI variables from UMDF drivers is not supported.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>GetFirmwareEnvironmentVariable</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI. To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <para>If you are creating a backup application, you can use this function to save all the boot settings for the system so they can be restored using the <see cref="SetFirmwareEnvironmentVariable" /></para>
      <para>function if needed.</para>
      <para>
        <b>GetFirmwareEnvironmentVariable</b> is the user-mode equivalent of the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/wdm/nf-wdm-exgetfirmwareenvironmentvariable">ExGetFirmwareEnvironmentVariable</a> kernel-mode routine.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetFirmwareEnvironmentVariable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariableEx" />
    <seealso cref="SetFirmwareEnvironmentVariable" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariableA">
    <summary>
      <para>Retrieves the value of the specified firmware environment variable.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be  a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value.</para>
    </param>
    <param name="pBuffer">
      <para>A pointer to a buffer that receives the value of the specified firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pBuffer</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pBuffer</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write Unified Extensible Firmware Interface (UEFI) firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>To read a firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>Starting with Windows 10, version 1803, reading Unified Extensible Firmware Interface (UEFI) variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI variables from UMDF drivers is not supported.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>GetFirmwareEnvironmentVariable</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI. To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <para>If you are creating a backup application, you can use this function to save all the boot settings for the system so they can be restored using the <see cref="SetFirmwareEnvironmentVariable" /></para>
      <para>function if needed.</para>
      <para>
        <b>GetFirmwareEnvironmentVariable</b> is the user-mode equivalent of the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/wdm/nf-wdm-exgetfirmwareenvironmentvariable">ExGetFirmwareEnvironmentVariable</a> kernel-mode routine.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetFirmwareEnvironmentVariable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariableEx" />
    <seealso cref="SetFirmwareEnvironmentVariable" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariableW">
    <summary>
      <para>Retrieves the value of the specified firmware environment variable.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be  a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value.</para>
    </param>
    <param name="pBuffer">
      <para>A pointer to a buffer that receives the value of the specified firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pBuffer</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pBuffer</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write Unified Extensible Firmware Interface (UEFI) firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>To read a firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>Starting with Windows 10, version 1803, reading Unified Extensible Firmware Interface (UEFI) variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI variables from UMDF drivers is not supported.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>GetFirmwareEnvironmentVariable</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI. To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <para>If you are creating a backup application, you can use this function to save all the boot settings for the system so they can be restored using the <see cref="SetFirmwareEnvironmentVariable" /></para>
      <para>function if needed.</para>
      <para>
        <b>GetFirmwareEnvironmentVariable</b> is the user-mode equivalent of the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/wdm/nf-wdm-exgetfirmwareenvironmentvariable">ExGetFirmwareEnvironmentVariable</a> kernel-mode routine.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetFirmwareEnvironmentVariable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariableEx" />
    <seealso cref="SetFirmwareEnvironmentVariable" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariableEx">
    <summary>
      <para>Retrieves the value of the specified firmware environment variable and its attributes.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be  a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="pBuffer">
      <para>A pointer to a buffer that receives the value of the specified firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pValue</i> buffer, in bytes.</para>
    </param>
    <param name="pdwAttribubutes">
      <para>Bitmask identifying UEFI variable attributes associated with the variable. See <see cref="SetFirmwareEnvironmentVariableEx" /> for the bitmask definition.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pValue</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write UEFI firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>To read a UEFI firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>Starting with Windows 10, version 1803, reading Unified Extensible Firmware Interface (UEFI) variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI variables from UMDF drivers is not supported.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>GetFirmwareEnvironmentVariableEx</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI. To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <para>If you are creating a backup application, you can use this function to save all the boot settings for the system so they can be restored using the <see cref="SetFirmwareEnvironmentVariable" /></para>
      <para>function if needed.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetFirmwareEnvironmentVariableEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariable" />
    <seealso cref="SetFirmwareEnvironmentVariableEx" />
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariableExA">
    <summary>
      <para>Retrieves the value of the specified firmware environment variable and its attributes.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be  a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="pBuffer">
      <para>A pointer to a buffer that receives the value of the specified firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pValue</i> buffer, in bytes.</para>
    </param>
    <param name="pdwAttribubutes">
      <para>Bitmask identifying UEFI variable attributes associated with the variable. See <see cref="SetFirmwareEnvironmentVariableEx" /> for the bitmask definition.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pValue</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write UEFI firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>To read a UEFI firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>Starting with Windows 10, version 1803, reading Unified Extensible Firmware Interface (UEFI) variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI variables from UMDF drivers is not supported.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>GetFirmwareEnvironmentVariableEx</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI. To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <para>If you are creating a backup application, you can use this function to save all the boot settings for the system so they can be restored using the <see cref="SetFirmwareEnvironmentVariable" /></para>
      <para>function if needed.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetFirmwareEnvironmentVariableEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariable" />
    <seealso cref="SetFirmwareEnvironmentVariableEx" />
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariableExW">
    <summary>
      <para>Retrieves the value of the specified firmware environment variable and its attributes.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be  a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="pBuffer">
      <para>A pointer to a buffer that receives the value of the specified firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pValue</i> buffer, in bytes.</para>
    </param>
    <param name="pdwAttribubutes">
      <para>Bitmask identifying UEFI variable attributes associated with the variable. See <see cref="SetFirmwareEnvironmentVariableEx" /> for the bitmask definition.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pValue</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write UEFI firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>To read a UEFI firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>Starting with Windows 10, version 1803, reading Unified Extensible Firmware Interface (UEFI) variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI variables from UMDF drivers is not supported.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>GetFirmwareEnvironmentVariableEx</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI. To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <para>If you are creating a backup application, you can use this function to save all the boot settings for the system so they can be restored using the <see cref="SetFirmwareEnvironmentVariable" /></para>
      <para>function if needed.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetFirmwareEnvironmentVariableEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariable" />
    <seealso cref="SetFirmwareEnvironmentVariableEx" />
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariableEx">
    <summary>
      <para>Retrieves the value of the specified firmware environment variable and its attributes.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be  a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="pBuffer">
      <para>A pointer to a buffer that receives the value of the specified firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pValue</i> buffer, in bytes.</para>
    </param>
    <param name="pdwAttribubutes">
      <para>Bitmask identifying UEFI variable attributes associated with the variable. See <see cref="SetFirmwareEnvironmentVariableEx" /> for the bitmask definition.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pValue</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write UEFI firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>To read a UEFI firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>Starting with Windows 10, version 1803, reading Unified Extensible Firmware Interface (UEFI) variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI variables from UMDF drivers is not supported.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>GetFirmwareEnvironmentVariableEx</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI. To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <para>If you are creating a backup application, you can use this function to save all the boot settings for the system so they can be restored using the <see cref="SetFirmwareEnvironmentVariable" /></para>
      <para>function if needed.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetFirmwareEnvironmentVariableEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariable" />
    <seealso cref="SetFirmwareEnvironmentVariableEx" />
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariableExA">
    <summary>
      <para>Retrieves the value of the specified firmware environment variable and its attributes.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be  a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="pBuffer">
      <para>A pointer to a buffer that receives the value of the specified firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pValue</i> buffer, in bytes.</para>
    </param>
    <param name="pdwAttribubutes">
      <para>Bitmask identifying UEFI variable attributes associated with the variable. See <see cref="SetFirmwareEnvironmentVariableEx" /> for the bitmask definition.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pValue</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write UEFI firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>To read a UEFI firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>Starting with Windows 10, version 1803, reading Unified Extensible Firmware Interface (UEFI) variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI variables from UMDF drivers is not supported.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>GetFirmwareEnvironmentVariableEx</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI. To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <para>If you are creating a backup application, you can use this function to save all the boot settings for the system so they can be restored using the <see cref="SetFirmwareEnvironmentVariable" /></para>
      <para>function if needed.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetFirmwareEnvironmentVariableEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariable" />
    <seealso cref="SetFirmwareEnvironmentVariableEx" />
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariableExW">
    <summary>
      <para>Retrieves the value of the specified firmware environment variable and its attributes.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be  a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="pBuffer">
      <para>A pointer to a buffer that receives the value of the specified firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pValue</i> buffer, in bytes.</para>
    </param>
    <param name="pdwAttribubutes">
      <para>Bitmask identifying UEFI variable attributes associated with the variable. See <see cref="SetFirmwareEnvironmentVariableEx" /> for the bitmask definition.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pValue</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write UEFI firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>To read a UEFI firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>Starting with Windows 10, version 1803, reading Unified Extensible Firmware Interface (UEFI) variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI variables from UMDF drivers is not supported.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>GetFirmwareEnvironmentVariableEx</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI. To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <para>If you are creating a backup application, you can use this function to save all the boot settings for the system so they can be restored using the <see cref="SetFirmwareEnvironmentVariable" /></para>
      <para>function if needed.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetFirmwareEnvironmentVariableEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariable" />
    <seealso cref="SetFirmwareEnvironmentVariableEx" />
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariable">
    <summary>
      <para>Retrieves the value of the specified firmware environment variable.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be  a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value.</para>
    </param>
    <param name="pBuffer">
      <para>A pointer to a buffer that receives the value of the specified firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pBuffer</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pBuffer</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write Unified Extensible Firmware Interface (UEFI) firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>To read a firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>Starting with Windows 10, version 1803, reading Unified Extensible Firmware Interface (UEFI) variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI variables from UMDF drivers is not supported.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>GetFirmwareEnvironmentVariable</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI. To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <para>If you are creating a backup application, you can use this function to save all the boot settings for the system so they can be restored using the <see cref="SetFirmwareEnvironmentVariable" /></para>
      <para>function if needed.</para>
      <para>
        <b>GetFirmwareEnvironmentVariable</b> is the user-mode equivalent of the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/wdm/nf-wdm-exgetfirmwareenvironmentvariable">ExGetFirmwareEnvironmentVariable</a> kernel-mode routine.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetFirmwareEnvironmentVariable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariableEx" />
    <seealso cref="SetFirmwareEnvironmentVariable" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariableA">
    <summary>
      <para>Retrieves the value of the specified firmware environment variable.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be  a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value.</para>
    </param>
    <param name="pBuffer">
      <para>A pointer to a buffer that receives the value of the specified firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pBuffer</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pBuffer</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write Unified Extensible Firmware Interface (UEFI) firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>To read a firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>Starting with Windows 10, version 1803, reading Unified Extensible Firmware Interface (UEFI) variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI variables from UMDF drivers is not supported.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>GetFirmwareEnvironmentVariable</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI. To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <para>If you are creating a backup application, you can use this function to save all the boot settings for the system so they can be restored using the <see cref="SetFirmwareEnvironmentVariable" /></para>
      <para>function if needed.</para>
      <para>
        <b>GetFirmwareEnvironmentVariable</b> is the user-mode equivalent of the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/wdm/nf-wdm-exgetfirmwareenvironmentvariable">ExGetFirmwareEnvironmentVariable</a> kernel-mode routine.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetFirmwareEnvironmentVariable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariableEx" />
    <seealso cref="SetFirmwareEnvironmentVariable" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariableW">
    <summary>
      <para>Retrieves the value of the specified firmware environment variable.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be  a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value.</para>
    </param>
    <param name="pBuffer">
      <para>A pointer to a buffer that receives the value of the specified firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pBuffer</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pBuffer</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write Unified Extensible Firmware Interface (UEFI) firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>To read a firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>Starting with Windows 10, version 1803, reading Unified Extensible Firmware Interface (UEFI) variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI variables from UMDF drivers is not supported.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>GetFirmwareEnvironmentVariable</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI. To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <para>If you are creating a backup application, you can use this function to save all the boot settings for the system so they can be restored using the <see cref="SetFirmwareEnvironmentVariable" /></para>
      <para>function if needed.</para>
      <para>
        <b>GetFirmwareEnvironmentVariable</b> is the user-mode equivalent of the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/wdm/nf-wdm-exgetfirmwareenvironmentvariable">ExGetFirmwareEnvironmentVariable</a> kernel-mode routine.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetFirmwareEnvironmentVariable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariableEx" />
    <seealso cref="SetFirmwareEnvironmentVariable" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.GetFirmwareType">
    <summary>
      <para>Retrieves the firmware type of the local computer.</para>
    </summary>
    <param name="FirmwareType">
      <para>A pointer to a <see cref="FIRMWARE_TYPE" /> enumeration.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call the <see cref="GetLastError" /> function.</para>
    </returns>
    <seealso cref="FIRMWARE_TYPE" />
  </member>
  <member name="Windows.GetLogicalDriveStrings">
    <summary>
      <para>Fills a buffer with strings that specify valid drives in the system.</para>
    </summary>
    <param name="nBufferLength">
      <para>The maximum size of the buffer pointed to by <i>lpBuffer</i>, in
<b>TCHARs</b>. This size does not include the terminating null character. If this
parameter is zero, <i>lpBuffer</i> is not used.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives a series of null-terminated strings, one for each valid drive in the
system, plus with an additional null character. Each string is a device name.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer,
not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a
Unicode (UTF-16) null character uses two bytes.</para>
      <para>If the buffer is not large enough, the return value is greater than <i>nBufferLength</i>.
It is the size of the buffer required to hold the drive strings.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>Each string in the buffer may be used wherever a root directory is required, such as for the
<see cref="GetDriveType" /> and
<see cref="GetDiskFreeSpace" /> functions.</para>
      <para>This function returns a concatenation of the drives in the Global and Local MS-DOS Device namespaces. If a
drive exists in both namespaces, this function will return the entry in the Local MS-DOS Device namespace. For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a>.</para>
    </remarks>
    <seealso cref="GetDiskFreeSpace" />
    <seealso cref="GetDriveType" />
    <seealso cref="GetLogicalDrives" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetLogicalDriveStringsA">
    <summary>
      <para>Fills a buffer with strings that specify valid drives in the system.</para>
    </summary>
    <param name="nBufferLength">
      <para>The maximum size of the buffer pointed to by <i>lpBuffer</i>, in
<b>TCHARs</b>. This size does not include the terminating null character. If this
parameter is zero, <i>lpBuffer</i> is not used.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives a series of null-terminated strings, one for each valid drive in the
system, plus with an additional null character. Each string is a device name.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer,
not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a
Unicode (UTF-16) null character uses two bytes.</para>
      <para>If the buffer is not large enough, the return value is greater than <i>nBufferLength</i>.
It is the size of the buffer required to hold the drive strings.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>Each string in the buffer may be used wherever a root directory is required, such as for the
<see cref="GetDriveType" /> and
<see cref="GetDiskFreeSpace" /> functions.</para>
      <para>This function returns a concatenation of the drives in the Global and Local MS-DOS Device namespaces. If a
drive exists in both namespaces, this function will return the entry in the Local MS-DOS Device namespace. For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a>.</para>
    </remarks>
    <seealso cref="GetDiskFreeSpace" />
    <seealso cref="GetDriveType" />
    <seealso cref="GetLogicalDrives" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetLogicalDriveStringsW">
    <summary>
      <para>Fills a buffer with strings that specify valid drives in the system.</para>
    </summary>
    <param name="nBufferLength">
      <para>The maximum size of the buffer pointed to by <i>lpBuffer</i>, in
<b>TCHARs</b>. This size does not include the terminating null character. If this
parameter is zero, <i>lpBuffer</i> is not used.</para>
    </param>
    <param name="lpBuffer">
      <para>A pointer to a buffer that receives a series of null-terminated strings, one for each valid drive in the
system, plus with an additional null character. Each string is a device name.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer,
not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a
Unicode (UTF-16) null character uses two bytes.</para>
      <para>If the buffer is not large enough, the return value is greater than <i>nBufferLength</i>.
It is the size of the buffer required to hold the drive strings.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>Each string in the buffer may be used wherever a root directory is required, such as for the
<see cref="GetDriveType" /> and
<see cref="GetDiskFreeSpace" /> functions.</para>
      <para>This function returns a concatenation of the drives in the Global and Local MS-DOS Device namespaces. If a
drive exists in both namespaces, this function will return the entry in the Local MS-DOS Device namespace. For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a>.</para>
    </remarks>
    <seealso cref="GetDiskFreeSpace" />
    <seealso cref="GetDriveType" />
    <seealso cref="GetLogicalDrives" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetMailslotInfo">
    <summary>
      <para>Retrieves information about the specified mailslot.</para>
    </summary>
    <param name="hMailslot">
      <para>A handle to a mailslot. The
<see cref="CreateMailslot" /> function must create this handle.</para>
    </param>
    <param name="lpMaxMessageSize">
      <para>The maximum message size, in bytes, allowed for this mailslot. This value can be greater than or equal to the value specified in the <i>cbMaxMsg</i> parameter of the
<see cref="CreateMailslot" /> function that created the mailslot. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="lpNextSize">
      <para>The size of the next message, in bytes. The following value has special meaning.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MAILSLOT_NO_MESSAGE</b>
                </description>
              </item>
              <item>
                <description>((DWORD)-1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>There is no next message.</para>
          </description>
        </item>
      </list>
      <para>This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="lpMessageCount">
      <para>The total number of messages waiting to be read, when the function returns. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="lpReadTimeout">
      <para>The amount of time, in milliseconds, a read operation can wait for a message to be written to the mailslot before a time-out occurs. This parameter is filled in when the function returns. This parameter can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="CreateMailslot" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/mailslot-functions">Mailslot Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/mailslots">Mailslots Overview</seealso>
    <seealso cref="SetMailslotInfo" />
  </member>
  <member name="Windows.GetMaximumProcessorCount">
    <summary>
      <para>Returns the maximum number of logical processors that a processor group or the system can have.</para>
    </summary>
    <param name="GroupNumber">
      <para>The processor group number. If this parameter is ALL_PROCESSOR_GROUPS, the function returns the maximum number of processors that the system can have.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the maximum number of processors that the specified group can have.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, set _WIN32_WINNT &gt;= 0x0601. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
  </member>
  <member name="Windows.GetMaximumProcessorGroupCount">
    <summary>
      <para>Returns the maximum number of processor groups that the system can have.</para>
    </summary>
    <returns>
      <para>If the function succeeds, the return value is the maximum number of processor groups that the system can have.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, set _WIN32_WINNT &gt;= 0x0601. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
  </member>
  <member name="Windows.GetNamedPipeClientComputerName">
    <summary>
      <para>Retrieves the client computer name for the specified named pipe.</para>
    </summary>
    <param name="Pipe">
      <para>A handle to an instance of a named pipe. This handle must be created by the
<see cref="CreateNamedPipe" /> function.</para>
    </param>
    <param name="ClientComputerName">
      <para>The computer name.</para>
    </param>
    <param name="ClientComputerNameLength">
      <para>The size of the <i>ClientComputerName</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
the <see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>
        <b>Windows 10, version 1709:  </b>Pipes are only supported within an app-container; ie, from one UWP process to another UWP process that's part of the same app. Also, named pipes must use the syntax "\.\pipe\LOCAL" for the pipe name.</para>
    </remarks>
    <seealso cref="CreateNamedPipe" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipe-functions">Pipe Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipes">Pipes Overview</seealso>
  </member>
  <member name="Windows.GetNamedPipeClientComputerNameA">
    <summary>
      <para>Retrieves the client computer name for the specified named pipe.</para>
    </summary>
    <param name="Pipe">
      <para>A handle to an instance of a named pipe. This handle must be created by the
<see cref="CreateNamedPipe" /> function.</para>
    </param>
    <param name="ClientComputerName">
      <para>The computer name.</para>
    </param>
    <param name="ClientComputerNameLength">
      <para>The size of the <i>ClientComputerName</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
the <see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>
        <b>Windows 10, version 1709:  </b>Pipes are only supported within an app-container; ie, from one UWP process to another UWP process that's part of the same app. Also, named pipes must use the syntax "\.\pipe\LOCAL" for the pipe name.</para>
    </remarks>
    <seealso cref="CreateNamedPipe" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipe-functions">Pipe Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipes">Pipes Overview</seealso>
  </member>
  <member name="Windows.GetNamedPipeClientComputerNameW">
    <summary>
      <para>Retrieves the client computer name for the specified named pipe.</para>
    </summary>
    <param name="Pipe">
      <para>A handle to an instance of a named pipe. This handle must be created by the
<see cref="CreateNamedPipe" /> function.</para>
    </param>
    <param name="ClientComputerName">
      <para>The computer name.</para>
    </param>
    <param name="ClientComputerNameLength">
      <para>The size of the <i>ClientComputerName</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
the <see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>
        <b>Windows 10, version 1709:  </b>Pipes are only supported within an app-container; ie, from one UWP process to another UWP process that's part of the same app. Also, named pipes must use the syntax "\.\pipe\LOCAL" for the pipe name.</para>
    </remarks>
    <seealso cref="CreateNamedPipe" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipe-functions">Pipe Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipes">Pipes Overview</seealso>
  </member>
  <member name="Windows.GetNamedPipeClientProcessId">
    <summary>
      <para>Retrieves the client process identifier for the specified named pipe.</para>
    </summary>
    <param name="Pipe">
      <para>A handle to an instance of a named pipe. This handle must be created by the
<see cref="CreateNamedPipe" /> function.</para>
    </param>
    <param name="ClientProcessId">
      <para>The process identifier.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
the <see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>
        <b>Windows 10, version 1709:  </b>Pipes are only supported within an app-container; ie, from one UWP process to another UWP process that's part of the same app. Also, named pipes must use the syntax "\.\pipe\LOCAL" for the pipe name.</para>
    </remarks>
    <seealso cref="CreateNamedPipe" />
    <seealso cref="GetNamedPipeServerProcessId" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipe-functions">Pipe Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipes">Pipes Overview</seealso>
  </member>
  <member name="Windows.GetNamedPipeClientSessionId">
    <summary>
      <para>Retrieves the client session identifier for the specified named pipe.</para>
    </summary>
    <param name="Pipe">
      <para>A handle to an instance of a named pipe. This handle must be created by the
<see cref="CreateNamedPipe" /> function.</para>
    </param>
    <param name="ClientSessionId">
      <para>The session identifier.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
the <see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>
        <b>Windows 10, version 1709:  </b>Pipes are only supported within an app-container; ie, from one UWP process to another UWP process that's part of the same app. Also, named pipes must use the syntax "\.\pipe\LOCAL" for the pipe name.</para>
    </remarks>
    <seealso cref="CreateNamedPipe" />
    <seealso cref="GetNamedPipeServerSessionId" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipe-functions">Pipe Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipes">Pipes Overview</seealso>
  </member>
  <member name="Windows.GetNamedPipeHandleState">
    <summary>
      <para>Retrieves information about a specified named pipe. The information returned can vary during the lifetime of an instance of the named pipe.</para>
    </summary>
    <param name="hNamedPipe">
      <para>A handle to the named pipe for which information is wanted. The handle must have GENERIC_READ access for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a write-only pipe.</para>
      <para>This parameter can also be a handle to an anonymous pipe, as returned by the
<see cref="CreatePipe" /> function.</para>
    </param>
    <param name="lpState">
      <para>A pointer to a variable that indicates the current state of the handle. This parameter can be <b>NULL</b> if this information is not needed. Either or both of the following values can be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_NOWAIT</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The pipe handle is in nonblocking mode. If this flag is not specified, the pipe handle is in blocking mode.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_READMODE_MESSAGE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The pipe handle is in message-read mode. If this flag is not specified, the pipe handle is in byte-read mode.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpCurInstances">
      <para>A pointer to a variable that receives the number of current pipe instances. This parameter can be <b>NULL</b> if this information is not required.</para>
    </param>
    <param name="lpMaxCollectionCount">
      <para>A pointer to a variable that receives the maximum number of bytes to be collected on the client's computer before transmission to the server. This parameter must be <b>NULL</b> if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can be <b>NULL</b> if this information is not required.</para>
    </param>
    <param name="lpCollectDataTimeout">
      <para>A pointer to a variable that receives the maximum time, in milliseconds, that can pass before a remote named pipe transfers information over the network. This parameter must be <b>NULL</b> if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can be <b>NULL</b> if this information is not required.</para>
    </param>
    <param name="lpUserName">
      <para>A pointer to a buffer that receives the user name string associated with the client application. The server can only retrieve this information if the client opened the pipe with SECURITY_IMPERSONATION access.</para>
      <para>This parameter must be <b>NULL</b> if the specified pipe handle is to the client end of a named pipe. This parameter can be <b>NULL</b> if this information is not required.</para>
    </param>
    <param name="nMaxUserNameSize">
      <para>The size of the buffer specified by the <i>lpUserName</i> parameter, in <b>TCHARs</b>. This parameter is ignored if <i>lpUserName</i> is <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetNamedPipeHandleState</b> function returns successfully even if all of the pointers passed to it are <b>NULL</b>.</para>
      <para>To set the pipe handle state, use the
<see cref="SetNamedPipeHandleState" /> function.</para>
      <para>
        <b>Windows 10, version 1709:  </b>Pipes are only supported within an app-container; ie, from one UWP process to another UWP process that's part of the same app. Also, named pipes must use the syntax "\.\pipe\LOCAL" for the pipe name.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipe-functions">Pipe Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipes">Pipes Overview</seealso>
    <seealso cref="SetNamedPipeHandleState" />
  </member>
  <member name="Windows.GetNamedPipeHandleStateA">
    <summary>
      <para>Retrieves information about a specified named pipe. The information returned can vary during the lifetime of an instance of the named pipe.</para>
    </summary>
    <param name="hNamedPipe">
      <para>A handle to the named pipe for which information is wanted. The handle must have GENERIC_READ access for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a write-only pipe.</para>
      <para>This parameter can also be a handle to an anonymous pipe, as returned by the
<see cref="CreatePipe" /> function.</para>
    </param>
    <param name="lpState">
      <para>A pointer to a variable that indicates the current state of the handle. This parameter can be <b>NULL</b> if this information is not needed. Either or both of the following values can be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_NOWAIT</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The pipe handle is in nonblocking mode. If this flag is not specified, the pipe handle is in blocking mode.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_READMODE_MESSAGE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The pipe handle is in message-read mode. If this flag is not specified, the pipe handle is in byte-read mode.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpCurInstances">
      <para>A pointer to a variable that receives the number of current pipe instances. This parameter can be <b>NULL</b> if this information is not required.</para>
    </param>
    <param name="lpMaxCollectionCount">
      <para>A pointer to a variable that receives the maximum number of bytes to be collected on the client's computer before transmission to the server. This parameter must be <b>NULL</b> if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can be <b>NULL</b> if this information is not required.</para>
    </param>
    <param name="lpCollectDataTimeout">
      <para>A pointer to a variable that receives the maximum time, in milliseconds, that can pass before a remote named pipe transfers information over the network. This parameter must be <b>NULL</b> if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can be <b>NULL</b> if this information is not required.</para>
    </param>
    <param name="lpUserName">
      <para>A pointer to a buffer that receives the user name string associated with the client application. The server can only retrieve this information if the client opened the pipe with SECURITY_IMPERSONATION access.</para>
      <para>This parameter must be <b>NULL</b> if the specified pipe handle is to the client end of a named pipe. This parameter can be <b>NULL</b> if this information is not required.</para>
    </param>
    <param name="nMaxUserNameSize">
      <para>The size of the buffer specified by the <i>lpUserName</i> parameter, in <b>TCHARs</b>. This parameter is ignored if <i>lpUserName</i> is <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetNamedPipeHandleState</b> function returns successfully even if all of the pointers passed to it are <b>NULL</b>.</para>
      <para>To set the pipe handle state, use the
<see cref="SetNamedPipeHandleState" /> function.</para>
      <para>
        <b>Windows 10, version 1709:  </b>Pipes are only supported within an app-container; ie, from one UWP process to another UWP process that's part of the same app. Also, named pipes must use the syntax "\.\pipe\LOCAL" for the pipe name.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipe-functions">Pipe Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipes">Pipes Overview</seealso>
    <seealso cref="SetNamedPipeHandleState" />
  </member>
  <member name="Windows.GetNamedPipeHandleStateW">
    <summary>
      <para>Retrieves information about a specified named pipe. The information returned can vary during the lifetime of an instance of the named pipe.</para>
    </summary>
    <param name="hNamedPipe">
      <para>A handle to the named pipe for which information is wanted. The handle must have GENERIC_READ access for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a write-only pipe.</para>
      <para>This parameter can also be a handle to an anonymous pipe, as returned by the
<see cref="CreatePipe" /> function.</para>
    </param>
    <param name="lpState">
      <para>A pointer to a variable that indicates the current state of the handle. This parameter can be <b>NULL</b> if this information is not needed. Either or both of the following values can be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_NOWAIT</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The pipe handle is in nonblocking mode. If this flag is not specified, the pipe handle is in blocking mode.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PIPE_READMODE_MESSAGE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The pipe handle is in message-read mode. If this flag is not specified, the pipe handle is in byte-read mode.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpCurInstances">
      <para>A pointer to a variable that receives the number of current pipe instances. This parameter can be <b>NULL</b> if this information is not required.</para>
    </param>
    <param name="lpMaxCollectionCount">
      <para>A pointer to a variable that receives the maximum number of bytes to be collected on the client's computer before transmission to the server. This parameter must be <b>NULL</b> if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can be <b>NULL</b> if this information is not required.</para>
    </param>
    <param name="lpCollectDataTimeout">
      <para>A pointer to a variable that receives the maximum time, in milliseconds, that can pass before a remote named pipe transfers information over the network. This parameter must be <b>NULL</b> if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can be <b>NULL</b> if this information is not required.</para>
    </param>
    <param name="lpUserName">
      <para>A pointer to a buffer that receives the user name string associated with the client application. The server can only retrieve this information if the client opened the pipe with SECURITY_IMPERSONATION access.</para>
      <para>This parameter must be <b>NULL</b> if the specified pipe handle is to the client end of a named pipe. This parameter can be <b>NULL</b> if this information is not required.</para>
    </param>
    <param name="nMaxUserNameSize">
      <para>The size of the buffer specified by the <i>lpUserName</i> parameter, in <b>TCHARs</b>. This parameter is ignored if <i>lpUserName</i> is <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetNamedPipeHandleState</b> function returns successfully even if all of the pointers passed to it are <b>NULL</b>.</para>
      <para>To set the pipe handle state, use the
<see cref="SetNamedPipeHandleState" /> function.</para>
      <para>
        <b>Windows 10, version 1709:  </b>Pipes are only supported within an app-container; ie, from one UWP process to another UWP process that's part of the same app. Also, named pipes must use the syntax "\.\pipe\LOCAL" for the pipe name.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipe-functions">Pipe Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipes">Pipes Overview</seealso>
    <seealso cref="SetNamedPipeHandleState" />
  </member>
  <member name="Windows.GetNamedPipeServerProcessId">
    <summary>
      <para>Retrieves the server process identifier for the specified named pipe.</para>
    </summary>
    <param name="Pipe">
      <para>A handle to an instance of a named pipe. This handle must be created by the
<see cref="CreateNamedPipe" /> function.</para>
    </param>
    <param name="ServerProcessId">
      <para>The process identifier.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
the <see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>
        <b>Windows 10, version 1709:  </b>Pipes are only supported within an app-container; ie, from one UWP process to another UWP process that's part of the same app. Also, named pipes must use the syntax "\.\pipe\LOCAL" for the pipe name.</para>
    </remarks>
    <seealso cref="CreateNamedPipe" />
    <seealso cref="GetNamedPipeClientProcessId" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipe-functions">Pipe Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipes">Pipes Overview</seealso>
  </member>
  <member name="Windows.GetNamedPipeServerSessionId">
    <summary>
      <para>Retrieves the server session identifier for the specified named pipe.</para>
    </summary>
    <param name="Pipe">
      <para>A handle to an instance of a named pipe. This handle must be created by the
<see cref="CreateNamedPipe" /> function.</para>
    </param>
    <param name="ServerSessionId">
      <para>The session identifier.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
the <see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>
        <b>Windows 10, version 1709:  </b>Pipes are only supported within an app-container; ie, from one UWP process to another UWP process that's part of the same app. Also, named pipes must use the syntax "\.\pipe\LOCAL" for the pipe name.</para>
    </remarks>
    <seealso cref="CreateNamedPipe" />
    <seealso cref="GetNamedPipeClientSessionId" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipe-functions">Pipe Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipes">Pipes Overview</seealso>
  </member>
  <member name="Windows.GetNextUmsListItem">
    <summary>
      <para>Returns the next user-mode scheduling (UMS) thread context in a list of thread contexts.</para>
    </summary>
    <param name="UmsContext">
      <para>A pointer to a UMS context in a list of thread contexts. This list is retrieved by the <see cref="DequeueUmsCompletionListItems" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a pointer to the next thread context in the list.</para>
      <para>If there is no thread context after the context specified by the <i>UmsContext</i> parameter,  the function returns NULL. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="DequeueUmsCompletionListItems" />
  </member>
  <member name="Windows.GetNumaAvailableMemoryNode">
    <summary>
      <para>Retrieves the amount of memory available in the specified node.</para>
      <para>Use the <see cref="GetNumaAvailableMemoryNodeEx" /> function to specify the node  as a <b>USHORT</b> value.</para>
    </summary>
    <param name="Node">
      <para>The number of the node.</para>
    </param>
    <param name="AvailableBytes">
      <para>The amount of available memory for the node, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetNumaAvailableMemoryNode</b> function returns the amount of memory consumed by free and zeroed pages on the specified node. On systems with more than one node, this memory does not include standby pages. Therefore, the sum of the available memory values for all nodes in the system is equal to the value of the Free &amp; Zero Page List Bytes memory performance counter. On systems with only one node, the value returned by <b>GetNumaAvailableMemoryNode</b>  includes standby pages and  is equal to the value of the Available Bytes memory performance counter. For more information about performance counters, see <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa965225(v=vs.85)">Memory Performance Information</a>.</para>
    </remarks>
    <seealso cref="GetNumaAvailableMemoryNodeEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/numa-support">NUMA Support</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
  </member>
  <member name="Windows.GetNumaAvailableMemoryNodeEx">
    <summary>
      <para>Retrieves the amount of memory that is available in a node specified as a <b>USHORT</b> value.</para>
    </summary>
    <param name="Node">
      <para>The number of the node.</para>
    </param>
    <param name="AvailableBytes">
      <para>The amount of available memory for the node, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>GetNumaAvailableMemoryNodeEx</b> function returns the amount of memory consumed by free and zeroed pages on the specified node. On systems with more than one node, this memory does not include standby pages. Therefore, the sum of the available memory values for all nodes in the system is equal to the value of the Free &amp; Zero Page List Bytes memory performance counter. On systems with only one node, the value returned by <see cref="GetNumaAvailableMemoryNode" />  includes standby pages and  is equal to the value of the Available Bytes memory performance counter. For more information about performance counters, see <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa965225(v=vs.85)">Memory Performance Information</a>.</para>
      <para>The only difference between the <b>GetNumaAvailableMemoryNodeEx</b> function and the <see cref="GetNumaAvailableMemoryNode" /> function is the data type of the <i>Node</i> parameter.</para>
      <para>To compile an application that uses this function, set _WIN32_WINNT &gt;= 0x0601. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="GetNumaAvailableMemoryNode" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/numa-support">NUMA Support</seealso>
  </member>
  <member name="Windows.GetNumaNodeNumberFromHandle">
    <summary>
      <para>Retrieves the NUMA node associated with the file or I/O device represented by the specified file handle.</para>
    </summary>
    <param name="hFile">
      <para>A handle to a file or I/O device. Examples of I/O devices include files, file streams, volumes, physical disks, and sockets. For more information, see the <see cref="CreateFile" /> function.</para>
    </param>
    <param name="NodeNumber">
      <para>A pointer to a variable to receive the number of the NUMA node associated with the specified file handle.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the specified handle does not have a node associated with it, the function returns FALSE. The value of the <i>NodeNumber</i> parameter is undetermined and should not be used.</para>
      <para>To compile an application that uses this function, set _WIN32_WINNT &gt;= 0x0601. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/numa-support">NUMA Support</seealso>
  </member>
  <member name="Windows.GetNumaNodeProcessorMask">
    <summary>
      <para>Retrieves the processor mask for the specified node.</para>
    </summary>
    <param name="Node">
      <para>The number of the node.</para>
    </param>
    <param name="ProcessorMask">
      <para>The processor mask for the node. A processor mask is a bit vector in which each bit represents a processor and whether it is in the node.</para>
      <para>If the node has no processors configured, the processor mask is zero.</para>
      <para>On systems with more than 64 processors, this parameter is set to the processor mask for the node only if the node is in the same <a href="https://docs.microsoft.com//windows/desktop/ProcThread/processor-groups">processor group</a> as the calling thread. Otherwise, the parameter is set to zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To retrieve the highest numbered node in the system, use the
<see cref="GetNumaHighestNodeNumber" /> function. Note that this number is not guaranteed to equal the total number of nodes in the system.</para>
      <para>To ensure that all threads for your process run on the same node, use the
<see cref="SetProcessAffinityMask" /> function with a process affinity mask that specifies processors in the same node.</para>
      <para>Use the <see cref="GetNumaNodeProcessorMaskEx" /> function to retrieve the processor mask for a node in any processor group.</para>
      <blockquote>
        <para>[!NOTE]
Starting with <i>TBD Release Iron</i>, the behavior of this and other NUMA functions has been modified to better support systems with nodes containing more that 64 processors. For more information about this change, including information about enabling the old behavior of this API, see <a href="https://docs.microsoft.com//windows/win32/procthread/numa-support">NUMA Support</a>.</para>
      </blockquote>
      <h3>Behavior starting with TBD Release Iron</h3>
      <para>Each node is assigned a primary group by the system. The mask returned by <b>GetNumaNodeProcessorMask</b> is for the node's primary group and is only returned if the calling thread belongs to that group.</para>
      <h3>Behavior in previous versions</h3>
      <para>The mask for the specified node is returned.</para>
    </remarks>
    <seealso cref="GetNumaNodeProcessorMaskEx" />
    <seealso cref="GetNumaProcessorNode" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/numa-support">NUMA Support</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso cref="SetProcessAffinityMask" />
  </member>
  <member name="Windows.GetNumaProcessorNode">
    <summary>
      <para>Retrieves the node number for the specified processor.</para>
      <para>Use the <see cref="GetNumaProcessorNodeEx" /> function to specify a processor group and retrieve the node number as a <b>USHORT</b> value.</para>
    </summary>
    <param name="Processor">
      <para>The processor number.</para>
      <para>On a system with more than 64 logical processors, the processor number is relative to the <a href="https://docs.microsoft.com//windows/desktop/ProcThread/processor-groups">processor group</a> that contains the processor on which the calling thread is running.</para>
    </param>
    <param name="NodeNumber">
      <para>The node number. If the processor does not exist, this parameter is 0xFF.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To retrieve the list of processors on the system, use the
<see cref="GetProcessAffinityMask" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/Memory/allocating-memory-from-a-numa-node">Allocating Memory from a NUMA Node</a>.</para>
    </remarks>
    <seealso cref="GetNumaNodeProcessorMask" />
    <seealso cref="GetNumaProcessorNodeEx" />
    <seealso cref="GetNumaProximityNode" />
    <seealso cref="GetProcessAffinityMask" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/numa-support">NUMA Support</seealso>
  </member>
  <member name="Windows.GetNumaProcessorNodeEx">
    <summary>
      <para>Retrieves the node number as a <b>USHORT</b> value for the specified logical processor.</para>
    </summary>
    <param name="Processor">
      <para>A pointer to a <see cref="PROCESSOR_NUMBER" /> structure that represents the logical processor and the processor group to which it is assigned.</para>
    </param>
    <param name="NodeNumber">
      <para>A pointer  to a variable to receive the node number. If the specified processor does not exist, this parameter is set to MAXUSHORT.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, set _WIN32_WINNT &gt;= 0x0601. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="GetNumaProcessorNode" />
    <seealso cref="PROCESSOR_NUMBER" />
  </member>
  <member name="Windows.GetNumaProximityNode">
    <summary>
      <para>Retrieves the NUMA node number that corresponds to the specified proximity domain identifier.</para>
      <para>Use the <see cref="GetNumaProximityNodeEx" /> function to retrieve the node number as a <b>USHORT</b> value.</para>
    </summary>
    <param name="ProximityId">
      <para>The proximity domain identifier of the node.</para>
    </param>
    <param name="NodeNumber">
      <para>The node number. If the processor does not exist, this parameter is 0xFF.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error  information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>A proximity domain identifier is an index to a NUMA node on a NUMA system. Proximity domain identifiers are found in the ACPI System Resource Affinity Table (SRAT), where they are used to associate processors and memory regions with a particular NUMA node. Proximity domain identifiers are also found in the ACPI namespace, where they are used to associate a device with a particular NUMA node. Proximity domain identifiers are typically used only by management applications provided by system manufacturers. Windows does not use proximity domain identifiers to identify NUMA nodes; instead, it assigns a unique number to each NUMA node in the system.</para>
      <para>The relative distance between nodes on a system is stored in the ACPI System Locality Distance Information Table (SLIT), which is not exposed by any Windows functions. For more information about ACPI tables, see the <a href="http://www.acpi.info/">ACPI specifications</a>.</para>
    </remarks>
    <seealso cref="GetNumaProcessorNode" />
    <seealso cref="GetNumaProximityNodeEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/numa-support">NUMA Support</seealso>
  </member>
  <member name="Windows.GetNumberOfEventLogRecords">
    <summary>
      <para>Retrieves the number of records in the specified event log.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the open event log. The
<see cref="OpenEventLog" /> or
<see cref="OpenBackupEventLog" /> function returns this handle.</para>
    </param>
    <param name="NumberOfRecords">
      <para>A pointer to a variable that receives the number of records in the specified event log.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The oldest record in an event log is not necessarily record number 1. To determine the oldest record number in an event log, use the
<see cref="GetOldestEventLogRecord" /> function.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="GetOldestEventLogRecord" />
    <seealso cref="OpenBackupEventLog" />
    <seealso cref="OpenEventLog" />
  </member>
  <member name="Windows.GetOldestEventLogRecord">
    <summary>
      <para>Retrieves the absolute record number of the oldest record in the specified event log.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the open event log. The
<see cref="OpenEventLog" /> or
<see cref="OpenBackupEventLog" /> function returns this handle.</para>
    </param>
    <param name="OldestRecord">
      <para>A pointer to a variable that receives the absolute record number of the oldest record in the specified event log.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The oldest record in an event log is not necessarily record number 1. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-log-records">Event Log Records</a>.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/querying-for-event-source-messages">Querying for Event Information</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="GetNumberOfEventLogRecords" />
    <seealso cref="OpenBackupEventLog" />
    <seealso cref="OpenEventLog" />
  </member>
  <member name="Windows.GetPrivateProfileInt">
    <summary>
      <para>Retrieves an integer associated with a key in the specified section of an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose value is to be retrieved. This value is in the form of a string; the
<b>GetPrivateProfileInt</b> function converts the string into an integer and returns the integer.</para>
    </param>
    <param name="nDefault">
      <para>The default value to return if the key name cannot be found in the initialization file.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value is the integer equivalent of the string following the specified key name in the specified initialization file. If the key is not found, the return value is the specified default value.</para>
    </returns>
    <remarks>
      <para>The function searches the file for a key that matches the name specified by the <i>lpKeyName</i> parameter under the section name specified by the <i>lpAppName</i> parameter. A section in the initialization file must have the following form:</para>
      <code>[section]
key=value
      .
      .
      .
</code>
      <para>The
<b>GetPrivateProfileInt</b> function is not case-sensitive; the strings in <i>lpAppName</i> and <i>lpKeyName</i> can be a combination of uppercase and lowercase letters.</para>
      <para>An application can use the
<see cref="GetProfileInt" /> function to retrieve an integer value from the Win.ini file.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="GetProfileInt" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.GetPrivateProfileIntA">
    <summary>
      <para>Retrieves an integer associated with a key in the specified section of an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose value is to be retrieved. This value is in the form of a string; the
<b>GetPrivateProfileInt</b> function converts the string into an integer and returns the integer.</para>
    </param>
    <param name="nDefault">
      <para>The default value to return if the key name cannot be found in the initialization file.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value is the integer equivalent of the string following the specified key name in the specified initialization file. If the key is not found, the return value is the specified default value.</para>
    </returns>
    <remarks>
      <para>The function searches the file for a key that matches the name specified by the <i>lpKeyName</i> parameter under the section name specified by the <i>lpAppName</i> parameter. A section in the initialization file must have the following form:</para>
      <code>[section]
key=value
      .
      .
      .
</code>
      <para>The
<b>GetPrivateProfileInt</b> function is not case-sensitive; the strings in <i>lpAppName</i> and <i>lpKeyName</i> can be a combination of uppercase and lowercase letters.</para>
      <para>An application can use the
<see cref="GetProfileInt" /> function to retrieve an integer value from the Win.ini file.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="GetProfileInt" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.GetPrivateProfileIntW">
    <summary>
      <para>Retrieves an integer associated with a key in the specified section of an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose value is to be retrieved. This value is in the form of a string; the
<b>GetPrivateProfileInt</b> function converts the string into an integer and returns the integer.</para>
    </param>
    <param name="nDefault">
      <para>The default value to return if the key name cannot be found in the initialization file.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value is the integer equivalent of the string following the specified key name in the specified initialization file. If the key is not found, the return value is the specified default value.</para>
    </returns>
    <remarks>
      <para>The function searches the file for a key that matches the name specified by the <i>lpKeyName</i> parameter under the section name specified by the <i>lpAppName</i> parameter. A section in the initialization file must have the following form:</para>
      <code>[section]
key=value
      .
      .
      .
</code>
      <para>The
<b>GetPrivateProfileInt</b> function is not case-sensitive; the strings in <i>lpAppName</i> and <i>lpKeyName</i> can be a combination of uppercase and lowercase letters.</para>
      <para>An application can use the
<see cref="GetProfileInt" /> function to retrieve an integer value from the Win.ini file.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="GetProfileInt" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.GetPrivateProfileInt">
    <summary>
      <para>Retrieves an integer associated with a key in the specified section of an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose value is to be retrieved. This value is in the form of a string; the
<b>GetPrivateProfileInt</b> function converts the string into an integer and returns the integer.</para>
    </param>
    <param name="nDefault">
      <para>The default value to return if the key name cannot be found in the initialization file.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value is the integer equivalent of the string following the specified key name in the specified initialization file. If the key is not found, the return value is the specified default value.</para>
    </returns>
    <remarks>
      <para>The function searches the file for a key that matches the name specified by the <i>lpKeyName</i> parameter under the section name specified by the <i>lpAppName</i> parameter. A section in the initialization file must have the following form:</para>
      <code>[section]
key=value
      .
      .
      .
</code>
      <para>The
<b>GetPrivateProfileInt</b> function is not case-sensitive; the strings in <i>lpAppName</i> and <i>lpKeyName</i> can be a combination of uppercase and lowercase letters.</para>
      <para>An application can use the
<see cref="GetProfileInt" /> function to retrieve an integer value from the Win.ini file.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileInt as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetProfileInt" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.GetPrivateProfileIntA">
    <summary>
      <para>Retrieves an integer associated with a key in the specified section of an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose value is to be retrieved. This value is in the form of a string; the
<b>GetPrivateProfileInt</b> function converts the string into an integer and returns the integer.</para>
    </param>
    <param name="nDefault">
      <para>The default value to return if the key name cannot be found in the initialization file.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value is the integer equivalent of the string following the specified key name in the specified initialization file. If the key is not found, the return value is the specified default value.</para>
    </returns>
    <remarks>
      <para>The function searches the file for a key that matches the name specified by the <i>lpKeyName</i> parameter under the section name specified by the <i>lpAppName</i> parameter. A section in the initialization file must have the following form:</para>
      <code>[section]
key=value
      .
      .
      .
</code>
      <para>The
<b>GetPrivateProfileInt</b> function is not case-sensitive; the strings in <i>lpAppName</i> and <i>lpKeyName</i> can be a combination of uppercase and lowercase letters.</para>
      <para>An application can use the
<see cref="GetProfileInt" /> function to retrieve an integer value from the Win.ini file.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileInt as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetProfileInt" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.GetPrivateProfileIntW">
    <summary>
      <para>Retrieves an integer associated with a key in the specified section of an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose value is to be retrieved. This value is in the form of a string; the
<b>GetPrivateProfileInt</b> function converts the string into an integer and returns the integer.</para>
    </param>
    <param name="nDefault">
      <para>The default value to return if the key name cannot be found in the initialization file.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value is the integer equivalent of the string following the specified key name in the specified initialization file. If the key is not found, the return value is the specified default value.</para>
    </returns>
    <remarks>
      <para>The function searches the file for a key that matches the name specified by the <i>lpKeyName</i> parameter under the section name specified by the <i>lpAppName</i> parameter. A section in the initialization file must have the following form:</para>
      <code>[section]
key=value
      .
      .
      .
</code>
      <para>The
<b>GetPrivateProfileInt</b> function is not case-sensitive; the strings in <i>lpAppName</i> and <i>lpKeyName</i> can be a combination of uppercase and lowercase letters.</para>
      <para>An application can use the
<see cref="GetProfileInt" /> function to retrieve an integer value from the Win.ini file.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileInt as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetProfileInt" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.GetPrivateProfileInt">
    <summary>
      <para>Retrieves an integer associated with a key in the specified section of an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose value is to be retrieved. This value is in the form of a string; the
<b>GetPrivateProfileInt</b> function converts the string into an integer and returns the integer.</para>
    </param>
    <param name="nDefault">
      <para>The default value to return if the key name cannot be found in the initialization file.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value is the integer equivalent of the string following the specified key name in the specified initialization file. If the key is not found, the return value is the specified default value.</para>
    </returns>
    <remarks>
      <para>The function searches the file for a key that matches the name specified by the <i>lpKeyName</i> parameter under the section name specified by the <i>lpAppName</i> parameter. A section in the initialization file must have the following form:</para>
      <code>[section]
key=value
      .
      .
      .
</code>
      <para>The
<b>GetPrivateProfileInt</b> function is not case-sensitive; the strings in <i>lpAppName</i> and <i>lpKeyName</i> can be a combination of uppercase and lowercase letters.</para>
      <para>An application can use the
<see cref="GetProfileInt" /> function to retrieve an integer value from the Win.ini file.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileInt as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetProfileInt" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.GetPrivateProfileIntA">
    <summary>
      <para>Retrieves an integer associated with a key in the specified section of an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose value is to be retrieved. This value is in the form of a string; the
<b>GetPrivateProfileInt</b> function converts the string into an integer and returns the integer.</para>
    </param>
    <param name="nDefault">
      <para>The default value to return if the key name cannot be found in the initialization file.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value is the integer equivalent of the string following the specified key name in the specified initialization file. If the key is not found, the return value is the specified default value.</para>
    </returns>
    <remarks>
      <para>The function searches the file for a key that matches the name specified by the <i>lpKeyName</i> parameter under the section name specified by the <i>lpAppName</i> parameter. A section in the initialization file must have the following form:</para>
      <code>[section]
key=value
      .
      .
      .
</code>
      <para>The
<b>GetPrivateProfileInt</b> function is not case-sensitive; the strings in <i>lpAppName</i> and <i>lpKeyName</i> can be a combination of uppercase and lowercase letters.</para>
      <para>An application can use the
<see cref="GetProfileInt" /> function to retrieve an integer value from the Win.ini file.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileInt as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetProfileInt" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.GetPrivateProfileIntW">
    <summary>
      <para>Retrieves an integer associated with a key in the specified section of an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose value is to be retrieved. This value is in the form of a string; the
<b>GetPrivateProfileInt</b> function converts the string into an integer and returns the integer.</para>
    </param>
    <param name="nDefault">
      <para>The default value to return if the key name cannot be found in the initialization file.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value is the integer equivalent of the string following the specified key name in the specified initialization file. If the key is not found, the return value is the specified default value.</para>
    </returns>
    <remarks>
      <para>The function searches the file for a key that matches the name specified by the <i>lpKeyName</i> parameter under the section name specified by the <i>lpAppName</i> parameter. A section in the initialization file must have the following form:</para>
      <code>[section]
key=value
      .
      .
      .
</code>
      <para>The
<b>GetPrivateProfileInt</b> function is not case-sensitive; the strings in <i>lpAppName</i> and <i>lpKeyName</i> can be a combination of uppercase and lowercase letters.</para>
      <para>An application can use the
<see cref="GetProfileInt" /> function to retrieve an integer value from the Win.ini file.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileInt as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetProfileInt" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.GetPrivateProfileSection">
    <summary>
      <para>Retrieves all the keys and values for the specified section of an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit applications written for Windows. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the buffer, not including the terminating null character. If the buffer is not large enough to contain all the key name and value pairs associated with the named section, the return value is equal to <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>The data in the buffer pointed to by the <i>lpReturnedString</i> parameter consists of one or more null-terminated strings, followed by a final null character. Each string has the following format:</para>
      <para>
        <i>key</i>
        <b>=</b>
        <i>string</i>
      </para>
      <para>The
<b>GetPrivateProfileSection</b> function is not case-sensitive; the string pointed to by the <i>lpAppName</i> parameter can be a combination of uppercase and lowercase letters.</para>
      <para>This operation is atomic; no updates to the specified initialization file are allowed while the key name and value pairs for the section are being copied to the buffer pointed to by the <i>lpReturnedString</i> parameter.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <para>Comments (any line that starts with a semicolon) are stripped out and not returned in the <i>lpReturnedString</i> buffer.</para>
    </remarks>
    <seealso cref="GetPrivateProfileSectionNames" />
    <seealso cref="GetProfileSection" />
    <seealso cref="WritePrivateProfileSection" />
  </member>
  <member name="Windows.GetPrivateProfileSectionA">
    <summary>
      <para>Retrieves all the keys and values for the specified section of an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit applications written for Windows. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the buffer, not including the terminating null character. If the buffer is not large enough to contain all the key name and value pairs associated with the named section, the return value is equal to <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>The data in the buffer pointed to by the <i>lpReturnedString</i> parameter consists of one or more null-terminated strings, followed by a final null character. Each string has the following format:</para>
      <para>
        <i>key</i>
        <b>=</b>
        <i>string</i>
      </para>
      <para>The
<b>GetPrivateProfileSection</b> function is not case-sensitive; the string pointed to by the <i>lpAppName</i> parameter can be a combination of uppercase and lowercase letters.</para>
      <para>This operation is atomic; no updates to the specified initialization file are allowed while the key name and value pairs for the section are being copied to the buffer pointed to by the <i>lpReturnedString</i> parameter.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <para>Comments (any line that starts with a semicolon) are stripped out and not returned in the <i>lpReturnedString</i> buffer.</para>
    </remarks>
    <seealso cref="GetPrivateProfileSectionNames" />
    <seealso cref="GetProfileSection" />
    <seealso cref="WritePrivateProfileSection" />
  </member>
  <member name="Windows.GetPrivateProfileSectionW">
    <summary>
      <para>Retrieves all the keys and values for the specified section of an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit applications written for Windows. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the buffer, not including the terminating null character. If the buffer is not large enough to contain all the key name and value pairs associated with the named section, the return value is equal to <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>The data in the buffer pointed to by the <i>lpReturnedString</i> parameter consists of one or more null-terminated strings, followed by a final null character. Each string has the following format:</para>
      <para>
        <i>key</i>
        <b>=</b>
        <i>string</i>
      </para>
      <para>The
<b>GetPrivateProfileSection</b> function is not case-sensitive; the string pointed to by the <i>lpAppName</i> parameter can be a combination of uppercase and lowercase letters.</para>
      <para>This operation is atomic; no updates to the specified initialization file are allowed while the key name and value pairs for the section are being copied to the buffer pointed to by the <i>lpReturnedString</i> parameter.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <para>Comments (any line that starts with a semicolon) are stripped out and not returned in the <i>lpReturnedString</i> buffer.</para>
    </remarks>
    <seealso cref="GetPrivateProfileSectionNames" />
    <seealso cref="GetProfileSection" />
    <seealso cref="WritePrivateProfileSection" />
  </member>
  <member name="Windows.GetPrivateProfileSection">
    <summary>
      <para>Retrieves all the keys and values for the specified section of an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit applications written for Windows. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the buffer, not including the terminating null character. If the buffer is not large enough to contain all the key name and value pairs associated with the named section, the return value is equal to <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>The data in the buffer pointed to by the <i>lpReturnedString</i> parameter consists of one or more null-terminated strings, followed by a final null character. Each string has the following format:</para>
      <para>
        <i>key</i>
        <b>=</b>
        <i>string</i>
      </para>
      <para>The
<b>GetPrivateProfileSection</b> function is not case-sensitive; the string pointed to by the <i>lpAppName</i> parameter can be a combination of uppercase and lowercase letters.</para>
      <para>This operation is atomic; no updates to the specified initialization file are allowed while the key name and value pairs for the section are being copied to the buffer pointed to by the <i>lpReturnedString</i> parameter.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <para>Comments (any line that starts with a semicolon) are stripped out and not returned in the <i>lpReturnedString</i> buffer.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileSectionNames" />
    <seealso cref="GetProfileSection" />
    <seealso cref="WritePrivateProfileSection" />
  </member>
  <member name="Windows.GetPrivateProfileSectionA">
    <summary>
      <para>Retrieves all the keys and values for the specified section of an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit applications written for Windows. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the buffer, not including the terminating null character. If the buffer is not large enough to contain all the key name and value pairs associated with the named section, the return value is equal to <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>The data in the buffer pointed to by the <i>lpReturnedString</i> parameter consists of one or more null-terminated strings, followed by a final null character. Each string has the following format:</para>
      <para>
        <i>key</i>
        <b>=</b>
        <i>string</i>
      </para>
      <para>The
<b>GetPrivateProfileSection</b> function is not case-sensitive; the string pointed to by the <i>lpAppName</i> parameter can be a combination of uppercase and lowercase letters.</para>
      <para>This operation is atomic; no updates to the specified initialization file are allowed while the key name and value pairs for the section are being copied to the buffer pointed to by the <i>lpReturnedString</i> parameter.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <para>Comments (any line that starts with a semicolon) are stripped out and not returned in the <i>lpReturnedString</i> buffer.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileSectionNames" />
    <seealso cref="GetProfileSection" />
    <seealso cref="WritePrivateProfileSection" />
  </member>
  <member name="Windows.GetPrivateProfileSectionW">
    <summary>
      <para>Retrieves all the keys and values for the specified section of an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit applications written for Windows. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the buffer, not including the terminating null character. If the buffer is not large enough to contain all the key name and value pairs associated with the named section, the return value is equal to <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>The data in the buffer pointed to by the <i>lpReturnedString</i> parameter consists of one or more null-terminated strings, followed by a final null character. Each string has the following format:</para>
      <para>
        <i>key</i>
        <b>=</b>
        <i>string</i>
      </para>
      <para>The
<b>GetPrivateProfileSection</b> function is not case-sensitive; the string pointed to by the <i>lpAppName</i> parameter can be a combination of uppercase and lowercase letters.</para>
      <para>This operation is atomic; no updates to the specified initialization file are allowed while the key name and value pairs for the section are being copied to the buffer pointed to by the <i>lpReturnedString</i> parameter.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <para>Comments (any line that starts with a semicolon) are stripped out and not returned in the <i>lpReturnedString</i> buffer.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileSectionNames" />
    <seealso cref="GetProfileSection" />
    <seealso cref="WritePrivateProfileSection" />
  </member>
  <member name="Windows.GetPrivateProfileSectionNames">
    <summary>
      <para>Retrieves the names of all sections in an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpszReturnBuffer">
      <para>A pointer to a buffer that receives the section names associated with the named file. The buffer is filled with one or more <b>null</b>-terminated strings; the last string is followed by a second <b>null</b> character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpszReturnBuffer</i> parameter, in characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter is <b>NULL</b>, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the specified buffer, not including the terminating <b>null</b> character. If the buffer is not large enough to contain all the section names associated with the specified initialization file, the return value is equal to the size specified by <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>This operation is atomic; no updates to the initialization file are allowed while the section names are being copied to the buffer.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="GetPrivateProfileSection" />
    <seealso cref="WritePrivateProfileSection" />
  </member>
  <member name="Windows.GetPrivateProfileSectionNamesA">
    <summary>
      <para>Retrieves the names of all sections in an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpszReturnBuffer">
      <para>A pointer to a buffer that receives the section names associated with the named file. The buffer is filled with one or more <b>null</b>-terminated strings; the last string is followed by a second <b>null</b> character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpszReturnBuffer</i> parameter, in characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter is <b>NULL</b>, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the specified buffer, not including the terminating <b>null</b> character. If the buffer is not large enough to contain all the section names associated with the specified initialization file, the return value is equal to the size specified by <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>This operation is atomic; no updates to the initialization file are allowed while the section names are being copied to the buffer.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="GetPrivateProfileSection" />
    <seealso cref="WritePrivateProfileSection" />
  </member>
  <member name="Windows.GetPrivateProfileSectionNamesW">
    <summary>
      <para>Retrieves the names of all sections in an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpszReturnBuffer">
      <para>A pointer to a buffer that receives the section names associated with the named file. The buffer is filled with one or more <b>null</b>-terminated strings; the last string is followed by a second <b>null</b> character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpszReturnBuffer</i> parameter, in characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter is <b>NULL</b>, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the specified buffer, not including the terminating <b>null</b> character. If the buffer is not large enough to contain all the section names associated with the specified initialization file, the return value is equal to the size specified by <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>This operation is atomic; no updates to the initialization file are allowed while the section names are being copied to the buffer.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="GetPrivateProfileSection" />
    <seealso cref="WritePrivateProfileSection" />
  </member>
  <member name="Windows.GetPrivateProfileSectionNames">
    <summary>
      <para>Retrieves the names of all sections in an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpszReturnBuffer">
      <para>A pointer to a buffer that receives the section names associated with the named file. The buffer is filled with one or more <b>null</b>-terminated strings; the last string is followed by a second <b>null</b> character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpszReturnBuffer</i> parameter, in characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter is <b>NULL</b>, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the specified buffer, not including the terminating <b>null</b> character. If the buffer is not large enough to contain all the section names associated with the specified initialization file, the return value is equal to the size specified by <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>This operation is atomic; no updates to the initialization file are allowed while the section names are being copied to the buffer.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileSectionNames as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileSection" />
    <seealso cref="WritePrivateProfileSection" />
  </member>
  <member name="Windows.GetPrivateProfileSectionNamesA">
    <summary>
      <para>Retrieves the names of all sections in an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpszReturnBuffer">
      <para>A pointer to a buffer that receives the section names associated with the named file. The buffer is filled with one or more <b>null</b>-terminated strings; the last string is followed by a second <b>null</b> character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpszReturnBuffer</i> parameter, in characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter is <b>NULL</b>, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the specified buffer, not including the terminating <b>null</b> character. If the buffer is not large enough to contain all the section names associated with the specified initialization file, the return value is equal to the size specified by <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>This operation is atomic; no updates to the initialization file are allowed while the section names are being copied to the buffer.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileSectionNames as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileSection" />
    <seealso cref="WritePrivateProfileSection" />
  </member>
  <member name="Windows.GetPrivateProfileSectionNamesW">
    <summary>
      <para>Retrieves the names of all sections in an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpszReturnBuffer">
      <para>A pointer to a buffer that receives the section names associated with the named file. The buffer is filled with one or more <b>null</b>-terminated strings; the last string is followed by a second <b>null</b> character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpszReturnBuffer</i> parameter, in characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter is <b>NULL</b>, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the specified buffer, not including the terminating <b>null</b> character. If the buffer is not large enough to contain all the section names associated with the specified initialization file, the return value is equal to the size specified by <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>This operation is atomic; no updates to the initialization file are allowed while the section names are being copied to the buffer.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileSectionNames as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileSection" />
    <seealso cref="WritePrivateProfileSection" />
  </member>
  <member name="Windows.GetPrivateProfileSectionNames">
    <summary>
      <para>Retrieves the names of all sections in an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpszReturnBuffer">
      <para>A pointer to a buffer that receives the section names associated with the named file. The buffer is filled with one or more <b>null</b>-terminated strings; the last string is followed by a second <b>null</b> character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpszReturnBuffer</i> parameter, in characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter is <b>NULL</b>, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the specified buffer, not including the terminating <b>null</b> character. If the buffer is not large enough to contain all the section names associated with the specified initialization file, the return value is equal to the size specified by <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>This operation is atomic; no updates to the initialization file are allowed while the section names are being copied to the buffer.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileSectionNames as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileSection" />
    <seealso cref="WritePrivateProfileSection" />
  </member>
  <member name="Windows.GetPrivateProfileSectionNamesA">
    <summary>
      <para>Retrieves the names of all sections in an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpszReturnBuffer">
      <para>A pointer to a buffer that receives the section names associated with the named file. The buffer is filled with one or more <b>null</b>-terminated strings; the last string is followed by a second <b>null</b> character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpszReturnBuffer</i> parameter, in characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter is <b>NULL</b>, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the specified buffer, not including the terminating <b>null</b> character. If the buffer is not large enough to contain all the section names associated with the specified initialization file, the return value is equal to the size specified by <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>This operation is atomic; no updates to the initialization file are allowed while the section names are being copied to the buffer.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileSectionNames as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileSection" />
    <seealso cref="WritePrivateProfileSection" />
  </member>
  <member name="Windows.GetPrivateProfileSectionNamesW">
    <summary>
      <para>Retrieves the names of all sections in an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpszReturnBuffer">
      <para>A pointer to a buffer that receives the section names associated with the named file. The buffer is filled with one or more <b>null</b>-terminated strings; the last string is followed by a second <b>null</b> character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpszReturnBuffer</i> parameter, in characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter is <b>NULL</b>, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the specified buffer, not including the terminating <b>null</b> character. If the buffer is not large enough to contain all the section names associated with the specified initialization file, the return value is equal to the size specified by <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>This operation is atomic; no updates to the initialization file are allowed while the section names are being copied to the buffer.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileSectionNames as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileSection" />
    <seealso cref="WritePrivateProfileSection" />
  </member>
  <member name="Windows.GetPrivateProfileSection">
    <summary>
      <para>Retrieves all the keys and values for the specified section of an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit applications written for Windows. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the buffer, not including the terminating null character. If the buffer is not large enough to contain all the key name and value pairs associated with the named section, the return value is equal to <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>The data in the buffer pointed to by the <i>lpReturnedString</i> parameter consists of one or more null-terminated strings, followed by a final null character. Each string has the following format:</para>
      <para>
        <i>key</i>
        <b>=</b>
        <i>string</i>
      </para>
      <para>The
<b>GetPrivateProfileSection</b> function is not case-sensitive; the string pointed to by the <i>lpAppName</i> parameter can be a combination of uppercase and lowercase letters.</para>
      <para>This operation is atomic; no updates to the specified initialization file are allowed while the key name and value pairs for the section are being copied to the buffer pointed to by the <i>lpReturnedString</i> parameter.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <para>Comments (any line that starts with a semicolon) are stripped out and not returned in the <i>lpReturnedString</i> buffer.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileSectionNames" />
    <seealso cref="GetProfileSection" />
    <seealso cref="WritePrivateProfileSection" />
  </member>
  <member name="Windows.GetPrivateProfileSectionA">
    <summary>
      <para>Retrieves all the keys and values for the specified section of an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit applications written for Windows. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the buffer, not including the terminating null character. If the buffer is not large enough to contain all the key name and value pairs associated with the named section, the return value is equal to <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>The data in the buffer pointed to by the <i>lpReturnedString</i> parameter consists of one or more null-terminated strings, followed by a final null character. Each string has the following format:</para>
      <para>
        <i>key</i>
        <b>=</b>
        <i>string</i>
      </para>
      <para>The
<b>GetPrivateProfileSection</b> function is not case-sensitive; the string pointed to by the <i>lpAppName</i> parameter can be a combination of uppercase and lowercase letters.</para>
      <para>This operation is atomic; no updates to the specified initialization file are allowed while the key name and value pairs for the section are being copied to the buffer pointed to by the <i>lpReturnedString</i> parameter.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <para>Comments (any line that starts with a semicolon) are stripped out and not returned in the <i>lpReturnedString</i> buffer.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileSectionNames" />
    <seealso cref="GetProfileSection" />
    <seealso cref="WritePrivateProfileSection" />
  </member>
  <member name="Windows.GetPrivateProfileSectionW">
    <summary>
      <para>Retrieves all the keys and values for the specified section of an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit applications written for Windows. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the buffer, not including the terminating null character. If the buffer is not large enough to contain all the key name and value pairs associated with the named section, the return value is equal to <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>The data in the buffer pointed to by the <i>lpReturnedString</i> parameter consists of one or more null-terminated strings, followed by a final null character. Each string has the following format:</para>
      <para>
        <i>key</i>
        <b>=</b>
        <i>string</i>
      </para>
      <para>The
<b>GetPrivateProfileSection</b> function is not case-sensitive; the string pointed to by the <i>lpAppName</i> parameter can be a combination of uppercase and lowercase letters.</para>
      <para>This operation is atomic; no updates to the specified initialization file are allowed while the key name and value pairs for the section are being copied to the buffer pointed to by the <i>lpReturnedString</i> parameter.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <para>Comments (any line that starts with a semicolon) are stripped out and not returned in the <i>lpReturnedString</i> buffer.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileSectionNames" />
    <seealso cref="GetProfileSection" />
    <seealso cref="WritePrivateProfileSection" />
  </member>
  <member name="Windows.GetPrivateProfileString">
    <summary>
      <para>Retrieves a string from the specified section in an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section containing the key name. If this parameter is <b>NULL</b>, the
<b>GetPrivateProfileString</b> function copies all section names in the file to the supplied buffer.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all key names in the section specified by the <i>lpAppName</i> parameter are copied to the buffer specified by the <i>lpReturnedString</i> parameter.</para>
    </param>
    <param name="lpDefault">
      <para>A default string. If the <i>lpKeyName</i> key cannot be found in the initialization file,
<b>GetPrivateProfileString</b> copies the default string to the <i>lpReturnedString</i> buffer.</para>
      <para>If this parameter is <b>NULL</b>, the default is an empty string, "".</para>
      <para>Avoid specifying a default string with trailing blank characters. The function inserts a <b>null</b> character in the <i>lpReturnedString</i> buffer to strip any trailing blanks.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to the buffer that receives the retrieved string.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value is the number of characters copied to the buffer, not including the terminating <b>null</b> character.</para>
      <para>If neither <i>lpAppName</i> nor <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a <b>null</b> character, and the return value is equal to <i>nSize</i> minus one.</para>
      <para>If either <i>lpAppName</i> or <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters. In this case, the return value is equal to <i>nSize</i> minus two.</para>
      <para>In the event the initialization file specified by <i>lpFileName</i> is not found, or contains invalid values, calling <b>GetLastError</b> will return '0x2' (File Not Found). To retrieve extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetPrivateProfileString</b> function searches the specified initialization file for a key that matches the name specified by the <i>lpKeyName</i> parameter under the section heading specified by the <i>lpAppName</i> parameter. If it finds the key, the function copies the corresponding string to the buffer. If the key does not exist, the function copies the default character string specified by the <i>lpDefault</i> parameter. A section in the initialization file must have the following form:</para>
      <code>[section]
key=string
      .
      .
      .
</code>
      <para>If <i>lpAppName</i> is <b>NULL</b>,
<b>GetPrivateProfileString</b> copies all section names in the specified file to the supplied buffer. If <i>lpKeyName</i> is <b>NULL</b>, the function copies all key names in the specified section to the supplied buffer. An application can use this method to enumerate all of the sections and keys in a file. In either case, each string is followed by a <b>null</b> character and the final string is followed by a second <b>null</b> character. If the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters.</para>
      <para>If the string associated with <i>lpKeyName</i> is enclosed in single or double quotation marks, the marks are discarded when the
<b>GetPrivateProfileString</b> function retrieves the string.</para>
      <para>The
<b>GetPrivateProfileString</b> function is not case-sensitive; the strings can be a combination of uppercase and lowercase letters.</para>
      <para>To retrieve a string from the Win.ini file, use the
<see cref="GetProfileString" /> function.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="GetProfileString" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.GetPrivateProfileStringA">
    <summary>
      <para>Retrieves a string from the specified section in an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section containing the key name. If this parameter is <b>NULL</b>, the
<b>GetPrivateProfileString</b> function copies all section names in the file to the supplied buffer.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all key names in the section specified by the <i>lpAppName</i> parameter are copied to the buffer specified by the <i>lpReturnedString</i> parameter.</para>
    </param>
    <param name="lpDefault">
      <para>A default string. If the <i>lpKeyName</i> key cannot be found in the initialization file,
<b>GetPrivateProfileString</b> copies the default string to the <i>lpReturnedString</i> buffer.</para>
      <para>If this parameter is <b>NULL</b>, the default is an empty string, "".</para>
      <para>Avoid specifying a default string with trailing blank characters. The function inserts a <b>null</b> character in the <i>lpReturnedString</i> buffer to strip any trailing blanks.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to the buffer that receives the retrieved string.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value is the number of characters copied to the buffer, not including the terminating <b>null</b> character.</para>
      <para>If neither <i>lpAppName</i> nor <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a <b>null</b> character, and the return value is equal to <i>nSize</i> minus one.</para>
      <para>If either <i>lpAppName</i> or <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters. In this case, the return value is equal to <i>nSize</i> minus two.</para>
      <para>In the event the initialization file specified by <i>lpFileName</i> is not found, or contains invalid values, calling <b>GetLastError</b> will return '0x2' (File Not Found). To retrieve extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetPrivateProfileString</b> function searches the specified initialization file for a key that matches the name specified by the <i>lpKeyName</i> parameter under the section heading specified by the <i>lpAppName</i> parameter. If it finds the key, the function copies the corresponding string to the buffer. If the key does not exist, the function copies the default character string specified by the <i>lpDefault</i> parameter. A section in the initialization file must have the following form:</para>
      <code>[section]
key=string
      .
      .
      .
</code>
      <para>If <i>lpAppName</i> is <b>NULL</b>,
<b>GetPrivateProfileString</b> copies all section names in the specified file to the supplied buffer. If <i>lpKeyName</i> is <b>NULL</b>, the function copies all key names in the specified section to the supplied buffer. An application can use this method to enumerate all of the sections and keys in a file. In either case, each string is followed by a <b>null</b> character and the final string is followed by a second <b>null</b> character. If the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters.</para>
      <para>If the string associated with <i>lpKeyName</i> is enclosed in single or double quotation marks, the marks are discarded when the
<b>GetPrivateProfileString</b> function retrieves the string.</para>
      <para>The
<b>GetPrivateProfileString</b> function is not case-sensitive; the strings can be a combination of uppercase and lowercase letters.</para>
      <para>To retrieve a string from the Win.ini file, use the
<see cref="GetProfileString" /> function.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="GetProfileString" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.GetPrivateProfileStringW">
    <summary>
      <para>Retrieves a string from the specified section in an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section containing the key name. If this parameter is <b>NULL</b>, the
<b>GetPrivateProfileString</b> function copies all section names in the file to the supplied buffer.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all key names in the section specified by the <i>lpAppName</i> parameter are copied to the buffer specified by the <i>lpReturnedString</i> parameter.</para>
    </param>
    <param name="lpDefault">
      <para>A default string. If the <i>lpKeyName</i> key cannot be found in the initialization file,
<b>GetPrivateProfileString</b> copies the default string to the <i>lpReturnedString</i> buffer.</para>
      <para>If this parameter is <b>NULL</b>, the default is an empty string, "".</para>
      <para>Avoid specifying a default string with trailing blank characters. The function inserts a <b>null</b> character in the <i>lpReturnedString</i> buffer to strip any trailing blanks.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to the buffer that receives the retrieved string.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value is the number of characters copied to the buffer, not including the terminating <b>null</b> character.</para>
      <para>If neither <i>lpAppName</i> nor <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a <b>null</b> character, and the return value is equal to <i>nSize</i> minus one.</para>
      <para>If either <i>lpAppName</i> or <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters. In this case, the return value is equal to <i>nSize</i> minus two.</para>
      <para>In the event the initialization file specified by <i>lpFileName</i> is not found, or contains invalid values, calling <b>GetLastError</b> will return '0x2' (File Not Found). To retrieve extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetPrivateProfileString</b> function searches the specified initialization file for a key that matches the name specified by the <i>lpKeyName</i> parameter under the section heading specified by the <i>lpAppName</i> parameter. If it finds the key, the function copies the corresponding string to the buffer. If the key does not exist, the function copies the default character string specified by the <i>lpDefault</i> parameter. A section in the initialization file must have the following form:</para>
      <code>[section]
key=string
      .
      .
      .
</code>
      <para>If <i>lpAppName</i> is <b>NULL</b>,
<b>GetPrivateProfileString</b> copies all section names in the specified file to the supplied buffer. If <i>lpKeyName</i> is <b>NULL</b>, the function copies all key names in the specified section to the supplied buffer. An application can use this method to enumerate all of the sections and keys in a file. In either case, each string is followed by a <b>null</b> character and the final string is followed by a second <b>null</b> character. If the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters.</para>
      <para>If the string associated with <i>lpKeyName</i> is enclosed in single or double quotation marks, the marks are discarded when the
<b>GetPrivateProfileString</b> function retrieves the string.</para>
      <para>The
<b>GetPrivateProfileString</b> function is not case-sensitive; the strings can be a combination of uppercase and lowercase letters.</para>
      <para>To retrieve a string from the Win.ini file, use the
<see cref="GetProfileString" /> function.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="GetProfileString" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.GetPrivateProfileString">
    <summary>
      <para>Retrieves a string from the specified section in an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section containing the key name. If this parameter is <b>NULL</b>, the
<b>GetPrivateProfileString</b> function copies all section names in the file to the supplied buffer.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all key names in the section specified by the <i>lpAppName</i> parameter are copied to the buffer specified by the <i>lpReturnedString</i> parameter.</para>
    </param>
    <param name="lpDefault">
      <para>A default string. If the <i>lpKeyName</i> key cannot be found in the initialization file,
<b>GetPrivateProfileString</b> copies the default string to the <i>lpReturnedString</i> buffer.</para>
      <para>If this parameter is <b>NULL</b>, the default is an empty string, "".</para>
      <para>Avoid specifying a default string with trailing blank characters. The function inserts a <b>null</b> character in the <i>lpReturnedString</i> buffer to strip any trailing blanks.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to the buffer that receives the retrieved string.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value is the number of characters copied to the buffer, not including the terminating <b>null</b> character.</para>
      <para>If neither <i>lpAppName</i> nor <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a <b>null</b> character, and the return value is equal to <i>nSize</i> minus one.</para>
      <para>If either <i>lpAppName</i> or <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters. In this case, the return value is equal to <i>nSize</i> minus two.</para>
      <para>In the event the initialization file specified by <i>lpFileName</i> is not found, or contains invalid values, this function will set <b>errorno</b> with a value of '0x2' (File Not Found). To retrieve extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetPrivateProfileString</b> function searches the specified initialization file for a key that matches the name specified by the <i>lpKeyName</i> parameter under the section heading specified by the <i>lpAppName</i> parameter. If it finds the key, the function copies the corresponding string to the buffer. If the key does not exist, the function copies the default character string specified by the <i>lpDefault</i> parameter. A section in the initialization file must have the following form:</para>
      <code>[section]
key=string
      .
      .
      .
</code>
      <para>If <i>lpAppName</i> is <b>NULL</b>,
<b>GetPrivateProfileString</b> copies all section names in the specified file to the supplied buffer. If <i>lpKeyName</i> is <b>NULL</b>, the function copies all key names in the specified section to the supplied buffer. An application can use this method to enumerate all of the sections and keys in a file. In either case, each string is followed by a <b>null</b> character and the final string is followed by a second <b>null</b> character. If the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters.</para>
      <para>If the string associated with <i>lpKeyName</i> is enclosed in single or double quotation marks, the marks are discarded when the
<b>GetPrivateProfileString</b> function retrieves the string.</para>
      <para>The
<b>GetPrivateProfileString</b> function is not case-sensitive; the strings can be a combination of uppercase and lowercase letters.</para>
      <para>To retrieve a string from the Win.ini file, use the
<see cref="GetProfileString" /> function.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="GetProfileString" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.GetPrivateProfileStringA">
    <summary>
      <para>Retrieves a string from the specified section in an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section containing the key name. If this parameter is <b>NULL</b>, the
<b>GetPrivateProfileString</b> function copies all section names in the file to the supplied buffer.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all key names in the section specified by the <i>lpAppName</i> parameter are copied to the buffer specified by the <i>lpReturnedString</i> parameter.</para>
    </param>
    <param name="lpDefault">
      <para>A default string. If the <i>lpKeyName</i> key cannot be found in the initialization file,
<b>GetPrivateProfileString</b> copies the default string to the <i>lpReturnedString</i> buffer.</para>
      <para>If this parameter is <b>NULL</b>, the default is an empty string, "".</para>
      <para>Avoid specifying a default string with trailing blank characters. The function inserts a <b>null</b> character in the <i>lpReturnedString</i> buffer to strip any trailing blanks.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to the buffer that receives the retrieved string.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value is the number of characters copied to the buffer, not including the terminating <b>null</b> character.</para>
      <para>If neither <i>lpAppName</i> nor <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a <b>null</b> character, and the return value is equal to <i>nSize</i> minus one.</para>
      <para>If either <i>lpAppName</i> or <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters. In this case, the return value is equal to <i>nSize</i> minus two.</para>
      <para>In the event the initialization file specified by <i>lpFileName</i> is not found, or contains invalid values, this function will set <b>errorno</b> with a value of '0x2' (File Not Found). To retrieve extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetPrivateProfileString</b> function searches the specified initialization file for a key that matches the name specified by the <i>lpKeyName</i> parameter under the section heading specified by the <i>lpAppName</i> parameter. If it finds the key, the function copies the corresponding string to the buffer. If the key does not exist, the function copies the default character string specified by the <i>lpDefault</i> parameter. A section in the initialization file must have the following form:</para>
      <code>[section]
key=string
      .
      .
      .
</code>
      <para>If <i>lpAppName</i> is <b>NULL</b>,
<b>GetPrivateProfileString</b> copies all section names in the specified file to the supplied buffer. If <i>lpKeyName</i> is <b>NULL</b>, the function copies all key names in the specified section to the supplied buffer. An application can use this method to enumerate all of the sections and keys in a file. In either case, each string is followed by a <b>null</b> character and the final string is followed by a second <b>null</b> character. If the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters.</para>
      <para>If the string associated with <i>lpKeyName</i> is enclosed in single or double quotation marks, the marks are discarded when the
<b>GetPrivateProfileString</b> function retrieves the string.</para>
      <para>The
<b>GetPrivateProfileString</b> function is not case-sensitive; the strings can be a combination of uppercase and lowercase letters.</para>
      <para>To retrieve a string from the Win.ini file, use the
<see cref="GetProfileString" /> function.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="GetProfileString" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.GetPrivateProfileStringW">
    <summary>
      <para>Retrieves a string from the specified section in an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section containing the key name. If this parameter is <b>NULL</b>, the
<b>GetPrivateProfileString</b> function copies all section names in the file to the supplied buffer.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all key names in the section specified by the <i>lpAppName</i> parameter are copied to the buffer specified by the <i>lpReturnedString</i> parameter.</para>
    </param>
    <param name="lpDefault">
      <para>A default string. If the <i>lpKeyName</i> key cannot be found in the initialization file,
<b>GetPrivateProfileString</b> copies the default string to the <i>lpReturnedString</i> buffer.</para>
      <para>If this parameter is <b>NULL</b>, the default is an empty string, "".</para>
      <para>Avoid specifying a default string with trailing blank characters. The function inserts a <b>null</b> character in the <i>lpReturnedString</i> buffer to strip any trailing blanks.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to the buffer that receives the retrieved string.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value is the number of characters copied to the buffer, not including the terminating <b>null</b> character.</para>
      <para>If neither <i>lpAppName</i> nor <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a <b>null</b> character, and the return value is equal to <i>nSize</i> minus one.</para>
      <para>If either <i>lpAppName</i> or <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters. In this case, the return value is equal to <i>nSize</i> minus two.</para>
      <para>In the event the initialization file specified by <i>lpFileName</i> is not found, or contains invalid values, this function will set <b>errorno</b> with a value of '0x2' (File Not Found). To retrieve extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetPrivateProfileString</b> function searches the specified initialization file for a key that matches the name specified by the <i>lpKeyName</i> parameter under the section heading specified by the <i>lpAppName</i> parameter. If it finds the key, the function copies the corresponding string to the buffer. If the key does not exist, the function copies the default character string specified by the <i>lpDefault</i> parameter. A section in the initialization file must have the following form:</para>
      <code>[section]
key=string
      .
      .
      .
</code>
      <para>If <i>lpAppName</i> is <b>NULL</b>,
<b>GetPrivateProfileString</b> copies all section names in the specified file to the supplied buffer. If <i>lpKeyName</i> is <b>NULL</b>, the function copies all key names in the specified section to the supplied buffer. An application can use this method to enumerate all of the sections and keys in a file. In either case, each string is followed by a <b>null</b> character and the final string is followed by a second <b>null</b> character. If the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters.</para>
      <para>If the string associated with <i>lpKeyName</i> is enclosed in single or double quotation marks, the marks are discarded when the
<b>GetPrivateProfileString</b> function retrieves the string.</para>
      <para>The
<b>GetPrivateProfileString</b> function is not case-sensitive; the strings can be a combination of uppercase and lowercase letters.</para>
      <para>To retrieve a string from the Win.ini file, use the
<see cref="GetProfileString" /> function.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="GetProfileString" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.GetPrivateProfileString">
    <summary>
      <para>Retrieves a string from the specified section in an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section containing the key name. If this parameter is <b>NULL</b>, the
<b>GetPrivateProfileString</b> function copies all section names in the file to the supplied buffer.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all key names in the section specified by the <i>lpAppName</i> parameter are copied to the buffer specified by the <i>lpReturnedString</i> parameter.</para>
    </param>
    <param name="lpDefault">
      <para>A default string. If the <i>lpKeyName</i> key cannot be found in the initialization file,
<b>GetPrivateProfileString</b> copies the default string to the <i>lpReturnedString</i> buffer.</para>
      <para>If this parameter is <b>NULL</b>, the default is an empty string, "".</para>
      <para>Avoid specifying a default string with trailing blank characters. The function inserts a <b>null</b> character in the <i>lpReturnedString</i> buffer to strip any trailing blanks.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to the buffer that receives the retrieved string.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value is the number of characters copied to the buffer, not including the terminating <b>null</b> character.</para>
      <para>If neither <i>lpAppName</i> nor <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a <b>null</b> character, and the return value is equal to <i>nSize</i> minus one.</para>
      <para>If either <i>lpAppName</i> or <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters. In this case, the return value is equal to <i>nSize</i> minus two.</para>
      <para>In the event the initialization file specified by <i>lpFileName</i> is not found, or contains invalid values, this function will set <b>errorno</b> with a value of '0x2' (File Not Found). To retrieve extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetPrivateProfileString</b> function searches the specified initialization file for a key that matches the name specified by the <i>lpKeyName</i> parameter under the section heading specified by the <i>lpAppName</i> parameter. If it finds the key, the function copies the corresponding string to the buffer. If the key does not exist, the function copies the default character string specified by the <i>lpDefault</i> parameter. A section in the initialization file must have the following form:</para>
      <code>[section]
key=string
      .
      .
      .
</code>
      <para>If <i>lpAppName</i> is <b>NULL</b>,
<b>GetPrivateProfileString</b> copies all section names in the specified file to the supplied buffer. If <i>lpKeyName</i> is <b>NULL</b>, the function copies all key names in the specified section to the supplied buffer. An application can use this method to enumerate all of the sections and keys in a file. In either case, each string is followed by a <b>null</b> character and the final string is followed by a second <b>null</b> character. If the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters.</para>
      <para>If the string associated with <i>lpKeyName</i> is enclosed in single or double quotation marks, the marks are discarded when the
<b>GetPrivateProfileString</b> function retrieves the string.</para>
      <para>The
<b>GetPrivateProfileString</b> function is not case-sensitive; the strings can be a combination of uppercase and lowercase letters.</para>
      <para>To retrieve a string from the Win.ini file, use the
<see cref="GetProfileString" /> function.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="GetProfileString" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.GetPrivateProfileStringA">
    <summary>
      <para>Retrieves a string from the specified section in an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section containing the key name. If this parameter is <b>NULL</b>, the
<b>GetPrivateProfileString</b> function copies all section names in the file to the supplied buffer.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all key names in the section specified by the <i>lpAppName</i> parameter are copied to the buffer specified by the <i>lpReturnedString</i> parameter.</para>
    </param>
    <param name="lpDefault">
      <para>A default string. If the <i>lpKeyName</i> key cannot be found in the initialization file,
<b>GetPrivateProfileString</b> copies the default string to the <i>lpReturnedString</i> buffer.</para>
      <para>If this parameter is <b>NULL</b>, the default is an empty string, "".</para>
      <para>Avoid specifying a default string with trailing blank characters. The function inserts a <b>null</b> character in the <i>lpReturnedString</i> buffer to strip any trailing blanks.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to the buffer that receives the retrieved string.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value is the number of characters copied to the buffer, not including the terminating <b>null</b> character.</para>
      <para>If neither <i>lpAppName</i> nor <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a <b>null</b> character, and the return value is equal to <i>nSize</i> minus one.</para>
      <para>If either <i>lpAppName</i> or <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters. In this case, the return value is equal to <i>nSize</i> minus two.</para>
      <para>In the event the initialization file specified by <i>lpFileName</i> is not found, or contains invalid values, this function will set <b>errorno</b> with a value of '0x2' (File Not Found). To retrieve extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetPrivateProfileString</b> function searches the specified initialization file for a key that matches the name specified by the <i>lpKeyName</i> parameter under the section heading specified by the <i>lpAppName</i> parameter. If it finds the key, the function copies the corresponding string to the buffer. If the key does not exist, the function copies the default character string specified by the <i>lpDefault</i> parameter. A section in the initialization file must have the following form:</para>
      <code>[section]
key=string
      .
      .
      .
</code>
      <para>If <i>lpAppName</i> is <b>NULL</b>,
<b>GetPrivateProfileString</b> copies all section names in the specified file to the supplied buffer. If <i>lpKeyName</i> is <b>NULL</b>, the function copies all key names in the specified section to the supplied buffer. An application can use this method to enumerate all of the sections and keys in a file. In either case, each string is followed by a <b>null</b> character and the final string is followed by a second <b>null</b> character. If the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters.</para>
      <para>If the string associated with <i>lpKeyName</i> is enclosed in single or double quotation marks, the marks are discarded when the
<b>GetPrivateProfileString</b> function retrieves the string.</para>
      <para>The
<b>GetPrivateProfileString</b> function is not case-sensitive; the strings can be a combination of uppercase and lowercase letters.</para>
      <para>To retrieve a string from the Win.ini file, use the
<see cref="GetProfileString" /> function.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="GetProfileString" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.GetPrivateProfileStringW">
    <summary>
      <para>Retrieves a string from the specified section in an initialization file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section containing the key name. If this parameter is <b>NULL</b>, the
<b>GetPrivateProfileString</b> function copies all section names in the file to the supplied buffer.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all key names in the section specified by the <i>lpAppName</i> parameter are copied to the buffer specified by the <i>lpReturnedString</i> parameter.</para>
    </param>
    <param name="lpDefault">
      <para>A default string. If the <i>lpKeyName</i> key cannot be found in the initialization file,
<b>GetPrivateProfileString</b> copies the default string to the <i>lpReturnedString</i> buffer.</para>
      <para>If this parameter is <b>NULL</b>, the default is an empty string, "".</para>
      <para>Avoid specifying a default string with trailing blank characters. The function inserts a <b>null</b> character in the <i>lpReturnedString</i> buffer to strip any trailing blanks.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to the buffer that receives the retrieved string.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
    </param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>The return value is the number of characters copied to the buffer, not including the terminating <b>null</b> character.</para>
      <para>If neither <i>lpAppName</i> nor <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a <b>null</b> character, and the return value is equal to <i>nSize</i> minus one.</para>
      <para>If either <i>lpAppName</i> or <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters. In this case, the return value is equal to <i>nSize</i> minus two.</para>
      <para>In the event the initialization file specified by <i>lpFileName</i> is not found, or contains invalid values, this function will set <b>errorno</b> with a value of '0x2' (File Not Found). To retrieve extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>GetPrivateProfileString</b> function searches the specified initialization file for a key that matches the name specified by the <i>lpKeyName</i> parameter under the section heading specified by the <i>lpAppName</i> parameter. If it finds the key, the function copies the corresponding string to the buffer. If the key does not exist, the function copies the default character string specified by the <i>lpDefault</i> parameter. A section in the initialization file must have the following form:</para>
      <code>[section]
key=string
      .
      .
      .
</code>
      <para>If <i>lpAppName</i> is <b>NULL</b>,
<b>GetPrivateProfileString</b> copies all section names in the specified file to the supplied buffer. If <i>lpKeyName</i> is <b>NULL</b>, the function copies all key names in the specified section to the supplied buffer. An application can use this method to enumerate all of the sections and keys in a file. In either case, each string is followed by a <b>null</b> character and the final string is followed by a second <b>null</b> character. If the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters.</para>
      <para>If the string associated with <i>lpKeyName</i> is enclosed in single or double quotation marks, the marks are discarded when the
<b>GetPrivateProfileString</b> function retrieves the string.</para>
      <para>The
<b>GetPrivateProfileString</b> function is not case-sensitive; the strings can be a combination of uppercase and lowercase letters.</para>
      <para>To retrieve a string from the Win.ini file, use the
<see cref="GetProfileString" /> function.</para>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="GetProfileString" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.GetPrivateProfileStruct">
    <summary>
      <para>Retrieves the data associated with a key in the specified section of an initialization file. As it retrieves the data, the function calculates a checksum and compares it with the checksum calculated by the
<see cref="WritePrivateProfileStruct" /> function when the data was added to the file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpszSection">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpszKey">
      <para>The name of the key whose data is to be retrieved.</para>
    </param>
    <param name="lpStruct">
      <para>A pointer to the buffer that receives the data associated with the file, section, and key names.</para>
    </param>
    <param name="uSizeStruct">
      <para>The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</para>
    </param>
    <param name="szFile">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>A section in the initialization file must have the following form:</para>
      <code>[section]
key=data
      .
      .
      .
</code>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file, say MyFile.ini, under <b>IniFileMapping</b>.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under <b>myfile.ini</b>, or a subkey of <b>myfile.ini</b>, or will not exist.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value under <b>myfile.ini</b>, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey of <b>myfile.ini</b>, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey under <b>myfile.ini</b>, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) under <b>myfile.ini</b> that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no <b>myfile.ini</b> subkey, or if it does not contain an entry for the section name, then look for the actual MyFile.ini on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="WritePrivateProfileStruct" />
  </member>
  <member name="Windows.GetPrivateProfileStructA">
    <summary>
      <para>Retrieves the data associated with a key in the specified section of an initialization file. As it retrieves the data, the function calculates a checksum and compares it with the checksum calculated by the
<see cref="WritePrivateProfileStruct" /> function when the data was added to the file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpszSection">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpszKey">
      <para>The name of the key whose data is to be retrieved.</para>
    </param>
    <param name="lpStruct">
      <para>A pointer to the buffer that receives the data associated with the file, section, and key names.</para>
    </param>
    <param name="uSizeStruct">
      <para>The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</para>
    </param>
    <param name="szFile">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>A section in the initialization file must have the following form:</para>
      <code>[section]
key=data
      .
      .
      .
</code>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file, say MyFile.ini, under <b>IniFileMapping</b>.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under <b>myfile.ini</b>, or a subkey of <b>myfile.ini</b>, or will not exist.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value under <b>myfile.ini</b>, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey of <b>myfile.ini</b>, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey under <b>myfile.ini</b>, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) under <b>myfile.ini</b> that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no <b>myfile.ini</b> subkey, or if it does not contain an entry for the section name, then look for the actual MyFile.ini on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="WritePrivateProfileStruct" />
  </member>
  <member name="Windows.GetPrivateProfileStructW">
    <summary>
      <para>Retrieves the data associated with a key in the specified section of an initialization file. As it retrieves the data, the function calculates a checksum and compares it with the checksum calculated by the
<see cref="WritePrivateProfileStruct" /> function when the data was added to the file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpszSection">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpszKey">
      <para>The name of the key whose data is to be retrieved.</para>
    </param>
    <param name="lpStruct">
      <para>A pointer to the buffer that receives the data associated with the file, section, and key names.</para>
    </param>
    <param name="uSizeStruct">
      <para>The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</para>
    </param>
    <param name="szFile">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>A section in the initialization file must have the following form:</para>
      <code>[section]
key=data
      .
      .
      .
</code>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file, say MyFile.ini, under <b>IniFileMapping</b>.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under <b>myfile.ini</b>, or a subkey of <b>myfile.ini</b>, or will not exist.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value under <b>myfile.ini</b>, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey of <b>myfile.ini</b>, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey under <b>myfile.ini</b>, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) under <b>myfile.ini</b> that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no <b>myfile.ini</b> subkey, or if it does not contain an entry for the section name, then look for the actual MyFile.ini on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="WritePrivateProfileStruct" />
  </member>
  <member name="Windows.GetPrivateProfileStruct">
    <summary>
      <para>Retrieves the data associated with a key in the specified section of an initialization file. As it retrieves the data, the function calculates a checksum and compares it with the checksum calculated by the
<see cref="WritePrivateProfileStruct" /> function when the data was added to the file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpszSection">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpszKey">
      <para>The name of the key whose data is to be retrieved.</para>
    </param>
    <param name="lpStruct">
      <para>A pointer to the buffer that receives the data associated with the file, section, and key names.</para>
    </param>
    <param name="uSizeStruct">
      <para>The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</para>
    </param>
    <param name="szFile">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>A section in the initialization file must have the following form:</para>
      <code>[section]
key=data
      .
      .
      .
</code>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file, say MyFile.ini, under <b>IniFileMapping</b>.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under <b>myfile.ini</b>, or a subkey of <b>myfile.ini</b>, or will not exist.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value under <b>myfile.ini</b>, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey of <b>myfile.ini</b>, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey under <b>myfile.ini</b>, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) under <b>myfile.ini</b> that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no <b>myfile.ini</b> subkey, or if it does not contain an entry for the section name, then look for the actual MyFile.ini on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileStruct as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="WritePrivateProfileStruct" />
  </member>
  <member name="Windows.GetPrivateProfileStructA">
    <summary>
      <para>Retrieves the data associated with a key in the specified section of an initialization file. As it retrieves the data, the function calculates a checksum and compares it with the checksum calculated by the
<see cref="WritePrivateProfileStruct" /> function when the data was added to the file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpszSection">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpszKey">
      <para>The name of the key whose data is to be retrieved.</para>
    </param>
    <param name="lpStruct">
      <para>A pointer to the buffer that receives the data associated with the file, section, and key names.</para>
    </param>
    <param name="uSizeStruct">
      <para>The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</para>
    </param>
    <param name="szFile">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>A section in the initialization file must have the following form:</para>
      <code>[section]
key=data
      .
      .
      .
</code>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file, say MyFile.ini, under <b>IniFileMapping</b>.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under <b>myfile.ini</b>, or a subkey of <b>myfile.ini</b>, or will not exist.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value under <b>myfile.ini</b>, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey of <b>myfile.ini</b>, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey under <b>myfile.ini</b>, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) under <b>myfile.ini</b> that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no <b>myfile.ini</b> subkey, or if it does not contain an entry for the section name, then look for the actual MyFile.ini on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileStruct as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="WritePrivateProfileStruct" />
  </member>
  <member name="Windows.GetPrivateProfileStructW">
    <summary>
      <para>Retrieves the data associated with a key in the specified section of an initialization file. As it retrieves the data, the function calculates a checksum and compares it with the checksum calculated by the
<see cref="WritePrivateProfileStruct" /> function when the data was added to the file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpszSection">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpszKey">
      <para>The name of the key whose data is to be retrieved.</para>
    </param>
    <param name="lpStruct">
      <para>A pointer to the buffer that receives the data associated with the file, section, and key names.</para>
    </param>
    <param name="uSizeStruct">
      <para>The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</para>
    </param>
    <param name="szFile">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>A section in the initialization file must have the following form:</para>
      <code>[section]
key=data
      .
      .
      .
</code>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file, say MyFile.ini, under <b>IniFileMapping</b>.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under <b>myfile.ini</b>, or a subkey of <b>myfile.ini</b>, or will not exist.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value under <b>myfile.ini</b>, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey of <b>myfile.ini</b>, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey under <b>myfile.ini</b>, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) under <b>myfile.ini</b> that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no <b>myfile.ini</b> subkey, or if it does not contain an entry for the section name, then look for the actual MyFile.ini on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileStruct as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="WritePrivateProfileStruct" />
  </member>
  <member name="Windows.GetPrivateProfileStruct">
    <summary>
      <para>Retrieves the data associated with a key in the specified section of an initialization file. As it retrieves the data, the function calculates a checksum and compares it with the checksum calculated by the
<see cref="WritePrivateProfileStruct" /> function when the data was added to the file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpszSection">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpszKey">
      <para>The name of the key whose data is to be retrieved.</para>
    </param>
    <param name="lpStruct">
      <para>A pointer to the buffer that receives the data associated with the file, section, and key names.</para>
    </param>
    <param name="uSizeStruct">
      <para>The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</para>
    </param>
    <param name="szFile">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>A section in the initialization file must have the following form:</para>
      <code>[section]
key=data
      .
      .
      .
</code>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file, say MyFile.ini, under <b>IniFileMapping</b>.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under <b>myfile.ini</b>, or a subkey of <b>myfile.ini</b>, or will not exist.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value under <b>myfile.ini</b>, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey of <b>myfile.ini</b>, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey under <b>myfile.ini</b>, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) under <b>myfile.ini</b> that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no <b>myfile.ini</b> subkey, or if it does not contain an entry for the section name, then look for the actual MyFile.ini on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileStruct as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="WritePrivateProfileStruct" />
  </member>
  <member name="Windows.GetPrivateProfileStructA">
    <summary>
      <para>Retrieves the data associated with a key in the specified section of an initialization file. As it retrieves the data, the function calculates a checksum and compares it with the checksum calculated by the
<see cref="WritePrivateProfileStruct" /> function when the data was added to the file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpszSection">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpszKey">
      <para>The name of the key whose data is to be retrieved.</para>
    </param>
    <param name="lpStruct">
      <para>A pointer to the buffer that receives the data associated with the file, section, and key names.</para>
    </param>
    <param name="uSizeStruct">
      <para>The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</para>
    </param>
    <param name="szFile">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>A section in the initialization file must have the following form:</para>
      <code>[section]
key=data
      .
      .
      .
</code>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file, say MyFile.ini, under <b>IniFileMapping</b>.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under <b>myfile.ini</b>, or a subkey of <b>myfile.ini</b>, or will not exist.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value under <b>myfile.ini</b>, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey of <b>myfile.ini</b>, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey under <b>myfile.ini</b>, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) under <b>myfile.ini</b> that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no <b>myfile.ini</b> subkey, or if it does not contain an entry for the section name, then look for the actual MyFile.ini on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileStruct as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="WritePrivateProfileStruct" />
  </member>
  <member name="Windows.GetPrivateProfileStructW">
    <summary>
      <para>Retrieves the data associated with a key in the specified section of an initialization file. As it retrieves the data, the function calculates a checksum and compares it with the checksum calculated by the
<see cref="WritePrivateProfileStruct" /> function when the data was added to the file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpszSection">
      <para>The name of the section in the initialization file.</para>
    </param>
    <param name="lpszKey">
      <para>The name of the key whose data is to be retrieved.</para>
    </param>
    <param name="lpStruct">
      <para>A pointer to the buffer that receives the data associated with the file, section, and key names.</para>
    </param>
    <param name="uSizeStruct">
      <para>The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</para>
    </param>
    <param name="szFile">
      <para>The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>A section in the initialization file must have the following form:</para>
      <code>[section]
key=data
      .
      .
      .
</code>
      <para>The system maps most .ini file references to the registry, using the mapping defined under the following registry key:<b>HKEY_LOCAL_MACHINE</b>\<b>SOFTWARE</b>\<b>Microsoft</b>\<b>Windows NT</b>\<b>CurrentVersion</b>\<b>IniFileMapping</b></para>
      <para>This mapping is likely if an application modifies system-component initialization files, such as Control.ini, System.ini, and Winfile.ini. In these cases, the
function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file, say MyFile.ini, under <b>IniFileMapping</b>.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under <b>myfile.ini</b>, or a subkey of <b>myfile.ini</b>, or will not exist.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value under <b>myfile.ini</b>, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey of <b>myfile.ini</b>, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey under <b>myfile.ini</b>, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) under <b>myfile.ini</b> that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no <b>myfile.ini</b> subkey, or if it does not contain an entry for the section name, then look for the actual MyFile.ini on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetPrivateProfileStruct as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="WritePrivateProfileStruct" />
  </member>
  <member name="Windows.GetProcessAffinityMask">
    <summary>
      <para>Retrieves the process affinity mask for the specified process and the system affinity mask for the system.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process whose affinity mask is desired.</para>
      <para>This handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpProcessAffinityMask">
      <para>A pointer to a variable that receives the affinity mask for the specified process.</para>
    </param>
    <param name="lpSystemAffinityMask">
      <para>A pointer to a variable that receives the affinity mask for the system.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero and the function sets the variables pointed to by <i>lpProcessAffinityMask</i> and <i>lpSystemAffinityMask</i> to the appropriate affinity masks.</para>
      <para>On a system with more than 64 processors, if the threads of the calling process are in a single <a href="https://docs.microsoft.com//windows/desktop/ProcThread/processor-groups">processor group</a>, the function sets the variables pointed to by <i>lpProcessAffinityMask</i> and <i>lpSystemAffinityMask</i> to the process affinity mask and the processor mask of active logical processors for that group. If the calling process contains threads in multiple groups, the function returns zero for both affinity masks.</para>
      <para>If the function fails, the return value is zero, and the values of the variables pointed to by <i>lpProcessAffinityMask</i> and <i>lpSystemAffinityMask</i> are undefined. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>A process affinity mask is a bit vector in which each bit represents the processors that a process is allowed to run on. A system affinity mask is a bit vector in which each bit represents the processors that are configured into a system.</para>
      <para>A process affinity mask is a subset of the system affinity mask. A process is only allowed to run on the processors configured into a system. Therefore, the process affinity mask cannot specify a 1 bit for a processor when the system affinity mask specifies a 0 bit for that processor.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-processors">Multiple Processors</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/processor-groups">Processor Groups</seealso>
    <seealso cref="SetProcessAffinityMask" />
    <seealso cref="SetThreadAffinityMask" />
  </member>
  <member name="Windows.GetProcessDEPPolicy">
    <summary>
      <para>Gets the data execution prevention (DEP) and DEP-ATL thunk emulation settings for the specified 32-bit process.<b>Windows XP with SP3:  </b>Gets the DEP and DEP-ATL thunk emulation settings for the current process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. <b>PROCESS_QUERY_INFORMATION</b> privilege is required to get the DEP policy of a process.</para>
      <para>
        <b>Windows XP with SP3:  </b>The <i>hProcess</i> parameter is ignored.</para>
    </param>
    <param name="lpFlags">
      <para>A <b>DWORD</b> that receives one or more of the following flags.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>DEP is disabled for the specified process.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PROCESS_DEP_ENABLE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>DEP is enabled for the specified process.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>DEP-ATL thunk emulation is disabled for the specified process. For information about DEP-ATL thunk emulation, see <see cref="SetProcessDEPPolicy" />.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpPermanent">
      <para>
        <b>TRUE</b> if DEP is enabled or disabled permanently for the specified process; otherwise <b>FALSE</b>. If <i>lpPermanent</i> is <b>TRUE</b>, the current DEP setting persists for the life of the process and cannot be changed by calling <see cref="SetProcessDEPPolicy" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>.</para>
      <para>If the function fails, it returns <b>FALSE</b>. To retrieve error values defined for this function,  call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>GetProcessDEPPolicy</b> is supported for 32-bit processes only. If this function is called on a 64-bit process, it fails with <b>ERROR_NOT_SUPPORTED</b>.</para>
      <para>To compile an application that calls this function, define <b>_WIN32_WINNT</b> as 0x0600 or later. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/data-execution-prevention">Data Execution Prevention</seealso>
    <seealso cref="GetSystemDEPPolicy" />
    <seealso cref="SetProcessDEPPolicy" />
  </member>
  <member name="Windows.GetProcessIoCounters">
    <summary>
      <para>Retrieves accounting information for all I/O operations performed by the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpIoCounters">
      <para>A pointer to an
<see cref="IO_COUNTERS" /> structure that receives the I/O accounting information for the process.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="IO_COUNTERS" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
  </member>
  <member name="Windows.GetProfileInt">
    <summary>
      <para>Retrieves an integer from a key in the specified section of the Win.ini file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section containing the key name.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose value is to be retrieved. This value is in the form of a string; the
<b>GetProfileInt</b> function converts the string into an integer and returns the integer.</para>
    </param>
    <param name="nDefault">
      <para>The default value to return if the key name cannot be found in the initialization file.</para>
    </param>
    <returns>
      <para>The return value is the integer equivalent of the string following the key name in Win.ini. If the function cannot find the key, the return value is the default value. If the value of the key is less than zero, the return value is zero.</para>
    </returns>
    <remarks>
      <para>If the key name consists of digits followed by characters that are not numeric, the function returns only the value of the digits. For example, the function returns 102 for the following line: KeyName=102abc.</para>
      <para>
        <b>Windows Server 2003 and Windows XP/2000:  </b>Calls to profile functions may be mapped to the registry instead of to the initialization files. This mapping occurs when the initialization file and section are specified in the registry under the following key:<b>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\IniFileMapping</b></para>
      <para>When the operation has been mapped, the
<b>GetProfileInt</b> function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetProfileInt as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileInt" />
    <seealso cref="WriteProfileString" />
  </member>
  <member name="Windows.GetProfileIntA">
    <summary>
      <para>Retrieves an integer from a key in the specified section of the Win.ini file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section containing the key name.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose value is to be retrieved. This value is in the form of a string; the
<b>GetProfileInt</b> function converts the string into an integer and returns the integer.</para>
    </param>
    <param name="nDefault">
      <para>The default value to return if the key name cannot be found in the initialization file.</para>
    </param>
    <returns>
      <para>The return value is the integer equivalent of the string following the key name in Win.ini. If the function cannot find the key, the return value is the default value. If the value of the key is less than zero, the return value is zero.</para>
    </returns>
    <remarks>
      <para>If the key name consists of digits followed by characters that are not numeric, the function returns only the value of the digits. For example, the function returns 102 for the following line: KeyName=102abc.</para>
      <para>
        <b>Windows Server 2003 and Windows XP/2000:  </b>Calls to profile functions may be mapped to the registry instead of to the initialization files. This mapping occurs when the initialization file and section are specified in the registry under the following key:<b>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\IniFileMapping</b></para>
      <para>When the operation has been mapped, the
<b>GetProfileInt</b> function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetProfileInt as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileInt" />
    <seealso cref="WriteProfileString" />
  </member>
  <member name="Windows.GetProfileIntW">
    <summary>
      <para>Retrieves an integer from a key in the specified section of the Win.ini file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section containing the key name.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose value is to be retrieved. This value is in the form of a string; the
<b>GetProfileInt</b> function converts the string into an integer and returns the integer.</para>
    </param>
    <param name="nDefault">
      <para>The default value to return if the key name cannot be found in the initialization file.</para>
    </param>
    <returns>
      <para>The return value is the integer equivalent of the string following the key name in Win.ini. If the function cannot find the key, the return value is the default value. If the value of the key is less than zero, the return value is zero.</para>
    </returns>
    <remarks>
      <para>If the key name consists of digits followed by characters that are not numeric, the function returns only the value of the digits. For example, the function returns 102 for the following line: KeyName=102abc.</para>
      <para>
        <b>Windows Server 2003 and Windows XP/2000:  </b>Calls to profile functions may be mapped to the registry instead of to the initialization files. This mapping occurs when the initialization file and section are specified in the registry under the following key:<b>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\IniFileMapping</b></para>
      <para>When the operation has been mapped, the
<b>GetProfileInt</b> function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetProfileInt as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileInt" />
    <seealso cref="WriteProfileString" />
  </member>
  <member name="Windows.GetProfileInt">
    <summary>
      <para>Retrieves an integer from a key in the specified section of the Win.ini file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section containing the key name.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose value is to be retrieved. This value is in the form of a string; the
<b>GetProfileInt</b> function converts the string into an integer and returns the integer.</para>
    </param>
    <param name="nDefault">
      <para>The default value to return if the key name cannot be found in the initialization file.</para>
    </param>
    <returns>
      <para>The return value is the integer equivalent of the string following the key name in Win.ini. If the function cannot find the key, the return value is the default value. If the value of the key is less than zero, the return value is zero.</para>
    </returns>
    <remarks>
      <para>If the key name consists of digits followed by characters that are not numeric, the function returns only the value of the digits. For example, the function returns 102 for the following line: KeyName=102abc.</para>
      <para>
        <b>Windows Server 2003 and Windows XP/2000:  </b>Calls to profile functions may be mapped to the registry instead of to the initialization files. This mapping occurs when the initialization file and section are specified in the registry under the following key:<b>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\IniFileMapping</b></para>
      <para>When the operation has been mapped, the
<b>GetProfileInt</b> function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetProfileInt as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileInt" />
    <seealso cref="WriteProfileString" />
  </member>
  <member name="Windows.GetProfileIntA">
    <summary>
      <para>Retrieves an integer from a key in the specified section of the Win.ini file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section containing the key name.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose value is to be retrieved. This value is in the form of a string; the
<b>GetProfileInt</b> function converts the string into an integer and returns the integer.</para>
    </param>
    <param name="nDefault">
      <para>The default value to return if the key name cannot be found in the initialization file.</para>
    </param>
    <returns>
      <para>The return value is the integer equivalent of the string following the key name in Win.ini. If the function cannot find the key, the return value is the default value. If the value of the key is less than zero, the return value is zero.</para>
    </returns>
    <remarks>
      <para>If the key name consists of digits followed by characters that are not numeric, the function returns only the value of the digits. For example, the function returns 102 for the following line: KeyName=102abc.</para>
      <para>
        <b>Windows Server 2003 and Windows XP/2000:  </b>Calls to profile functions may be mapped to the registry instead of to the initialization files. This mapping occurs when the initialization file and section are specified in the registry under the following key:<b>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\IniFileMapping</b></para>
      <para>When the operation has been mapped, the
<b>GetProfileInt</b> function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetProfileInt as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileInt" />
    <seealso cref="WriteProfileString" />
  </member>
  <member name="Windows.GetProfileIntW">
    <summary>
      <para>Retrieves an integer from a key in the specified section of the Win.ini file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section containing the key name.</para>
    </param>
    <param name="lpKeyName">
      <para>The name of the key whose value is to be retrieved. This value is in the form of a string; the
<b>GetProfileInt</b> function converts the string into an integer and returns the integer.</para>
    </param>
    <param name="nDefault">
      <para>The default value to return if the key name cannot be found in the initialization file.</para>
    </param>
    <returns>
      <para>The return value is the integer equivalent of the string following the key name in Win.ini. If the function cannot find the key, the return value is the default value. If the value of the key is less than zero, the return value is zero.</para>
    </returns>
    <remarks>
      <para>If the key name consists of digits followed by characters that are not numeric, the function returns only the value of the digits. For example, the function returns 102 for the following line: KeyName=102abc.</para>
      <para>
        <b>Windows Server 2003 and Windows XP/2000:  </b>Calls to profile functions may be mapped to the registry instead of to the initialization files. This mapping occurs when the initialization file and section are specified in the registry under the following key:<b>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\IniFileMapping</b></para>
      <para>When the operation has been mapped, the
<b>GetProfileInt</b> function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetProfileInt as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileInt" />
    <seealso cref="WriteProfileString" />
  </member>
  <member name="Windows.GetProfileSection">
    <summary>
      <para>Retrieves all the keys and values for the specified section of the Win.ini file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the Win.ini file.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to a buffer that receives the keys and values associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the specified buffer, not including the terminating null character. If the buffer is not large enough to contain all the keys and values associated with the named section, the return value is equal to the size specified by <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>The format of the returned keys and values is one or more null-terminated strings, followed by a final null character. Each string has the following form: <i>key</i>=<i>string</i></para>
      <para>The
<b>GetProfileSection</b> function is not case-sensitive; the strings can be a combination of uppercase and lowercase letters.</para>
      <para>This operation is atomic; no updates to the Win.ini file are allowed while the keys and values for the section are being copied to the buffer.</para>
      <para>
        <b>Windows Server 2003 and Windows XP/2000:  </b>Calls to profile functions may be mapped to the registry instead of to the initialization files. This mapping occurs when the initialization file and section are specified in the registry under the following key: <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\IniFileMapping</b>.</para>
      <para>When the operation has been mapped, the
<b>GetProfileSection</b> function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetProfileSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileSection" />
    <seealso cref="WriteProfileSection" />
  </member>
  <member name="Windows.GetProfileSectionA">
    <summary>
      <para>Retrieves all the keys and values for the specified section of the Win.ini file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the Win.ini file.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to a buffer that receives the keys and values associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the specified buffer, not including the terminating null character. If the buffer is not large enough to contain all the keys and values associated with the named section, the return value is equal to the size specified by <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>The format of the returned keys and values is one or more null-terminated strings, followed by a final null character. Each string has the following form: <i>key</i>=<i>string</i></para>
      <para>The
<b>GetProfileSection</b> function is not case-sensitive; the strings can be a combination of uppercase and lowercase letters.</para>
      <para>This operation is atomic; no updates to the Win.ini file are allowed while the keys and values for the section are being copied to the buffer.</para>
      <para>
        <b>Windows Server 2003 and Windows XP/2000:  </b>Calls to profile functions may be mapped to the registry instead of to the initialization files. This mapping occurs when the initialization file and section are specified in the registry under the following key: <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\IniFileMapping</b>.</para>
      <para>When the operation has been mapped, the
<b>GetProfileSection</b> function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetProfileSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileSection" />
    <seealso cref="WriteProfileSection" />
  </member>
  <member name="Windows.GetProfileSectionW">
    <summary>
      <para>Retrieves all the keys and values for the specified section of the Win.ini file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the Win.ini file.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to a buffer that receives the keys and values associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the specified buffer, not including the terminating null character. If the buffer is not large enough to contain all the keys and values associated with the named section, the return value is equal to the size specified by <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>The format of the returned keys and values is one or more null-terminated strings, followed by a final null character. Each string has the following form: <i>key</i>=<i>string</i></para>
      <para>The
<b>GetProfileSection</b> function is not case-sensitive; the strings can be a combination of uppercase and lowercase letters.</para>
      <para>This operation is atomic; no updates to the Win.ini file are allowed while the keys and values for the section are being copied to the buffer.</para>
      <para>
        <b>Windows Server 2003 and Windows XP/2000:  </b>Calls to profile functions may be mapped to the registry instead of to the initialization files. This mapping occurs when the initialization file and section are specified in the registry under the following key: <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\IniFileMapping</b>.</para>
      <para>When the operation has been mapped, the
<b>GetProfileSection</b> function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetProfileSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileSection" />
    <seealso cref="WriteProfileSection" />
  </member>
  <member name="Windows.GetProfileSection">
    <summary>
      <para>Retrieves all the keys and values for the specified section of the Win.ini file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the Win.ini file.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to a buffer that receives the keys and values associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the specified buffer, not including the terminating null character. If the buffer is not large enough to contain all the keys and values associated with the named section, the return value is equal to the size specified by <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>The format of the returned keys and values is one or more null-terminated strings, followed by a final null character. Each string has the following form: <i>key</i>=<i>string</i></para>
      <para>The
<b>GetProfileSection</b> function is not case-sensitive; the strings can be a combination of uppercase and lowercase letters.</para>
      <para>This operation is atomic; no updates to the Win.ini file are allowed while the keys and values for the section are being copied to the buffer.</para>
      <para>
        <b>Windows Server 2003 and Windows XP/2000:  </b>Calls to profile functions may be mapped to the registry instead of to the initialization files. This mapping occurs when the initialization file and section are specified in the registry under the following key: <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\IniFileMapping</b>.</para>
      <para>When the operation has been mapped, the
<b>GetProfileSection</b> function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetProfileSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileSection" />
    <seealso cref="WriteProfileSection" />
  </member>
  <member name="Windows.GetProfileSectionA">
    <summary>
      <para>Retrieves all the keys and values for the specified section of the Win.ini file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the Win.ini file.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to a buffer that receives the keys and values associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the specified buffer, not including the terminating null character. If the buffer is not large enough to contain all the keys and values associated with the named section, the return value is equal to the size specified by <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>The format of the returned keys and values is one or more null-terminated strings, followed by a final null character. Each string has the following form: <i>key</i>=<i>string</i></para>
      <para>The
<b>GetProfileSection</b> function is not case-sensitive; the strings can be a combination of uppercase and lowercase letters.</para>
      <para>This operation is atomic; no updates to the Win.ini file are allowed while the keys and values for the section are being copied to the buffer.</para>
      <para>
        <b>Windows Server 2003 and Windows XP/2000:  </b>Calls to profile functions may be mapped to the registry instead of to the initialization files. This mapping occurs when the initialization file and section are specified in the registry under the following key: <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\IniFileMapping</b>.</para>
      <para>When the operation has been mapped, the
<b>GetProfileSection</b> function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetProfileSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileSection" />
    <seealso cref="WriteProfileSection" />
  </member>
  <member name="Windows.GetProfileSectionW">
    <summary>
      <para>Retrieves all the keys and values for the specified section of the Win.ini file.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</para>
    </summary>
    <param name="lpAppName">
      <para>The name of the section in the Win.ini file.</para>
    </param>
    <param name="lpReturnedString">
      <para>A pointer to a buffer that receives the keys and values associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</para>
    </param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <returns>
      <para>The return value specifies the number of characters copied to the specified buffer, not including the terminating null character. If the buffer is not large enough to contain all the keys and values associated with the named section, the return value is equal to the size specified by <i>nSize</i> minus two.</para>
    </returns>
    <remarks>
      <para>The format of the returned keys and values is one or more null-terminated strings, followed by a final null character. Each string has the following form: <i>key</i>=<i>string</i></para>
      <para>The
<b>GetProfileSection</b> function is not case-sensitive; the strings can be a combination of uppercase and lowercase letters.</para>
      <para>This operation is atomic; no updates to the Win.ini file are allowed while the keys and values for the section are being copied to the buffer.</para>
      <para>
        <b>Windows Server 2003 and Windows XP/2000:  </b>Calls to profile functions may be mapped to the registry instead of to the initialization files. This mapping occurs when the initialization file and section are specified in the registry under the following key: <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\IniFileMapping</b>.</para>
      <para>When the operation has been mapped, the
<b>GetProfileSection</b> function retrieves information from the registry, not from the initialization file; the change in the storage location has no effect on the function's behavior.</para>
      <para>The profile functions use the following steps to locate initialization information:</para>
      <list type="number">
        <item>
          <description>Look in the registry for the name of the initialization file  under the <b>IniFileMapping</b> key.</description>
        </item>
        <item>
          <description>Look for the section name specified by <i>lpAppName</i>. This will be a named value under the key that has the name of the initialization file, or a subkey with this name, or the name will not exist as either a value or subkey.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a named value, then that value specifies where in the registry you will find the keys for the section.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> is a subkey, then named values under that subkey specify where in the registry you will find the keys for the section. If the key you are looking for does not exist as a named value, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the key.</description>
        </item>
        <item>
          <description>If the section name specified by <i>lpAppName</i> does not exist as a named value or as a subkey, then there will be an unnamed value (shown as <b>&lt;No Name&gt;</b>) that specifies the default location in the registry where you will find the keys for the section.</description>
        </item>
        <item>
          <description>If there is no subkey or entry for the section name, then look for the actual initialization file on the disk and read its contents.</description>
        </item>
      </list>
      <para>When looking at values in the registry that specify other registry locations, there are several prefixes that change the behavior of the .ini file mapping:</para>
      <list type="bullet">
        <item>
          <description>! - this character forces all writes to go both to the registry and to the .ini file on disk.</description>
        </item>
        <item>
          <description># - this character causes the registry value to be set to the value in the Windows 3.1 .ini file when a new user logs in for the first time after setup.</description>
        </item>
        <item>
          <description>@ - this character prevents any reads from going to the .ini file on disk if the requested data is not found in the registry.</description>
        </item>
        <item>
          <description>USR: - this prefix stands for <b>HKEY_CURRENT_USER</b>, and the text after the prefix is relative to that key.</description>
        </item>
        <item>
          <description>SYS: - this prefix stands for <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>, and the text after the prefix is relative to that key.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetProfileSection as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetPrivateProfileSection" />
    <seealso cref="WriteProfileSection" />
  </member>
  <member name="Windows.GetShortPathName">
    <summary>
      <para>Retrieves the short path form of the specified path.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </summary>
    <param name="lpszLongPath">
      <para>The path string.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </param>
    <param name="lpszShortPath">
      <para>A pointer to a buffer to receive the null-terminated short form of the path that
<i>lpszLongPath</i> specifies.</para>
      <para>Passing <b>NULL</b> for this parameter and zero for <i>cchBuffer</i></para>
      <para>will always return the required buffer size for a specified <i>lpszLongPath</i>.</para>
    </param>
    <param name="cchBuffer">
      <para>The size of the buffer  that <i>lpszShortPath</i> points to, in
<b>TCHARs</b>.</para>
      <para>Set this parameter to zero if <i>lpszShortPath</i> is set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string that is copied to <i>lpszShortPath</i>, not including the terminating null
character.</para>
      <para>If the <i>lpszShortPath</i> buffer is too small to contain the path, the return value is
the size of the buffer, in <b>TCHARs</b>, that is required to hold the path and the
terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The path that the <i>lpszLongPath</i> parameter specifies does not have to be a full or
long path. The short form can be longer than the specified path.</para>
      <para>If the return value is greater than the value specified in the <i>cchBuffer</i> parameter,
you can call the function again with a buffer that is large enough to hold the path. For an example of this case
in addition to using zero-length buffer for dynamic allocation, see the Example Code section.</para>
      <para>
        <b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return
value on success does not include the terminating null character in the count.</para>
      <para>If the specified path is already in its short form  and conversion is not needed, the function simply copies
the specified path to the buffer specified by the <i>lpszShortPath</i> parameter.</para>
      <para>You can set the <i>lpszShortPath</i> parameter to the same value as the
<i>lpszLongPath</i> parameter; in other words, you can set the output buffer for the short path
to the address of the input path string. Always ensure that the <i>cchBuffer</i> parameter
accurately represents the total size, in <b>TCHARs</b>, of this buffer.</para>
      <para>You can obtain the long name of a file from the short name by calling the
<see cref="GetLongPathName" /> function. Alternatively, where
<b>GetLongPathName</b> is not available, you can call
<see cref="FindFirstFile" /> on each component of the path to get the
corresponding long name.</para>
      <para>It is possible to have access to a file or directory but not have access to some of the parent directories of
that file or directory. As a result, <b>GetShortPathName</b></para>
      <para>may fail when it is unable to query the parent directory of a path component  to determine the short name for that
component. This check can be skipped for directory components that already meet the requirements of a short name.
For more information, see the
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Short vs. Long Names</a> section of
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support short names on shares with continuous availability capability.</para>
      <para>Resilient File System (ReFS) doesn't support short names. If you call <b>GetShortPathName</b> on a path that doesn't have any short names on-disk, the call will succeed, but will return the long-name path instead. This outcome is also possible with NTFS volumes because there's no guarantee that a short name will exist for a given long name.</para>
      <h4>Examples</h4>
      <para>For an example that uses <b>GetShortPathName</b>, see
the Example Code section for <see cref="GetFullPathName" />.</para>
      <para>The following C++ example shows how to use a dynamically allocated output buffer.</para>
      <code>//...
    long     length = 0;
    TCHAR*   buffer = NULL;

// First obtain the size needed by passing NULL and 0.

    length = GetShortPathName(lpszPath, NULL, 0);
    if (length == 0) ErrorExit(TEXT("GetShortPathName"));

// Dynamically allocate the correct size
// (terminating null char was included in length)

    buffer = new TCHAR[length];

// Now simply call again using same long path.

    length = GetShortPathName(lpszPath, buffer, length);
    if (length == 0) ErrorExit(TEXT("GetShortPathName"));

    _tprintf(TEXT("long name = %s shortname = %s"), lpszPath, buffer);

    delete [] buffer;
///...

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindFirstFile" />
    <seealso cref="GetFullPathName" />
    <seealso cref="GetLongPathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
    <seealso cref="SetFileShortName" />
  </member>
  <member name="Windows.GetShortPathNameA">
    <summary>
      <para>Retrieves the short path form of the specified path.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </summary>
    <param name="lpszLongPath">
      <para>The path string.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </param>
    <param name="lpszShortPath">
      <para>A pointer to a buffer to receive the null-terminated short form of the path that
<i>lpszLongPath</i> specifies.</para>
      <para>Passing <b>NULL</b> for this parameter and zero for <i>cchBuffer</i></para>
      <para>will always return the required buffer size for a specified <i>lpszLongPath</i>.</para>
    </param>
    <param name="cchBuffer">
      <para>The size of the buffer  that <i>lpszShortPath</i> points to, in
<b>TCHARs</b>.</para>
      <para>Set this parameter to zero if <i>lpszShortPath</i> is set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string that is copied to <i>lpszShortPath</i>, not including the terminating null
character.</para>
      <para>If the <i>lpszShortPath</i> buffer is too small to contain the path, the return value is
the size of the buffer, in <b>TCHARs</b>, that is required to hold the path and the
terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The path that the <i>lpszLongPath</i> parameter specifies does not have to be a full or
long path. The short form can be longer than the specified path.</para>
      <para>If the return value is greater than the value specified in the <i>cchBuffer</i> parameter,
you can call the function again with a buffer that is large enough to hold the path. For an example of this case
in addition to using zero-length buffer for dynamic allocation, see the Example Code section.</para>
      <para>
        <b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return
value on success does not include the terminating null character in the count.</para>
      <para>If the specified path is already in its short form  and conversion is not needed, the function simply copies
the specified path to the buffer specified by the <i>lpszShortPath</i> parameter.</para>
      <para>You can set the <i>lpszShortPath</i> parameter to the same value as the
<i>lpszLongPath</i> parameter; in other words, you can set the output buffer for the short path
to the address of the input path string. Always ensure that the <i>cchBuffer</i> parameter
accurately represents the total size, in <b>TCHARs</b>, of this buffer.</para>
      <para>You can obtain the long name of a file from the short name by calling the
<see cref="GetLongPathName" /> function. Alternatively, where
<b>GetLongPathName</b> is not available, you can call
<see cref="FindFirstFile" /> on each component of the path to get the
corresponding long name.</para>
      <para>It is possible to have access to a file or directory but not have access to some of the parent directories of
that file or directory. As a result, <b>GetShortPathName</b></para>
      <para>may fail when it is unable to query the parent directory of a path component  to determine the short name for that
component. This check can be skipped for directory components that already meet the requirements of a short name.
For more information, see the
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Short vs. Long Names</a> section of
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support short names on shares with continuous availability capability.</para>
      <para>Resilient File System (ReFS) doesn't support short names. If you call <b>GetShortPathName</b> on a path that doesn't have any short names on-disk, the call will succeed, but will return the long-name path instead. This outcome is also possible with NTFS volumes because there's no guarantee that a short name will exist for a given long name.</para>
      <h4>Examples</h4>
      <para>For an example that uses <b>GetShortPathName</b>, see
the Example Code section for <see cref="GetFullPathName" />.</para>
      <para>The following C++ example shows how to use a dynamically allocated output buffer.</para>
      <code>//...
    long     length = 0;
    TCHAR*   buffer = NULL;

// First obtain the size needed by passing NULL and 0.

    length = GetShortPathName(lpszPath, NULL, 0);
    if (length == 0) ErrorExit(TEXT("GetShortPathName"));

// Dynamically allocate the correct size
// (terminating null char was included in length)

    buffer = new TCHAR[length];

// Now simply call again using same long path.

    length = GetShortPathName(lpszPath, buffer, length);
    if (length == 0) ErrorExit(TEXT("GetShortPathName"));

    _tprintf(TEXT("long name = %s shortname = %s"), lpszPath, buffer);

    delete [] buffer;
///...

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindFirstFile" />
    <seealso cref="GetFullPathName" />
    <seealso cref="GetLongPathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
    <seealso cref="SetFileShortName" />
  </member>
  <member name="Windows.GetShortPathNameW">
    <summary>
      <para>Retrieves the short path form of the specified path.</para>
      <para>For more information about file and path names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </summary>
    <param name="lpszLongPath">
      <para>The path string.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </param>
    <param name="lpszShortPath">
      <para>A pointer to a buffer to receive the null-terminated short form of the path that
<i>lpszLongPath</i> specifies.</para>
      <para>Passing <b>NULL</b> for this parameter and zero for <i>cchBuffer</i></para>
      <para>will always return the required buffer size for a specified <i>lpszLongPath</i>.</para>
    </param>
    <param name="cchBuffer">
      <para>The size of the buffer  that <i>lpszShortPath</i> points to, in
<b>TCHARs</b>.</para>
      <para>Set this parameter to zero if <i>lpszShortPath</i> is set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the
string that is copied to <i>lpszShortPath</i>, not including the terminating null
character.</para>
      <para>If the <i>lpszShortPath</i> buffer is too small to contain the path, the return value is
the size of the buffer, in <b>TCHARs</b>, that is required to hold the path and the
terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The path that the <i>lpszLongPath</i> parameter specifies does not have to be a full or
long path. The short form can be longer than the specified path.</para>
      <para>If the return value is greater than the value specified in the <i>cchBuffer</i> parameter,
you can call the function again with a buffer that is large enough to hold the path. For an example of this case
in addition to using zero-length buffer for dynamic allocation, see the Example Code section.</para>
      <para>
        <b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return
value on success does not include the terminating null character in the count.</para>
      <para>If the specified path is already in its short form  and conversion is not needed, the function simply copies
the specified path to the buffer specified by the <i>lpszShortPath</i> parameter.</para>
      <para>You can set the <i>lpszShortPath</i> parameter to the same value as the
<i>lpszLongPath</i> parameter; in other words, you can set the output buffer for the short path
to the address of the input path string. Always ensure that the <i>cchBuffer</i> parameter
accurately represents the total size, in <b>TCHARs</b>, of this buffer.</para>
      <para>You can obtain the long name of a file from the short name by calling the
<see cref="GetLongPathName" /> function. Alternatively, where
<b>GetLongPathName</b> is not available, you can call
<see cref="FindFirstFile" /> on each component of the path to get the
corresponding long name.</para>
      <para>It is possible to have access to a file or directory but not have access to some of the parent directories of
that file or directory. As a result, <b>GetShortPathName</b></para>
      <para>may fail when it is unable to query the parent directory of a path component  to determine the short name for that
component. This check can be skipped for directory components that already meet the requirements of a short name.
For more information, see the
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Short vs. Long Names</a> section of
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support short names on shares with continuous availability capability.</para>
      <para>Resilient File System (ReFS) doesn't support short names. If you call <b>GetShortPathName</b> on a path that doesn't have any short names on-disk, the call will succeed, but will return the long-name path instead. This outcome is also possible with NTFS volumes because there's no guarantee that a short name will exist for a given long name.</para>
      <h4>Examples</h4>
      <para>For an example that uses <b>GetShortPathName</b>, see
the Example Code section for <see cref="GetFullPathName" />.</para>
      <para>The following C++ example shows how to use a dynamically allocated output buffer.</para>
      <code>//...
    long     length = 0;
    TCHAR*   buffer = NULL;

// First obtain the size needed by passing NULL and 0.

    length = GetShortPathName(lpszPath, NULL, 0);
    if (length == 0) ErrorExit(TEXT("GetShortPathName"));

// Dynamically allocate the correct size
// (terminating null char was included in length)

    buffer = new TCHAR[length];

// Now simply call again using same long path.

    length = GetShortPathName(lpszPath, buffer, length);
    if (length == 0) ErrorExit(TEXT("GetShortPathName"));

    _tprintf(TEXT("long name = %s shortname = %s"), lpszPath, buffer);

    delete [] buffer;
///...

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="FindFirstFile" />
    <seealso cref="GetFullPathName" />
    <seealso cref="GetLongPathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
    <seealso cref="SetFileShortName" />
  </member>
  <member name="Windows.GetSystemDEPPolicy">
    <summary>
      <para>Gets the data execution prevention (DEP) policy setting for the system.</para>
    </summary>
    <returns>
      <para>This function returns a value of type <b>DEP_SYSTEM_POLICY_TYPE</b>, which can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>AlwaysOff</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>DEP is disabled for all parts of the system, regardless of hardware support for DEP. The processor runs in PAE mode with 32-bit versions of Windows unless PAE is disabled in the boot configuration data.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>AlwaysOn</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>DEP is enabled for all parts of the system. All processes always run with DEP enabled. DEP cannot be explicitly disabled for selected applications. System compatibility fixes are ignored.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OptIn</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>On systems with processors that are capable of hardware-enforced DEP, DEP is automatically enabled only for operating system components. This is the default setting for client versions of Windows. DEP can be explicitly enabled for selected applications or the current process.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OptOut</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>DEP is automatically enabled for operating system components and all processes. This is the default setting for Windows Server versions. DEP can be explicitly disabled for selected applications or the current process. System compatibility fixes for DEP are in effect.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The system-wide DEP policy is configured at boot time according to the policy setting in the boot configuration data.  To change the system-wide DEP policy setting, use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/bcdedit--set">BCDEdit /set</a> command to set the <b>nx</b> boot entry option.</para>
      <para>If the system DEP policy is OptIn or OptOut, DEP can be selectively enabled or disabled for the current process by calling the <see cref="SetProcessDEPPolicy" /> function. This function works only for 32-bit processes.</para>
      <para>A user with administrative privileges can disable DEP for selected applications by using the <b>System</b> Control Panel application. If the system DEP policy is OptOut, DEP is disabled for these applications.</para>
      <para>The Application Compatibility Toolkit can be used to create a list of individual applications that are exempt from DEP. If the system DEP policy is OptOut, DEP is automatically disabled for applications on the list.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/data-execution-prevention">Data Execution Prevention</seealso>
    <seealso cref="GetProcessDEPPolicy" />
    <seealso cref="GetSystemDEPPolicy" />
  </member>
  <member name="Windows.GetSystemPowerStatus">
    <summary>
      <para>Retrieves the power status of the system. The status indicates whether the system is running on AC or DC power, whether the battery is currently charging, how much battery life remains, and if battery saver is on or off.</para>
    </summary>
    <param name="lpSystemPowerStatus">
      <para>A pointer to a
<see cref="SYSTEM_POWER_STATUS" /> structure that receives status information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Power/power-management-functions">Power Management Functions</seealso>
    <seealso cref="SYSTEM_POWER_STATUS" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Power/system-power-status">System Power Status</seealso>
  </member>
  <member name="Windows.GetSystemRegistryQuota">
    <summary>
      <para>Retrieves the current size of the registry and the  maximum size that the registry is allowed to attain on the system.</para>
    </summary>
    <param name="pdwQuotaAllowed">
      <para>A pointer to a variable that receives the maximum size that the registry is allowed to attain on this system, in bytes.</para>
    </param>
    <param name="pdwQuotaUsed">
      <para>A pointer to a variable that receives the current size of  the registry, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0501 or later. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.GetTapeParameters">
    <summary>
      <para>The
<b>GetTapeParameters</b> function retrieves information that describes the tape or the tape drive.</para>
    </summary>
    <param name="hDevice">
      <para>Handle to the device about which information is sought. This handle is created by using the
<see cref="CreateFile" /> function.</para>
    </param>
    <param name="dwOperation">
      <para>Type of information requested. This parameter must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>GET_TAPE_DRIVE_INFORMATION</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Retrieves information about the tape device.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>GET_TAPE_MEDIA_INFORMATION</b>
                </description>
              </item>
              <item>
                <description>0</description>
              </item>
            </list>
          </description>
          <description>
            <para>Retrieves information about the tape in the tape device.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpdwSize">
      <para>Pointer to a variable that receives the size, in bytes, of the buffer specified by the <i>lpTapeInformation</i> parameter. If the buffer is too small, this parameter receives the required size.</para>
    </param>
    <param name="lpTapeInformation">
      <para>Pointer to a structure that contains the requested information. If the <i>dwOperation</i> parameter is <b>GET_TAPE_MEDIA_INFORMATION</b>, <i>lpTapeInformation</i> points to a
<see cref="TAPE_GET_MEDIA_PARAMETERS" /> structure.</para>
      <para>If <i>dwOperation</i> is <b>GET_TAPE_DRIVE_INFORMATION</b>, <i>lpTapeInformation</i> points to a
<see cref="TAPE_GET_DRIVE_PARAMETERS" /> structure.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>NO_ERROR</b>.</para>
      <para>If the function fails, it can return one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_BEGINNING_OF_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1102L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to access data before the beginning-of-medium marker failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_BUS_RESET</b>
                </description>
              </item>
              <item>
                <description>1111L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A reset condition was detected on the bus.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_DEVICE_NOT_PARTITIONED</b>
                </description>
              </item>
              <item>
                <description>1107L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The partition information could not be found when a tape was being loaded.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_END_OF_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1100L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The end-of-tape marker was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_FILEMARK_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1101L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A filemark was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_INVALID_BLOCK_LENGTH</b>
                </description>
              </item>
              <item>
                <description>1106L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The block size is incorrect on a new tape in a multivolume partition.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_MEDIA_CHANGED</b>
                </description>
              </item>
              <item>
                <description>1110L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape that was in the drive has been replaced or removed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NO_DATA_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1104L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The end-of-data marker was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NO_MEDIA_IN_DRIVE</b>
                </description>
              </item>
              <item>
                <description>1112L</description>
              </item>
            </list>
          </description>
          <description>
            <para>There is no media in the drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NOT_SUPPORTED</b>
                </description>
              </item>
              <item>
                <description>50L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape driver does not support a requested function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_PARTITION_FAILURE</b>
                </description>
              </item>
              <item>
                <description>1105L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape could not be partitioned.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_SETMARK_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1103L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A setmark was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_UNABLE_TO_LOCK_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1108L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to lock the ejection mechanism failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1109L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to unload the tape failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_WRITE_PROTECT</b>
                </description>
              </item>
              <item>
                <description>19L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The media is write protected.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The block size range values (maximum and minimum) returned by the
<b>GetTapeParameters</b> function called with the <i>dwOperation</i> parameter set to the <b>GET_TAPE_DRIVE_INFORMATION</b> value will indicate system limits, not drive limits. However, it is the tape drive device and the media present in the drive that determine the true block size limits. Thus, an application may not be able to set all the block sizes mentioned in the range obtained by specifying <b>GET_TAPE_DRIVE_INFORMATION</b> in <i>dwOperation</i>.</para>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="SetTapeParameters" />
    <seealso cref="TAPE_GET_DRIVE_PARAMETERS" />
    <seealso cref="TAPE_GET_MEDIA_PARAMETERS" />
  </member>
  <member name="Windows.GetTapePosition">
    <summary>
      <para>The
<b>GetTapePosition</b> function retrieves the current address of the tape, in logical or absolute blocks.</para>
    </summary>
    <param name="hDevice">
      <para>Handle to the device on which to get the tape position. This handle is created by using
<see cref="CreateFile" />.</para>
    </param>
    <param name="dwPositionType">
      <para>Type of address to obtain. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_ABSOLUTE_POSITION</b>
                </description>
              </item>
              <item>
                <description>0L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>lpdwOffsetLow</i> and <i>lpdwOffsetHigh</i> parameters receive the device-specific block address. The <i>dwPartition</i> parameter receives zero.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_LOGICAL_POSITION</b>
                </description>
              </item>
              <item>
                <description>1L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The <i>lpdwOffsetLow</i> and <i>lpdwOffsetHigh</i> parameters receive the logical block address. The <i>dwPartition</i> parameter receives the logical tape partition.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpdwPartition">
      <para>Pointer to a variable that receives the number of the current tape partition. Partitions are numbered logically from 1 through n, where 1 is the first partition on the tape and n is the last. When a device-specific block address is retrieved, or if the device supports only one partition, this parameter receives zero.</para>
    </param>
    <param name="lpdwOffsetLow">
      <para>Pointer to a variable that receives the low-order bits of the current tape position.</para>
    </param>
    <param name="lpdwOffsetHigh">
      <para>Pointer to a variable that receives the high-order bits of the current tape position. This parameter can be <b>NULL</b> if the high-order bits are not required.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, it can return one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_BEGINNING_OF_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1102L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to access data before the beginning-of-medium marker failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_BUS_RESET</b>
                </description>
              </item>
              <item>
                <description>1111L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A reset condition was detected on the bus.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_DEVICE_NOT_PARTITIONED</b>
                </description>
              </item>
              <item>
                <description>1107L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The partition information could not be found when a tape was being loaded.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_END_OF_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1100L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The end-of-tape marker was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_FILEMARK_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1101L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A filemark was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_INVALID_BLOCK_LENGTH</b>
                </description>
              </item>
              <item>
                <description>1106L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The block size is incorrect on a new tape in a multivolume partition.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_MEDIA_CHANGED</b>
                </description>
              </item>
              <item>
                <description>1110L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape that was in the drive has been replaced or removed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NO_DATA_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1104L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The end-of-data marker was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NO_MEDIA_IN_DRIVE</b>
                </description>
              </item>
              <item>
                <description>1112L</description>
              </item>
            </list>
          </description>
          <description>
            <para>There is no media in the drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NOT_SUPPORTED</b>
                </description>
              </item>
              <item>
                <description>50L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape driver does not support a requested function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_PARTITION_FAILURE</b>
                </description>
              </item>
              <item>
                <description>1105L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape could not be partitioned.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_SETMARK_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1103L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A setmark was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_UNABLE_TO_LOCK_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1108L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to lock the ejection mechanism failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1109L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to unload the tape failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_WRITE_PROTECT</b>
                </description>
              </item>
              <item>
                <description>19L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The media is write protected.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>A logical block address is relative to a partition. The first logical block address on each partition is zero.</para>
      <para>Call the
<see cref="GetTapeParameters" /> function to obtain information about the status, capabilities, and capacities of tape drives and media.</para>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="GetTapeParameters" />
    <seealso cref="SetTapePosition" />
  </member>
  <member name="Windows.GetTapeStatus">
    <summary>
      <para>The
<b>GetTapeStatus</b> function determines whether the tape device is ready to process tape commands.</para>
    </summary>
    <param name="hDevice">
      <para>Handle to the device for which to get the device status. This handle is created by using the
<see cref="CreateFile" /> function.</para>
    </param>
    <returns>
      <para>If the tape device is ready to accept appropriate tape-access commands without returning errors, the return value is NO_ERROR.</para>
      <para>If the function fails, it can return one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_BEGINNING_OF_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1102L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to access data before the beginning-of-medium marker failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_BUS_RESET</b>
                </description>
              </item>
              <item>
                <description>1111L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A reset condition was detected on the bus.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_DEVICE_NOT_PARTITIONED</b>
                </description>
              </item>
              <item>
                <description>1107L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The partition information could not be found when a tape was being loaded.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_DEVICE_REQUIRES_CLEANING</b>
                </description>
              </item>
              <item>
                <description>1165L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape drive is capable of reporting that it requires cleaning, and reports that it does require cleaning.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_END_OF_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1100L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The end-of-tape marker was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_FILEMARK_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1101L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A filemark was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_INVALID_BLOCK_LENGTH</b>
                </description>
              </item>
              <item>
                <description>1106L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The block size is incorrect on a new tape in a multivolume partition.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_MEDIA_CHANGED</b>
                </description>
              </item>
              <item>
                <description>1110L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape that was in the drive has been replaced or removed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NO_DATA_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1104L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The end-of-data marker was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NO_MEDIA_IN_DRIVE</b>
                </description>
              </item>
              <item>
                <description>1112L</description>
              </item>
            </list>
          </description>
          <description>
            <para>There is no media in the drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NOT_SUPPORTED</b>
                </description>
              </item>
              <item>
                <description>50L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape driver does not support a requested function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_PARTITION_FAILURE</b>
                </description>
              </item>
              <item>
                <description>1105L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape could not be partitioned.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_SETMARK_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1103L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A setmark was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_UNABLE_TO_LOCK_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1108L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to lock the ejection mechanism failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1109L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to unload the tape failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_WRITE_PROTECT</b>
                </description>
              </item>
              <item>
                <description>19L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The media is write protected.</para>
          </description>
        </item>
      </list>
    </returns>
    <seealso cref="CreateFile" />
  </member>
  <member name="Windows.GetTempFileName">
    <summary>
      <para>Creates a name for a temporary file. If a unique file name is generated, an empty file is created and
the handle to it is released; otherwise, only a file name is generated.</para>
    </summary>
    <param name="lpPathName">
      <para>The directory path for the file name. Applications typically specify a period (.) for the current directory
or the result of the <see cref="GetTempPath" /> function. The string
cannot be longer than <b>MAX_PATH</b>–14 characters or
<b>GetTempFileName</b> will fail. If this parameter is
<b>NULL</b>, the function fails.</para>
    </param>
    <param name="lpPrefixString">
      <para>The null-terminated prefix string. The function uses up to the first three characters of this string as the
prefix of the file name. This string must consist of characters in the OEM-defined character set.</para>
    </param>
    <param name="uUnique">
      <para>An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.</para>
      <para>If <i>uUnique</i> is zero, the function attempts to form a unique file name using the
current system time. If the file already exists, the number is increased by one and the functions tests if this
file already exists. This continues until a unique filename is found; the function creates a file by that name
and closes it.  Note that the function does not attempt  to verify the uniqueness of the file name when
<i>uUnique</i> is nonzero.</para>
    </param>
    <param name="lpTempFileName">
      <para>A pointer to the buffer that receives the temporary file name. This buffer should be
<b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the unique numeric value used in the temporary file
name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same
number.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The following is a possible return value.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_BUFFER_OVERFLOW</b>
            </para>
          </description>
          <description>
            <para>The length of the string pointed to by the <i>lpPathName</i> parameter is more than
<b>MAX_PATH</b>–14 characters.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetTempFileName</b> function creates a temporary
file name of the following form:</para>
      <para>
        <i>&lt;path&gt;</i>\<i>&lt;pre&gt;</i><i>&lt;uuuu&gt;</i>.TMP</para>
      <para>The following table describes the file name syntax.</para>
      <list type="table">
        <listheader>
          <description>Component</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <i>&lt;path&gt;</i>
          </description>
          <description>Path specified by the <i>lpPathName</i> parameter</description>
        </item>
        <item>
          <description>
            <i>&lt;pre&gt;</i>
          </description>
          <description>First three letters of the <i>lpPrefixString</i> string</description>
        </item>
        <item>
          <description>
            <i>&lt;uuuu&gt;</i>
          </description>
          <description>Hexadecimal value of <i>uUnique</i></description>
        </item>
      </list>
      <para>If <i>uUnique</i> is zero,
<b>GetTempFileName</b> creates an empty file and closes it. If
<i>uUnique</i> is not zero, you must create the file yourself. Only a file name is created,
because <b>GetTempFileName</b> is not able to guarantee that
the file name is unique.</para>
      <para>Only the lower 16 bits of the <i>uUnique</i> parameter are used. This limits
<b>GetTempFileName</b> to a maximum of 65,535 unique file names
if the <i>lpPathName</i> and <i>lpPrefixString</i> parameters remain the
same.</para>
      <para>Due to the algorithm used to generate file names,
<b>GetTempFileName</b> can perform poorly when creating a large
number of files with the same prefix. In such cases, it is recommended that you construct unique file names based
on <b>GUID</b>s.</para>
      <para>Temporary files whose names have been created by this function are not automatically deleted. To delete these
files call <see cref="DeleteFile" />.</para>
      <para>To avoid problems resulting when converting an ANSI string, an application should call the
<see cref="CreateFile" /> function to create a temporary file.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetTempPath" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
  </member>
  <member name="Windows.GetTempFileNameA">
    <summary>
      <para>Creates a name for a temporary file. If a unique file name is generated, an empty file is created and
the handle to it is released; otherwise, only a file name is generated.</para>
    </summary>
    <param name="lpPathName">
      <para>The directory path for the file name. Applications typically specify a period (.) for the current directory
or the result of the <see cref="GetTempPath" /> function. The string
cannot be longer than <b>MAX_PATH</b>–14 characters or
<b>GetTempFileName</b> will fail. If this parameter is
<b>NULL</b>, the function fails.</para>
    </param>
    <param name="lpPrefixString">
      <para>The null-terminated prefix string. The function uses up to the first three characters of this string as the
prefix of the file name. This string must consist of characters in the OEM-defined character set.</para>
    </param>
    <param name="uUnique">
      <para>An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.</para>
      <para>If <i>uUnique</i> is zero, the function attempts to form a unique file name using the
current system time. If the file already exists, the number is increased by one and the functions tests if this
file already exists. This continues until a unique filename is found; the function creates a file by that name
and closes it.  Note that the function does not attempt  to verify the uniqueness of the file name when
<i>uUnique</i> is nonzero.</para>
    </param>
    <param name="lpTempFileName">
      <para>A pointer to the buffer that receives the temporary file name. This buffer should be
<b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the unique numeric value used in the temporary file
name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same
number.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The following is a possible return value.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_BUFFER_OVERFLOW</b>
            </para>
          </description>
          <description>
            <para>The length of the string pointed to by the <i>lpPathName</i> parameter is more than
<b>MAX_PATH</b>–14 characters.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetTempFileName</b> function creates a temporary
file name of the following form:</para>
      <para>
        <i>&lt;path&gt;</i>\<i>&lt;pre&gt;</i><i>&lt;uuuu&gt;</i>.TMP</para>
      <para>The following table describes the file name syntax.</para>
      <list type="table">
        <listheader>
          <description>Component</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <i>&lt;path&gt;</i>
          </description>
          <description>Path specified by the <i>lpPathName</i> parameter</description>
        </item>
        <item>
          <description>
            <i>&lt;pre&gt;</i>
          </description>
          <description>First three letters of the <i>lpPrefixString</i> string</description>
        </item>
        <item>
          <description>
            <i>&lt;uuuu&gt;</i>
          </description>
          <description>Hexadecimal value of <i>uUnique</i></description>
        </item>
      </list>
      <para>If <i>uUnique</i> is zero,
<b>GetTempFileName</b> creates an empty file and closes it. If
<i>uUnique</i> is not zero, you must create the file yourself. Only a file name is created,
because <b>GetTempFileName</b> is not able to guarantee that
the file name is unique.</para>
      <para>Only the lower 16 bits of the <i>uUnique</i> parameter are used. This limits
<b>GetTempFileName</b> to a maximum of 65,535 unique file names
if the <i>lpPathName</i> and <i>lpPrefixString</i> parameters remain the
same.</para>
      <para>Due to the algorithm used to generate file names,
<b>GetTempFileName</b> can perform poorly when creating a large
number of files with the same prefix. In such cases, it is recommended that you construct unique file names based
on <b>GUID</b>s.</para>
      <para>Temporary files whose names have been created by this function are not automatically deleted. To delete these
files call <see cref="DeleteFile" />.</para>
      <para>To avoid problems resulting when converting an ANSI string, an application should call the
<see cref="CreateFile" /> function to create a temporary file.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetTempPath" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
  </member>
  <member name="Windows.GetTempFileNameW">
    <summary>
      <para>Creates a name for a temporary file. If a unique file name is generated, an empty file is created and
the handle to it is released; otherwise, only a file name is generated.</para>
    </summary>
    <param name="lpPathName">
      <para>The directory path for the file name. Applications typically specify a period (.) for the current directory
or the result of the <see cref="GetTempPath" /> function. The string
cannot be longer than <b>MAX_PATH</b>–14 characters or
<b>GetTempFileName</b> will fail. If this parameter is
<b>NULL</b>, the function fails.</para>
    </param>
    <param name="lpPrefixString">
      <para>The null-terminated prefix string. The function uses up to the first three characters of this string as the
prefix of the file name. This string must consist of characters in the OEM-defined character set.</para>
    </param>
    <param name="uUnique">
      <para>An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.</para>
      <para>If <i>uUnique</i> is zero, the function attempts to form a unique file name using the
current system time. If the file already exists, the number is increased by one and the functions tests if this
file already exists. This continues until a unique filename is found; the function creates a file by that name
and closes it.  Note that the function does not attempt  to verify the uniqueness of the file name when
<i>uUnique</i> is nonzero.</para>
    </param>
    <param name="lpTempFileName">
      <para>A pointer to the buffer that receives the temporary file name. This buffer should be
<b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the unique numeric value used in the temporary file
name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same
number.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The following is a possible return value.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_BUFFER_OVERFLOW</b>
            </para>
          </description>
          <description>
            <para>The length of the string pointed to by the <i>lpPathName</i> parameter is more than
<b>MAX_PATH</b>–14 characters.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>GetTempFileName</b> function creates a temporary
file name of the following form:</para>
      <para>
        <i>&lt;path&gt;</i>\<i>&lt;pre&gt;</i><i>&lt;uuuu&gt;</i>.TMP</para>
      <para>The following table describes the file name syntax.</para>
      <list type="table">
        <listheader>
          <description>Component</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <i>&lt;path&gt;</i>
          </description>
          <description>Path specified by the <i>lpPathName</i> parameter</description>
        </item>
        <item>
          <description>
            <i>&lt;pre&gt;</i>
          </description>
          <description>First three letters of the <i>lpPrefixString</i> string</description>
        </item>
        <item>
          <description>
            <i>&lt;uuuu&gt;</i>
          </description>
          <description>Hexadecimal value of <i>uUnique</i></description>
        </item>
      </list>
      <para>If <i>uUnique</i> is zero,
<b>GetTempFileName</b> creates an empty file and closes it. If
<i>uUnique</i> is not zero, you must create the file yourself. Only a file name is created,
because <b>GetTempFileName</b> is not able to guarantee that
the file name is unique.</para>
      <para>Only the lower 16 bits of the <i>uUnique</i> parameter are used. This limits
<b>GetTempFileName</b> to a maximum of 65,535 unique file names
if the <i>lpPathName</i> and <i>lpPrefixString</i> parameters remain the
same.</para>
      <para>Due to the algorithm used to generate file names,
<b>GetTempFileName</b> can perform poorly when creating a large
number of files with the same prefix. In such cases, it is recommended that you construct unique file names based
on <b>GUID</b>s.</para>
      <para>Temporary files whose names have been created by this function are not automatically deleted. To delete these
files call <see cref="DeleteFile" />.</para>
      <para>To avoid problems resulting when converting an ANSI string, an application should call the
<see cref="CreateFile" /> function to create a temporary file.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetTempPath" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</seealso>
  </member>
  <member name="Windows.GetThreadSelectorEntry">
    <summary>
      <para>Retrieves a descriptor table entry for the specified selector and thread.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread containing the specified selector. The handle must have THREAD_QUERY_INFORMATION access. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
    </param>
    <param name="dwSelector">
      <para>The global or local selector value to look up in the thread's descriptor tables.</para>
    </param>
    <param name="lpSelectorEntry">
      <para>A pointer to an
<see cref="LDT_ENTRY" /> structure that receives a copy of the descriptor table entry if the specified selector has an entry in the specified thread's descriptor table. This information can be used to convert a segment-relative address to a linear virtual address.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero. In that case, the structure pointed to by the <i>lpSelectorEntry</i> parameter receives a copy of the specified descriptor table entry.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <b>GetThreadSelectorEntry</b> is only functional on x86-based systems. For systems that are not x86-based, the function returns <b>FALSE</b>.</para>
      <para>Debuggers use this function to convert segment-relative addresses to linear virtual addresses. The
<see cref="ReadProcessMemory" /> and
<see cref="WriteProcessMemory" /> functions use linear virtual addresses.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/debugging-functions">Debugging Functions</seealso>
    <seealso cref="LDT_ENTRY" />
    <seealso cref="ReadProcessMemory" />
    <seealso cref="WriteProcessMemory" />
  </member>
  <member name="Windows.GetUmsCompletionListEvent">
    <summary>
      <para>Retrieves a handle to the event associated with the specified user-mode scheduling (UMS) completion list.</para>
    </summary>
    <param name="UmsCompletionList">
      <para>A pointer to a UMS completion list. The <see cref="CreateUmsCompletionList" /> function provides this pointer.</para>
    </param>
    <param name="UmsCompletionEvent">
      <para>A pointer to a HANDLE variable. On output, the <i>UmsCompletionEvent</i> parameter is set to a handle to the event associated with the specified completion list.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The system signals a UMS completion list event when the system queues items to an empty completion list. A completion list event handle can be used with any <a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait function</a> that takes a handle to an event. When the event is signaled, an application typically calls <see cref="DequeueUmsCompletionListItems" /> to retrieve the contents of the completion list.</para>
      <para>The event handle remains valid until its completion list is deleted. Do not use the event handle to wait on a completion list that has been deleted or is in the process of being deleted.</para>
      <para>When the handle is no longer needed, use the <see cref="CloseHandle" /> function to close the handle.</para>
    </remarks>
    <seealso cref="CreateUmsCompletionList" />
    <seealso cref="DequeueUmsCompletionListItems" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">Wait Functions</seealso>
  </member>
  <member name="Windows.GetUmsSystemThreadInformation">
    <summary>
      <para>Queries whether the specified thread is a UMS scheduler thread, a UMS worker thread, or a non-UMS thread.</para>
    </summary>
    <param name="ThreadHandle">
      <para>A handle to a thread. The thread handle must have the THREAD_QUERY_INFORMATION access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
    </param>
    <param name="SystemThreadInfo">
      <para>A pointer to an initialized <see cref="UMS_SYSTEM_THREAD_INFORMATION" /> structure that specifies the kind of thread for the query.</para>
    </param>
    <returns>
      <para>Returns TRUE if the specified thread matches the kind of thread specified by the <i>SystemThreadInfo</i> parameter. Otherwise, the function returns FALSE.</para>
    </returns>
    <remarks>
      <para>The <b>GetUmsSystemThreadInformation</b> function is intended for use in debuggers, troubleshooting tools, and profiling applications. For example, thread-isolated tracing or single-stepping through instructions might involve suspending all other threads in the process. However, if the thread to be traced is a UMS worker thread, suspending UMS scheduler threads might cause a deadlock because a UMS worker thread requires the intervention of a UMS scheduler thread in order to run. A debugger can call <b>GetUmsSystemThreadInformation</b> for each thread that it might suspend to determine the kind of thread, and then suspend it or not as needed for the code being debugged.</para>
    </remarks>
  </member>
  <member name="Windows.GetUserName">
    <summary>
      <para>Retrieves the name of the user associated with the current thread.</para>
      <para>Use the
<see cref="GetUserNameEx" /> function to retrieve the user name in a specified format. Additional information is provided by the
<see cref="IADsADSystemInfo" /> interface.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to the buffer to receive the user's logon name. If this buffer is not large enough to contain the entire user name, the function fails. A buffer size of (UNLEN + 1) characters will hold the maximum length user name including the terminating null character. UNLEN is defined in Lmcons.h.</para>
    </param>
    <param name="pcbBuffer">
      <para>On input, this variable specifies the size of the <i>lpBuffer</i> buffer, in <b>TCHARs</b>. On output, the variable receives the number of <b>TCHARs</b> copied to the buffer, including the terminating null character.</para>
      <para>If <i>lpBuffer</i> is too small, the function fails and <see cref="GetLastError" /> returns ERROR_INSUFFICIENT_BUFFER. This parameter receives the required buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value, and the variable pointed to by <i>lpnSize</i> contains the number of <b>TCHARs</b> copied to the buffer specified by <i>lpBuffer</i>, including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the current thread is impersonating another client, the
<b>GetUserName</b> function returns the user name of the client that the thread is impersonating.</para>
      <para>If <b>GetUserName</b> is called from a process that is running under the  "NETWORK SERVICE" account, the string returned in <i>lpBuffer</i> may be different depending on the version of Windows.  On Windows XP, the "NETWORK SERVICE" string is returned. On Windows Vista, the “&lt;HOSTNAME&gt;$” string is returned.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetUserName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetUserNameEx" />
    <seealso cref="LookupAccountName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.GetUserNameA">
    <summary>
      <para>Retrieves the name of the user associated with the current thread.</para>
      <para>Use the
<see cref="GetUserNameEx" /> function to retrieve the user name in a specified format. Additional information is provided by the
<see cref="IADsADSystemInfo" /> interface.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to the buffer to receive the user's logon name. If this buffer is not large enough to contain the entire user name, the function fails. A buffer size of (UNLEN + 1) characters will hold the maximum length user name including the terminating null character. UNLEN is defined in Lmcons.h.</para>
    </param>
    <param name="pcbBuffer">
      <para>On input, this variable specifies the size of the <i>lpBuffer</i> buffer, in <b>TCHARs</b>. On output, the variable receives the number of <b>TCHARs</b> copied to the buffer, including the terminating null character.</para>
      <para>If <i>lpBuffer</i> is too small, the function fails and <see cref="GetLastError" /> returns ERROR_INSUFFICIENT_BUFFER. This parameter receives the required buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value, and the variable pointed to by <i>lpnSize</i> contains the number of <b>TCHARs</b> copied to the buffer specified by <i>lpBuffer</i>, including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the current thread is impersonating another client, the
<b>GetUserName</b> function returns the user name of the client that the thread is impersonating.</para>
      <para>If <b>GetUserName</b> is called from a process that is running under the  "NETWORK SERVICE" account, the string returned in <i>lpBuffer</i> may be different depending on the version of Windows.  On Windows XP, the "NETWORK SERVICE" string is returned. On Windows Vista, the “&lt;HOSTNAME&gt;$” string is returned.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetUserName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetUserNameEx" />
    <seealso cref="LookupAccountName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.GetUserNameW">
    <summary>
      <para>Retrieves the name of the user associated with the current thread.</para>
      <para>Use the
<see cref="GetUserNameEx" /> function to retrieve the user name in a specified format. Additional information is provided by the
<see cref="IADsADSystemInfo" /> interface.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to the buffer to receive the user's logon name. If this buffer is not large enough to contain the entire user name, the function fails. A buffer size of (UNLEN + 1) characters will hold the maximum length user name including the terminating null character. UNLEN is defined in Lmcons.h.</para>
    </param>
    <param name="pcbBuffer">
      <para>On input, this variable specifies the size of the <i>lpBuffer</i> buffer, in <b>TCHARs</b>. On output, the variable receives the number of <b>TCHARs</b> copied to the buffer, including the terminating null character.</para>
      <para>If <i>lpBuffer</i> is too small, the function fails and <see cref="GetLastError" /> returns ERROR_INSUFFICIENT_BUFFER. This parameter receives the required buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value, and the variable pointed to by <i>lpnSize</i> contains the number of <b>TCHARs</b> copied to the buffer specified by <i>lpBuffer</i>, including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the current thread is impersonating another client, the
<b>GetUserName</b> function returns the user name of the client that the thread is impersonating.</para>
      <para>If <b>GetUserName</b> is called from a process that is running under the  "NETWORK SERVICE" account, the string returned in <i>lpBuffer</i> may be different depending on the version of Windows.  On Windows XP, the "NETWORK SERVICE" string is returned. On Windows Vista, the “&lt;HOSTNAME&gt;$” string is returned.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetUserName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetUserNameEx" />
    <seealso cref="LookupAccountName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.GetUserName">
    <summary>
      <para>Retrieves the name of the user associated with the current thread.</para>
      <para>Use the
<see cref="GetUserNameEx" /> function to retrieve the user name in a specified format. Additional information is provided by the
<see cref="IADsADSystemInfo" /> interface.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to the buffer to receive the user's logon name. If this buffer is not large enough to contain the entire user name, the function fails. A buffer size of (UNLEN + 1) characters will hold the maximum length user name including the terminating null character. UNLEN is defined in Lmcons.h.</para>
    </param>
    <param name="pcbBuffer">
      <para>On input, this variable specifies the size of the <i>lpBuffer</i> buffer, in <b>TCHARs</b>. On output, the variable receives the number of <b>TCHARs</b> copied to the buffer, including the terminating null character.</para>
      <para>If <i>lpBuffer</i> is too small, the function fails and <see cref="GetLastError" /> returns ERROR_INSUFFICIENT_BUFFER. This parameter receives the required buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value, and the variable pointed to by <i>lpnSize</i> contains the number of <b>TCHARs</b> copied to the buffer specified by <i>lpBuffer</i>, including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the current thread is impersonating another client, the
<b>GetUserName</b> function returns the user name of the client that the thread is impersonating.</para>
      <para>If <b>GetUserName</b> is called from a process that is running under the  "NETWORK SERVICE" account, the string returned in <i>lpBuffer</i> may be different depending on the version of Windows.  On Windows XP, the "NETWORK SERVICE" string is returned. On Windows Vista, the “&lt;HOSTNAME&gt;$” string is returned.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetUserName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetUserNameEx" />
    <seealso cref="LookupAccountName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.GetUserNameA">
    <summary>
      <para>Retrieves the name of the user associated with the current thread.</para>
      <para>Use the
<see cref="GetUserNameEx" /> function to retrieve the user name in a specified format. Additional information is provided by the
<see cref="IADsADSystemInfo" /> interface.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to the buffer to receive the user's logon name. If this buffer is not large enough to contain the entire user name, the function fails. A buffer size of (UNLEN + 1) characters will hold the maximum length user name including the terminating null character. UNLEN is defined in Lmcons.h.</para>
    </param>
    <param name="pcbBuffer">
      <para>On input, this variable specifies the size of the <i>lpBuffer</i> buffer, in <b>TCHARs</b>. On output, the variable receives the number of <b>TCHARs</b> copied to the buffer, including the terminating null character.</para>
      <para>If <i>lpBuffer</i> is too small, the function fails and <see cref="GetLastError" /> returns ERROR_INSUFFICIENT_BUFFER. This parameter receives the required buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value, and the variable pointed to by <i>lpnSize</i> contains the number of <b>TCHARs</b> copied to the buffer specified by <i>lpBuffer</i>, including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the current thread is impersonating another client, the
<b>GetUserName</b> function returns the user name of the client that the thread is impersonating.</para>
      <para>If <b>GetUserName</b> is called from a process that is running under the  "NETWORK SERVICE" account, the string returned in <i>lpBuffer</i> may be different depending on the version of Windows.  On Windows XP, the "NETWORK SERVICE" string is returned. On Windows Vista, the “&lt;HOSTNAME&gt;$” string is returned.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetUserName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetUserNameEx" />
    <seealso cref="LookupAccountName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.GetUserNameW">
    <summary>
      <para>Retrieves the name of the user associated with the current thread.</para>
      <para>Use the
<see cref="GetUserNameEx" /> function to retrieve the user name in a specified format. Additional information is provided by the
<see cref="IADsADSystemInfo" /> interface.</para>
    </summary>
    <param name="lpBuffer">
      <para>A pointer to the buffer to receive the user's logon name. If this buffer is not large enough to contain the entire user name, the function fails. A buffer size of (UNLEN + 1) characters will hold the maximum length user name including the terminating null character. UNLEN is defined in Lmcons.h.</para>
    </param>
    <param name="pcbBuffer">
      <para>On input, this variable specifies the size of the <i>lpBuffer</i> buffer, in <b>TCHARs</b>. On output, the variable receives the number of <b>TCHARs</b> copied to the buffer, including the terminating null character.</para>
      <para>If <i>lpBuffer</i> is too small, the function fails and <see cref="GetLastError" /> returns ERROR_INSUFFICIENT_BUFFER. This parameter receives the required buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value, and the variable pointed to by <i>lpnSize</i> contains the number of <b>TCHARs</b> copied to the buffer specified by <i>lpBuffer</i>, including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the current thread is impersonating another client, the
<b>GetUserName</b> function returns the user name of the client that the thread is impersonating.</para>
      <para>If <b>GetUserName</b> is called from a process that is running under the  "NETWORK SERVICE" account, the string returned in <i>lpBuffer</i> may be different depending on the version of Windows.  On Windows XP, the "NETWORK SERVICE" string is returned. On Windows Vista, the “&lt;HOSTNAME&gt;$” string is returned.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/SysInfo/getting-system-information">Getting System Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GetUserName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetUserNameEx" />
    <seealso cref="LookupAccountName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System Information Functions</seealso>
  </member>
  <member name="Windows.GetVolumeNameForVolumeMountPoint">
    <summary>
      <para>Retrieves a volume <b>GUID</b> path for the volume that is associated with the specified volume mount point (
drive letter, volume <b>GUID</b> path, or mounted folder).</para>
    </summary>
    <param name="lpszVolumeMountPoint">
      <para>A pointer to a string that contains the path of a mounted folder (for example, "Y:\MountX") or a drive letter (for example, "X:"). The string must end with a trailing backslash ('').</para>
    </param>
    <param name="lpszVolumeName">
      <para>A pointer to a string that receives the volume <b>GUID</b> path. This path is of the form "\?\Volume{<i>GUID</i>}" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. If there is more than one volume <b>GUID</b> path for the volume, only the first one in the mount manager's cache is returned.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the output buffer, in <b>TCHARs</b>. A reasonable size for the buffer to accommodate the largest possible volume <b>GUID</b> path is 50 characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Use
<b>GetVolumeNameForVolumeMountPoint</b> to obtain a volume <b>GUID</b> path for use with functions such as <see cref="SetVolumeMountPoint" /> and <see cref="FindFirstVolumeMountPoint" /> that require a volume <b>GUID</b> path as an input parameter. For more information about volume <b>GUID</b> paths, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming A Volume</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <para>Mount points aren't supported by ReFS volumes.</para>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="GetVolumePathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetVolumeNameForVolumeMountPointA">
    <summary>
      <para>Retrieves a volume <b>GUID</b> path for the volume that is associated with the specified volume mount point (
drive letter, volume <b>GUID</b> path, or mounted folder).</para>
    </summary>
    <param name="lpszVolumeMountPoint">
      <para>A pointer to a string that contains the path of a mounted folder (for example, "Y:\MountX") or a drive letter (for example, "X:"). The string must end with a trailing backslash ('').</para>
    </param>
    <param name="lpszVolumeName">
      <para>A pointer to a string that receives the volume <b>GUID</b> path. This path is of the form "\?\Volume{<i>GUID</i>}" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. If there is more than one volume <b>GUID</b> path for the volume, only the first one in the mount manager's cache is returned.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the output buffer, in <b>TCHARs</b>. A reasonable size for the buffer to accommodate the largest possible volume <b>GUID</b> path is 50 characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Use
<b>GetVolumeNameForVolumeMountPoint</b> to obtain a volume <b>GUID</b> path for use with functions such as <see cref="SetVolumeMountPoint" /> and <see cref="FindFirstVolumeMountPoint" /> that require a volume <b>GUID</b> path as an input parameter. For more information about volume <b>GUID</b> paths, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming A Volume</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <para>Mount points aren't supported by ReFS volumes.</para>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="GetVolumePathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetVolumeNameForVolumeMountPointW">
    <summary>
      <para>Retrieves a volume <b>GUID</b> path for the volume that is associated with the specified volume mount point (
drive letter, volume <b>GUID</b> path, or mounted folder).</para>
    </summary>
    <param name="lpszVolumeMountPoint">
      <para>A pointer to a string that contains the path of a mounted folder (for example, "Y:\MountX") or a drive letter (for example, "X:"). The string must end with a trailing backslash ('').</para>
    </param>
    <param name="lpszVolumeName">
      <para>A pointer to a string that receives the volume <b>GUID</b> path. This path is of the form "\?\Volume{<i>GUID</i>}" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. If there is more than one volume <b>GUID</b> path for the volume, only the first one in the mount manager's cache is returned.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the output buffer, in <b>TCHARs</b>. A reasonable size for the buffer to accommodate the largest possible volume <b>GUID</b> path is 50 characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Use
<b>GetVolumeNameForVolumeMountPoint</b> to obtain a volume <b>GUID</b> path for use with functions such as <see cref="SetVolumeMountPoint" /> and <see cref="FindFirstVolumeMountPoint" /> that require a volume <b>GUID</b> path as an input parameter. For more information about volume <b>GUID</b> paths, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming A Volume</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <para>Mount points aren't supported by ReFS volumes.</para>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="GetVolumePathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso cref="SetVolumeMountPoint" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetVolumePathNamesForVolumeName">
    <summary>
      <para>Retrieves a list of drive letters and mounted folder paths for the specified volume.</para>
    </summary>
    <param name="lpszVolumeName">
      <para>A volume <b>GUID</b> path for the volume. A volume <b>GUID</b></para>
      <para>path is of the form
"\?\Volume{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}".</para>
    </param>
    <param name="lpszVolumePathNames">
      <para>A pointer to a buffer that receives the list of drive letters and mounted folder paths. The list is an
array of null-terminated strings terminated by an additional <b>NULL</b> character. If the
buffer is not large enough to hold the complete list, the buffer holds as much of the list as possible.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the <i>lpszVolumePathNames</i> buffer, in
<b>TCHARs</b>, including all <b>NULL</b> characters.</para>
    </param>
    <param name="lpcchReturnLength">
      <para>If the call is successful, this parameter is the number of <b>TCHARs</b> copied to
the <i>lpszVolumePathNames</i> buffer. Otherwise, this parameter is the size of the buffer
required to hold the complete list, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If the buffer is not large enough to
hold the complete list, the error code is <b>ERROR_MORE_DATA</b> and the
<i>lpcchReturnLength</i> parameter receives the required buffer size.</para>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetVolumePathNamesForVolumeNameA">
    <summary>
      <para>Retrieves a list of drive letters and mounted folder paths for the specified volume.</para>
    </summary>
    <param name="lpszVolumeName">
      <para>A volume <b>GUID</b> path for the volume. A volume <b>GUID</b></para>
      <para>path is of the form
"\?\Volume{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}".</para>
    </param>
    <param name="lpszVolumePathNames">
      <para>A pointer to a buffer that receives the list of drive letters and mounted folder paths. The list is an
array of null-terminated strings terminated by an additional <b>NULL</b> character. If the
buffer is not large enough to hold the complete list, the buffer holds as much of the list as possible.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the <i>lpszVolumePathNames</i> buffer, in
<b>TCHARs</b>, including all <b>NULL</b> characters.</para>
    </param>
    <param name="lpcchReturnLength">
      <para>If the call is successful, this parameter is the number of <b>TCHARs</b> copied to
the <i>lpszVolumePathNames</i> buffer. Otherwise, this parameter is the size of the buffer
required to hold the complete list, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If the buffer is not large enough to
hold the complete list, the error code is <b>ERROR_MORE_DATA</b> and the
<i>lpcchReturnLength</i> parameter receives the required buffer size.</para>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetVolumePathNamesForVolumeNameW">
    <summary>
      <para>Retrieves a list of drive letters and mounted folder paths for the specified volume.</para>
    </summary>
    <param name="lpszVolumeName">
      <para>A volume <b>GUID</b> path for the volume. A volume <b>GUID</b></para>
      <para>path is of the form
"\?\Volume{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}".</para>
    </param>
    <param name="lpszVolumePathNames">
      <para>A pointer to a buffer that receives the list of drive letters and mounted folder paths. The list is an
array of null-terminated strings terminated by an additional <b>NULL</b> character. If the
buffer is not large enough to hold the complete list, the buffer holds as much of the list as possible.</para>
    </param>
    <param name="cchBufferLength">
      <para>The length of the <i>lpszVolumePathNames</i> buffer, in
<b>TCHARs</b>, including all <b>NULL</b> characters.</para>
    </param>
    <param name="lpcchReturnLength">
      <para>If the call is successful, this parameter is the number of <b>TCHARs</b> copied to
the <i>lpszVolumePathNames</i> buffer. Otherwise, this parameter is the size of the buffer
required to hold the complete list, in <b>TCHARs</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. If the buffer is not large enough to
hold the complete list, the error code is <b>ERROR_MORE_DATA</b> and the
<i>lpcchReturnLength</i> parameter receives the required buffer size.</para>
    </returns>
    <remarks>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.GetXStateFeaturesMask">
    <summary>
      <para>Returns the mask of XState features set within a
<see cref="CONTEXT" /> structure.</para>
    </summary>
    <param name="Context">
      <para>A pointer to a <see cref="CONTEXT" /> structure that has been
initialized with <see cref="InitializeContext" />.</para>
    </param>
    <param name="FeatureMask">
      <para>A pointer to a variable that receives the mask of XState features which are present in the specified
<b>CONTEXT</b> structure.</para>
    </param>
    <returns>
      <para>This function returns <b>TRUE</b> if successful, otherwise
<b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The <b>GetXStateFeaturesMask</b> function returns
the mask of valid features in the specified context.  If a
<see cref="CONTEXT" /> is to be passed to
<see cref="GetThreadContext" /> or
<see cref="Wow64GetThreadContext" />, the application must
call <see cref="SetXStateFeaturesMask" /> to set which
features are to be retrieved.
<b>GetXStateFeaturesMask</b> should then be called on
the <b>CONTEXT</b> returned by
<b>GetThreadContext</b> or
<b>Wow64GetThreadContext</b> to determine which
feature areas contain valid data. If a particular feature bit is not set, the corresponding state is in a
processor-specific <b>INITIALIZED</b> state and the contents of the feature area retrieved by
<see cref="LocateXStateFeature" /> are undefined.</para>
      <para>The definition of XState features are processor vendor specific. Please refer to the relevant processor
reference manuals for additional information on a particular feature.</para>
      <para>
        <b>Note</b>  The value returned by
<b>GetXStateFeaturesMask</b> on a
<see cref="CONTEXT" /> after a context operation will always be a subset
of the mask specified in a call to
<see cref="SetXStateFeaturesMask" /> prior to the context
operation.</para>
      <para>
        <b>Windows 7 with SP1 and Windows Server 2008 R2 with SP1:  </b>The <a href="https://docs.microsoft.com//windows/desktop/Debug/avx-support-portal">AVX API</a> is first implemented on
Windows 7 with SP1 and Windows Server 2008 R2 with SP1 . Since there is no SDK for SP1, that means there are
no available headers and library files to work with. In this situation, a caller must declare the needed
functions from this documentation and get pointers to them using
<see cref="GetModuleHandle" /> on
"Kernel32.dll", followed by calls to
<see cref="GetProcAddress" />. See
<a href="https://docs.microsoft.com//windows/desktop/Debug/working-with-xstate-context">Working with XState Context</a> for
details.</para>
    </remarks>
    <seealso cref="CONTEXT" />
    <seealso cref="GetThreadContext" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/avx-support-portal">Intel AVX</seealso>
    <seealso cref="SetXStateFeaturesMask" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/working-with-xstate-context">Working with XState Context</seealso>
    <seealso cref="Wow64GetThreadContext" />
  </member>
  <member name="Windows.GlobalAddAtom">
    <summary>
      <para>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the string already exists in the global atom table, the atom for the existing string is returned and the atom's reference count is incremented.</para>
      <para>The string associated with the atom is not deleted from memory until its reference count is zero. For more information, see the <see cref="GlobalDeleteAtom" /> function.</para>
      <para>Global atoms are not deleted automatically when the application terminates. For every call to the <b>GlobalAddAtom</b> function, there must be a corresponding call to the <see cref="GlobalDeleteAtom" /> function.</para>
      <para>If the
<i>lpString</i> parameter has the form "#1234", <b>GlobalAddAtom</b> returns an integer atom whose value is the 16-bit representation of the decimal number specified in the string (0x04D2, in this example). If the decimal value specified is 0x0000 or is greater than or equal to 0xC000, the return value is zero, indicating an error. If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <para>If
<i>lpString</i> has any other form, <b>GlobalAddAtom</b> returns a string atom.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalAddAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GetAtomName" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="GlobalGetAtomName" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.GlobalAddAtomA">
    <summary>
      <para>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the string already exists in the global atom table, the atom for the existing string is returned and the atom's reference count is incremented.</para>
      <para>The string associated with the atom is not deleted from memory until its reference count is zero. For more information, see the <see cref="GlobalDeleteAtom" /> function.</para>
      <para>Global atoms are not deleted automatically when the application terminates. For every call to the <b>GlobalAddAtom</b> function, there must be a corresponding call to the <see cref="GlobalDeleteAtom" /> function.</para>
      <para>If the
<i>lpString</i> parameter has the form "#1234", <b>GlobalAddAtom</b> returns an integer atom whose value is the 16-bit representation of the decimal number specified in the string (0x04D2, in this example). If the decimal value specified is 0x0000 or is greater than or equal to 0xC000, the return value is zero, indicating an error. If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <para>If
<i>lpString</i> has any other form, <b>GlobalAddAtom</b> returns a string atom.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalAddAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GetAtomName" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="GlobalGetAtomName" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.GlobalAddAtomW">
    <summary>
      <para>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the string already exists in the global atom table, the atom for the existing string is returned and the atom's reference count is incremented.</para>
      <para>The string associated with the atom is not deleted from memory until its reference count is zero. For more information, see the <see cref="GlobalDeleteAtom" /> function.</para>
      <para>Global atoms are not deleted automatically when the application terminates. For every call to the <b>GlobalAddAtom</b> function, there must be a corresponding call to the <see cref="GlobalDeleteAtom" /> function.</para>
      <para>If the
<i>lpString</i> parameter has the form "#1234", <b>GlobalAddAtom</b> returns an integer atom whose value is the 16-bit representation of the decimal number specified in the string (0x04D2, in this example). If the decimal value specified is 0x0000 or is greater than or equal to 0xC000, the return value is zero, indicating an error. If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <para>If
<i>lpString</i> has any other form, <b>GlobalAddAtom</b> returns a string atom.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalAddAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GetAtomName" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="GlobalGetAtomName" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.GlobalAddAtomEx">
    <summary>
      <para>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</para>
    </summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <param name="Flags"></param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalAddAtomEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GlobalAddAtom" />
  </member>
  <member name="Windows.GlobalAddAtomExA">
    <summary>
      <para>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</para>
    </summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <param name="Flags"></param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalAddAtomEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GlobalAddAtom" />
  </member>
  <member name="Windows.GlobalAddAtomExW">
    <summary>
      <para>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</para>
    </summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <param name="Flags"></param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalAddAtomEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GlobalAddAtom" />
  </member>
  <member name="Windows.GlobalAddAtomEx">
    <summary>
      <para>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</para>
    </summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <param name="Flags"></param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalAddAtomEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GlobalAddAtom" />
  </member>
  <member name="Windows.GlobalAddAtomExA">
    <summary>
      <para>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</para>
    </summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <param name="Flags"></param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalAddAtomEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GlobalAddAtom" />
  </member>
  <member name="Windows.GlobalAddAtomExW">
    <summary>
      <para>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</para>
    </summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <param name="Flags"></param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalAddAtomEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GlobalAddAtom" />
  </member>
  <member name="Windows.GlobalAddAtom">
    <summary>
      <para>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the string already exists in the global atom table, the atom for the existing string is returned and the atom's reference count is incremented.</para>
      <para>The string associated with the atom is not deleted from memory until its reference count is zero. For more information, see the <see cref="GlobalDeleteAtom" /> function.</para>
      <para>Global atoms are not deleted automatically when the application terminates. For every call to the <b>GlobalAddAtom</b> function, there must be a corresponding call to the <see cref="GlobalDeleteAtom" /> function.</para>
      <para>If the
<i>lpString</i> parameter has the form "#1234", <b>GlobalAddAtom</b> returns an integer atom whose value is the 16-bit representation of the decimal number specified in the string (0x04D2, in this example). If the decimal value specified is 0x0000 or is greater than or equal to 0xC000, the return value is zero, indicating an error. If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <para>If
<i>lpString</i> has any other form, <b>GlobalAddAtom</b> returns a string atom.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalAddAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GetAtomName" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="GlobalGetAtomName" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.GlobalAddAtomA">
    <summary>
      <para>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the string already exists in the global atom table, the atom for the existing string is returned and the atom's reference count is incremented.</para>
      <para>The string associated with the atom is not deleted from memory until its reference count is zero. For more information, see the <see cref="GlobalDeleteAtom" /> function.</para>
      <para>Global atoms are not deleted automatically when the application terminates. For every call to the <b>GlobalAddAtom</b> function, there must be a corresponding call to the <see cref="GlobalDeleteAtom" /> function.</para>
      <para>If the
<i>lpString</i> parameter has the form "#1234", <b>GlobalAddAtom</b> returns an integer atom whose value is the 16-bit representation of the decimal number specified in the string (0x04D2, in this example). If the decimal value specified is 0x0000 or is greater than or equal to 0xC000, the return value is zero, indicating an error. If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <para>If
<i>lpString</i> has any other form, <b>GlobalAddAtom</b> returns a string atom.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalAddAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GetAtomName" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="GlobalGetAtomName" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.GlobalAddAtomW">
    <summary>
      <para>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the string already exists in the global atom table, the atom for the existing string is returned and the atom's reference count is incremented.</para>
      <para>The string associated with the atom is not deleted from memory until its reference count is zero. For more information, see the <see cref="GlobalDeleteAtom" /> function.</para>
      <para>Global atoms are not deleted automatically when the application terminates. For every call to the <b>GlobalAddAtom</b> function, there must be a corresponding call to the <see cref="GlobalDeleteAtom" /> function.</para>
      <para>If the
<i>lpString</i> parameter has the form "#1234", <b>GlobalAddAtom</b> returns an integer atom whose value is the 16-bit representation of the decimal number specified in the string (0x04D2, in this example). If the decimal value specified is 0x0000 or is greater than or equal to 0xC000, the return value is zero, indicating an error. If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <para>If
<i>lpString</i> has any other form, <b>GlobalAddAtom</b> returns a string atom.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalAddAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GetAtomName" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="GlobalGetAtomName" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.GlobalDeleteAtom">
    <summary>
      <para>Decrements the reference count of a global string atom. If the atom's reference count reaches zero, <b>GlobalDeleteAtom</b> removes the string associated with the atom from the global atom table.</para>
    </summary>
    <param name="nAtom">
      <para>Type: <b>ATOM</b></para>
      <para>The atom and character string to be deleted.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>The function always returns (<b>ATOM</b>) 0.</para>
      <para>To determine whether the function has failed, call <see cref="SetLastError" /> with <b>ERROR_SUCCESS</b> before calling <b>GlobalDeleteAtom</b>, then call <see cref="GetLastError" />. If the last error code is still <b>ERROR_SUCCESS</b>, <b>GlobalDeleteAtom</b> has succeeded.</para>
    </returns>
    <remarks>
      <para>A string atom's reference count specifies the number of times the string has been added to the atom table. The <see cref="GlobalAddAtom" /> function increments the reference count of a string that already exists in the global atom table each time it is called.</para>
      <para>Each call to <see cref="GlobalAddAtom" /> should have a corresponding call to <b>GlobalDeleteAtom</b>. Do not call <b>GlobalDeleteAtom</b> more times than you call <b>GlobalAddAtom</b>, or you may delete the atom while other clients are using it. Applications using Dynamic Data Exchange (DDE) should follow the rules on global atom management to prevent leaks and premature deletion.</para>
      <para>
        <b>GlobalDeleteAtom</b> has no effect on an integer atom (an atom whose value is in the range 0x0001 to 0xBFFF). The function always returns zero for an integer atom.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/dataxchg/using-dynamic-data-exchange">Initiating a Conversation</a>.</para>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.GlobalDiscard">
    <summary>
      <para>Discards the specified global memory block. The lock count of the memory object must be zero.
<b>Note</b>  The global functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a global function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</para>
    </summary>
    <param name="h">
      <para>A handle to the global memory object. This handle is returned by either the
<see cref="GlobalAlloc" /> or
<see cref="GlobalReAlloc" /> function.</para>
    </param>
    <remarks>
      <para>Although
<b>GlobalDiscard</b> discards the object's memory block, the handle to the object remains valid. The process can subsequently pass the handle to the
<see cref="GlobalReAlloc" /> function to allocate another global memory block identified by the same handle.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</seealso>
    <seealso cref="GlobalAlloc" />
    <seealso cref="GlobalReAlloc" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
  </member>
  <member name="Windows.GlobalFindAtom">
    <summary>
      <para>Searches the global atom table for the specified character string and retrieves the global atom associated with that string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the global atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Even though the system preserves the case of a string in an atom table as it was originally entered, the search performed by <b>GlobalFindAtom</b> is not case sensitive.</para>
      <para>If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalFindAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GetAtomName" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalGetAtomName" />
  </member>
  <member name="Windows.GlobalFindAtomA">
    <summary>
      <para>Searches the global atom table for the specified character string and retrieves the global atom associated with that string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the global atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Even though the system preserves the case of a string in an atom table as it was originally entered, the search performed by <b>GlobalFindAtom</b> is not case sensitive.</para>
      <para>If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalFindAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GetAtomName" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalGetAtomName" />
  </member>
  <member name="Windows.GlobalFindAtomW">
    <summary>
      <para>Searches the global atom table for the specified character string and retrieves the global atom associated with that string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the global atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Even though the system preserves the case of a string in an atom table as it was originally entered, the search performed by <b>GlobalFindAtom</b> is not case sensitive.</para>
      <para>If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalFindAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GetAtomName" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalGetAtomName" />
  </member>
  <member name="Windows.GlobalFindAtom">
    <summary>
      <para>Searches the global atom table for the specified character string and retrieves the global atom associated with that string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the global atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Even though the system preserves the case of a string in an atom table as it was originally entered, the search performed by <b>GlobalFindAtom</b> is not case sensitive.</para>
      <para>If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalFindAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GetAtomName" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalGetAtomName" />
  </member>
  <member name="Windows.GlobalFindAtomA">
    <summary>
      <para>Searches the global atom table for the specified character string and retrieves the global atom associated with that string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the global atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Even though the system preserves the case of a string in an atom table as it was originally entered, the search performed by <b>GlobalFindAtom</b> is not case sensitive.</para>
      <para>If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalFindAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GetAtomName" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalGetAtomName" />
  </member>
  <member name="Windows.GlobalFindAtomW">
    <summary>
      <para>Searches the global atom table for the specified character string and retrieves the global atom associated with that string.</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>Type: <b>ATOM</b></para>
      <para>If the function succeeds, the return value is the global atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Even though the system preserves the case of a string in an atom table as it was originally entered, the search performed by <b>GlobalFindAtom</b> is not case sensitive.</para>
      <para>If
<i>lpString</i> was created by the <see cref="MAKEINTATOM" /> macro, the low-order word must be in the range 0x0001 through 0xBFFF. If the low-order word is not in this range, the function fails.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalFindAtom as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GetAtomName" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalGetAtomName" />
  </member>
  <member name="Windows.GlobalFlags">
    <summary>
      <para>Retrieves information about the specified global memory object.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. New applications should use the  <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a>. For more information, see Remarks.</para>
    </summary>
    <param name="hMem">
      <para>A handle to the global memory object. This handle is returned by either the
<see cref="GlobalAlloc" /> or
<see cref="GlobalReAlloc" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the allocation values and the lock count for the memory object.</para>
      <para>If the function fails, the return value is <b>GMEM_INVALID_HANDLE</b>, indicating that the global handle is not valid. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The low-order byte of the low-order word of the return value contains the lock count of the object. To retrieve the lock count from the return value, use the <b>GMEM_LOCKCOUNT</b> mask with the bitwise AND (&amp;) operator. The lock count of memory objects allocated with <b>GMEM_FIXED</b> is always zero.</para>
      <para>The high-order byte of the low-order word of the return value indicates the allocation values of the memory object. It can be zero or <b>GMEM_DISCARDED</b>.</para>
      <para>The global functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a global function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</seealso>
    <seealso cref="GlobalAlloc" />
    <seealso cref="GlobalDiscard" />
    <seealso cref="GlobalReAlloc" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
  </member>
  <member name="Windows.GlobalFree">
    <summary>
      <para>Frees the specified global memory object and invalidates its handle.
<b>Note</b>  The global functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a global function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</para>
    </summary>
    <param name="hMem">
      <para>A handle to the global memory object. This handle is returned by either the
<see cref="GlobalAlloc" /> or
<see cref="GlobalReAlloc" /> function. It is not safe to free memory allocated with <see cref="LocalAlloc" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>NULL</b>.</para>
      <para>If the function fails, the return value is equal to a handle to the global memory object. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the process examines or modifies the memory after it has been freed, heap corruption may occur or an access violation exception (EXCEPTION_ACCESS_VIOLATION) may be generated.</para>
      <para>The
<b>GlobalFree</b> function will free a locked memory object. A locked memory object has a lock count greater than zero. The
<see cref="GlobalLock" /> function locks a global memory object and increments the lock count by one. The
<see cref="GlobalUnlock" /> function unlocks it and decrements the lock count by one. To get the lock count of a global memory object, use the
<see cref="GlobalFlags" /> function.</para>
      <para>If an application is running under a debug version of the system,
<b>GlobalFree</b> will issue a message that tells you that a locked object is being freed. If you are debugging the application,
<b>GlobalFree</b> will enter a breakpoint just before freeing a locked object. This allows you to verify the intended behavior, then continue execution.</para>
      <h4>Examples</h4>
      <para>For an example, see
<see cref="GlobalAlloc" />.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</seealso>
    <seealso cref="GlobalAlloc" />
    <seealso cref="GlobalFlags" />
    <seealso cref="GlobalLock" />
    <seealso cref="GlobalReAlloc" />
    <seealso cref="GlobalUnlock" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
  </member>
  <member name="Windows.GlobalGetAtomName">
    <summary>
      <para>Retrieves a copy of the character string associated with the specified global atom.</para>
    </summary>
    <param name="nAtom">
      <para>Type: <b>ATOM</b></para>
      <para>The global atom associated with the character string to be retrieved.</para>
    </param>
    <param name="lpBuffer">
      <para>Type: <b>LPTSTR</b></para>
      <para>The buffer for the character string.</para>
    </param>
    <param name="nSize">
      <para>Type: <b>int</b></para>
      <para>The size, in
characters, of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in
characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The string returned for an integer atom (an atom whose value is in the range 0x0001 to 0xBFFF) is a null-terminated string in which the first character is a pound sign (#) and the remaining characters represent the unsigned integer atom value.</para>
      <h3>Security Considerations</h3>
      <para>Using this function incorrectly might compromise the security of your program. Incorrect use of this function includes not correctly specifying the size of the <i>lpBuffer</i> parameter. Also, note that a global atom is accessible by anyone; thus, privacy and the integrity of its contents is not assured.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalGetAtomName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.GlobalGetAtomNameA">
    <summary>
      <para>Retrieves a copy of the character string associated with the specified global atom.</para>
    </summary>
    <param name="nAtom">
      <para>Type: <b>ATOM</b></para>
      <para>The global atom associated with the character string to be retrieved.</para>
    </param>
    <param name="lpBuffer">
      <para>Type: <b>LPTSTR</b></para>
      <para>The buffer for the character string.</para>
    </param>
    <param name="nSize">
      <para>Type: <b>int</b></para>
      <para>The size, in
characters, of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in
characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The string returned for an integer atom (an atom whose value is in the range 0x0001 to 0xBFFF) is a null-terminated string in which the first character is a pound sign (#) and the remaining characters represent the unsigned integer atom value.</para>
      <h3>Security Considerations</h3>
      <para>Using this function incorrectly might compromise the security of your program. Incorrect use of this function includes not correctly specifying the size of the <i>lpBuffer</i> parameter. Also, note that a global atom is accessible by anyone; thus, privacy and the integrity of its contents is not assured.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalGetAtomName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.GlobalGetAtomNameW">
    <summary>
      <para>Retrieves a copy of the character string associated with the specified global atom.</para>
    </summary>
    <param name="nAtom">
      <para>Type: <b>ATOM</b></para>
      <para>The global atom associated with the character string to be retrieved.</para>
    </param>
    <param name="lpBuffer">
      <para>Type: <b>LPTSTR</b></para>
      <para>The buffer for the character string.</para>
    </param>
    <param name="nSize">
      <para>Type: <b>int</b></para>
      <para>The size, in
characters, of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in
characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The string returned for an integer atom (an atom whose value is in the range 0x0001 to 0xBFFF) is a null-terminated string in which the first character is a pound sign (#) and the remaining characters represent the unsigned integer atom value.</para>
      <h3>Security Considerations</h3>
      <para>Using this function incorrectly might compromise the security of your program. Incorrect use of this function includes not correctly specifying the size of the <i>lpBuffer</i> parameter. Also, note that a global atom is accessible by anyone; thus, privacy and the integrity of its contents is not assured.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalGetAtomName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.GlobalGetAtomName">
    <summary>
      <para>Retrieves a copy of the character string associated with the specified global atom.</para>
    </summary>
    <param name="nAtom">
      <para>Type: <b>ATOM</b></para>
      <para>The global atom associated with the character string to be retrieved.</para>
    </param>
    <param name="lpBuffer">
      <para>Type: <b>LPTSTR</b></para>
      <para>The buffer for the character string.</para>
    </param>
    <param name="nSize">
      <para>Type: <b>int</b></para>
      <para>The size, in
characters, of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in
characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The string returned for an integer atom (an atom whose value is in the range 0x0001 to 0xBFFF) is a null-terminated string in which the first character is a pound sign (#) and the remaining characters represent the unsigned integer atom value.</para>
      <h3>Security Considerations</h3>
      <para>Using this function incorrectly might compromise the security of your program. Incorrect use of this function includes not correctly specifying the size of the <i>lpBuffer</i> parameter. Also, note that a global atom is accessible by anyone; thus, privacy and the integrity of its contents is not assured.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalGetAtomName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.GlobalGetAtomNameA">
    <summary>
      <para>Retrieves a copy of the character string associated with the specified global atom.</para>
    </summary>
    <param name="nAtom">
      <para>Type: <b>ATOM</b></para>
      <para>The global atom associated with the character string to be retrieved.</para>
    </param>
    <param name="lpBuffer">
      <para>Type: <b>LPTSTR</b></para>
      <para>The buffer for the character string.</para>
    </param>
    <param name="nSize">
      <para>Type: <b>int</b></para>
      <para>The size, in
characters, of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in
characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The string returned for an integer atom (an atom whose value is in the range 0x0001 to 0xBFFF) is a null-terminated string in which the first character is a pound sign (#) and the remaining characters represent the unsigned integer atom value.</para>
      <h3>Security Considerations</h3>
      <para>Using this function incorrectly might compromise the security of your program. Incorrect use of this function includes not correctly specifying the size of the <i>lpBuffer</i> parameter. Also, note that a global atom is accessible by anyone; thus, privacy and the integrity of its contents is not assured.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalGetAtomName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.GlobalGetAtomNameW">
    <summary>
      <para>Retrieves a copy of the character string associated with the specified global atom.</para>
    </summary>
    <param name="nAtom">
      <para>Type: <b>ATOM</b></para>
      <para>The global atom associated with the character string to be retrieved.</para>
    </param>
    <param name="lpBuffer">
      <para>Type: <b>LPTSTR</b></para>
      <para>The buffer for the character string.</para>
    </param>
    <param name="nSize">
      <para>Type: <b>int</b></para>
      <para>The size, in
characters, of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in
characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The string returned for an integer atom (an atom whose value is in the range 0x0001 to 0xBFFF) is a null-terminated string in which the first character is a pound sign (#) and the remaining characters represent the unsigned integer atom value.</para>
      <h3>Security Considerations</h3>
      <para>Using this function incorrectly might compromise the security of your program. Incorrect use of this function includes not correctly specifying the size of the <i>lpBuffer</i> parameter. Also, note that a global atom is accessible by anyone; thus, privacy and the integrity of its contents is not assured.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines GlobalGetAtomName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="MAKEINTATOM" />
  </member>
  <member name="Windows.GlobalHandle">
    <summary>
      <para>Retrieves the handle associated with the specified pointer to a global memory block.
<b>Note</b>  The global functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a global function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</para>
    </summary>
    <param name="pMem">
      <para>A pointer to the first byte of the global memory block. This pointer is returned by the
<see cref="GlobalLock" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the specified global memory object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When the
<see cref="GlobalAlloc" /> function allocates a memory object with <b>GMEM_MOVEABLE</b>, it returns a handle to the object. The
<see cref="GlobalLock" /> function converts this handle into a pointer to the memory block, and
<b>GlobalHandle</b> converts the pointer back into a handle.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</seealso>
    <seealso cref="GlobalAlloc" />
    <seealso cref="GlobalLock" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
  </member>
  <member name="Windows.GlobalLock">
    <summary>
      <para>Locks a global memory object and returns a pointer to the first byte of the object's memory block.
<b>Note</b>  The global functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a global function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</para>
    </summary>
    <param name="hMem">
      <para>A handle to the global memory object. This handle is returned by either the
<see cref="GlobalAlloc" /> or
<see cref="GlobalReAlloc" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the first byte of the memory block.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The internal data structures for each memory object include a lock count that is initially zero. For movable memory objects,
<b>GlobalLock</b> increments the count by one, and the
<see cref="GlobalUnlock" /> function decrements the count by one. Each successful call that a process makes to
<b>GlobalLock</b> for an object must be matched by a corresponding call
to <b>GlobalUnlock</b>. Locked memory will not be moved or discarded, unless the memory object is reallocated by using the
<see cref="GlobalReAlloc" /> function. The memory block of a locked memory object remains locked until its lock count is decremented to zero, at which time it can be moved or discarded.</para>
      <para>Memory objects allocated with <b>GMEM_FIXED</b> always have a lock count of zero. For these objects, the value of the returned pointer is equal to the value of the specified handle.</para>
      <para>If the specified memory block has been discarded or if the memory block has a zero-byte size, this function returns <b>NULL</b>.</para>
      <para>Discarded objects always have a lock count of zero.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</seealso>
    <seealso cref="GlobalAlloc" />
    <seealso cref="GlobalReAlloc" />
    <seealso cref="GlobalUnlock" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
  </member>
  <member name="Windows.GlobalReAlloc">
    <summary>
      <para>Changes the size or attributes of a specified global memory object. The size can increase or decrease.
<b>Note</b>  The global functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a global function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</para>
    </summary>
    <param name="hMem">
      <para>A handle to the global memory object to be reallocated. This handle is returned by either the
<see cref="GlobalAlloc" /> or
<b>GlobalReAlloc</b> function.</para>
    </param>
    <param name="dwBytes">
      <para>The new size of the memory block, in bytes. If <i>uFlags</i> specifies <b>GMEM_MODIFY</b>, this parameter is ignored.</para>
    </param>
    <param name="uFlags">
      <para>The reallocation options. If <b>GMEM_MODIFY</b> is specified, the function modifies the attributes of the memory object only (the <i>dwBytes</i> parameter is ignored.) Otherwise, the function reallocates the memory object.</para>
      <para>You can optionally combine <b>GMEM_MODIFY</b> with the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>GMEM_MOVEABLE</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates movable memory.</para>
            <para>If the memory is a locked <b>GMEM_MOVEABLE</b> memory block or a <b>GMEM_FIXED</b> memory block and this flag is not specified, the memory can only be reallocated in place.</para>
          </description>
        </item>
      </list>
      <para>If this parameter does not specify <b>GMEM_MODIFY</b>, you can use the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>GMEM_ZEROINIT</b>
                </description>
              </item>
              <item>
                <description>0x0040</description>
              </item>
            </list>
          </description>
          <description>
            <para>Causes the additional memory contents to be initialized to zero if the memory object is growing in size.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the reallocated memory object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If
<b>GlobalReAlloc</b> reallocates a movable object, the return value is a handle to the memory object. To convert the handle to a pointer, use the
<see cref="GlobalLock" /> function.</para>
      <para>If
<b>GlobalReAlloc</b> reallocates a fixed object, the value of the handle returned is the address of the first byte of the memory block. To access the memory, a process can simply cast the return value to a pointer.</para>
      <para>If
<b>GlobalReAlloc</b> fails, the original memory is not freed, and the original handle and pointer are still valid.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</seealso>
    <seealso cref="GlobalAlloc" />
    <seealso cref="GlobalDiscard" />
    <seealso cref="GlobalLock" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
  </member>
  <member name="Windows.GlobalSize">
    <summary>
      <para>Retrieves the current size of the specified global memory object, in bytes.
<b>Note</b>  The global functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a global function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</para>
    </summary>
    <param name="hMem">
      <para>A handle to the global memory object. This handle is returned by either the
<see cref="GlobalAlloc" /> or
<see cref="GlobalReAlloc" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the size of the specified global memory object, in bytes.</para>
      <para>If the specified handle is not valid or if the object has been discarded, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The size of a memory block may be larger than the size requested when the memory was allocated.</para>
      <para>To verify that the specified object's memory block has not been discarded, use the
<see cref="GlobalFlags" /> function before calling
<b>GlobalSize</b>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</seealso>
    <seealso cref="GlobalAlloc" />
    <seealso cref="GlobalFlags" />
    <seealso cref="GlobalReAlloc" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
  </member>
  <member name="Windows.GlobalUnlock">
    <summary>
      <para>Decrements the lock count associated with a memory object that was allocated with <b>GMEM_MOVEABLE</b>. This function has no effect on memory objects allocated with <b>GMEM_FIXED</b>.
<b>Note</b>  The global functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a global function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</para>
    </summary>
    <param name="hMem">
      <para>A handle to the global memory object. This handle is returned by either the
<see cref="GlobalAlloc" /> or
<see cref="GlobalReAlloc" /> function.</para>
    </param>
    <returns>
      <para>If the memory object is still locked after decrementing the lock count, the return value is a nonzero value. If the memory object is unlocked after decrementing the lock count, the function returns zero and <see cref="GetLastError" /> returns <b>NO_ERROR</b>.</para>
      <para>If the function fails, the return value is zero and
<see cref="GetLastError" /> returns a value other than <b>NO_ERROR</b>.</para>
    </returns>
    <remarks>
      <para>The internal data structures for each memory object include a lock count that is initially zero. For movable memory objects, the
<see cref="GlobalLock" /> function increments the count by one, and
<b>GlobalUnlock</b> decrements the count by one. For each call that a process makes to
<b>GlobalLock</b> for an object, it must eventually call
<b>GlobalUnlock</b>. Locked memory will not be moved or discarded, unless the memory object is reallocated by using the
<see cref="GlobalReAlloc" /> function. The memory block of a locked memory object remains locked until its lock count is decremented to zero, at which time it can be moved or discarded.</para>
      <para>Memory objects allocated with <b>GMEM_FIXED</b> always have a lock count of zero. If the specified memory block is fixed memory, this function returns <b>TRUE</b>.</para>
      <para>If the memory object is already unlocked,
<b>GlobalUnlock</b> returns <b>FALSE</b> and
<see cref="GetLastError" /> reports <b>ERROR_NOT_LOCKED</b>.</para>
      <para>A process should not rely on the return value to determine the number of times it must subsequently call
<b>GlobalUnlock</b> for a memory object.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</seealso>
    <seealso cref="GlobalAlloc" />
    <seealso cref="GlobalLock" />
    <seealso cref="GlobalReAlloc" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
  </member>
  <member name="Windows.HasOverlappedIoCompleted">
    <summary>
      <para>Provides a high performance test operation that can be used to poll for the completion of an outstanding I/O operation.</para>
    </summary>
    <param name="lpOverlapped">
      <para>A pointer to an
<see cref="OVERLAPPED" /> structure that was specified when the overlapped I/O operation was started.</para>
    </param>
    <remarks>
      <para>Do not call this macro unless the call to
<see cref="GetLastError" /> returns <b>ERROR_IO_PENDING</b>, indicating that the overlapped I/O has started.</para>
      <para>To cancel all pending asynchronous I/O operations, use the
<a href="https://docs.microsoft.com//windows/desktop/FileIO/cancelio">CancelIo</a> function. The <b>CancelIo</b> function only cancels operations issued by the calling thread for the specified file handle. I/O operations that are canceled complete with the error <b>ERROR_OPERATION_ABORTED</b>.</para>
      <para>To get more details about a completed I/O operation, call the
<see cref="GetOverlappedResult" /> or
<see cref="GetQueuedCompletionStatus" /> function.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/cancelio">CancelIo</seealso>
    <seealso cref="ConnectNamedPipe" />
    <seealso cref="OVERLAPPED" />
    <seealso cref="ReadFile" />
    <seealso cref="TransactNamedPipe" />
    <seealso cref="WaitCommEvent" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.InitAtomTable">
    <summary>
      <para>Initializes the local atom table and sets the number of hash buckets to the specified size.</para>
    </summary>
    <param name="nSize">
      <para>Type: <b>DWORD</b></para>
      <para>The number of hash buckets to use for the atom table. If this parameter is zero, the default number of hash buckets are created.</para>
      <para>To achieve better performance, specify a prime number in
<i>nSize</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
    <remarks>
      <para>An application need not use this function to use a local atom table. The default number of hash buckets used is 37. If an application does use <b>InitAtomTable</b>, however, it should call the function before any other atom-management function.</para>
      <para>If an application uses a large number of local atoms, it can reduce the time required to add an atom to the local atom table or to find an atom in the table by increasing the size of the table. However, this increases the amount of memory required to maintain the table.</para>
      <para>The number of buckets in the global atom table cannot be changed. If the atom table has already been initialized, either explicitly by a prior call to <b>InitAtomTable</b>, or implicitly by the use of any atom-management function, <b>InitAtomTable</b> returns success without changing the number of hash buckets.</para>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="FindAtom" />
    <seealso cref="GetAtomName" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalFindAtom" />
    <seealso cref="GlobalGetAtomName" />
  </member>
  <member name="Windows.InitializeContext">
    <summary>
      <para>Initializes a <see cref="CONTEXT" /> structure inside a buffer
with the necessary size and alignment.</para>
    </summary>
    <param name="Buffer">
      <para>A pointer to a buffer within which to initialize a
<see cref="CONTEXT" /> structure. This parameter can be
<b>NULL</b> to determine the buffer size required to hold a context record with the
specified <i>ContextFlags</i>.</para>
    </param>
    <param name="ContextFlags">
      <para>A value indicating which portions of the <i>Context</i> structure should be initialized.
This parameter influences the size of the initialized <i>Context</i> structure.</para>
      <para>
        <b>Note</b>  <b>CONTEXT_XSTATE</b> is not part of <b>CONTEXT_FULL</b> or
<b>CONTEXT_ALL</b>.  It must be specified separately if an XState context is desired.</para>
    </param>
    <param name="Context">
      <para>A pointer to a variable which receives the address of the initialized
<see cref="CONTEXT" /> structure within the
<i>Buffer</i>.</para>
      <para>
        <b>Note</b>  Due to alignment requirements of <see cref="CONTEXT" /> structures,
the value returned in <i>Context</i> may not be at the beginning of the supplied
buffer.</para>
    </param>
    <param name="ContextLength">
      <para>On input, specifies the length of the buffer pointed to by <i>Buffer</i>, in bytes. If
the buffer is not large enough to contain the specified portions of the
<see cref="CONTEXT" />, the function fails,
<see cref="GetLastError" /> returns
<b>ERROR_INSUFFICIENT_BUFFER</b>, and <i>ContextLength</i> is set to the
required size of the buffer.  If the function fails with an error other than
<b>ERROR_INSUFFICIENT_BUFFER</b>, the contents of
<i>ContextLength</i> are undefined.</para>
    </param>
    <returns>
      <para>This function returns <b>TRUE</b> if successful, otherwise
<b>FALSE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <i>InitializeContext</i> can be used to initialize a
<see cref="CONTEXT" /> structure within a buffer with the required size and
alignment characteristics.  This routine is required if the <b>CONTEXT_XSTATE</b><i>ContextFlag</i> is specified since the required context size and alignment may change
depending on which processor features are enabled on the system.</para>
      <para>First, call this function with the
<i>ContextFlags</i> parameter set to the maximum number of features you will be using and the
<i>Buffer</i> parameter to <b>NULL</b>. The function returns the required
buffer size in bytes in the <i>ContextLength</i> parameter. Allocate enough space for the data
in the <i>Buffer</i> and call the function again to initialize the
<i>Context</i>. Upon successful completion of this routine, the
<i>ContextFlags</i> member of the <i>Context</i> structure is initialized,
but the remaining contents of the structure are undefined. Some bits specified in the
<i>ContextFlags</i> parameter may not be set in
<i>Context</i>-&gt;<i>ContextFlags</i> if they are not supported by the
system. Applications may subsequently remove, but must never add, bits from the
<i>ContextFlags</i> member of
<see cref="CONTEXT" />.</para>
      <para>
        <b>Windows 7 with SP1 and Windows Server 2008 R2 with SP1:  </b>The <a href="https://docs.microsoft.com//windows/desktop/Debug/avx-support-portal">AVX API</a> is first implemented on
Windows 7 with SP1 and Windows Server 2008 R2 with SP1 . Since there is no SDK for SP1, that means there are
no available headers and library files to work with. In this situation, a caller must declare the needed
functions from this documentation and get pointers to them using
<see cref="GetModuleHandle" /> on
"Kernel32.dll", followed by calls to
<see cref="GetProcAddress" />. See
<a href="https://docs.microsoft.com//windows/desktop/Debug/working-with-xstate-context">Working with XState Context</a> for
details.</para>
    </remarks>
    <seealso cref="CONTEXT" />
    <seealso cref="CopyContext" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/avx-support-portal">Intel AVX</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/working-with-xstate-context">Working with XState Context</seealso>
  </member>
  <member name="Windows.InitializeContext2">
    <summary>
      <para>Initializes a <see cref="CONTEXT" /> structure inside a buffer
with the necessary size and alignment, with the option to specify an XSTATE compaction mask.</para>
    </summary>
    <param name="Buffer">
      <para>A pointer to a buffer within which to initialize a
<see cref="CONTEXT" /> structure. This parameter can be
<b>NULL</b> to determine the buffer size required to hold a context record with the
specified <i>ContextFlags</i>.</para>
    </param>
    <param name="ContextFlags">
      <para>A value indicating which portions of the <i>Context</i> structure should be initialized.
This parameter influences the size of the initialized <i>Context</i> structure.</para>
      <para>
        <b>Note</b>  <b>CONTEXT_XSTATE</b> is not part of <b>CONTEXT_FULL</b> or
<b>CONTEXT_ALL</b>.  It must be specified separately if an XState context is desired.</para>
    </param>
    <param name="Context">
      <para>A pointer to a variable which receives the address of the initialized
<see cref="CONTEXT" /> structure within the
<i>Buffer</i>.</para>
      <para>
        <b>Note</b>  Due to alignment requirements of <see cref="CONTEXT" /> structures,
the value returned in <i>Context</i> may not be at the beginning of the supplied
buffer.</para>
    </param>
    <param name="ContextLength">
      <para>On input, specifies the length of the buffer pointed to by <i>Buffer</i>, in bytes. If
the buffer is not large enough to contain the specified portions of the
<see cref="CONTEXT" />, the function fails,
<see cref="GetLastError" /> returns
<b>ERROR_INSUFFICIENT_BUFFER</b>, and <i>ContextLength</i> is set to the
required size of the buffer.  If the function fails with an error other than
<b>ERROR_INSUFFICIENT_BUFFER</b>, the contents of
<i>ContextLength</i> are undefined.</para>
    </param>
    <param name="XStateCompactionMask">
      <para>Supplies the XState compaction mask to use when allocating the <i>Context</i> structure.
This parameter is only used when <b>CONTEXT_XSTATE</b> is supplied to <i>ContextFlags</i> and the system has XState enabled in compaction mode.</para>
    </param>
    <returns>
      <para>This function returns <b>TRUE</b> if successful, otherwise
<b>FALSE</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>
        <i>InitializeContext</i> can be used to initialize a
<see cref="CONTEXT" /> structure within a buffer with the required size and
alignment characteristics.  This routine is required if the <b>CONTEXT_XSTATE</b><i>ContextFlag</i> is specified since the required context size and alignment may change
depending on which processor features are enabled on the system.</para>
      <para>First, call this function with the
<i>ContextFlags</i> parameter set to the maximum number of features you will be using and the
<i>Buffer</i> parameter to <b>NULL</b>. The function returns the required
buffer size in bytes in the <i>ContextLength</i> parameter. Allocate enough space for the data
in the <i>Buffer</i> and call the function again to initialize the
<i>Context</i>. Upon successful completion of this routine, the
<i>ContextFlags</i> member of the <i>Context</i> structure is initialized,
but the remaining contents of the structure are undefined. Some bits specified in the
<i>ContextFlags</i> parameter may not be set in
<i>Context</i>-&gt;<i>ContextFlags</i> if they are not supported by the
system. Applications may subsequently remove, but must never add, bits from the
<i>ContextFlags</i> member of
<see cref="CONTEXT" />.</para>
      <para>
        <b>Windows 7 with SP1 and Windows Server 2008 R2 with SP1:  </b>The <a href="https://docs.microsoft.com//windows/desktop/Debug/avx-support-portal">AVX API</a> is first implemented on
Windows 7 with SP1 and Windows Server 2008 R2 with SP1 . Since there is no SDK for SP1, that means there are
no available headers and library files to work with. In this situation, a caller must declare the needed
functions from this documentation and get pointers to them using
<see cref="GetModuleHandle" /> on
"Kernel32.dll", followed by calls to
<see cref="GetProcAddress" />. See
<a href="https://docs.microsoft.com//windows/desktop/Debug/working-with-xstate-context">Working with XState Context</a> for
details.</para>
      <para>When XState is enabled in compaction mode, specifying an <i>XStateCompactionMask</i> that contains only a subset of the enabled XState components can decrease the buffer size required to store the <i>Context</i>.
This is particularly useful if the system has many XState components enabled, but the <i>Context</i> will only be used to affect a small number of XState components.
The full set of enabled XState components can be obtained by calling <see cref="GetEnabledXStateFeatures" />.
This function copies the specified XState compaction mask into the relevant location in the XState header.</para>
    </remarks>
    <seealso cref="CONTEXT" />
    <seealso cref="CopyContext" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/avx-support-portal">Intel AVX</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/working-with-xstate-context">Working with XState Context</seealso>
  </member>
  <member name="Windows.InitializeThreadpoolEnvironment">
    <summary>
      <para>Initializes a callback environment.</para>
    </summary>
    <param name="pcbe">
      <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines a callback environment.</para>
    </param>
    <remarks>
      <para>By default, a callback executes in the default thread pool for the process. No cleanup group is associated with the callback environment, the caller is responsible for keeping the callback's DLL loaded while there are outstanding callbacks, and the callback is expected to run in a reasonable amount of time for the application.</para>
      <para>Create a callback environment if you plan to call one of the following functions to modify the environment:</para>
      <list type="bullet">
        <item>
          <description>
            <see cref="SetThreadpoolCallbackCleanupGroup" />
          </description>
        </item>
        <item>
          <description>
            <see cref="SetThreadpoolCallbackLibrary" />
          </description>
        </item>
        <item>
          <description>
            <see cref="SetThreadpoolCallbackPool" />
          </description>
        </item>
        <item>
          <description>
            <see cref="SetThreadpoolCallbackPriority" />
          </description>
        </item>
        <item>
          <description>
            <see cref="SetThreadpoolCallbackRunsLong" />
          </description>
        </item>
      </list>
      <para>To use the default callback environment, set the optional callback environment parameter to NULL when calling one of the following functions:</para>
      <list type="bullet">
        <item>
          <description>
            <see cref="CreateThreadpoolIo" />
          </description>
        </item>
        <item>
          <description>
            <see cref="CreateThreadpoolTimer" />
          </description>
        </item>
        <item>
          <description>
            <see cref="CreateThreadpoolWait" />
          </description>
        </item>
        <item>
          <description>
            <see cref="CreateThreadpoolWork" />
          </description>
        </item>
        <item>
          <description>
            <see cref="TrySubmitThreadpoolCallback" />
          </description>
        </item>
      </list>
      <para>The <b>InitializeThreadpoolEnvironment</b> function is implemented as an inline function.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/using-the-thread-pool-functions">Using the Thread Pool Functions</a>.</para>
    </remarks>
    <seealso cref="DestroyThreadpoolEnvironment" />
    <seealso cref="SetThreadpoolCallbackCleanupGroup" />
    <seealso cref="SetThreadpoolCallbackLibrary" />
    <seealso cref="SetThreadpoolCallbackPool" />
    <seealso cref="SetThreadpoolCallbackRunsLong" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-pools">Thread Pools</seealso>
  </member>
  <member name="Windows.InterlockedExchangeSubtract">
    <summary>
      <para>Performs an atomic subtraction of two values.</para>
    </summary>
    <param name="Addend">
      <para>A pointer to a variable. The value of this variable is replaced with the result of the operation.</para>
    </param>
    <param name="Value">
      <para>The value to be subtracted from the variable pointed to by the <i>Addend</i> parameter.</para>
    </param>
    <returns>
      <para>The function returns the initial value of  the <i>Addend</i> parameter.</para>
    </returns>
    <remarks>
      <para>This function  generates a full memory barrier (or fence) to ensure that memory operations are completed in order.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/interlocked-variable-access">Interlocked Variable Access</seealso>
    <seealso cref="InterlockedCompareExchange" />
    <seealso cref="InterlockedExchange" />
    <seealso cref="InterlockedExchangeAdd" />
    <seealso cref="InterlockedExchangePointer" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.IsBadCodePtr">
    <summary>
      <para>Determines whether the calling process has read access to the memory at the specified address.
<b>Important</b>  This function is obsolete and should not be used. Despite its name, it does not guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks on this page.</para>
    </summary>
    <param name="lpfn">
      <para>A pointer to a memory address.</para>
    </param>
    <returns>
      <para>If the calling process has read access to the specified memory, the return value is zero.</para>
      <para>If the calling process does not have read access to the specified memory, the return value is nonzero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the application is compiled as a debugging version, and the process does not have read access to  the specified memory location, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value. This behavior is by design, as a debugging aid.</para>
    </returns>
    <remarks>
      <para>In a preemptive multitasking environment, it is possible for some other thread to change the process's access to the memory being tested. Even when the function indicates that the process has read access to the specified memory, you should use structured exception handling when attempting to access the memory. Use of structured exception handling enables the system to notify the process if an access violation exception occurs, giving the process an opportunity to handle the exception.</para>
    </remarks>
    <seealso cref="IsBadReadPtr" />
    <seealso cref="IsBadStringPtr" />
    <seealso cref="IsBadWritePtr" />
  </member>
  <member name="Windows.IsBadReadPtr">
    <summary>
      <para>Verifies that the calling process has read access to the specified range of memory.
<b>Important</b>  This function is obsolete and should not be used. Despite its name, it does not guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks on this page.</para>
    </summary>
    <param name="lp">
      <para>A pointer to the first byte of the memory block.</para>
    </param>
    <param name="ucb">
      <para>The size of the memory block, in bytes. If this parameter is zero, the return value is zero.</para>
    </param>
    <returns>
      <para>If the calling process has read access to all bytes in the specified memory range, the return value is zero.</para>
      <para>If the calling process does not have read access to all bytes in the specified memory range, the return value is nonzero.</para>
      <para>If the application is compiled as a debugging version, and the process does not have read access to all bytes in the specified memory range, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value. This behavior is by design, as a debugging aid.</para>
    </returns>
    <remarks>
      <para>This function is typically used when working with pointers returned from third-party libraries, where you cannot determine the memory management behavior in the third-party DLL.</para>
      <para>Threads in a process are expected to cooperate in such a way that one will not free memory that the other needs. Use of this function does not negate the need to do this. If this is not done, the application may fail in an unpredictable manner.</para>
      <para>Dereferencing potentially invalid pointers can disable stack expansion in other threads. A thread exhausting its stack, when stack expansion has been disabled, results in the immediate termination of the parent process, with no pop-up error window or diagnostic information.</para>
      <para>If the calling process has read access to some, but not all, of the bytes in the specified memory range, the return value is nonzero.</para>
      <para>In a preemptive multitasking environment, it is possible for some other thread to change the process's access to the memory being tested. Even when the function indicates that the process has read access to the specified memory, you should use structured exception handling when attempting to access the memory. Use of structured exception handling enables the system to notify the process if an access violation exception occurs, giving the process an opportunity to handle the exception.</para>
    </remarks>
    <seealso cref="IsBadCodePtr" />
    <seealso cref="IsBadStringPtr" />
    <seealso cref="IsBadWritePtr" />
  </member>
  <member name="Windows.IsBadStringPtr">
    <summary>
      <para>Verifies that the calling process has read access to the specified range of memory.
<b>Important</b>  This function is obsolete and should not be used. Despite its name, it does not guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks on this page.</para>
    </summary>
    <param name="lpsz">
      <para>A pointer to a null-terminated string, either Unicode or ASCII.</para>
    </param>
    <param name="ucchMax">
      <para>The maximum size of the string, in <b>TCHARs</b>. The function checks for read access in all characters up to the string's terminating null character or up to the number of characters specified by this parameter, whichever is smaller. If this parameter is zero, the return value is zero.</para>
    </param>
    <returns>
      <para>If the calling process has read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is zero.</para>
      <para>If the calling process does not have read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is nonzero.</para>
      <para>If the application is compiled as a debugging version, and the process does not have read access to the entire memory range specified, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value This behavior is by design, as a debugging aid.</para>
    </returns>
    <remarks>
      <para>This function is typically used when working with pointers returned from third-party libraries, where you cannot determine the memory management behavior in the third-party DLL.</para>
      <para>Threads in a process are expected to cooperate in such a way that one will not free memory that the other needs. Use of this function does not negate the need to do this. If this is not done, the application may fail in an unpredictable manner.</para>
      <para>Dereferencing potentially invalid pointers can disable stack expansion in other threads. A thread exhausting its stack, when stack expansion has been disabled, results in the immediate termination of the parent process, with no pop-up error window or diagnostic information.</para>
      <para>If the calling process has read access to some, but not all, of the specified memory range, the return value is nonzero.</para>
      <para>In a preemptive multitasking environment, it is possible for some other thread to change the process's access to the memory being tested. Even when the function indicates that the process has read access to the specified memory, you should use
<a href="https://docs.microsoft.com//windows/desktop/Debug/structured-exception-handling">structured exception handling</a> when attempting to access the memory. Use of structured exception handling enables the system to notify the process if an access violation exception occurs, giving the process an opportunity to handle the exception.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines IsBadStringPtr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IsBadCodePtr" />
    <seealso cref="IsBadReadPtr" />
    <seealso cref="IsBadWritePtr" />
  </member>
  <member name="Windows.IsBadStringPtrA">
    <summary>
      <para>Verifies that the calling process has read access to the specified range of memory.
<b>Important</b>  This function is obsolete and should not be used. Despite its name, it does not guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks on this page.</para>
    </summary>
    <param name="lpsz">
      <para>A pointer to a null-terminated string, either Unicode or ASCII.</para>
    </param>
    <param name="ucchMax">
      <para>The maximum size of the string, in <b>TCHARs</b>. The function checks for read access in all characters up to the string's terminating null character or up to the number of characters specified by this parameter, whichever is smaller. If this parameter is zero, the return value is zero.</para>
    </param>
    <returns>
      <para>If the calling process has read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is zero.</para>
      <para>If the calling process does not have read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is nonzero.</para>
      <para>If the application is compiled as a debugging version, and the process does not have read access to the entire memory range specified, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value This behavior is by design, as a debugging aid.</para>
    </returns>
    <remarks>
      <para>This function is typically used when working with pointers returned from third-party libraries, where you cannot determine the memory management behavior in the third-party DLL.</para>
      <para>Threads in a process are expected to cooperate in such a way that one will not free memory that the other needs. Use of this function does not negate the need to do this. If this is not done, the application may fail in an unpredictable manner.</para>
      <para>Dereferencing potentially invalid pointers can disable stack expansion in other threads. A thread exhausting its stack, when stack expansion has been disabled, results in the immediate termination of the parent process, with no pop-up error window or diagnostic information.</para>
      <para>If the calling process has read access to some, but not all, of the specified memory range, the return value is nonzero.</para>
      <para>In a preemptive multitasking environment, it is possible for some other thread to change the process's access to the memory being tested. Even when the function indicates that the process has read access to the specified memory, you should use
<a href="https://docs.microsoft.com//windows/desktop/Debug/structured-exception-handling">structured exception handling</a> when attempting to access the memory. Use of structured exception handling enables the system to notify the process if an access violation exception occurs, giving the process an opportunity to handle the exception.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines IsBadStringPtr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IsBadCodePtr" />
    <seealso cref="IsBadReadPtr" />
    <seealso cref="IsBadWritePtr" />
  </member>
  <member name="Windows.IsBadStringPtrW">
    <summary>
      <para>Verifies that the calling process has read access to the specified range of memory.
<b>Important</b>  This function is obsolete and should not be used. Despite its name, it does not guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks on this page.</para>
    </summary>
    <param name="lpsz">
      <para>A pointer to a null-terminated string, either Unicode or ASCII.</para>
    </param>
    <param name="ucchMax">
      <para>The maximum size of the string, in <b>TCHARs</b>. The function checks for read access in all characters up to the string's terminating null character or up to the number of characters specified by this parameter, whichever is smaller. If this parameter is zero, the return value is zero.</para>
    </param>
    <returns>
      <para>If the calling process has read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is zero.</para>
      <para>If the calling process does not have read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is nonzero.</para>
      <para>If the application is compiled as a debugging version, and the process does not have read access to the entire memory range specified, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value This behavior is by design, as a debugging aid.</para>
    </returns>
    <remarks>
      <para>This function is typically used when working with pointers returned from third-party libraries, where you cannot determine the memory management behavior in the third-party DLL.</para>
      <para>Threads in a process are expected to cooperate in such a way that one will not free memory that the other needs. Use of this function does not negate the need to do this. If this is not done, the application may fail in an unpredictable manner.</para>
      <para>Dereferencing potentially invalid pointers can disable stack expansion in other threads. A thread exhausting its stack, when stack expansion has been disabled, results in the immediate termination of the parent process, with no pop-up error window or diagnostic information.</para>
      <para>If the calling process has read access to some, but not all, of the specified memory range, the return value is nonzero.</para>
      <para>In a preemptive multitasking environment, it is possible for some other thread to change the process's access to the memory being tested. Even when the function indicates that the process has read access to the specified memory, you should use
<a href="https://docs.microsoft.com//windows/desktop/Debug/structured-exception-handling">structured exception handling</a> when attempting to access the memory. Use of structured exception handling enables the system to notify the process if an access violation exception occurs, giving the process an opportunity to handle the exception.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines IsBadStringPtr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IsBadCodePtr" />
    <seealso cref="IsBadReadPtr" />
    <seealso cref="IsBadWritePtr" />
  </member>
  <member name="Windows.IsBadStringPtr">
    <summary>
      <para>Verifies that the calling process has read access to the specified range of memory.
<b>Important</b>  This function is obsolete and should not be used. Despite its name, it does not guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks on this page.</para>
    </summary>
    <param name="lpsz">
      <para>A pointer to a null-terminated string, either Unicode or ASCII.</para>
    </param>
    <param name="ucchMax">
      <para>The maximum size of the string, in <b>TCHARs</b>. The function checks for read access in all characters up to the string's terminating null character or up to the number of characters specified by this parameter, whichever is smaller. If this parameter is zero, the return value is zero.</para>
    </param>
    <returns>
      <para>If the calling process has read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is zero.</para>
      <para>If the calling process does not have read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is nonzero.</para>
      <para>If the application is compiled as a debugging version, and the process does not have read access to the entire memory range specified, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value This behavior is by design, as a debugging aid.</para>
    </returns>
    <remarks>
      <para>This function is typically used when working with pointers returned from third-party libraries, where you cannot determine the memory management behavior in the third-party DLL.</para>
      <para>Threads in a process are expected to cooperate in such a way that one will not free memory that the other needs. Use of this function does not negate the need to do this. If this is not done, the application may fail in an unpredictable manner.</para>
      <para>Dereferencing potentially invalid pointers can disable stack expansion in other threads. A thread exhausting its stack, when stack expansion has been disabled, results in the immediate termination of the parent process, with no pop-up error window or diagnostic information.</para>
      <para>If the calling process has read access to some, but not all, of the specified memory range, the return value is nonzero.</para>
      <para>In a preemptive multitasking environment, it is possible for some other thread to change the process's access to the memory being tested. Even when the function indicates that the process has read access to the specified memory, you should use
<a href="https://docs.microsoft.com//windows/desktop/Debug/structured-exception-handling">structured exception handling</a> when attempting to access the memory. Use of structured exception handling enables the system to notify the process if an access violation exception occurs, giving the process an opportunity to handle the exception.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines IsBadStringPtr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IsBadCodePtr" />
    <seealso cref="IsBadReadPtr" />
    <seealso cref="IsBadWritePtr" />
  </member>
  <member name="Windows.IsBadStringPtrA">
    <summary>
      <para>Verifies that the calling process has read access to the specified range of memory.
<b>Important</b>  This function is obsolete and should not be used. Despite its name, it does not guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks on this page.</para>
    </summary>
    <param name="lpsz">
      <para>A pointer to a null-terminated string, either Unicode or ASCII.</para>
    </param>
    <param name="ucchMax">
      <para>The maximum size of the string, in <b>TCHARs</b>. The function checks for read access in all characters up to the string's terminating null character or up to the number of characters specified by this parameter, whichever is smaller. If this parameter is zero, the return value is zero.</para>
    </param>
    <returns>
      <para>If the calling process has read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is zero.</para>
      <para>If the calling process does not have read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is nonzero.</para>
      <para>If the application is compiled as a debugging version, and the process does not have read access to the entire memory range specified, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value This behavior is by design, as a debugging aid.</para>
    </returns>
    <remarks>
      <para>This function is typically used when working with pointers returned from third-party libraries, where you cannot determine the memory management behavior in the third-party DLL.</para>
      <para>Threads in a process are expected to cooperate in such a way that one will not free memory that the other needs. Use of this function does not negate the need to do this. If this is not done, the application may fail in an unpredictable manner.</para>
      <para>Dereferencing potentially invalid pointers can disable stack expansion in other threads. A thread exhausting its stack, when stack expansion has been disabled, results in the immediate termination of the parent process, with no pop-up error window or diagnostic information.</para>
      <para>If the calling process has read access to some, but not all, of the specified memory range, the return value is nonzero.</para>
      <para>In a preemptive multitasking environment, it is possible for some other thread to change the process's access to the memory being tested. Even when the function indicates that the process has read access to the specified memory, you should use
<a href="https://docs.microsoft.com//windows/desktop/Debug/structured-exception-handling">structured exception handling</a> when attempting to access the memory. Use of structured exception handling enables the system to notify the process if an access violation exception occurs, giving the process an opportunity to handle the exception.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines IsBadStringPtr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IsBadCodePtr" />
    <seealso cref="IsBadReadPtr" />
    <seealso cref="IsBadWritePtr" />
  </member>
  <member name="Windows.IsBadStringPtrW">
    <summary>
      <para>Verifies that the calling process has read access to the specified range of memory.
<b>Important</b>  This function is obsolete and should not be used. Despite its name, it does not guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks on this page.</para>
    </summary>
    <param name="lpsz">
      <para>A pointer to a null-terminated string, either Unicode or ASCII.</para>
    </param>
    <param name="ucchMax">
      <para>The maximum size of the string, in <b>TCHARs</b>. The function checks for read access in all characters up to the string's terminating null character or up to the number of characters specified by this parameter, whichever is smaller. If this parameter is zero, the return value is zero.</para>
    </param>
    <returns>
      <para>If the calling process has read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is zero.</para>
      <para>If the calling process does not have read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is nonzero.</para>
      <para>If the application is compiled as a debugging version, and the process does not have read access to the entire memory range specified, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value This behavior is by design, as a debugging aid.</para>
    </returns>
    <remarks>
      <para>This function is typically used when working with pointers returned from third-party libraries, where you cannot determine the memory management behavior in the third-party DLL.</para>
      <para>Threads in a process are expected to cooperate in such a way that one will not free memory that the other needs. Use of this function does not negate the need to do this. If this is not done, the application may fail in an unpredictable manner.</para>
      <para>Dereferencing potentially invalid pointers can disable stack expansion in other threads. A thread exhausting its stack, when stack expansion has been disabled, results in the immediate termination of the parent process, with no pop-up error window or diagnostic information.</para>
      <para>If the calling process has read access to some, but not all, of the specified memory range, the return value is nonzero.</para>
      <para>In a preemptive multitasking environment, it is possible for some other thread to change the process's access to the memory being tested. Even when the function indicates that the process has read access to the specified memory, you should use
<a href="https://docs.microsoft.com//windows/desktop/Debug/structured-exception-handling">structured exception handling</a> when attempting to access the memory. Use of structured exception handling enables the system to notify the process if an access violation exception occurs, giving the process an opportunity to handle the exception.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines IsBadStringPtr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IsBadCodePtr" />
    <seealso cref="IsBadReadPtr" />
    <seealso cref="IsBadWritePtr" />
  </member>
  <member name="Windows.IsBadWritePtr">
    <summary>
      <para>Verifies that the calling process has write access to the specified range of memory.
<b>Important</b>  This function is obsolete and should not be used. Despite its name, it does not guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks on this page.</para>
    </summary>
    <param name="lp">
      <para>A pointer to the first byte of the memory block.</para>
    </param>
    <param name="ucb">
      <para>The size of the memory block, in bytes. If this parameter is zero, the return value is zero.</para>
    </param>
    <returns>
      <para>If the calling process has write access to all bytes in the specified memory range, the return value is zero.</para>
      <para>If the calling process does not have write access to all bytes in the specified memory range, the return value is nonzero.</para>
      <para>If the application is run under a debugger and the process does not have write access to all bytes in the specified memory range, the function causes a first chance STATUS_ACCESS_VIOLATION exception. The debugger can be configured to break for this condition. After resuming process execution in the debugger, the function continues as usual and returns a nonzero value This behavior is by design and serves as a debugging aid.</para>
    </returns>
    <remarks>
      <para>This function is typically used when working with pointers returned from third-party libraries, where you cannot determine the memory management behavior in the third-party DLL.</para>
      <para>Threads in a process are expected to cooperate in such a way that one will not free memory that the other needs. Use of this function does not negate the need to do this. If this is not done, the application may fail in an unpredictable manner.</para>
      <para>Dereferencing potentially invalid pointers can disable stack expansion in other threads. A thread exhausting its stack, when stack expansion has been disabled, results in the immediate termination of the parent process, with no pop-up error window or diagnostic information.</para>
      <para>If the calling process has write access to some, but not all, of the bytes in the specified memory range, the return value is nonzero.</para>
      <para>In a preemptive multitasking environment, it is possible for some other thread to change the process's access to the memory being tested. Even when the function indicates that the process has write access to the specified memory, you should use structured exception handling when attempting to access the memory. Use of structured exception handling enables the system to notify the process if an access violation exception occurs, giving the process an opportunity to handle the exception.</para>
      <para>
        <b>IsBadWritePtr</b> is not multithread safe. To use it properly on a pointer shared by multiple threads, call it inside a critical region of code that allows only one thread to access the memory being checked. Use operating system–level objects such as critical sections or mutexes or the interlocked functions to create the critical region of code.</para>
    </remarks>
    <seealso cref="IsBadCodePtr" />
    <seealso cref="IsBadReadPtr" />
    <seealso cref="IsBadStringPtr" />
  </member>
  <member name="Windows.IsNativeVhdBoot">
    <summary>
      <para>Indicates if the OS was booted from a VHD container.</para>
    </summary>
    <param name="NativeVhdBoot">
      <para>Pointer to a variable that receives a boolean
indicating if the OS was booted from a VHD.</para>
    </param>
    <returns>
      <para>TRUE if the OS was a native VHD boot; otherwise, FALSE.</para>
      <para>Call <see cref="GetLastError" /> to get extended error information.</para>
    </returns>
    <seealso cref="GetProcessHandleCount" />
    <seealso cref="GetProcessMemoryInfo" />
    <seealso cref="GetSystemInfo" />
    <seealso cref="GetSystemRegistryQuota" />
    <seealso cref="GetSystemTimes" />
  </member>
  <member name="Windows.IsSystemResumeAutomatic">
    <summary>
      <para>Determines the current state of the computer.</para>
    </summary>
    <returns>
      <para>If the system was restored to the working state automatically and the user is not active, the function returns <b>TRUE</b>. Otherwise, the function returns <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The
<a href="https://docs.microsoft.com//windows/desktop/Power/pbt-apmresumeautomatic">PBT_APMRESUMEAUTOMATIC</a> event is broadcast when the system wakes automatically to handle an event. The user is generally not present. If the system detects any user activity after broadcasting the
PBT_APMRESUMEAUTOMATIC event, it will broadcast the
<a href="https://docs.microsoft.com//windows/desktop/Power/pbt-apmresumesuspend">PBT_APMRESUMESUSPEND</a> event to let applications know they can resume full interaction with the user.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Power/pbt-apmresumeautomatic">PBT_APMRESUMEAUTOMATIC</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Power/pbt-apmresumesuspend">PBT_APMRESUMESUSPEND</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Power/power-management-functions">Power Management Functions</seealso>
  </member>
  <member name="Windows.IsTextUnicode">
    <summary>
      <para>Determines if a buffer is likely to contain a form of Unicode text.</para>
    </summary>
    <param name="lpv">
      <para>Pointer to the input buffer to examine.</para>
    </param>
    <param name="iSize">
      <para>Size, in bytes, of the input buffer indicated by <i>lpv</i>.</para>
    </param>
    <param name="lpiResult">
      <para>On input, pointer to the tests to apply to the input buffer text. On output, this parameter receives the results of the specified tests: 1 if the contents of the buffer pass a test, 0 for failure. Only flags that are set upon input to the function are significant upon output.</para>
      <para>If <i>lpiResult</i> is <b>NULL</b>, the function uses all available tests to determine if the data in the buffer is likely to be Unicode text.</para>
      <para>This parameter can be one or more of the following values. Values can be combined with binary "OR".</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>IS_TEXT_UNICODE_ASCII16</b>
          </description>
          <description>
            <para>The text is Unicode, and contains only zero-extended ASCII values/characters.</para>
          </description>
        </item>
        <item>
          <description>
            <b>IS_TEXT_UNICODE_REVERSE_ASCII16</b>
          </description>
          <description>
            <para>Same as the preceding, except that the Unicode text is byte-reversed.</para>
          </description>
        </item>
        <item>
          <description>
            <b>IS_TEXT_UNICODE_STATISTICS</b>
          </description>
          <description>
            <para>The text is probably Unicode, with the determination made by applying statistical analysis. Absolute certainty is not guaranteed. See the Remarks section.</para>
          </description>
        </item>
        <item>
          <description>
            <b>IS_TEXT_UNICODE_REVERSE_STATISTICS</b>
          </description>
          <description>
            <para>Same as the preceding, except that the text that is probably Unicode is byte-reversed.</para>
          </description>
        </item>
        <item>
          <description>
            <b>IS_TEXT_UNICODE_CONTROLS</b>
          </description>
          <description>
            <para>The text contains Unicode representations of one or more of these nonprinting characters: RETURN, LINEFEED, SPACE, CJK_SPACE, TAB.</para>
          </description>
        </item>
        <item>
          <description>
            <b>IS_TEXT_UNICODE_REVERSE_CONTROLS</b>
          </description>
          <description>
            <para>Same as the preceding, except that the Unicode characters are byte-reversed.</para>
          </description>
        </item>
        <item>
          <description>
            <b>IS_TEXT_UNICODE_BUFFER_TOO_SMALL</b>
          </description>
          <description>
            <para>There are too few characters in the buffer for meaningful analysis (fewer than two bytes).</para>
          </description>
        </item>
        <item>
          <description>
            <b>IS_TEXT_UNICODE_SIGNATURE</b>
          </description>
          <description>
            <para>The text contains the Unicode byte-order mark (BOM) 0xFEFF as its first character.</para>
          </description>
        </item>
        <item>
          <description>
            <b>IS_TEXT_UNICODE_REVERSE_SIGNATURE</b>
          </description>
          <description>
            <para>The text contains the Unicode byte-reversed byte-order mark (Reverse BOM) 0xFFFE as its first character.</para>
          </description>
        </item>
        <item>
          <description>
            <b>IS_TEXT_UNICODE_ILLEGAL_CHARS</b>
          </description>
          <description>
            <para>The text contains one of these Unicode-illegal characters: embedded Reverse BOM, UNICODE_NUL, CRLF (packed into one word), or 0xFFFF.</para>
          </description>
        </item>
        <item>
          <description>
            <b>IS_TEXT_UNICODE_ODD_LENGTH</b>
          </description>
          <description>
            <para>The number of characters in the string is odd. A string of odd length cannot (by definition) be Unicode text.</para>
          </description>
        </item>
        <item>
          <description>
            <b>IS_TEXT_UNICODE_NULL_BYTES</b>
          </description>
          <description>
            <para>The text contains null bytes, which indicate non-ASCII text.</para>
          </description>
        </item>
        <item>
          <description>
            <b>IS_TEXT_UNICODE_UNICODE_MASK</b>
          </description>
          <description>
            <para>The value is a combination of IS_TEXT_UNICODE_ASCII16, IS_TEXT_UNICODE_STATISTICS, IS_TEXT_UNICODE_CONTROLS, IS_TEXT_UNICODE_SIGNATURE.</para>
          </description>
        </item>
        <item>
          <description>
            <b>IS_TEXT_UNICODE_REVERSE_MASK</b>
          </description>
          <description>
            <para>The value is a combination of IS_TEXT_UNICODE_REVERSE_ASCII16, IS_TEXT_UNICODE_REVERSE_STATISTICS, IS_TEXT_UNICODE_REVERSE_CONTROLS, IS_TEXT_UNICODE_REVERSE_SIGNATURE.</para>
          </description>
        </item>
        <item>
          <description>
            <b>IS_TEXT_UNICODE_NOT_UNICODE_MASK</b>
          </description>
          <description>
            <para>The value is a combination of IS_TEXT_UNICODE_ILLEGAL_CHARS, IS_TEXT_UNICODE_ODD_LENGTH, and two currently unused bit flags.</para>
          </description>
        </item>
        <item>
          <description>
            <b>IS_TEXT_UNICODE_NOT_ASCII_MASK</b>
          </description>
          <description>
            <para>The value is a combination of IS_TEXT_UNICODE_NULL_BYTES and three currently unused bit flags.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>Returns a nonzero value if the data in the buffer passes the specified tests. The function returns 0 if the data in the buffer does not pass the specified tests.</para>
    </returns>
    <remarks>
      <para>This function uses various statistical and deterministic methods to make its determination, under the control of flags passed in the <i>lpiResult</i> parameter. When the function returns, the results of such tests are reported using the same parameter.</para>
      <para>The IS_TEXT_UNICODE_STATISTICS and IS_TEXT_UNICODE_REVERSE_STATISTICS tests use statistical analysis. These tests are not foolproof. The statistical tests assume certain amounts of variation between low and high bytes in a string, and some ASCII strings can slip through. For example, if <i>lpv</i> indicates the ASCII string 0x41, 0x0A, 0x0D, 0x1D (A\n\r^Z), the string passes the IS_TEXT_UNICODE_STATISTICS test, although failure would be preferable.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/unicode-and-character-set-functions">Unicode and Character Set Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Intl/unicode-and-character-sets">Unicode and Character Sets</seealso>
  </member>
  <member name="Windows.LoadModule">
    <summary>
      <para>Loads and executes an application or creates a new instance of an existing application.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the
<see cref="CreateProcess" /> function.</para>
    </summary>
    <param name="lpModuleName">
      <para>The file name of the application to be run. When specifying a path, be sure to use backslashes (\), not forward slashes (/). If the <i>lpModuleName</i> parameter does not contain a directory path, the system searches for the executable file in this order:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory.</description>
        </item>
        <item>
          <description>The system directory. Use the
<see cref="GetSystemDirectory" /> function to get the path of this directory.
</description>
        </item>
        <item>
          <description> The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</description>
        </item>
        <item>
          <description>The Windows directory. Use the
<see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable.</description>
        </item>
      </list>
    </param>
    <param name="lpParameterBlock">
      <para>A pointer to an application-defined <b>LOADPARMS32</b> structure that defines the new application's parameter block.</para>
      <para>Set all unused members to NULL, except for <b>lpCmdLine</b>, which must point to a null-terminated string if it is not used. For more information, see Remarks.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is greater than 31.</para>
      <para>If the function fails, the return value is an error value, which may be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>The system is out of memory or resources.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_BAD_FORMAT</b>
                </description>
              </item>
              <item>
                <description>11L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The .exe file is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_FILE_NOT_FOUND</b>
                </description>
              </item>
              <item>
                <description>2L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified file was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </description>
              </item>
              <item>
                <description>3L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The specified path was not found.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>LOADPARMS32</b> structure has the following form:</para>
      <code>typedef struct tagLOADPARMS32 {
  LPSTR lpEnvAddress;  // address of environment strings
  LPSTR lpCmdLine;     // address of command line
  LPSTR lpCmdShow;     // how to show new program
  DWORD dwReserved;    // must be zero
} LOADPARMS32;
</code>
      <list type="table">
        <listheader>
          <description>Member</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>lpEnvAddress</b>
          </description>
          <description>Pointer to an array of null-terminated strings that supply the environment strings for the new process. The array has a value of NULL as its last entry. A value of NULL for this parameter causes the new process to start with the same environment as the calling process.</description>
        </item>
        <item>
          <description>
            <b>lpCmdLine</b>
          </description>
          <description>Pointer to a Pascal-style string that contains a correctly formed command line. The first byte of the string contains the number of bytes in the string. The remainder of the string contains the command line arguments, excluding the name of the child process. If there are no command line arguments, this parameter must point to a zero length string; it cannot be NULL.</description>
        </item>
        <item>
          <description>
            <b>lpCmdShow</b>
          </description>
          <description>Pointer to a structure containing two <b>WORD</b> values. The first value must always be set to two. The second value specifies how the application window is to be shown and is used to supply the <b>wShowWindow</b> member of the
<see cref="STARTUPINFO" /> structure to the
<see cref="CreateProcess" /> function. See the description of the <i>nCmdShow</i> parameter of the
<see cref="ShowWindow" /> function for a list of acceptable values.</description>
        </item>
        <item>
          <description>
            <b>dwReserved</b>
          </description>
          <description>This parameter is reserved; it must be zero.</description>
        </item>
      </list>
      <para>Applications should use the
<see cref="CreateProcess" /> function instead of
<b>LoadModule</b>. The
<b>LoadModule</b> function calls
<see cref="CreateProcess" /> by forming the parameters as follows.</para>
      <list type="table">
        <listheader>
          <description>CreateProcess parameter</description>
          <description>Argument used</description>
        </listheader>
        <item>
          <description>
            <i>lpszApplicationName</i>
          </description>
          <description>
            <i>lpModuleName</i>
          </description>
        </item>
        <item>
          <description>
            <i>lpszCommandLine</i>
          </description>
          <description>
            <i>lpParameterBlock</i>.<b>lpCmdLine</b></description>
        </item>
        <item>
          <description>
            <i>lpProcessAttributes</i>
          </description>
          <description>NULL</description>
        </item>
        <item>
          <description>
            <i>lpThreadAttributes</i>
          </description>
          <description>NULL</description>
        </item>
        <item>
          <description>
            <i>bInheritHandles</i>
          </description>
          <description>FALSE</description>
        </item>
        <item>
          <description>
            <i>dwCreationFlags</i>
          </description>
          <description>0</description>
        </item>
        <item>
          <description>
            <i>lpEnvironment</i>
          </description>
          <description>
            <i>lpParameterBlock</i>.<b>lpEnvAddress</b></description>
        </item>
        <item>
          <description>
            <i>lpCurrentDirectory</i>
          </description>
          <description>NULL</description>
        </item>
        <item>
          <description>
            <i>lpStartupInfo</i>
          </description>
          <description>The structure is initialized to zero. The <b>cb</b> member is set to the size of the structure. The <b>wShowWindow</b> member is set to the value of the second word of <i>lpParameterBlock</i>.<b>lpCmdShow</b>.</description>
        </item>
        <item>
          <description>
            <i>lpProcessInformation</i>
            <b>.hProcess</b>
          </description>
          <description>The handle is immediately closed.</description>
        </item>
        <item>
          <description>
            <i>lpProcessInformation</i>
            <b>.hThread</b>
          </description>
          <description>The handle is immediately closed.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="CreateProcess" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-functions">Dynamic-Link Library Functions</seealso>
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
  </member>
  <member name="Windows.LoadPackagedLibrary">
    <summary>
      <para>Loads the specified packaged module and its dependencies into the address space of the calling process.</para>
    </summary>
    <param name="lpwLibFileName">
      <para>The file name of the packaged module to load. The module can be a library module (a .dll file) or an executable module (an .exe file).</para>
      <para>If this parameter specifies a module name without a path and the file name extension is omitted, the function appends the default library extension .dll to the module name. To prevent the function from appending .dll to the module name, include a trailing point character (.) in the module name string.</para>
      <para>If this parameter specifies a path, the function searches that path for the module. The path cannot be an absolute path or a relative path that contains ".." in the path.   When specifying a path, be sure to use backslashes (\), not forward slashes (/). For more information about paths, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>If the specified module is already loaded in the process, the function returns a handle to the loaded module. The module must have been originally loaded  from the package dependency graph of the process.</para>
      <para>If loading the specified module causes the system to load other associated modules, the function first searches loaded modules, then it searches the package dependency graph of the process.  For more information, see Remarks.</para>
    </param>
    <param name="Reserved">
      <para>This parameter is reserved. It must be 0.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the loaded module.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>LoadPackagedLibrary</b> function is a simplified version of <see cref="LoadLibraryEx" />. Windows Runtime apps  can use <b>LoadPackagedLibrary</b> to load packaged modules. Desktop applications cannot use <b>LoadPackagedLibrary</b>; if a desktop application calls this function it fails with <b>APPMODEL_ERROR_NO_PACKAGE</b>.</para>
      <para>
        <b>LoadPackagedLibrary</b> returns a handle to the specified module and increments its reference count. If the module is already loaded, the function returns a handle to the loaded module. The calling process can use the handle returned by <b>LoadPackagedLibrary</b> to identify the module in calls to the
<see cref="GetProcAddress" /> function. Use the <see cref="FreeLibrary" /> function to free a loaded module and decrement its reference              count.</para>
      <para>If the function must search for the specified module or its dependencies, it searches only the package dependency graph of the process.  This is the application's package plus any dependencies specified as <code>&lt;PackageDependency&gt;</code> in the <code>&lt;Dependencies&gt;</code> section of the application's package manifest. Dependencies are searched in the order they appear in the manifest. The package dependency graph is specified in the <code>&lt;Dependencies&gt;</code> section of the application's package manifest. Dependencies are searched in the order they appear in the manifest. The search proceeds as follows:</para>
      <list type="number">
        <item>
          <description>The function first searches modules that are already loaded. If the specified module was originally loaded from the package dependency graph of the process, the function returns a handle to the loaded module. If the specified module was not loaded from the package dependency graph of the process, the function returns <b>NULL</b>.</description>
        </item>
        <item>
          <description>If the module is not already loaded, the function searches the package dependency graph of the process.</description>
        </item>
        <item>
          <description>If the function cannot find the specified module or one of its dependencies, the function fails.</description>
        </item>
      </list>
      <para>It is not safe to call
<b>LoadPackagedLibrary</b> from
<a href="https://docs.microsoft.com//windows/desktop/Dlls/dllmain">DllMain</a>. For more information, see the Remarks section in
<b>DllMain</b>.</para>
      <blockquote>
        <para>[!NOTE]
On Windows Phone, <b>LoadPackagedLibrary</b> must be called from <code>PhoneAppModelHost.dll</code>. Using <code>Kernel32.dll</code> is not supported.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</seealso>
  </member>
  <member name="Windows.LocalFlags">
    <summary>
      <para>Retrieves information about the specified local memory object.
<b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a>. For more information, see Remarks.</para>
    </summary>
    <param name="hMem">
      <para>A handle to the local memory object. This handle is returned by either the
<see cref="LocalAlloc" /> or
<see cref="LocalReAlloc" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the allocation values and the lock count for the memory object.</para>
      <para>If the function fails, the return value is <b>LMEM_INVALID_HANDLE</b>, indicating that the local handle is not valid. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The low-order byte of the low-order word of the return value contains the lock count of the object. To retrieve the lock count from the return value, use the <b>LMEM_LOCKCOUNT</b> mask with the bitwise AND (&amp;) operator. The lock count of memory objects allocated with <b>LMEM_FIXED</b> is always zero.</para>
      <para>The high-order byte of the low-order word of the return value indicates the allocation values of the memory object. It can be zero or <b>LMEM_DISCARDABLE</b>.</para>
      <para>The local functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a local function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</seealso>
    <seealso cref="GlobalFlags" />
    <seealso cref="LocalAlloc" />
    <seealso cref="LocalDiscard" />
    <seealso cref="LocalLock" />
    <seealso cref="LocalReAlloc" />
    <seealso cref="LocalUnlock" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
  </member>
  <member name="Windows.LocalFree">
    <summary>
      <para>Frees the specified local memory object and invalidates its handle.
<b>Note</b>  The local functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a local function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</para>
    </summary>
    <param name="hMem">
      <para>A handle to the local memory object. This handle is returned by either the
<see cref="LocalAlloc" /> or
<see cref="LocalReAlloc" /> function. It is not safe to free memory allocated with <see cref="GlobalAlloc" />.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>NULL</b>.</para>
      <para>If the function fails, the return value is equal to a handle to the local memory object. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the process tries to examine or modify the memory after it has been freed, heap corruption may occur or an access violation exception (EXCEPTION_ACCESS_VIOLATION) may be generated.</para>
      <para>If the <i>hMem</i> parameter is <b>NULL</b>,
<b>LocalFree</b> ignores the parameter and returns <b>NULL</b>.</para>
      <para>The
<b>LocalFree</b> function will free a locked memory object. A locked memory object has a lock count greater than zero. The
<see cref="LocalLock" /> function locks a local memory object and increments the lock count by one. The
<see cref="LocalUnlock" /> function unlocks it and decrements the lock count by one. To get the lock count of a local memory object, use the
<see cref="LocalFlags" /> function.</para>
      <para>If an application is running under a debug version of the system,
<b>LocalFree</b> will issue a message that tells you that a locked object is being freed. If you are debugging the application,
<b>LocalFree</b> will enter a breakpoint just before freeing a locked object. This allows you to verify the intended behavior, then continue execution.</para>
      <h4>Examples</h4>
      <para>For an example, see
<see cref="LocalAlloc" />.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</seealso>
    <seealso cref="GlobalFree" />
    <seealso cref="LocalAlloc" />
    <seealso cref="LocalFlags" />
    <seealso cref="LocalLock" />
    <seealso cref="LocalReAlloc" />
    <seealso cref="LocalUnlock" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
  </member>
  <member name="Windows.LocalHandle">
    <summary>
      <para>Retrieves the handle associated with the specified pointer to a local memory object.
<b>Note</b>  The local functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a local function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</para>
    </summary>
    <param name="pMem">
      <para>A pointer to the first byte of the local memory object. This pointer is returned by the
<see cref="LocalLock" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the specified local memory object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When the
<see cref="LocalAlloc" /> function allocates a local memory object with <b>LMEM_MOVEABLE</b>, it returns a handle to the object. The
<see cref="LocalLock" /> function converts this handle into a pointer to the object's memory block, and
<b>LocalHandle</b> converts the pointer back into a handle.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</seealso>
    <seealso cref="LocalAlloc" />
    <seealso cref="LocalLock" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
  </member>
  <member name="Windows.LocalLock">
    <summary>
      <para>Locks a local memory object and returns a pointer to the first byte of the object's memory block.
<b>Note</b>  The local functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a local function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</para>
    </summary>
    <param name="hMem">
      <para>A handle to the local memory object. This handle is returned by either the
<see cref="LocalAlloc" /> or
<see cref="LocalReAlloc" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the first byte of the memory block.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The internal data structures for each memory object include a lock count that is initially zero. For movable memory objects,
<b>LocalLock</b> increments the count by one, and the
<see cref="LocalUnlock" /> function decrements the count by one. Each successful call that a process makes to
<b>LocalLock</b> for an object must be matched by a corresponding call to
<b>LocalUnlock</b>. Locked memory will not be moved or discarded unless the memory object is reallocated by using the
<see cref="LocalReAlloc" /> function. The memory block of a locked memory object remains locked in memory until its lock count is decremented to zero, at which time it can be moved or discarded.</para>
      <para>Memory objects allocated with <b>LMEM_FIXED</b> always have a lock count of zero. For these objects, the value of the returned pointer is equal to the value of the specified handle.</para>
      <para>If the specified memory block has been discarded or if the memory block has a zero-byte size, this function returns <b>NULL</b>.</para>
      <para>Discarded objects always have a lock count of zero.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</seealso>
    <seealso cref="LocalAlloc" />
    <seealso cref="LocalFlags" />
    <seealso cref="LocalReAlloc" />
    <seealso cref="LocalUnlock" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
  </member>
  <member name="Windows.LocalReAlloc">
    <summary>
      <para>Changes the size or the attributes of a specified local memory object. The size can increase or decrease.
<b>Note</b>  The local functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a local function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</para>
    </summary>
    <param name="hMem">
      <para>A handle to the local memory object to be reallocated. This handle is returned by either the
<see cref="LocalAlloc" /> or
<b>LocalReAlloc</b> function.</para>
    </param>
    <param name="uBytes">
      <para>The new size of the memory block, in bytes. If <i>uFlags</i> specifies <b>LMEM_MODIFY</b>, this parameter is ignored.</para>
    </param>
    <param name="uFlags">
      <para>The reallocation options. If <b>LMEM_MODIFY</b> is specified, the function modifies the attributes of the memory object only (the <i>uBytes</i> parameter is ignored.) Otherwise, the function reallocates the memory object.</para>
      <para>You can optionally combine <b>LMEM_MODIFY</b> with the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LMEM_MOVEABLE</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Allocates fixed or movable memory.</para>
            <para>If the memory is a locked <b>LMEM_MOVEABLE</b> memory block or a <b>LMEM_FIXED</b> memory block and this flag is not specified, the memory can only be reallocated in place.</para>
          </description>
        </item>
      </list>
      <para>If this parameter does not specify <b>LMEM_MODIFY</b>, you can use the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>LMEM_ZEROINIT</b>
                </description>
              </item>
              <item>
                <description>0x0040</description>
              </item>
            </list>
          </description>
          <description>
            <para>Causes the additional memory contents to be initialized to zero if the memory object is growing in size.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the reallocated memory object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If
<b>LocalReAlloc</b> fails, the original memory is not freed, and the original handle and pointer are still valid.</para>
      <para>If
<b>LocalReAlloc</b> reallocates a fixed object, the value of the handle returned is the address of the first byte of the memory block. To access the memory, a process can simply cast the return value to a pointer.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</seealso>
    <seealso cref="LocalAlloc" />
    <seealso cref="LocalFree" />
    <seealso cref="LocalLock" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
  </member>
  <member name="Windows.LocalSize">
    <summary>
      <para>Retrieves the current size of the specified local memory object, in bytes.
<b>Note</b>  The local functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a local function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</para>
    </summary>
    <param name="hMem">
      <para>A handle to the local memory object. This handle is returned by the
<see cref="LocalAlloc" />,
<see cref="LocalReAlloc" />, or
<see cref="LocalHandle" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the size of the specified local memory object, in bytes. If the specified handle is not valid or if the object has been discarded, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The size of a memory block may be larger than the size requested when the memory was allocated.</para>
      <para>To verify that the specified object's memory block has not been discarded, call the
<see cref="LocalFlags" /> function before calling
<b>LocalSize</b>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</seealso>
    <seealso cref="LocalAlloc" />
    <seealso cref="LocalFlags" />
    <seealso cref="LocalHandle" />
    <seealso cref="LocalReAlloc" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
  </member>
  <member name="Windows.LocalUnlock">
    <summary>
      <para>Decrements the lock count associated with a memory object that was allocated with <b>LMEM_MOVEABLE</b>. This function has no effect on memory objects allocated with <b>LMEM_FIXED</b>.
<b>Note</b>  The local functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a local function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</para>
    </summary>
    <param name="hMem">
      <para>A handle to the local memory object. This handle is returned by either the
<see cref="LocalAlloc" /> or
<see cref="LocalReAlloc" /> function.</para>
    </param>
    <returns>
      <para>If the memory object is still locked after decrementing the lock count, the return value is nonzero. If the memory object is unlocked after decrementing the lock count, the function returns zero and <see cref="GetLastError" /> returns <b>NO_ERROR</b>.</para>
      <para>If the function fails, the return value is zero and
<see cref="GetLastError" /> returns a value other than <b>NO_ERROR</b>.</para>
    </returns>
    <remarks>
      <para>The internal data structures for each memory object include a lock count that is initially zero. For movable memory objects, the
<see cref="LocalLock" /> function increments the count by one, and
<b>LocalUnlock</b> decrements the count by one. For each call that a process makes to
<b>LocalLock</b> for an object, it must eventually call
<b>LocalUnlock</b>. Locked memory will not be moved or discarded unless the memory object is reallocated by using the
<see cref="LocalReAlloc" /> function. The memory block of a locked memory object remains locked until its lock count is decremented to zero, at which time it can be moved or discarded.</para>
      <para>If the memory object is already unlocked,
<b>LocalUnlock</b> returns <b>FALSE</b> and <see cref="GetLastError" /> reports <b>ERROR_NOT_LOCKED</b>. Memory objects allocated with <b>LMEM_FIXED</b> always have a lock count of zero and cause the <b>ERROR_NOT_LOCKED</b> error.</para>
      <para>A process should not rely on the return value to determine the number of times it must subsequently call
<b>LocalUnlock</b> for the memory block.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</seealso>
    <seealso cref="LocalAlloc" />
    <seealso cref="LocalFlags" />
    <seealso cref="LocalLock" />
    <seealso cref="LocalReAlloc" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory
Management Functions</seealso>
  </member>
  <member name="Windows.LocateXStateFeature">
    <summary>
      <para>Retrieves a pointer to the processor state for an XState feature within a
<see cref="CONTEXT" /> structure.</para>
      <para>The definition of XState feature bits are processor vendor specific. Please refer to the relevant processor
reference manuals for additional information on a particular feature.</para>
    </summary>
    <param name="Context">
      <para>A pointer to a <see cref="CONTEXT" /> structure containing the state
to retrieve or set. This <b>CONTEXT</b> should have been
initialized with <see cref="InitializeContext" /> with the
<b>CONTEXT_XSTATE</b> flag set in the <i>ContextFlags</i></para>
      <para>parameter.</para>
    </param>
    <param name="FeatureId">
      <para>The number of the feature to locate within the
<see cref="CONTEXT" /> structure.</para>
    </param>
    <param name="Length">
      <para>A pointer to a variable which receives the length of the feature area in bytes. The contents of this
variable are undefined if this function returns <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the specified feature is supported by the system and the specified
<see cref="CONTEXT" /> structure has been initialized with the
<b>CONTEXT_XSTATE</b> flag, this function returns a pointer to the feature area for the
specified feature.  The contents and layout of this area is processor-specific.</para>
      <para>If the <b>CONTEXT_XSTATE</b> flag is not set in the
<see cref="CONTEXT" /> structure or the
<i>FeatureID</i> is not supported by the system, the return value is
<b>NULL</b>. No additional error information is available.</para>
    </returns>
    <remarks>
      <para>The <b>LocateXStateFeature</b> function must be used
to find an individual XState feature within an extensible
<see cref="CONTEXT" /> structure. Features are not necessarily contiguous
in memory and applications should not assume the offset between two consecutive features will remain constant in
the future.</para>
      <para>The <i>FeatureID</i> parameter of the function corresponds to a bit within the feature
mask. For example, <i>FeatureId</i> 2 corresponds to a <i>FeatureMask</i> of
4 in <see cref="SetXStateFeaturesMask" />.
<i>FeatureID</i> values of 0 and 1 correspond to X87 FPU state and SSE state,
respectively.</para>
      <para>If you are setting XState on a thread via the
<see cref="SetThreadContext" /> or
<see cref="Wow64SetThreadContext" /></para>
      <para>APIs, you must also call
<see cref="SetXStateFeaturesMask" /> on the
<see cref="CONTEXT" /> structure with the mask value of the filled-in
feature to mark the feature as active.</para>
      <para>
        <b>Windows 7 with SP1 and Windows Server 2008 R2 with SP1:  </b>The <a href="https://docs.microsoft.com//windows/desktop/Debug/avx-support-portal">AVX API</a> is first implemented on
Windows 7 with SP1 and Windows Server 2008 R2 with SP1 . Since there is no SDK for SP1, that means there are
no available headers and library files to work with. In this situation, a caller must declare the needed
functions from this documentation and get pointers to them using
<see cref="GetModuleHandle" /> on
"Kernel32.dll", followed by calls to
<see cref="GetProcAddress" />. See
<a href="https://docs.microsoft.com//windows/desktop/Debug/working-with-xstate-context">Working with XState Context</a> for
details.</para>
    </remarks>
    <seealso cref="CONTEXT" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/avx-support-portal">Intel AVX</seealso>
    <seealso cref="SetThreadContext" />
    <seealso cref="SetXStateFeaturesMask" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/working-with-xstate-context">Working with XState Context</seealso>
    <seealso cref="Wow64SetThreadContext" />
  </member>
  <member name="Windows.LogonUser">
    <summary>
      <para>The <b>LogonUser</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUser</b> was called. You cannot use <b>LogonUser</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">plaintext</a> password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> that runs in the context of the specified user.</para>
    </summary>
    <param name="lpszUsername">
      <para>A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, <i>User</i><b>@</b><i>DNSDomainName</i>, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpszDomain">
      <para>A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</para>
    </param>
    <param name="lpszPassword">
      <para>A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>.  When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</para>
    </param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values, defined in Winbase.h.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_LOGON_BATCH</b>
          </description>
          <description>
            <para>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_INTERACTIVE</b>
          </description>
          <description>
            <para>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK</b>
          </description>
          <description>
            <para>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUser</b> function does not cache credentials for this logon type.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
          </description>
          <description>
            <para>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUser</b>, verify that the user can access the system across the network, and still communicate with other servers.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
          </description>
          <description>
            <para>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.</para>
            <para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_SERVICE</b>
          </description>
          <description>
            <para>Indicates a service-type logon. The account provided must have the service privilege enabled.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_UNLOCK</b>
          </description>
          <description>
            <para>GINAs are no longer supported.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>Specifies the logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_PROVIDER_DEFAULT</b>
          </description>
          <description>
            <para>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is negotiate, unless you pass <b>NULL</b> for the domain name and the user name is not in UPN format. In this case, the default provider is NTLM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT50</b>
          </description>
          <description>
            <para>Use the negotiate logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT40</b>
          </description>
          <description>
            <para>Use the NTLM logon provider.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the
<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the
<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUser</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert it to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the
<see cref="CloseHandle" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The LOGON32_LOGON_NETWORK logon type is fastest, but it has the following limitations:</para>
      <list type="bullet">
        <item>
          <description>The function returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a>, not a primary token. You cannot use this token directly in the
<see cref="CreateProcessAsUser" /> function. However, you can call the
<see cref="DuplicateTokenEx" /> function to convert the token to a primary token, and then use it in <b>CreateProcessAsUser</b>.</description>
        </item>
        <item>
          <description>If you convert the token to a primary token and use it in <see cref="CreateProcessAsUser" /> to start a process, the new process cannot access other network resources, such as remote servers or printers, through the redirector. An exception is that if the network resource is not access controlled, then the new process will be able to access it.</description>
        </item>
      </list>
      <para>The SE_TCB_NAME privilege is not required for this function unless you are logging onto a Passport account.</para>
      <para>The account specified by <i>lpszUsername</i>, must have the necessary account rights. For example, to log on a user with the LOGON32_LOGON_INTERACTIVE flag, the user (or a group to which the user belongs) must have the SE_INTERACTIVE_LOGON_NAME account right. For a list of the account rights that affect the various logon operations, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/account-rights-constants">Account Rights Constants</a>.</para>
      <para>A user is considered logged on if at least one token exists. If you call
<see cref="CreateProcessAsUser" /> and then close the token, the system considers the user as still logged on until the process (and all child processes) have ended.</para>
      <para>If the <b>LogonUser</b> call is successful, the system notifies network providers that the logon occurred by calling the provider's <see cref="NPLogonNotify" /> entry-point function.</para>
      <h4>Examples</h4>
      <para>You can generate a LocalService token by using the following code.</para>
      <code>LogonUser(L"LocalService", L"NT AUTHORITY", NULL, LOGON32_LOGON_SERVICE, LOGON32_PROVIDER_DEFAULT, &amp;amp;amp;amp;amp;amp;hToken)

</code>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LogonUser as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcessAsUser" />
    <seealso cref="DuplicateTokenEx" />
    <seealso cref="ImpersonateLoggedOnUser" />
  </member>
  <member name="Windows.LogonUserA">
    <summary>
      <para>The <b>LogonUser</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUser</b> was called. You cannot use <b>LogonUser</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">plaintext</a> password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> that runs in the context of the specified user.</para>
    </summary>
    <param name="lpszUsername">
      <para>A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, <i>User</i><b>@</b><i>DNSDomainName</i>, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpszDomain">
      <para>A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</para>
    </param>
    <param name="lpszPassword">
      <para>A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>.  When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</para>
    </param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values, defined in Winbase.h.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_LOGON_BATCH</b>
          </description>
          <description>
            <para>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_INTERACTIVE</b>
          </description>
          <description>
            <para>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK</b>
          </description>
          <description>
            <para>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUser</b> function does not cache credentials for this logon type.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
          </description>
          <description>
            <para>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUser</b>, verify that the user can access the system across the network, and still communicate with other servers.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
          </description>
          <description>
            <para>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.</para>
            <para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_SERVICE</b>
          </description>
          <description>
            <para>Indicates a service-type logon. The account provided must have the service privilege enabled.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_UNLOCK</b>
          </description>
          <description>
            <para>GINAs are no longer supported.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>Specifies the logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_PROVIDER_DEFAULT</b>
          </description>
          <description>
            <para>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is negotiate, unless you pass <b>NULL</b> for the domain name and the user name is not in UPN format. In this case, the default provider is NTLM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT50</b>
          </description>
          <description>
            <para>Use the negotiate logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT40</b>
          </description>
          <description>
            <para>Use the NTLM logon provider.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the
<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the
<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUser</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert it to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the
<see cref="CloseHandle" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The LOGON32_LOGON_NETWORK logon type is fastest, but it has the following limitations:</para>
      <list type="bullet">
        <item>
          <description>The function returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a>, not a primary token. You cannot use this token directly in the
<see cref="CreateProcessAsUser" /> function. However, you can call the
<see cref="DuplicateTokenEx" /> function to convert the token to a primary token, and then use it in <b>CreateProcessAsUser</b>.</description>
        </item>
        <item>
          <description>If you convert the token to a primary token and use it in <see cref="CreateProcessAsUser" /> to start a process, the new process cannot access other network resources, such as remote servers or printers, through the redirector. An exception is that if the network resource is not access controlled, then the new process will be able to access it.</description>
        </item>
      </list>
      <para>The SE_TCB_NAME privilege is not required for this function unless you are logging onto a Passport account.</para>
      <para>The account specified by <i>lpszUsername</i>, must have the necessary account rights. For example, to log on a user with the LOGON32_LOGON_INTERACTIVE flag, the user (or a group to which the user belongs) must have the SE_INTERACTIVE_LOGON_NAME account right. For a list of the account rights that affect the various logon operations, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/account-rights-constants">Account Rights Constants</a>.</para>
      <para>A user is considered logged on if at least one token exists. If you call
<see cref="CreateProcessAsUser" /> and then close the token, the system considers the user as still logged on until the process (and all child processes) have ended.</para>
      <para>If the <b>LogonUser</b> call is successful, the system notifies network providers that the logon occurred by calling the provider's <see cref="NPLogonNotify" /> entry-point function.</para>
      <h4>Examples</h4>
      <para>You can generate a LocalService token by using the following code.</para>
      <code>LogonUser(L"LocalService", L"NT AUTHORITY", NULL, LOGON32_LOGON_SERVICE, LOGON32_PROVIDER_DEFAULT, &amp;amp;amp;amp;amp;amp;hToken)

</code>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LogonUser as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcessAsUser" />
    <seealso cref="DuplicateTokenEx" />
    <seealso cref="ImpersonateLoggedOnUser" />
  </member>
  <member name="Windows.LogonUserW">
    <summary>
      <para>The <b>LogonUser</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUser</b> was called. You cannot use <b>LogonUser</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">plaintext</a> password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> that runs in the context of the specified user.</para>
    </summary>
    <param name="lpszUsername">
      <para>A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, <i>User</i><b>@</b><i>DNSDomainName</i>, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpszDomain">
      <para>A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</para>
    </param>
    <param name="lpszPassword">
      <para>A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>.  When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</para>
    </param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values, defined in Winbase.h.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_LOGON_BATCH</b>
          </description>
          <description>
            <para>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_INTERACTIVE</b>
          </description>
          <description>
            <para>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK</b>
          </description>
          <description>
            <para>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUser</b> function does not cache credentials for this logon type.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
          </description>
          <description>
            <para>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUser</b>, verify that the user can access the system across the network, and still communicate with other servers.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
          </description>
          <description>
            <para>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.</para>
            <para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_SERVICE</b>
          </description>
          <description>
            <para>Indicates a service-type logon. The account provided must have the service privilege enabled.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_UNLOCK</b>
          </description>
          <description>
            <para>GINAs are no longer supported.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>Specifies the logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_PROVIDER_DEFAULT</b>
          </description>
          <description>
            <para>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is negotiate, unless you pass <b>NULL</b> for the domain name and the user name is not in UPN format. In this case, the default provider is NTLM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT50</b>
          </description>
          <description>
            <para>Use the negotiate logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT40</b>
          </description>
          <description>
            <para>Use the NTLM logon provider.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the
<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the
<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUser</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert it to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the
<see cref="CloseHandle" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The LOGON32_LOGON_NETWORK logon type is fastest, but it has the following limitations:</para>
      <list type="bullet">
        <item>
          <description>The function returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a>, not a primary token. You cannot use this token directly in the
<see cref="CreateProcessAsUser" /> function. However, you can call the
<see cref="DuplicateTokenEx" /> function to convert the token to a primary token, and then use it in <b>CreateProcessAsUser</b>.</description>
        </item>
        <item>
          <description>If you convert the token to a primary token and use it in <see cref="CreateProcessAsUser" /> to start a process, the new process cannot access other network resources, such as remote servers or printers, through the redirector. An exception is that if the network resource is not access controlled, then the new process will be able to access it.</description>
        </item>
      </list>
      <para>The SE_TCB_NAME privilege is not required for this function unless you are logging onto a Passport account.</para>
      <para>The account specified by <i>lpszUsername</i>, must have the necessary account rights. For example, to log on a user with the LOGON32_LOGON_INTERACTIVE flag, the user (or a group to which the user belongs) must have the SE_INTERACTIVE_LOGON_NAME account right. For a list of the account rights that affect the various logon operations, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/account-rights-constants">Account Rights Constants</a>.</para>
      <para>A user is considered logged on if at least one token exists. If you call
<see cref="CreateProcessAsUser" /> and then close the token, the system considers the user as still logged on until the process (and all child processes) have ended.</para>
      <para>If the <b>LogonUser</b> call is successful, the system notifies network providers that the logon occurred by calling the provider's <see cref="NPLogonNotify" /> entry-point function.</para>
      <h4>Examples</h4>
      <para>You can generate a LocalService token by using the following code.</para>
      <code>LogonUser(L"LocalService", L"NT AUTHORITY", NULL, LOGON32_LOGON_SERVICE, LOGON32_PROVIDER_DEFAULT, &amp;amp;amp;amp;amp;amp;hToken)

</code>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LogonUser as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcessAsUser" />
    <seealso cref="DuplicateTokenEx" />
    <seealso cref="ImpersonateLoggedOnUser" />
  </member>
  <member name="Windows.LogonUserEx">
    <summary>
      <para>The <b>LogonUserEx</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUserEx</b> was called. You cannot use <b>LogonUserEx</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a plaintext password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a>  that runs in the context of the specified user.</para>
    </summary>
    <param name="lpszUsername">
      <para>A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, user@DNS_domain_name, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpszDomain">
      <para>A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</para>
    </param>
    <param name="lpszPassword">
      <para>A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>.  When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</para>
    </param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_LOGON_BATCH</b>
          </description>
          <description>
            <para>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_INTERACTIVE</b>
          </description>
          <description>
            <para>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK</b>
          </description>
          <description>
            <para>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
          </description>
          <description>
            <para>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUserEx</b>, verify that the user can access the system across the network, and still communicate with other servers.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
          </description>
          <description>
            <para>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.</para>
            <para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_SERVICE</b>
          </description>
          <description>
            <para>Indicates a service-type logon. The account provided must have the service privilege enabled.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_UNLOCK</b>
          </description>
          <description>
            <para>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>The logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_PROVIDER_DEFAULT</b>
          </description>
          <description>
            <para>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is NTLM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT50</b>
          </description>
          <description>
            <para>Use the negotiate logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT40</b>
          </description>
          <description>
            <para>Use the NTLM logon provider.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the
<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the
<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUserEx</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert the impersonation token to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the
<see cref="CloseHandle" /> function.</para>
    </param>
    <param name="ppLogonSid">
      <para>A pointer to a pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) that receives the SID of the user logged on.</para>
      <para>When you have finished using the SID, free it by calling the <see cref="LocalFree" /> function.</para>
    </param>
    <param name="ppProfileBuffer">
      <para>A pointer to a pointer that receives the address of a buffer that contains the logged on user's profile.</para>
    </param>
    <param name="pdwProfileLength">
      <para>A pointer to a <b>DWORD</b> that receives the length of the profile buffer.</para>
    </param>
    <param name="pQuotaLimits">
      <para>A pointer to a <see cref="QUOTA_LIMITS" /> structure that receives information about the quotas for the logged on user.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns  nonzero.</para>
      <para>If the function fails, it returns  zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The LOGON32_LOGON_NETWORK logon type is fastest, but it has the following limitations:</para>
      <list type="bullet">
        <item>
          <description>The function returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a>, not a primary token. You cannot use this token directly in the
<see cref="CreateProcessAsUser" /> function. However, you can call the
<see cref="DuplicateTokenEx" /> function to convert the token to a primary token, and then use it in <b>CreateProcessAsUser</b>.</description>
        </item>
        <item>
          <description>If you convert the token to a primary token and use it in <see cref="CreateProcessAsUser" /> to start a process, the new process cannot access other network resources, such as remote servers or printers, through the redirector. An exception is that if the network resource is not access controlled, then the new process will be able to access it.</description>
        </item>
      </list>
      <para>The SE_TCB_NAME privilege is not required for this function unless you are logging onto a Passport account.</para>
      <para>The account specified by <i>lpszUsername</i> must have the necessary account rights. For example, to log on a user with the LOGON32_LOGON_INTERACTIVE flag, the user (or a group to which the user belongs) must have the SE_INTERACTIVE_LOGON_NAME account right. For a list of the account rights that affect the various logon operations, see
<a href="https://docs.microsoft.com//windows/desktop/SecMgmt/account-object-access-rights">Account Object Access Rights</a>.</para>
      <para>A user is considered logged on if at least one token exists. If you call
<see cref="CreateProcessAsUser" /> and then close the token, the user is still logged on until the process (and all child processes) have ended.</para>
      <para>If the <b>LogonUserEx</b> call is successful, the system notifies network providers that the logon occurred by calling the provider's <see cref="NPLogonNotify" /> entry-point function.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LogonUserEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcessAsUser" />
    <seealso cref="DuplicateTokenEx" />
    <seealso cref="ImpersonateLoggedOnUser" />
    <seealso cref="QUOTA_LIMITS" />
  </member>
  <member name="Windows.LogonUserExA">
    <summary>
      <para>The <b>LogonUserEx</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUserEx</b> was called. You cannot use <b>LogonUserEx</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a plaintext password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a>  that runs in the context of the specified user.</para>
    </summary>
    <param name="lpszUsername">
      <para>A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, user@DNS_domain_name, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpszDomain">
      <para>A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</para>
    </param>
    <param name="lpszPassword">
      <para>A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>.  When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</para>
    </param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_LOGON_BATCH</b>
          </description>
          <description>
            <para>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_INTERACTIVE</b>
          </description>
          <description>
            <para>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK</b>
          </description>
          <description>
            <para>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
          </description>
          <description>
            <para>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUserEx</b>, verify that the user can access the system across the network, and still communicate with other servers.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
          </description>
          <description>
            <para>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.</para>
            <para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_SERVICE</b>
          </description>
          <description>
            <para>Indicates a service-type logon. The account provided must have the service privilege enabled.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_UNLOCK</b>
          </description>
          <description>
            <para>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>The logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_PROVIDER_DEFAULT</b>
          </description>
          <description>
            <para>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is NTLM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT50</b>
          </description>
          <description>
            <para>Use the negotiate logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT40</b>
          </description>
          <description>
            <para>Use the NTLM logon provider.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the
<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the
<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUserEx</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert the impersonation token to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the
<see cref="CloseHandle" /> function.</para>
    </param>
    <param name="ppLogonSid">
      <para>A pointer to a pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) that receives the SID of the user logged on.</para>
      <para>When you have finished using the SID, free it by calling the <see cref="LocalFree" /> function.</para>
    </param>
    <param name="ppProfileBuffer">
      <para>A pointer to a pointer that receives the address of a buffer that contains the logged on user's profile.</para>
    </param>
    <param name="pdwProfileLength">
      <para>A pointer to a <b>DWORD</b> that receives the length of the profile buffer.</para>
    </param>
    <param name="pQuotaLimits">
      <para>A pointer to a <see cref="QUOTA_LIMITS" /> structure that receives information about the quotas for the logged on user.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns  nonzero.</para>
      <para>If the function fails, it returns  zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The LOGON32_LOGON_NETWORK logon type is fastest, but it has the following limitations:</para>
      <list type="bullet">
        <item>
          <description>The function returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a>, not a primary token. You cannot use this token directly in the
<see cref="CreateProcessAsUser" /> function. However, you can call the
<see cref="DuplicateTokenEx" /> function to convert the token to a primary token, and then use it in <b>CreateProcessAsUser</b>.</description>
        </item>
        <item>
          <description>If you convert the token to a primary token and use it in <see cref="CreateProcessAsUser" /> to start a process, the new process cannot access other network resources, such as remote servers or printers, through the redirector. An exception is that if the network resource is not access controlled, then the new process will be able to access it.</description>
        </item>
      </list>
      <para>The SE_TCB_NAME privilege is not required for this function unless you are logging onto a Passport account.</para>
      <para>The account specified by <i>lpszUsername</i> must have the necessary account rights. For example, to log on a user with the LOGON32_LOGON_INTERACTIVE flag, the user (or a group to which the user belongs) must have the SE_INTERACTIVE_LOGON_NAME account right. For a list of the account rights that affect the various logon operations, see
<a href="https://docs.microsoft.com//windows/desktop/SecMgmt/account-object-access-rights">Account Object Access Rights</a>.</para>
      <para>A user is considered logged on if at least one token exists. If you call
<see cref="CreateProcessAsUser" /> and then close the token, the user is still logged on until the process (and all child processes) have ended.</para>
      <para>If the <b>LogonUserEx</b> call is successful, the system notifies network providers that the logon occurred by calling the provider's <see cref="NPLogonNotify" /> entry-point function.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LogonUserEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcessAsUser" />
    <seealso cref="DuplicateTokenEx" />
    <seealso cref="ImpersonateLoggedOnUser" />
    <seealso cref="QUOTA_LIMITS" />
  </member>
  <member name="Windows.LogonUserExW">
    <summary>
      <para>The <b>LogonUserEx</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUserEx</b> was called. You cannot use <b>LogonUserEx</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a plaintext password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a>  that runs in the context of the specified user.</para>
    </summary>
    <param name="lpszUsername">
      <para>A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, user@DNS_domain_name, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpszDomain">
      <para>A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</para>
    </param>
    <param name="lpszPassword">
      <para>A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>.  When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</para>
    </param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_LOGON_BATCH</b>
          </description>
          <description>
            <para>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_INTERACTIVE</b>
          </description>
          <description>
            <para>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK</b>
          </description>
          <description>
            <para>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
          </description>
          <description>
            <para>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUserEx</b>, verify that the user can access the system across the network, and still communicate with other servers.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
          </description>
          <description>
            <para>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.</para>
            <para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_SERVICE</b>
          </description>
          <description>
            <para>Indicates a service-type logon. The account provided must have the service privilege enabled.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_UNLOCK</b>
          </description>
          <description>
            <para>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>The logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_PROVIDER_DEFAULT</b>
          </description>
          <description>
            <para>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is NTLM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT50</b>
          </description>
          <description>
            <para>Use the negotiate logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT40</b>
          </description>
          <description>
            <para>Use the NTLM logon provider.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the
<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the
<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUserEx</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert the impersonation token to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the
<see cref="CloseHandle" /> function.</para>
    </param>
    <param name="ppLogonSid">
      <para>A pointer to a pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) that receives the SID of the user logged on.</para>
      <para>When you have finished using the SID, free it by calling the <see cref="LocalFree" /> function.</para>
    </param>
    <param name="ppProfileBuffer">
      <para>A pointer to a pointer that receives the address of a buffer that contains the logged on user's profile.</para>
    </param>
    <param name="pdwProfileLength">
      <para>A pointer to a <b>DWORD</b> that receives the length of the profile buffer.</para>
    </param>
    <param name="pQuotaLimits">
      <para>A pointer to a <see cref="QUOTA_LIMITS" /> structure that receives information about the quotas for the logged on user.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns  nonzero.</para>
      <para>If the function fails, it returns  zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The LOGON32_LOGON_NETWORK logon type is fastest, but it has the following limitations:</para>
      <list type="bullet">
        <item>
          <description>The function returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a>, not a primary token. You cannot use this token directly in the
<see cref="CreateProcessAsUser" /> function. However, you can call the
<see cref="DuplicateTokenEx" /> function to convert the token to a primary token, and then use it in <b>CreateProcessAsUser</b>.</description>
        </item>
        <item>
          <description>If you convert the token to a primary token and use it in <see cref="CreateProcessAsUser" /> to start a process, the new process cannot access other network resources, such as remote servers or printers, through the redirector. An exception is that if the network resource is not access controlled, then the new process will be able to access it.</description>
        </item>
      </list>
      <para>The SE_TCB_NAME privilege is not required for this function unless you are logging onto a Passport account.</para>
      <para>The account specified by <i>lpszUsername</i> must have the necessary account rights. For example, to log on a user with the LOGON32_LOGON_INTERACTIVE flag, the user (or a group to which the user belongs) must have the SE_INTERACTIVE_LOGON_NAME account right. For a list of the account rights that affect the various logon operations, see
<a href="https://docs.microsoft.com//windows/desktop/SecMgmt/account-object-access-rights">Account Object Access Rights</a>.</para>
      <para>A user is considered logged on if at least one token exists. If you call
<see cref="CreateProcessAsUser" /> and then close the token, the user is still logged on until the process (and all child processes) have ended.</para>
      <para>If the <b>LogonUserEx</b> call is successful, the system notifies network providers that the logon occurred by calling the provider's <see cref="NPLogonNotify" /> entry-point function.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LogonUserEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcessAsUser" />
    <seealso cref="DuplicateTokenEx" />
    <seealso cref="ImpersonateLoggedOnUser" />
    <seealso cref="QUOTA_LIMITS" />
  </member>
  <member name="Windows.LogonUserEx">
    <summary>
      <para>The <b>LogonUserEx</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUserEx</b> was called. You cannot use <b>LogonUserEx</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a plaintext password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a>  that runs in the context of the specified user.</para>
    </summary>
    <param name="lpszUsername">
      <para>A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, user@DNS_domain_name, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpszDomain">
      <para>A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</para>
    </param>
    <param name="lpszPassword">
      <para>A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>.  When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</para>
    </param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_LOGON_BATCH</b>
          </description>
          <description>
            <para>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_INTERACTIVE</b>
          </description>
          <description>
            <para>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK</b>
          </description>
          <description>
            <para>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
          </description>
          <description>
            <para>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUserEx</b>, verify that the user can access the system across the network, and still communicate with other servers.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
          </description>
          <description>
            <para>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.</para>
            <para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_SERVICE</b>
          </description>
          <description>
            <para>Indicates a service-type logon. The account provided must have the service privilege enabled.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_UNLOCK</b>
          </description>
          <description>
            <para>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>The logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_PROVIDER_DEFAULT</b>
          </description>
          <description>
            <para>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is NTLM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT50</b>
          </description>
          <description>
            <para>Use the negotiate logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT40</b>
          </description>
          <description>
            <para>Use the NTLM logon provider.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the
<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the
<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUserEx</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert the impersonation token to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the
<see cref="CloseHandle" /> function.</para>
    </param>
    <param name="ppLogonSid">
      <para>A pointer to a pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) that receives the SID of the user logged on.</para>
      <para>When you have finished using the SID, free it by calling the <see cref="LocalFree" /> function.</para>
    </param>
    <param name="ppProfileBuffer">
      <para>A pointer to a pointer that receives the address of a buffer that contains the logged on user's profile.</para>
    </param>
    <param name="pdwProfileLength">
      <para>A pointer to a <b>DWORD</b> that receives the length of the profile buffer.</para>
    </param>
    <param name="pQuotaLimits">
      <para>A pointer to a <see cref="QUOTA_LIMITS" /> structure that receives information about the quotas for the logged on user.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns  nonzero.</para>
      <para>If the function fails, it returns  zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The LOGON32_LOGON_NETWORK logon type is fastest, but it has the following limitations:</para>
      <list type="bullet">
        <item>
          <description>The function returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a>, not a primary token. You cannot use this token directly in the
<see cref="CreateProcessAsUser" /> function. However, you can call the
<see cref="DuplicateTokenEx" /> function to convert the token to a primary token, and then use it in <b>CreateProcessAsUser</b>.</description>
        </item>
        <item>
          <description>If you convert the token to a primary token and use it in <see cref="CreateProcessAsUser" /> to start a process, the new process cannot access other network resources, such as remote servers or printers, through the redirector. An exception is that if the network resource is not access controlled, then the new process will be able to access it.</description>
        </item>
      </list>
      <para>The SE_TCB_NAME privilege is not required for this function unless you are logging onto a Passport account.</para>
      <para>The account specified by <i>lpszUsername</i> must have the necessary account rights. For example, to log on a user with the LOGON32_LOGON_INTERACTIVE flag, the user (or a group to which the user belongs) must have the SE_INTERACTIVE_LOGON_NAME account right. For a list of the account rights that affect the various logon operations, see
<a href="https://docs.microsoft.com//windows/desktop/SecMgmt/account-object-access-rights">Account Object Access Rights</a>.</para>
      <para>A user is considered logged on if at least one token exists. If you call
<see cref="CreateProcessAsUser" /> and then close the token, the user is still logged on until the process (and all child processes) have ended.</para>
      <para>If the <b>LogonUserEx</b> call is successful, the system notifies network providers that the logon occurred by calling the provider's <see cref="NPLogonNotify" /> entry-point function.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LogonUserEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcessAsUser" />
    <seealso cref="DuplicateTokenEx" />
    <seealso cref="ImpersonateLoggedOnUser" />
    <seealso cref="QUOTA_LIMITS" />
  </member>
  <member name="Windows.LogonUserExA">
    <summary>
      <para>The <b>LogonUserEx</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUserEx</b> was called. You cannot use <b>LogonUserEx</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a plaintext password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a>  that runs in the context of the specified user.</para>
    </summary>
    <param name="lpszUsername">
      <para>A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, user@DNS_domain_name, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpszDomain">
      <para>A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</para>
    </param>
    <param name="lpszPassword">
      <para>A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>.  When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</para>
    </param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_LOGON_BATCH</b>
          </description>
          <description>
            <para>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_INTERACTIVE</b>
          </description>
          <description>
            <para>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK</b>
          </description>
          <description>
            <para>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
          </description>
          <description>
            <para>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUserEx</b>, verify that the user can access the system across the network, and still communicate with other servers.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
          </description>
          <description>
            <para>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.</para>
            <para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_SERVICE</b>
          </description>
          <description>
            <para>Indicates a service-type logon. The account provided must have the service privilege enabled.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_UNLOCK</b>
          </description>
          <description>
            <para>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>The logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_PROVIDER_DEFAULT</b>
          </description>
          <description>
            <para>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is NTLM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT50</b>
          </description>
          <description>
            <para>Use the negotiate logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT40</b>
          </description>
          <description>
            <para>Use the NTLM logon provider.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the
<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the
<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUserEx</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert the impersonation token to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the
<see cref="CloseHandle" /> function.</para>
    </param>
    <param name="ppLogonSid">
      <para>A pointer to a pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) that receives the SID of the user logged on.</para>
      <para>When you have finished using the SID, free it by calling the <see cref="LocalFree" /> function.</para>
    </param>
    <param name="ppProfileBuffer">
      <para>A pointer to a pointer that receives the address of a buffer that contains the logged on user's profile.</para>
    </param>
    <param name="pdwProfileLength">
      <para>A pointer to a <b>DWORD</b> that receives the length of the profile buffer.</para>
    </param>
    <param name="pQuotaLimits">
      <para>A pointer to a <see cref="QUOTA_LIMITS" /> structure that receives information about the quotas for the logged on user.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns  nonzero.</para>
      <para>If the function fails, it returns  zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The LOGON32_LOGON_NETWORK logon type is fastest, but it has the following limitations:</para>
      <list type="bullet">
        <item>
          <description>The function returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a>, not a primary token. You cannot use this token directly in the
<see cref="CreateProcessAsUser" /> function. However, you can call the
<see cref="DuplicateTokenEx" /> function to convert the token to a primary token, and then use it in <b>CreateProcessAsUser</b>.</description>
        </item>
        <item>
          <description>If you convert the token to a primary token and use it in <see cref="CreateProcessAsUser" /> to start a process, the new process cannot access other network resources, such as remote servers or printers, through the redirector. An exception is that if the network resource is not access controlled, then the new process will be able to access it.</description>
        </item>
      </list>
      <para>The SE_TCB_NAME privilege is not required for this function unless you are logging onto a Passport account.</para>
      <para>The account specified by <i>lpszUsername</i> must have the necessary account rights. For example, to log on a user with the LOGON32_LOGON_INTERACTIVE flag, the user (or a group to which the user belongs) must have the SE_INTERACTIVE_LOGON_NAME account right. For a list of the account rights that affect the various logon operations, see
<a href="https://docs.microsoft.com//windows/desktop/SecMgmt/account-object-access-rights">Account Object Access Rights</a>.</para>
      <para>A user is considered logged on if at least one token exists. If you call
<see cref="CreateProcessAsUser" /> and then close the token, the user is still logged on until the process (and all child processes) have ended.</para>
      <para>If the <b>LogonUserEx</b> call is successful, the system notifies network providers that the logon occurred by calling the provider's <see cref="NPLogonNotify" /> entry-point function.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LogonUserEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcessAsUser" />
    <seealso cref="DuplicateTokenEx" />
    <seealso cref="ImpersonateLoggedOnUser" />
    <seealso cref="QUOTA_LIMITS" />
  </member>
  <member name="Windows.LogonUserExW">
    <summary>
      <para>The <b>LogonUserEx</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUserEx</b> was called. You cannot use <b>LogonUserEx</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a plaintext password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a>  that runs in the context of the specified user.</para>
    </summary>
    <param name="lpszUsername">
      <para>A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, user@DNS_domain_name, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpszDomain">
      <para>A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</para>
    </param>
    <param name="lpszPassword">
      <para>A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>.  When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</para>
    </param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_LOGON_BATCH</b>
          </description>
          <description>
            <para>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_INTERACTIVE</b>
          </description>
          <description>
            <para>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK</b>
          </description>
          <description>
            <para>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
          </description>
          <description>
            <para>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUserEx</b>, verify that the user can access the system across the network, and still communicate with other servers.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
          </description>
          <description>
            <para>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.</para>
            <para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_SERVICE</b>
          </description>
          <description>
            <para>Indicates a service-type logon. The account provided must have the service privilege enabled.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_UNLOCK</b>
          </description>
          <description>
            <para>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>The logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_PROVIDER_DEFAULT</b>
          </description>
          <description>
            <para>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is NTLM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT50</b>
          </description>
          <description>
            <para>Use the negotiate logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT40</b>
          </description>
          <description>
            <para>Use the NTLM logon provider.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the
<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the
<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUserEx</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert the impersonation token to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the
<see cref="CloseHandle" /> function.</para>
    </param>
    <param name="ppLogonSid">
      <para>A pointer to a pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) that receives the SID of the user logged on.</para>
      <para>When you have finished using the SID, free it by calling the <see cref="LocalFree" /> function.</para>
    </param>
    <param name="ppProfileBuffer">
      <para>A pointer to a pointer that receives the address of a buffer that contains the logged on user's profile.</para>
    </param>
    <param name="pdwProfileLength">
      <para>A pointer to a <b>DWORD</b> that receives the length of the profile buffer.</para>
    </param>
    <param name="pQuotaLimits">
      <para>A pointer to a <see cref="QUOTA_LIMITS" /> structure that receives information about the quotas for the logged on user.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns  nonzero.</para>
      <para>If the function fails, it returns  zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The LOGON32_LOGON_NETWORK logon type is fastest, but it has the following limitations:</para>
      <list type="bullet">
        <item>
          <description>The function returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a>, not a primary token. You cannot use this token directly in the
<see cref="CreateProcessAsUser" /> function. However, you can call the
<see cref="DuplicateTokenEx" /> function to convert the token to a primary token, and then use it in <b>CreateProcessAsUser</b>.</description>
        </item>
        <item>
          <description>If you convert the token to a primary token and use it in <see cref="CreateProcessAsUser" /> to start a process, the new process cannot access other network resources, such as remote servers or printers, through the redirector. An exception is that if the network resource is not access controlled, then the new process will be able to access it.</description>
        </item>
      </list>
      <para>The SE_TCB_NAME privilege is not required for this function unless you are logging onto a Passport account.</para>
      <para>The account specified by <i>lpszUsername</i> must have the necessary account rights. For example, to log on a user with the LOGON32_LOGON_INTERACTIVE flag, the user (or a group to which the user belongs) must have the SE_INTERACTIVE_LOGON_NAME account right. For a list of the account rights that affect the various logon operations, see
<a href="https://docs.microsoft.com//windows/desktop/SecMgmt/account-object-access-rights">Account Object Access Rights</a>.</para>
      <para>A user is considered logged on if at least one token exists. If you call
<see cref="CreateProcessAsUser" /> and then close the token, the user is still logged on until the process (and all child processes) have ended.</para>
      <para>If the <b>LogonUserEx</b> call is successful, the system notifies network providers that the logon occurred by calling the provider's <see cref="NPLogonNotify" /> entry-point function.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LogonUserEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcessAsUser" />
    <seealso cref="DuplicateTokenEx" />
    <seealso cref="ImpersonateLoggedOnUser" />
    <seealso cref="QUOTA_LIMITS" />
  </member>
  <member name="Windows.LogonUser">
    <summary>
      <para>The <b>LogonUser</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUser</b> was called. You cannot use <b>LogonUser</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">plaintext</a> password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> that runs in the context of the specified user.</para>
    </summary>
    <param name="lpszUsername">
      <para>A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, <i>User</i><b>@</b><i>DNSDomainName</i>, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpszDomain">
      <para>A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</para>
    </param>
    <param name="lpszPassword">
      <para>A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>.  When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</para>
    </param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values, defined in Winbase.h.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_LOGON_BATCH</b>
          </description>
          <description>
            <para>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_INTERACTIVE</b>
          </description>
          <description>
            <para>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK</b>
          </description>
          <description>
            <para>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUser</b> function does not cache credentials for this logon type.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
          </description>
          <description>
            <para>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUser</b>, verify that the user can access the system across the network, and still communicate with other servers.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
          </description>
          <description>
            <para>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.</para>
            <para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_SERVICE</b>
          </description>
          <description>
            <para>Indicates a service-type logon. The account provided must have the service privilege enabled.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_UNLOCK</b>
          </description>
          <description>
            <para>GINAs are no longer supported.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>Specifies the logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_PROVIDER_DEFAULT</b>
          </description>
          <description>
            <para>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is negotiate, unless you pass <b>NULL</b> for the domain name and the user name is not in UPN format. In this case, the default provider is NTLM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT50</b>
          </description>
          <description>
            <para>Use the negotiate logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT40</b>
          </description>
          <description>
            <para>Use the NTLM logon provider.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the
<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the
<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUser</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert it to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the
<see cref="CloseHandle" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The LOGON32_LOGON_NETWORK logon type is fastest, but it has the following limitations:</para>
      <list type="bullet">
        <item>
          <description>The function returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a>, not a primary token. You cannot use this token directly in the
<see cref="CreateProcessAsUser" /> function. However, you can call the
<see cref="DuplicateTokenEx" /> function to convert the token to a primary token, and then use it in <b>CreateProcessAsUser</b>.</description>
        </item>
        <item>
          <description>If you convert the token to a primary token and use it in <see cref="CreateProcessAsUser" /> to start a process, the new process cannot access other network resources, such as remote servers or printers, through the redirector. An exception is that if the network resource is not access controlled, then the new process will be able to access it.</description>
        </item>
      </list>
      <para>The SE_TCB_NAME privilege is not required for this function unless you are logging onto a Passport account.</para>
      <para>The account specified by <i>lpszUsername</i>, must have the necessary account rights. For example, to log on a user with the LOGON32_LOGON_INTERACTIVE flag, the user (or a group to which the user belongs) must have the SE_INTERACTIVE_LOGON_NAME account right. For a list of the account rights that affect the various logon operations, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/account-rights-constants">Account Rights Constants</a>.</para>
      <para>A user is considered logged on if at least one token exists. If you call
<see cref="CreateProcessAsUser" /> and then close the token, the system considers the user as still logged on until the process (and all child processes) have ended.</para>
      <para>If the <b>LogonUser</b> call is successful, the system notifies network providers that the logon occurred by calling the provider's <see cref="NPLogonNotify" /> entry-point function.</para>
      <h4>Examples</h4>
      <para>You can generate a LocalService token by using the following code.</para>
      <code>LogonUser(L"LocalService", L"NT AUTHORITY", NULL, LOGON32_LOGON_SERVICE, LOGON32_PROVIDER_DEFAULT, &amp;amp;amp;amp;amp;amp;hToken)

</code>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LogonUser as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcessAsUser" />
    <seealso cref="DuplicateTokenEx" />
    <seealso cref="ImpersonateLoggedOnUser" />
  </member>
  <member name="Windows.LogonUserA">
    <summary>
      <para>The <b>LogonUser</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUser</b> was called. You cannot use <b>LogonUser</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">plaintext</a> password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> that runs in the context of the specified user.</para>
    </summary>
    <param name="lpszUsername">
      <para>A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, <i>User</i><b>@</b><i>DNSDomainName</i>, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpszDomain">
      <para>A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</para>
    </param>
    <param name="lpszPassword">
      <para>A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>.  When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</para>
    </param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values, defined in Winbase.h.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_LOGON_BATCH</b>
          </description>
          <description>
            <para>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_INTERACTIVE</b>
          </description>
          <description>
            <para>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK</b>
          </description>
          <description>
            <para>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUser</b> function does not cache credentials for this logon type.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
          </description>
          <description>
            <para>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUser</b>, verify that the user can access the system across the network, and still communicate with other servers.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
          </description>
          <description>
            <para>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.</para>
            <para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_SERVICE</b>
          </description>
          <description>
            <para>Indicates a service-type logon. The account provided must have the service privilege enabled.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_UNLOCK</b>
          </description>
          <description>
            <para>GINAs are no longer supported.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>Specifies the logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_PROVIDER_DEFAULT</b>
          </description>
          <description>
            <para>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is negotiate, unless you pass <b>NULL</b> for the domain name and the user name is not in UPN format. In this case, the default provider is NTLM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT50</b>
          </description>
          <description>
            <para>Use the negotiate logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT40</b>
          </description>
          <description>
            <para>Use the NTLM logon provider.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the
<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the
<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUser</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert it to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the
<see cref="CloseHandle" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The LOGON32_LOGON_NETWORK logon type is fastest, but it has the following limitations:</para>
      <list type="bullet">
        <item>
          <description>The function returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a>, not a primary token. You cannot use this token directly in the
<see cref="CreateProcessAsUser" /> function. However, you can call the
<see cref="DuplicateTokenEx" /> function to convert the token to a primary token, and then use it in <b>CreateProcessAsUser</b>.</description>
        </item>
        <item>
          <description>If you convert the token to a primary token and use it in <see cref="CreateProcessAsUser" /> to start a process, the new process cannot access other network resources, such as remote servers or printers, through the redirector. An exception is that if the network resource is not access controlled, then the new process will be able to access it.</description>
        </item>
      </list>
      <para>The SE_TCB_NAME privilege is not required for this function unless you are logging onto a Passport account.</para>
      <para>The account specified by <i>lpszUsername</i>, must have the necessary account rights. For example, to log on a user with the LOGON32_LOGON_INTERACTIVE flag, the user (or a group to which the user belongs) must have the SE_INTERACTIVE_LOGON_NAME account right. For a list of the account rights that affect the various logon operations, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/account-rights-constants">Account Rights Constants</a>.</para>
      <para>A user is considered logged on if at least one token exists. If you call
<see cref="CreateProcessAsUser" /> and then close the token, the system considers the user as still logged on until the process (and all child processes) have ended.</para>
      <para>If the <b>LogonUser</b> call is successful, the system notifies network providers that the logon occurred by calling the provider's <see cref="NPLogonNotify" /> entry-point function.</para>
      <h4>Examples</h4>
      <para>You can generate a LocalService token by using the following code.</para>
      <code>LogonUser(L"LocalService", L"NT AUTHORITY", NULL, LOGON32_LOGON_SERVICE, LOGON32_PROVIDER_DEFAULT, &amp;amp;amp;amp;amp;amp;hToken)

</code>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LogonUser as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcessAsUser" />
    <seealso cref="DuplicateTokenEx" />
    <seealso cref="ImpersonateLoggedOnUser" />
  </member>
  <member name="Windows.LogonUserW">
    <summary>
      <para>The <b>LogonUser</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUser</b> was called. You cannot use <b>LogonUser</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">plaintext</a> password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> that runs in the context of the specified user.</para>
    </summary>
    <param name="lpszUsername">
      <para>A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, <i>User</i><b>@</b><i>DNSDomainName</i>, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</para>
    </param>
    <param name="lpszDomain">
      <para>A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</para>
    </param>
    <param name="lpszPassword">
      <para>A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>.  When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</para>
    </param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values, defined in Winbase.h.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_LOGON_BATCH</b>
          </description>
          <description>
            <para>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_INTERACTIVE</b>
          </description>
          <description>
            <para>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK</b>
          </description>
          <description>
            <para>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUser</b> function does not cache credentials for this logon type.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
          </description>
          <description>
            <para>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUser</b>, verify that the user can access the system across the network, and still communicate with other servers.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
          </description>
          <description>
            <para>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.</para>
            <para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_SERVICE</b>
          </description>
          <description>
            <para>Indicates a service-type logon. The account provided must have the service privilege enabled.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_LOGON_UNLOCK</b>
          </description>
          <description>
            <para>GINAs are no longer supported.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>Specifies the logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>LOGON32_PROVIDER_DEFAULT</b>
          </description>
          <description>
            <para>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is negotiate, unless you pass <b>NULL</b> for the domain name and the user name is not in UPN format. In this case, the default provider is NTLM.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT50</b>
          </description>
          <description>
            <para>Use the negotiate logon provider.</para>
          </description>
        </item>
        <item>
          <description>
            <b>LOGON32_PROVIDER_WINNT40</b>
          </description>
          <description>
            <para>Use the NTLM logon provider.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the
<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the
<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUser</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert it to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the
<see cref="CloseHandle" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The LOGON32_LOGON_NETWORK logon type is fastest, but it has the following limitations:</para>
      <list type="bullet">
        <item>
          <description>The function returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a>, not a primary token. You cannot use this token directly in the
<see cref="CreateProcessAsUser" /> function. However, you can call the
<see cref="DuplicateTokenEx" /> function to convert the token to a primary token, and then use it in <b>CreateProcessAsUser</b>.</description>
        </item>
        <item>
          <description>If you convert the token to a primary token and use it in <see cref="CreateProcessAsUser" /> to start a process, the new process cannot access other network resources, such as remote servers or printers, through the redirector. An exception is that if the network resource is not access controlled, then the new process will be able to access it.</description>
        </item>
      </list>
      <para>The SE_TCB_NAME privilege is not required for this function unless you are logging onto a Passport account.</para>
      <para>The account specified by <i>lpszUsername</i>, must have the necessary account rights. For example, to log on a user with the LOGON32_LOGON_INTERACTIVE flag, the user (or a group to which the user belongs) must have the SE_INTERACTIVE_LOGON_NAME account right. For a list of the account rights that affect the various logon operations, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/account-rights-constants">Account Rights Constants</a>.</para>
      <para>A user is considered logged on if at least one token exists. If you call
<see cref="CreateProcessAsUser" /> and then close the token, the system considers the user as still logged on until the process (and all child processes) have ended.</para>
      <para>If the <b>LogonUser</b> call is successful, the system notifies network providers that the logon occurred by calling the provider's <see cref="NPLogonNotify" /> entry-point function.</para>
      <h4>Examples</h4>
      <para>You can generate a LocalService token by using the following code.</para>
      <code>LogonUser(L"LocalService", L"NT AUTHORITY", NULL, LOGON32_LOGON_SERVICE, LOGON32_PROVIDER_DEFAULT, &amp;amp;amp;amp;amp;amp;hToken)

</code>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LogonUser as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateProcessAsUser" />
    <seealso cref="DuplicateTokenEx" />
    <seealso cref="ImpersonateLoggedOnUser" />
  </member>
  <member name="Windows.LookupAccountName">
    <summary>
      <para>The <b>LookupAccountName</b> function accepts the name of a system and an account as input. It retrieves a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) for the account and the name of the domain on which the account was found.</para>
      <para>The <see cref="LsaLookupNames" /> function can also retrieve computer accounts.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a <b>null</b>-terminated character string that specifies the name of the system. This string can be the name of a remote computer. If this string is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for  <i>lpSystemName</i> only when the  account is in an untrusted domain and the   name of a computer in that domain is known.</para>
    </param>
    <param name="lpAccountName">
      <para>A pointer to a <b>null</b>-terminated string that specifies the account name.</para>
      <para>Use a fully qualified string in the domain_name\user_name format to ensure that <b>LookupAccountName</b> finds the account in the desired domain.</para>
    </param>
    <param name="Sid">
      <para>A pointer to a buffer that receives the
<see cref="SID" /> structure that corresponds to the account name pointed to by the <i>lpAccountName</i> parameter. If this parameter is <b>NULL</b>, <i>cbSid</i> must be zero.</para>
    </param>
    <param name="cbSid">
      <para>A pointer to a variable. On input, this value specifies the size, in bytes, of the <i>Sid</i> buffer. If the function fails because the buffer is too small or if <i>cbSid</i> is zero, this variable receives the required buffer size.</para>
    </param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives the name of the domain where the account name is found. For computers that are not joined to a domain, this buffer receives the computer name. If this parameter is <b>NULL</b>, the function returns the required buffer size.</para>
    </param>
    <param name="cchReferencedDomainName">
      <para>A pointer to a variable. On input, this value specifies the size, in <b>TCHAR</b>s, of the <i>ReferencedDomainName</i> buffer. If the function fails because the buffer is too small, this variable receives the required buffer size, including the terminating <b>null</b> character. If the <i>ReferencedDomainName</i> parameter is <b>NULL</b>, this parameter must be zero.</para>
    </param>
    <param name="peUse">
      <para>A pointer to a
<see cref="SID_NAME_USE" /> enumerated type that indicates the type of the account when the function returns.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. For extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupAccountName</b> function attempts to find a SID for the specified name by first checking a list of well-known SIDs. If the name does not correspond to a well-known SID, the function checks built-in and administratively defined local accounts. Next, the function checks the primary domain. If the name is not found there, trusted domains are checked.</para>
      <para>Use fully qualified account names (for example, domain_name\user_name) instead of isolated names (for example, user_name). Fully qualified names are unambiguous and provide better performance when the lookup is performed. This function also supports fully qualified DNS names (for example, example.example.com\user_name) and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal names</a> (UPN) (for example, someone@example.com).</para>
      <para>In addition to looking up local accounts, local domain accounts, and explicitly trusted domain accounts, <b>LookupAccountName</b> can look up the name for any account in any domain in the forest.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupAccountName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="EqualPrefixSid" />
    <seealso cref="GetUserName" />
    <seealso cref="LookupAccountSid" />
    <seealso cref="LsaLookupNames2" />
    <seealso cref="SID" />
    <seealso cref="SID_NAME_USE" />
  </member>
  <member name="Windows.LookupAccountNameA">
    <summary>
      <para>The <b>LookupAccountName</b> function accepts the name of a system and an account as input. It retrieves a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) for the account and the name of the domain on which the account was found.</para>
      <para>The <see cref="LsaLookupNames" /> function can also retrieve computer accounts.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a <b>null</b>-terminated character string that specifies the name of the system. This string can be the name of a remote computer. If this string is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for  <i>lpSystemName</i> only when the  account is in an untrusted domain and the   name of a computer in that domain is known.</para>
    </param>
    <param name="lpAccountName">
      <para>A pointer to a <b>null</b>-terminated string that specifies the account name.</para>
      <para>Use a fully qualified string in the domain_name\user_name format to ensure that <b>LookupAccountName</b> finds the account in the desired domain.</para>
    </param>
    <param name="Sid">
      <para>A pointer to a buffer that receives the
<see cref="SID" /> structure that corresponds to the account name pointed to by the <i>lpAccountName</i> parameter. If this parameter is <b>NULL</b>, <i>cbSid</i> must be zero.</para>
    </param>
    <param name="cbSid">
      <para>A pointer to a variable. On input, this value specifies the size, in bytes, of the <i>Sid</i> buffer. If the function fails because the buffer is too small or if <i>cbSid</i> is zero, this variable receives the required buffer size.</para>
    </param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives the name of the domain where the account name is found. For computers that are not joined to a domain, this buffer receives the computer name. If this parameter is <b>NULL</b>, the function returns the required buffer size.</para>
    </param>
    <param name="cchReferencedDomainName">
      <para>A pointer to a variable. On input, this value specifies the size, in <b>TCHAR</b>s, of the <i>ReferencedDomainName</i> buffer. If the function fails because the buffer is too small, this variable receives the required buffer size, including the terminating <b>null</b> character. If the <i>ReferencedDomainName</i> parameter is <b>NULL</b>, this parameter must be zero.</para>
    </param>
    <param name="peUse">
      <para>A pointer to a
<see cref="SID_NAME_USE" /> enumerated type that indicates the type of the account when the function returns.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. For extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupAccountName</b> function attempts to find a SID for the specified name by first checking a list of well-known SIDs. If the name does not correspond to a well-known SID, the function checks built-in and administratively defined local accounts. Next, the function checks the primary domain. If the name is not found there, trusted domains are checked.</para>
      <para>Use fully qualified account names (for example, domain_name\user_name) instead of isolated names (for example, user_name). Fully qualified names are unambiguous and provide better performance when the lookup is performed. This function also supports fully qualified DNS names (for example, example.example.com\user_name) and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal names</a> (UPN) (for example, someone@example.com).</para>
      <para>In addition to looking up local accounts, local domain accounts, and explicitly trusted domain accounts, <b>LookupAccountName</b> can look up the name for any account in any domain in the forest.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupAccountName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="EqualPrefixSid" />
    <seealso cref="GetUserName" />
    <seealso cref="LookupAccountSid" />
    <seealso cref="LsaLookupNames2" />
    <seealso cref="SID" />
    <seealso cref="SID_NAME_USE" />
  </member>
  <member name="Windows.LookupAccountNameW">
    <summary>
      <para>The <b>LookupAccountName</b> function accepts the name of a system and an account as input. It retrieves a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) for the account and the name of the domain on which the account was found.</para>
      <para>The <see cref="LsaLookupNames" /> function can also retrieve computer accounts.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a <b>null</b>-terminated character string that specifies the name of the system. This string can be the name of a remote computer. If this string is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for  <i>lpSystemName</i> only when the  account is in an untrusted domain and the   name of a computer in that domain is known.</para>
    </param>
    <param name="lpAccountName">
      <para>A pointer to a <b>null</b>-terminated string that specifies the account name.</para>
      <para>Use a fully qualified string in the domain_name\user_name format to ensure that <b>LookupAccountName</b> finds the account in the desired domain.</para>
    </param>
    <param name="Sid">
      <para>A pointer to a buffer that receives the
<see cref="SID" /> structure that corresponds to the account name pointed to by the <i>lpAccountName</i> parameter. If this parameter is <b>NULL</b>, <i>cbSid</i> must be zero.</para>
    </param>
    <param name="cbSid">
      <para>A pointer to a variable. On input, this value specifies the size, in bytes, of the <i>Sid</i> buffer. If the function fails because the buffer is too small or if <i>cbSid</i> is zero, this variable receives the required buffer size.</para>
    </param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives the name of the domain where the account name is found. For computers that are not joined to a domain, this buffer receives the computer name. If this parameter is <b>NULL</b>, the function returns the required buffer size.</para>
    </param>
    <param name="cchReferencedDomainName">
      <para>A pointer to a variable. On input, this value specifies the size, in <b>TCHAR</b>s, of the <i>ReferencedDomainName</i> buffer. If the function fails because the buffer is too small, this variable receives the required buffer size, including the terminating <b>null</b> character. If the <i>ReferencedDomainName</i> parameter is <b>NULL</b>, this parameter must be zero.</para>
    </param>
    <param name="peUse">
      <para>A pointer to a
<see cref="SID_NAME_USE" /> enumerated type that indicates the type of the account when the function returns.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. For extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupAccountName</b> function attempts to find a SID for the specified name by first checking a list of well-known SIDs. If the name does not correspond to a well-known SID, the function checks built-in and administratively defined local accounts. Next, the function checks the primary domain. If the name is not found there, trusted domains are checked.</para>
      <para>Use fully qualified account names (for example, domain_name\user_name) instead of isolated names (for example, user_name). Fully qualified names are unambiguous and provide better performance when the lookup is performed. This function also supports fully qualified DNS names (for example, example.example.com\user_name) and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal names</a> (UPN) (for example, someone@example.com).</para>
      <para>In addition to looking up local accounts, local domain accounts, and explicitly trusted domain accounts, <b>LookupAccountName</b> can look up the name for any account in any domain in the forest.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupAccountName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="EqualPrefixSid" />
    <seealso cref="GetUserName" />
    <seealso cref="LookupAccountSid" />
    <seealso cref="LsaLookupNames2" />
    <seealso cref="SID" />
    <seealso cref="SID_NAME_USE" />
  </member>
  <member name="Windows.LookupAccountName">
    <summary>
      <para>The <b>LookupAccountName</b> function accepts the name of a system and an account as input. It retrieves a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) for the account and the name of the domain on which the account was found.</para>
      <para>The <see cref="LsaLookupNames" /> function can also retrieve computer accounts.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a <b>null</b>-terminated character string that specifies the name of the system. This string can be the name of a remote computer. If this string is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for  <i>lpSystemName</i> only when the  account is in an untrusted domain and the   name of a computer in that domain is known.</para>
    </param>
    <param name="lpAccountName">
      <para>A pointer to a <b>null</b>-terminated string that specifies the account name.</para>
      <para>Use a fully qualified string in the domain_name\user_name format to ensure that <b>LookupAccountName</b> finds the account in the desired domain.</para>
    </param>
    <param name="Sid">
      <para>A pointer to a buffer that receives the
<see cref="SID" /> structure that corresponds to the account name pointed to by the <i>lpAccountName</i> parameter. If this parameter is <b>NULL</b>, <i>cbSid</i> must be zero.</para>
    </param>
    <param name="cbSid">
      <para>A pointer to a variable. On input, this value specifies the size, in bytes, of the <i>Sid</i> buffer. If the function fails because the buffer is too small or if <i>cbSid</i> is zero, this variable receives the required buffer size.</para>
    </param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives the name of the domain where the account name is found. For computers that are not joined to a domain, this buffer receives the computer name. If this parameter is <b>NULL</b>, the function returns the required buffer size.</para>
    </param>
    <param name="cchReferencedDomainName">
      <para>A pointer to a variable. On input, this value specifies the size, in <b>TCHAR</b>s, of the <i>ReferencedDomainName</i> buffer. If the function fails because the buffer is too small, this variable receives the required buffer size, including the terminating <b>null</b> character. If the <i>ReferencedDomainName</i> parameter is <b>NULL</b>, this parameter must be zero.</para>
    </param>
    <param name="peUse">
      <para>A pointer to a
<see cref="SID_NAME_USE" /> enumerated type that indicates the type of the account when the function returns.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. For extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupAccountName</b> function attempts to find a SID for the specified name by first checking a list of well-known SIDs. If the name does not correspond to a well-known SID, the function checks built-in and administratively defined local accounts. Next, the function checks the primary domain. If the name is not found there, trusted domains are checked.</para>
      <para>Use fully qualified account names (for example, domain_name\user_name) instead of isolated names (for example, user_name). Fully qualified names are unambiguous and provide better performance when the lookup is performed. This function also supports fully qualified DNS names (for example, example.example.com\user_name) and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal names</a> (UPN) (for example, someone@example.com).</para>
      <para>In addition to looking up local accounts, local domain accounts, and explicitly trusted domain accounts, <b>LookupAccountName</b> can look up the name for any account in any domain in the forest.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupAccountName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="EqualPrefixSid" />
    <seealso cref="GetUserName" />
    <seealso cref="LookupAccountSid" />
    <seealso cref="LsaLookupNames2" />
    <seealso cref="SID" />
    <seealso cref="SID_NAME_USE" />
  </member>
  <member name="Windows.LookupAccountNameA">
    <summary>
      <para>The <b>LookupAccountName</b> function accepts the name of a system and an account as input. It retrieves a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) for the account and the name of the domain on which the account was found.</para>
      <para>The <see cref="LsaLookupNames" /> function can also retrieve computer accounts.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a <b>null</b>-terminated character string that specifies the name of the system. This string can be the name of a remote computer. If this string is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for  <i>lpSystemName</i> only when the  account is in an untrusted domain and the   name of a computer in that domain is known.</para>
    </param>
    <param name="lpAccountName">
      <para>A pointer to a <b>null</b>-terminated string that specifies the account name.</para>
      <para>Use a fully qualified string in the domain_name\user_name format to ensure that <b>LookupAccountName</b> finds the account in the desired domain.</para>
    </param>
    <param name="Sid">
      <para>A pointer to a buffer that receives the
<see cref="SID" /> structure that corresponds to the account name pointed to by the <i>lpAccountName</i> parameter. If this parameter is <b>NULL</b>, <i>cbSid</i> must be zero.</para>
    </param>
    <param name="cbSid">
      <para>A pointer to a variable. On input, this value specifies the size, in bytes, of the <i>Sid</i> buffer. If the function fails because the buffer is too small or if <i>cbSid</i> is zero, this variable receives the required buffer size.</para>
    </param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives the name of the domain where the account name is found. For computers that are not joined to a domain, this buffer receives the computer name. If this parameter is <b>NULL</b>, the function returns the required buffer size.</para>
    </param>
    <param name="cchReferencedDomainName">
      <para>A pointer to a variable. On input, this value specifies the size, in <b>TCHAR</b>s, of the <i>ReferencedDomainName</i> buffer. If the function fails because the buffer is too small, this variable receives the required buffer size, including the terminating <b>null</b> character. If the <i>ReferencedDomainName</i> parameter is <b>NULL</b>, this parameter must be zero.</para>
    </param>
    <param name="peUse">
      <para>A pointer to a
<see cref="SID_NAME_USE" /> enumerated type that indicates the type of the account when the function returns.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. For extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupAccountName</b> function attempts to find a SID for the specified name by first checking a list of well-known SIDs. If the name does not correspond to a well-known SID, the function checks built-in and administratively defined local accounts. Next, the function checks the primary domain. If the name is not found there, trusted domains are checked.</para>
      <para>Use fully qualified account names (for example, domain_name\user_name) instead of isolated names (for example, user_name). Fully qualified names are unambiguous and provide better performance when the lookup is performed. This function also supports fully qualified DNS names (for example, example.example.com\user_name) and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal names</a> (UPN) (for example, someone@example.com).</para>
      <para>In addition to looking up local accounts, local domain accounts, and explicitly trusted domain accounts, <b>LookupAccountName</b> can look up the name for any account in any domain in the forest.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupAccountName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="EqualPrefixSid" />
    <seealso cref="GetUserName" />
    <seealso cref="LookupAccountSid" />
    <seealso cref="LsaLookupNames2" />
    <seealso cref="SID" />
    <seealso cref="SID_NAME_USE" />
  </member>
  <member name="Windows.LookupAccountNameW">
    <summary>
      <para>The <b>LookupAccountName</b> function accepts the name of a system and an account as input. It retrieves a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) for the account and the name of the domain on which the account was found.</para>
      <para>The <see cref="LsaLookupNames" /> function can also retrieve computer accounts.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a <b>null</b>-terminated character string that specifies the name of the system. This string can be the name of a remote computer. If this string is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for  <i>lpSystemName</i> only when the  account is in an untrusted domain and the   name of a computer in that domain is known.</para>
    </param>
    <param name="lpAccountName">
      <para>A pointer to a <b>null</b>-terminated string that specifies the account name.</para>
      <para>Use a fully qualified string in the domain_name\user_name format to ensure that <b>LookupAccountName</b> finds the account in the desired domain.</para>
    </param>
    <param name="Sid">
      <para>A pointer to a buffer that receives the
<see cref="SID" /> structure that corresponds to the account name pointed to by the <i>lpAccountName</i> parameter. If this parameter is <b>NULL</b>, <i>cbSid</i> must be zero.</para>
    </param>
    <param name="cbSid">
      <para>A pointer to a variable. On input, this value specifies the size, in bytes, of the <i>Sid</i> buffer. If the function fails because the buffer is too small or if <i>cbSid</i> is zero, this variable receives the required buffer size.</para>
    </param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives the name of the domain where the account name is found. For computers that are not joined to a domain, this buffer receives the computer name. If this parameter is <b>NULL</b>, the function returns the required buffer size.</para>
    </param>
    <param name="cchReferencedDomainName">
      <para>A pointer to a variable. On input, this value specifies the size, in <b>TCHAR</b>s, of the <i>ReferencedDomainName</i> buffer. If the function fails because the buffer is too small, this variable receives the required buffer size, including the terminating <b>null</b> character. If the <i>ReferencedDomainName</i> parameter is <b>NULL</b>, this parameter must be zero.</para>
    </param>
    <param name="peUse">
      <para>A pointer to a
<see cref="SID_NAME_USE" /> enumerated type that indicates the type of the account when the function returns.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. For extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupAccountName</b> function attempts to find a SID for the specified name by first checking a list of well-known SIDs. If the name does not correspond to a well-known SID, the function checks built-in and administratively defined local accounts. Next, the function checks the primary domain. If the name is not found there, trusted domains are checked.</para>
      <para>Use fully qualified account names (for example, domain_name\user_name) instead of isolated names (for example, user_name). Fully qualified names are unambiguous and provide better performance when the lookup is performed. This function also supports fully qualified DNS names (for example, example.example.com\user_name) and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal names</a> (UPN) (for example, someone@example.com).</para>
      <para>In addition to looking up local accounts, local domain accounts, and explicitly trusted domain accounts, <b>LookupAccountName</b> can look up the name for any account in any domain in the forest.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupAccountName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="EqualPrefixSid" />
    <seealso cref="GetUserName" />
    <seealso cref="LookupAccountSid" />
    <seealso cref="LsaLookupNames2" />
    <seealso cref="SID" />
    <seealso cref="SID_NAME_USE" />
  </member>
  <member name="Windows.LookupAccountSid">
    <summary>
      <para>The <b>LookupAccountSid</b> function accepts a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) as input. It retrieves the name of the account for this SID and the name of the first domain on which this SID is found.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a <b>null</b>-terminated character string that specifies the target computer. This string can be the name of a remote computer. If this parameter is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for  <i>lpSystemName</i> only when the  account is in an untrusted domain and the   name of a computer in that domain is known.</para>
    </param>
    <param name="Sid">
      <para>A pointer to the
<see cref="SID" /> to look up.</para>
    </param>
    <param name="Name">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</para>
    </param>
    <param name="cchName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="peUse">
      <para>A pointer to a variable that receives a
<see cref="SID_NAME_USE" /> value that indicates the type of the account.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupAccountSid</b> function attempts to find a name for the specified SID by first checking a list of well-known SIDs. If the supplied SID does not correspond to a well-known SID, the function checks built-in and administratively defined local accounts. Next, the function checks the primary domain. <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">Security identifiers</a> not recognized by the primary domain are checked against the trusted domains that correspond to their SID prefixes.</para>
      <para>If the function cannot find an account name for the SID, <see cref="GetLastError" /> returns ERROR_NONE_MAPPED. This can occur if a network time-out prevents the function from finding the name. It also occurs for SIDs that have no corresponding account name, such as a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">logon SID</a> that identifies a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">logon session</a>.</para>
      <para>In addition to looking up SIDs for local accounts, local domain accounts, and explicitly trusted domain accounts, <b>LookupAccountSid</b> can look up SIDs for any account in any domain in the forest, including SIDs that appear only in the SIDhistory field of an account in the forest. The SIDhistory field stores former SIDs of an account that has been moved from another domain. To look up a SID, <b>LookupAccountSid</b> queries the global catalog of the forest.</para>
      <h4>Examples</h4>
      <para>For an example that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/searching-for-a-sid-in-an-access-token-in-c--">Searching for a SID in an Access Token</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupAccountSid as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="EqualPrefixSid" />
    <seealso cref="LookupAccountName" />
    <seealso cref="SID" />
    <seealso cref="SID_NAME_USE" />
  </member>
  <member name="Windows.LookupAccountSidA">
    <summary>
      <para>The <b>LookupAccountSid</b> function accepts a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) as input. It retrieves the name of the account for this SID and the name of the first domain on which this SID is found.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a <b>null</b>-terminated character string that specifies the target computer. This string can be the name of a remote computer. If this parameter is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for  <i>lpSystemName</i> only when the  account is in an untrusted domain and the   name of a computer in that domain is known.</para>
    </param>
    <param name="Sid">
      <para>A pointer to the
<see cref="SID" /> to look up.</para>
    </param>
    <param name="Name">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</para>
    </param>
    <param name="cchName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="peUse">
      <para>A pointer to a variable that receives a
<see cref="SID_NAME_USE" /> value that indicates the type of the account.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupAccountSid</b> function attempts to find a name for the specified SID by first checking a list of well-known SIDs. If the supplied SID does not correspond to a well-known SID, the function checks built-in and administratively defined local accounts. Next, the function checks the primary domain. <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">Security identifiers</a> not recognized by the primary domain are checked against the trusted domains that correspond to their SID prefixes.</para>
      <para>If the function cannot find an account name for the SID, <see cref="GetLastError" /> returns ERROR_NONE_MAPPED. This can occur if a network time-out prevents the function from finding the name. It also occurs for SIDs that have no corresponding account name, such as a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">logon SID</a> that identifies a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">logon session</a>.</para>
      <para>In addition to looking up SIDs for local accounts, local domain accounts, and explicitly trusted domain accounts, <b>LookupAccountSid</b> can look up SIDs for any account in any domain in the forest, including SIDs that appear only in the SIDhistory field of an account in the forest. The SIDhistory field stores former SIDs of an account that has been moved from another domain. To look up a SID, <b>LookupAccountSid</b> queries the global catalog of the forest.</para>
      <h4>Examples</h4>
      <para>For an example that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/searching-for-a-sid-in-an-access-token-in-c--">Searching for a SID in an Access Token</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupAccountSid as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="EqualPrefixSid" />
    <seealso cref="LookupAccountName" />
    <seealso cref="SID" />
    <seealso cref="SID_NAME_USE" />
  </member>
  <member name="Windows.LookupAccountSidW">
    <summary>
      <para>The <b>LookupAccountSid</b> function accepts a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) as input. It retrieves the name of the account for this SID and the name of the first domain on which this SID is found.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a <b>null</b>-terminated character string that specifies the target computer. This string can be the name of a remote computer. If this parameter is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for  <i>lpSystemName</i> only when the  account is in an untrusted domain and the   name of a computer in that domain is known.</para>
    </param>
    <param name="Sid">
      <para>A pointer to the
<see cref="SID" /> to look up.</para>
    </param>
    <param name="Name">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</para>
    </param>
    <param name="cchName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="peUse">
      <para>A pointer to a variable that receives a
<see cref="SID_NAME_USE" /> value that indicates the type of the account.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupAccountSid</b> function attempts to find a name for the specified SID by first checking a list of well-known SIDs. If the supplied SID does not correspond to a well-known SID, the function checks built-in and administratively defined local accounts. Next, the function checks the primary domain. <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">Security identifiers</a> not recognized by the primary domain are checked against the trusted domains that correspond to their SID prefixes.</para>
      <para>If the function cannot find an account name for the SID, <see cref="GetLastError" /> returns ERROR_NONE_MAPPED. This can occur if a network time-out prevents the function from finding the name. It also occurs for SIDs that have no corresponding account name, such as a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">logon SID</a> that identifies a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">logon session</a>.</para>
      <para>In addition to looking up SIDs for local accounts, local domain accounts, and explicitly trusted domain accounts, <b>LookupAccountSid</b> can look up SIDs for any account in any domain in the forest, including SIDs that appear only in the SIDhistory field of an account in the forest. The SIDhistory field stores former SIDs of an account that has been moved from another domain. To look up a SID, <b>LookupAccountSid</b> queries the global catalog of the forest.</para>
      <h4>Examples</h4>
      <para>For an example that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/searching-for-a-sid-in-an-access-token-in-c--">Searching for a SID in an Access Token</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupAccountSid as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="EqualPrefixSid" />
    <seealso cref="LookupAccountName" />
    <seealso cref="SID" />
    <seealso cref="SID_NAME_USE" />
  </member>
  <member name="Windows.LookupAccountSidLocal">
    <summary>
      <para>Retrieves the name of the account for the specified SID on the local machine.</para>
    </summary>
    <param name="Sid">
      <para>A pointer to the
<see cref="SID" /> to look up.</para>
    </param>
    <param name="Name">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</para>
    </param>
    <param name="cchName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="peUse">
      <para>A pointer to a variable that receives a
<see cref="SID_NAME_USE" /> value that indicates the type of the account.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function is similar to <see cref="LookupAccountSid" />, but restricts the search to the local machine.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupAccountSidLocal as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="EqualPrefixSid" />
    <seealso cref="LookupAccountName" />
    <seealso cref="SID" />
    <seealso cref="SID_NAME_USE" />
  </member>
  <member name="Windows.LookupAccountSidLocalA">
    <summary>
      <para>Retrieves the name of the account for the specified SID on the local machine.</para>
    </summary>
    <param name="Sid">
      <para>A pointer to the
<see cref="SID" /> to look up.</para>
    </param>
    <param name="Name">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</para>
    </param>
    <param name="cchName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="peUse">
      <para>A pointer to a variable that receives a
<see cref="SID_NAME_USE" /> value that indicates the type of the account.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function is similar to <see cref="LookupAccountSid" />, but restricts the search to the local machine.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupAccountSidLocal as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="EqualPrefixSid" />
    <seealso cref="LookupAccountName" />
    <seealso cref="SID" />
    <seealso cref="SID_NAME_USE" />
  </member>
  <member name="Windows.LookupAccountSidLocalW">
    <summary>
      <para>Retrieves the name of the account for the specified SID on the local machine.</para>
    </summary>
    <param name="Sid">
      <para>A pointer to the
<see cref="SID" /> to look up.</para>
    </param>
    <param name="Name">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</para>
    </param>
    <param name="cchName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="peUse">
      <para>A pointer to a variable that receives a
<see cref="SID_NAME_USE" /> value that indicates the type of the account.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function is similar to <see cref="LookupAccountSid" />, but restricts the search to the local machine.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupAccountSidLocal as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="EqualPrefixSid" />
    <seealso cref="LookupAccountName" />
    <seealso cref="SID" />
    <seealso cref="SID_NAME_USE" />
  </member>
  <member name="Windows.LookupAccountSidLocal">
    <summary>
      <para>Retrieves the name of the account for the specified SID on the local machine.</para>
    </summary>
    <param name="Sid">
      <para>A pointer to the
<see cref="SID" /> to look up.</para>
    </param>
    <param name="Name">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</para>
    </param>
    <param name="cchName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="peUse">
      <para>A pointer to a variable that receives a
<see cref="SID_NAME_USE" /> value that indicates the type of the account.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function is similar to <see cref="LookupAccountSid" />, but restricts the search to the local machine.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupAccountSidLocal as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="EqualPrefixSid" />
    <seealso cref="LookupAccountName" />
    <seealso cref="SID" />
    <seealso cref="SID_NAME_USE" />
  </member>
  <member name="Windows.LookupAccountSidLocalA">
    <summary>
      <para>Retrieves the name of the account for the specified SID on the local machine.</para>
    </summary>
    <param name="Sid">
      <para>A pointer to the
<see cref="SID" /> to look up.</para>
    </param>
    <param name="Name">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</para>
    </param>
    <param name="cchName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="peUse">
      <para>A pointer to a variable that receives a
<see cref="SID_NAME_USE" /> value that indicates the type of the account.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function is similar to <see cref="LookupAccountSid" />, but restricts the search to the local machine.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupAccountSidLocal as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="EqualPrefixSid" />
    <seealso cref="LookupAccountName" />
    <seealso cref="SID" />
    <seealso cref="SID_NAME_USE" />
  </member>
  <member name="Windows.LookupAccountSidLocalW">
    <summary>
      <para>Retrieves the name of the account for the specified SID on the local machine.</para>
    </summary>
    <param name="Sid">
      <para>A pointer to the
<see cref="SID" /> to look up.</para>
    </param>
    <param name="Name">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</para>
    </param>
    <param name="cchName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="peUse">
      <para>A pointer to a variable that receives a
<see cref="SID_NAME_USE" /> value that indicates the type of the account.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function is similar to <see cref="LookupAccountSid" />, but restricts the search to the local machine.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupAccountSidLocal as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="EqualPrefixSid" />
    <seealso cref="LookupAccountName" />
    <seealso cref="SID" />
    <seealso cref="SID_NAME_USE" />
  </member>
  <member name="Windows.LookupAccountSid">
    <summary>
      <para>The <b>LookupAccountSid</b> function accepts a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) as input. It retrieves the name of the account for this SID and the name of the first domain on which this SID is found.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a <b>null</b>-terminated character string that specifies the target computer. This string can be the name of a remote computer. If this parameter is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for  <i>lpSystemName</i> only when the  account is in an untrusted domain and the   name of a computer in that domain is known.</para>
    </param>
    <param name="Sid">
      <para>A pointer to the
<see cref="SID" /> to look up.</para>
    </param>
    <param name="Name">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</para>
    </param>
    <param name="cchName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="peUse">
      <para>A pointer to a variable that receives a
<see cref="SID_NAME_USE" /> value that indicates the type of the account.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupAccountSid</b> function attempts to find a name for the specified SID by first checking a list of well-known SIDs. If the supplied SID does not correspond to a well-known SID, the function checks built-in and administratively defined local accounts. Next, the function checks the primary domain. <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">Security identifiers</a> not recognized by the primary domain are checked against the trusted domains that correspond to their SID prefixes.</para>
      <para>If the function cannot find an account name for the SID, <see cref="GetLastError" /> returns ERROR_NONE_MAPPED. This can occur if a network time-out prevents the function from finding the name. It also occurs for SIDs that have no corresponding account name, such as a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">logon SID</a> that identifies a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">logon session</a>.</para>
      <para>In addition to looking up SIDs for local accounts, local domain accounts, and explicitly trusted domain accounts, <b>LookupAccountSid</b> can look up SIDs for any account in any domain in the forest, including SIDs that appear only in the SIDhistory field of an account in the forest. The SIDhistory field stores former SIDs of an account that has been moved from another domain. To look up a SID, <b>LookupAccountSid</b> queries the global catalog of the forest.</para>
      <h4>Examples</h4>
      <para>For an example that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/searching-for-a-sid-in-an-access-token-in-c--">Searching for a SID in an Access Token</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupAccountSid as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="EqualPrefixSid" />
    <seealso cref="LookupAccountName" />
    <seealso cref="SID" />
    <seealso cref="SID_NAME_USE" />
  </member>
  <member name="Windows.LookupAccountSidA">
    <summary>
      <para>The <b>LookupAccountSid</b> function accepts a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) as input. It retrieves the name of the account for this SID and the name of the first domain on which this SID is found.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a <b>null</b>-terminated character string that specifies the target computer. This string can be the name of a remote computer. If this parameter is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for  <i>lpSystemName</i> only when the  account is in an untrusted domain and the   name of a computer in that domain is known.</para>
    </param>
    <param name="Sid">
      <para>A pointer to the
<see cref="SID" /> to look up.</para>
    </param>
    <param name="Name">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</para>
    </param>
    <param name="cchName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="peUse">
      <para>A pointer to a variable that receives a
<see cref="SID_NAME_USE" /> value that indicates the type of the account.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupAccountSid</b> function attempts to find a name for the specified SID by first checking a list of well-known SIDs. If the supplied SID does not correspond to a well-known SID, the function checks built-in and administratively defined local accounts. Next, the function checks the primary domain. <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">Security identifiers</a> not recognized by the primary domain are checked against the trusted domains that correspond to their SID prefixes.</para>
      <para>If the function cannot find an account name for the SID, <see cref="GetLastError" /> returns ERROR_NONE_MAPPED. This can occur if a network time-out prevents the function from finding the name. It also occurs for SIDs that have no corresponding account name, such as a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">logon SID</a> that identifies a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">logon session</a>.</para>
      <para>In addition to looking up SIDs for local accounts, local domain accounts, and explicitly trusted domain accounts, <b>LookupAccountSid</b> can look up SIDs for any account in any domain in the forest, including SIDs that appear only in the SIDhistory field of an account in the forest. The SIDhistory field stores former SIDs of an account that has been moved from another domain. To look up a SID, <b>LookupAccountSid</b> queries the global catalog of the forest.</para>
      <h4>Examples</h4>
      <para>For an example that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/searching-for-a-sid-in-an-access-token-in-c--">Searching for a SID in an Access Token</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupAccountSid as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="EqualPrefixSid" />
    <seealso cref="LookupAccountName" />
    <seealso cref="SID" />
    <seealso cref="SID_NAME_USE" />
  </member>
  <member name="Windows.LookupAccountSidW">
    <summary>
      <para>The <b>LookupAccountSid</b> function accepts a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) as input. It retrieves the name of the account for this SID and the name of the first domain on which this SID is found.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a <b>null</b>-terminated character string that specifies the target computer. This string can be the name of a remote computer. If this parameter is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for  <i>lpSystemName</i> only when the  account is in an untrusted domain and the   name of a computer in that domain is known.</para>
    </param>
    <param name="Sid">
      <para>A pointer to the
<see cref="SID" /> to look up.</para>
    </param>
    <param name="Name">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</para>
    </param>
    <param name="cchName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">
      <para>On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</para>
    </param>
    <param name="peUse">
      <para>A pointer to a variable that receives a
<see cref="SID_NAME_USE" /> value that indicates the type of the account.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupAccountSid</b> function attempts to find a name for the specified SID by first checking a list of well-known SIDs. If the supplied SID does not correspond to a well-known SID, the function checks built-in and administratively defined local accounts. Next, the function checks the primary domain. <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">Security identifiers</a> not recognized by the primary domain are checked against the trusted domains that correspond to their SID prefixes.</para>
      <para>If the function cannot find an account name for the SID, <see cref="GetLastError" /> returns ERROR_NONE_MAPPED. This can occur if a network time-out prevents the function from finding the name. It also occurs for SIDs that have no corresponding account name, such as a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">logon SID</a> that identifies a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">logon session</a>.</para>
      <para>In addition to looking up SIDs for local accounts, local domain accounts, and explicitly trusted domain accounts, <b>LookupAccountSid</b> can look up SIDs for any account in any domain in the forest, including SIDs that appear only in the SIDhistory field of an account in the forest. The SIDhistory field stores former SIDs of an account that has been moved from another domain. To look up a SID, <b>LookupAccountSid</b> queries the global catalog of the forest.</para>
      <h4>Examples</h4>
      <para>For an example that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/searching-for-a-sid-in-an-access-token-in-c--">Searching for a SID in an Access Token</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupAccountSid as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="EqualPrefixSid" />
    <seealso cref="LookupAccountName" />
    <seealso cref="SID" />
    <seealso cref="SID_NAME_USE" />
  </member>
  <member name="Windows.LookupPrivilegeDisplayName">
    <summary>
      <para>The <b>LookupPrivilegeDisplayName</b> function retrieves the display name that represents a specified privilege.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a null-terminated string that specifies the name of the system on which the  privilege name is retrieved. If a null string is specified, the function attempts to find the display name on the local system.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a null-terminated string that specifies the name of the privilege, as defined in Winnt.h. For example, this parameter could specify the constant, SE_REMOTE_SHUTDOWN_NAME, or its corresponding string, "SeRemoteShutdownPrivilege". For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</para>
    </param>
    <param name="lpDisplayName">
      <para>A pointer to a buffer that receives a null-terminated string that specifies the privilege display name. For example, if the <i>lpName</i> parameter is SE_REMOTE_SHUTDOWN_NAME, the privilege display name is "Force shutdown from a remote system."</para>
    </param>
    <param name="cchDisplayName">
      <para>A pointer to a variable that specifies the size, in <b>TCHAR</b>s, of the <i>lpDisplayName</i> buffer. When the function returns, this parameter contains the length of the privilege display name, not including the terminating null character. If the buffer pointed to by the <i>lpDisplayName</i> parameter is too small, this variable contains the required size.</para>
    </param>
    <param name="lpLanguageId">
      <para>A pointer to a variable that receives the language identifier for the returned display name.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupPrivilegeDisplayName</b> function retrieves display names only for the privileges specified in the Defined Privileges section of Winnt.h.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupPrivilegeDisplayName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="LookupPrivilegeName" />
    <seealso cref="LookupPrivilegeValue" />
  </member>
  <member name="Windows.LookupPrivilegeDisplayNameA">
    <summary>
      <para>The <b>LookupPrivilegeDisplayName</b> function retrieves the display name that represents a specified privilege.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a null-terminated string that specifies the name of the system on which the  privilege name is retrieved. If a null string is specified, the function attempts to find the display name on the local system.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a null-terminated string that specifies the name of the privilege, as defined in Winnt.h. For example, this parameter could specify the constant, SE_REMOTE_SHUTDOWN_NAME, or its corresponding string, "SeRemoteShutdownPrivilege". For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</para>
    </param>
    <param name="lpDisplayName">
      <para>A pointer to a buffer that receives a null-terminated string that specifies the privilege display name. For example, if the <i>lpName</i> parameter is SE_REMOTE_SHUTDOWN_NAME, the privilege display name is "Force shutdown from a remote system."</para>
    </param>
    <param name="cchDisplayName">
      <para>A pointer to a variable that specifies the size, in <b>TCHAR</b>s, of the <i>lpDisplayName</i> buffer. When the function returns, this parameter contains the length of the privilege display name, not including the terminating null character. If the buffer pointed to by the <i>lpDisplayName</i> parameter is too small, this variable contains the required size.</para>
    </param>
    <param name="lpLanguageId">
      <para>A pointer to a variable that receives the language identifier for the returned display name.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupPrivilegeDisplayName</b> function retrieves display names only for the privileges specified in the Defined Privileges section of Winnt.h.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupPrivilegeDisplayName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="LookupPrivilegeName" />
    <seealso cref="LookupPrivilegeValue" />
  </member>
  <member name="Windows.LookupPrivilegeDisplayNameW">
    <summary>
      <para>The <b>LookupPrivilegeDisplayName</b> function retrieves the display name that represents a specified privilege.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a null-terminated string that specifies the name of the system on which the  privilege name is retrieved. If a null string is specified, the function attempts to find the display name on the local system.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a null-terminated string that specifies the name of the privilege, as defined in Winnt.h. For example, this parameter could specify the constant, SE_REMOTE_SHUTDOWN_NAME, or its corresponding string, "SeRemoteShutdownPrivilege". For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</para>
    </param>
    <param name="lpDisplayName">
      <para>A pointer to a buffer that receives a null-terminated string that specifies the privilege display name. For example, if the <i>lpName</i> parameter is SE_REMOTE_SHUTDOWN_NAME, the privilege display name is "Force shutdown from a remote system."</para>
    </param>
    <param name="cchDisplayName">
      <para>A pointer to a variable that specifies the size, in <b>TCHAR</b>s, of the <i>lpDisplayName</i> buffer. When the function returns, this parameter contains the length of the privilege display name, not including the terminating null character. If the buffer pointed to by the <i>lpDisplayName</i> parameter is too small, this variable contains the required size.</para>
    </param>
    <param name="lpLanguageId">
      <para>A pointer to a variable that receives the language identifier for the returned display name.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupPrivilegeDisplayName</b> function retrieves display names only for the privileges specified in the Defined Privileges section of Winnt.h.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupPrivilegeDisplayName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="LookupPrivilegeName" />
    <seealso cref="LookupPrivilegeValue" />
  </member>
  <member name="Windows.LookupPrivilegeDisplayName">
    <summary>
      <para>The <b>LookupPrivilegeDisplayName</b> function retrieves the display name that represents a specified privilege.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a null-terminated string that specifies the name of the system on which the  privilege name is retrieved. If a null string is specified, the function attempts to find the display name on the local system.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a null-terminated string that specifies the name of the privilege, as defined in Winnt.h. For example, this parameter could specify the constant, SE_REMOTE_SHUTDOWN_NAME, or its corresponding string, "SeRemoteShutdownPrivilege". For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</para>
    </param>
    <param name="lpDisplayName">
      <para>A pointer to a buffer that receives a null-terminated string that specifies the privilege display name. For example, if the <i>lpName</i> parameter is SE_REMOTE_SHUTDOWN_NAME, the privilege display name is "Force shutdown from a remote system."</para>
    </param>
    <param name="cchDisplayName">
      <para>A pointer to a variable that specifies the size, in <b>TCHAR</b>s, of the <i>lpDisplayName</i> buffer. When the function returns, this parameter contains the length of the privilege display name, not including the terminating null character. If the buffer pointed to by the <i>lpDisplayName</i> parameter is too small, this variable contains the required size.</para>
    </param>
    <param name="lpLanguageId">
      <para>A pointer to a variable that receives the language identifier for the returned display name.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupPrivilegeDisplayName</b> function retrieves display names only for the privileges specified in the Defined Privileges section of Winnt.h.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupPrivilegeDisplayName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="LookupPrivilegeName" />
    <seealso cref="LookupPrivilegeValue" />
  </member>
  <member name="Windows.LookupPrivilegeDisplayNameA">
    <summary>
      <para>The <b>LookupPrivilegeDisplayName</b> function retrieves the display name that represents a specified privilege.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a null-terminated string that specifies the name of the system on which the  privilege name is retrieved. If a null string is specified, the function attempts to find the display name on the local system.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a null-terminated string that specifies the name of the privilege, as defined in Winnt.h. For example, this parameter could specify the constant, SE_REMOTE_SHUTDOWN_NAME, or its corresponding string, "SeRemoteShutdownPrivilege". For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</para>
    </param>
    <param name="lpDisplayName">
      <para>A pointer to a buffer that receives a null-terminated string that specifies the privilege display name. For example, if the <i>lpName</i> parameter is SE_REMOTE_SHUTDOWN_NAME, the privilege display name is "Force shutdown from a remote system."</para>
    </param>
    <param name="cchDisplayName">
      <para>A pointer to a variable that specifies the size, in <b>TCHAR</b>s, of the <i>lpDisplayName</i> buffer. When the function returns, this parameter contains the length of the privilege display name, not including the terminating null character. If the buffer pointed to by the <i>lpDisplayName</i> parameter is too small, this variable contains the required size.</para>
    </param>
    <param name="lpLanguageId">
      <para>A pointer to a variable that receives the language identifier for the returned display name.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupPrivilegeDisplayName</b> function retrieves display names only for the privileges specified in the Defined Privileges section of Winnt.h.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupPrivilegeDisplayName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="LookupPrivilegeName" />
    <seealso cref="LookupPrivilegeValue" />
  </member>
  <member name="Windows.LookupPrivilegeDisplayNameW">
    <summary>
      <para>The <b>LookupPrivilegeDisplayName</b> function retrieves the display name that represents a specified privilege.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a null-terminated string that specifies the name of the system on which the  privilege name is retrieved. If a null string is specified, the function attempts to find the display name on the local system.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a null-terminated string that specifies the name of the privilege, as defined in Winnt.h. For example, this parameter could specify the constant, SE_REMOTE_SHUTDOWN_NAME, or its corresponding string, "SeRemoteShutdownPrivilege". For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</para>
    </param>
    <param name="lpDisplayName">
      <para>A pointer to a buffer that receives a null-terminated string that specifies the privilege display name. For example, if the <i>lpName</i> parameter is SE_REMOTE_SHUTDOWN_NAME, the privilege display name is "Force shutdown from a remote system."</para>
    </param>
    <param name="cchDisplayName">
      <para>A pointer to a variable that specifies the size, in <b>TCHAR</b>s, of the <i>lpDisplayName</i> buffer. When the function returns, this parameter contains the length of the privilege display name, not including the terminating null character. If the buffer pointed to by the <i>lpDisplayName</i> parameter is too small, this variable contains the required size.</para>
    </param>
    <param name="lpLanguageId">
      <para>A pointer to a variable that receives the language identifier for the returned display name.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupPrivilegeDisplayName</b> function retrieves display names only for the privileges specified in the Defined Privileges section of Winnt.h.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupPrivilegeDisplayName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control Overview</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="LookupPrivilegeName" />
    <seealso cref="LookupPrivilegeValue" />
  </member>
  <member name="Windows.LookupPrivilegeName">
    <summary>
      <para>The <b>LookupPrivilegeName</b> function retrieves the name that corresponds to the privilege represented on a specific system by a specified <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID).</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</para>
    </param>
    <param name="lpLuid">
      <para>A pointer to the LUID by which the privilege is known on the target system.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a buffer that receives a null-terminated string that represents the privilege name. For example, this string could be "SeSecurityPrivilege".</para>
    </param>
    <param name="cchName">
      <para>A pointer to a variable that specifies the size, in a <b>TCHAR</b> value, of the <i>lpName</i> buffer. When the function returns, this parameter contains the length of the privilege name, not including the terminating null character. If the buffer pointed to by the <i>lpName</i> parameter is too small, this variable contains the required size.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupPrivilegeName</b> function supports only the privileges specified in the Defined Privileges section of Winnt.h. For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupPrivilegeName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="LookupPrivilegeDisplayName" />
    <seealso cref="LookupPrivilegeValue" />
  </member>
  <member name="Windows.LookupPrivilegeNameA">
    <summary>
      <para>The <b>LookupPrivilegeName</b> function retrieves the name that corresponds to the privilege represented on a specific system by a specified <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID).</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</para>
    </param>
    <param name="lpLuid">
      <para>A pointer to the LUID by which the privilege is known on the target system.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a buffer that receives a null-terminated string that represents the privilege name. For example, this string could be "SeSecurityPrivilege".</para>
    </param>
    <param name="cchName">
      <para>A pointer to a variable that specifies the size, in a <b>TCHAR</b> value, of the <i>lpName</i> buffer. When the function returns, this parameter contains the length of the privilege name, not including the terminating null character. If the buffer pointed to by the <i>lpName</i> parameter is too small, this variable contains the required size.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupPrivilegeName</b> function supports only the privileges specified in the Defined Privileges section of Winnt.h. For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupPrivilegeName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="LookupPrivilegeDisplayName" />
    <seealso cref="LookupPrivilegeValue" />
  </member>
  <member name="Windows.LookupPrivilegeNameW">
    <summary>
      <para>The <b>LookupPrivilegeName</b> function retrieves the name that corresponds to the privilege represented on a specific system by a specified <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID).</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</para>
    </param>
    <param name="lpLuid">
      <para>A pointer to the LUID by which the privilege is known on the target system.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a buffer that receives a null-terminated string that represents the privilege name. For example, this string could be "SeSecurityPrivilege".</para>
    </param>
    <param name="cchName">
      <para>A pointer to a variable that specifies the size, in a <b>TCHAR</b> value, of the <i>lpName</i> buffer. When the function returns, this parameter contains the length of the privilege name, not including the terminating null character. If the buffer pointed to by the <i>lpName</i> parameter is too small, this variable contains the required size.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupPrivilegeName</b> function supports only the privileges specified in the Defined Privileges section of Winnt.h. For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupPrivilegeName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="LookupPrivilegeDisplayName" />
    <seealso cref="LookupPrivilegeValue" />
  </member>
  <member name="Windows.LookupPrivilegeName">
    <summary>
      <para>The <b>LookupPrivilegeName</b> function retrieves the name that corresponds to the privilege represented on a specific system by a specified <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID).</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</para>
    </param>
    <param name="lpLuid">
      <para>A pointer to the LUID by which the privilege is known on the target system.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a buffer that receives a null-terminated string that represents the privilege name. For example, this string could be "SeSecurityPrivilege".</para>
    </param>
    <param name="cchName">
      <para>A pointer to a variable that specifies the size, in a <b>TCHAR</b> value, of the <i>lpName</i> buffer. When the function returns, this parameter contains the length of the privilege name, not including the terminating null character. If the buffer pointed to by the <i>lpName</i> parameter is too small, this variable contains the required size.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupPrivilegeName</b> function supports only the privileges specified in the Defined Privileges section of Winnt.h. For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupPrivilegeName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="LookupPrivilegeDisplayName" />
    <seealso cref="LookupPrivilegeValue" />
  </member>
  <member name="Windows.LookupPrivilegeNameA">
    <summary>
      <para>The <b>LookupPrivilegeName</b> function retrieves the name that corresponds to the privilege represented on a specific system by a specified <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID).</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</para>
    </param>
    <param name="lpLuid">
      <para>A pointer to the LUID by which the privilege is known on the target system.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a buffer that receives a null-terminated string that represents the privilege name. For example, this string could be "SeSecurityPrivilege".</para>
    </param>
    <param name="cchName">
      <para>A pointer to a variable that specifies the size, in a <b>TCHAR</b> value, of the <i>lpName</i> buffer. When the function returns, this parameter contains the length of the privilege name, not including the terminating null character. If the buffer pointed to by the <i>lpName</i> parameter is too small, this variable contains the required size.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupPrivilegeName</b> function supports only the privileges specified in the Defined Privileges section of Winnt.h. For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupPrivilegeName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="LookupPrivilegeDisplayName" />
    <seealso cref="LookupPrivilegeValue" />
  </member>
  <member name="Windows.LookupPrivilegeNameW">
    <summary>
      <para>The <b>LookupPrivilegeName</b> function retrieves the name that corresponds to the privilege represented on a specific system by a specified <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID).</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</para>
    </param>
    <param name="lpLuid">
      <para>A pointer to the LUID by which the privilege is known on the target system.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a buffer that receives a null-terminated string that represents the privilege name. For example, this string could be "SeSecurityPrivilege".</para>
    </param>
    <param name="cchName">
      <para>A pointer to a variable that specifies the size, in a <b>TCHAR</b> value, of the <i>lpName</i> buffer. When the function returns, this parameter contains the length of the privilege name, not including the terminating null character. If the buffer pointed to by the <i>lpName</i> parameter is too small, this variable contains the required size.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupPrivilegeName</b> function supports only the privileges specified in the Defined Privileges section of Winnt.h. For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupPrivilegeName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="LookupPrivilegeDisplayName" />
    <seealso cref="LookupPrivilegeValue" />
  </member>
  <member name="Windows.LookupPrivilegeValue">
    <summary>
      <para>The <b>LookupPrivilegeValue</b> function retrieves the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID) used on a specified system to locally represent the specified privilege name.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a null-terminated string that specifies the name of the privilege, as defined in the Winnt.h header file. For example, this parameter could specify the constant, SE_SECURITY_NAME, or its corresponding string, "SeSecurityPrivilege".</para>
    </param>
    <param name="lpLuid">
      <para>A pointer to a variable that receives the LUID by which the privilege is known on the system specified by the <i>lpSystemName</i> parameter.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupPrivilegeValue</b> function supports only the privileges specified in the Defined Privileges section of Winnt.h. For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</para>
      <h4>Examples</h4>
      <para>For an example that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/enabling-and-disabling-privileges-in-c--">Enabling and Disabling Privileges</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupPrivilegeValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="LookupPrivilegeDisplayName" />
    <seealso cref="LookupPrivilegeName" />
  </member>
  <member name="Windows.LookupPrivilegeValueA">
    <summary>
      <para>The <b>LookupPrivilegeValue</b> function retrieves the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID) used on a specified system to locally represent the specified privilege name.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a null-terminated string that specifies the name of the privilege, as defined in the Winnt.h header file. For example, this parameter could specify the constant, SE_SECURITY_NAME, or its corresponding string, "SeSecurityPrivilege".</para>
    </param>
    <param name="lpLuid">
      <para>A pointer to a variable that receives the LUID by which the privilege is known on the system specified by the <i>lpSystemName</i> parameter.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupPrivilegeValue</b> function supports only the privileges specified in the Defined Privileges section of Winnt.h. For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</para>
      <h4>Examples</h4>
      <para>For an example that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/enabling-and-disabling-privileges-in-c--">Enabling and Disabling Privileges</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupPrivilegeValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="LookupPrivilegeDisplayName" />
    <seealso cref="LookupPrivilegeName" />
  </member>
  <member name="Windows.LookupPrivilegeValueW">
    <summary>
      <para>The <b>LookupPrivilegeValue</b> function retrieves the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID) used on a specified system to locally represent the specified privilege name.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a null-terminated string that specifies the name of the privilege, as defined in the Winnt.h header file. For example, this parameter could specify the constant, SE_SECURITY_NAME, or its corresponding string, "SeSecurityPrivilege".</para>
    </param>
    <param name="lpLuid">
      <para>A pointer to a variable that receives the LUID by which the privilege is known on the system specified by the <i>lpSystemName</i> parameter.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupPrivilegeValue</b> function supports only the privileges specified in the Defined Privileges section of Winnt.h. For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</para>
      <h4>Examples</h4>
      <para>For an example that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/enabling-and-disabling-privileges-in-c--">Enabling and Disabling Privileges</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupPrivilegeValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="LookupPrivilegeDisplayName" />
    <seealso cref="LookupPrivilegeName" />
  </member>
  <member name="Windows.LookupPrivilegeValue">
    <summary>
      <para>The <b>LookupPrivilegeValue</b> function retrieves the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID) used on a specified system to locally represent the specified privilege name.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a null-terminated string that specifies the name of the privilege, as defined in the Winnt.h header file. For example, this parameter could specify the constant, SE_SECURITY_NAME, or its corresponding string, "SeSecurityPrivilege".</para>
    </param>
    <param name="lpLuid">
      <para>A pointer to a variable that receives the LUID by which the privilege is known on the system specified by the <i>lpSystemName</i> parameter.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupPrivilegeValue</b> function supports only the privileges specified in the Defined Privileges section of Winnt.h. For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</para>
      <h4>Examples</h4>
      <para>For an example that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/enabling-and-disabling-privileges-in-c--">Enabling and Disabling Privileges</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupPrivilegeValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="LookupPrivilegeDisplayName" />
    <seealso cref="LookupPrivilegeName" />
  </member>
  <member name="Windows.LookupPrivilegeValueA">
    <summary>
      <para>The <b>LookupPrivilegeValue</b> function retrieves the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID) used on a specified system to locally represent the specified privilege name.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a null-terminated string that specifies the name of the privilege, as defined in the Winnt.h header file. For example, this parameter could specify the constant, SE_SECURITY_NAME, or its corresponding string, "SeSecurityPrivilege".</para>
    </param>
    <param name="lpLuid">
      <para>A pointer to a variable that receives the LUID by which the privilege is known on the system specified by the <i>lpSystemName</i> parameter.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupPrivilegeValue</b> function supports only the privileges specified in the Defined Privileges section of Winnt.h. For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</para>
      <h4>Examples</h4>
      <para>For an example that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/enabling-and-disabling-privileges-in-c--">Enabling and Disabling Privileges</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupPrivilegeValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="LookupPrivilegeDisplayName" />
    <seealso cref="LookupPrivilegeName" />
  </member>
  <member name="Windows.LookupPrivilegeValueW">
    <summary>
      <para>The <b>LookupPrivilegeValue</b> function retrieves the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID) used on a specified system to locally represent the specified privilege name.</para>
    </summary>
    <param name="lpSystemName">
      <para>A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</para>
    </param>
    <param name="lpName">
      <para>A pointer to a null-terminated string that specifies the name of the privilege, as defined in the Winnt.h header file. For example, this parameter could specify the constant, SE_SECURITY_NAME, or its corresponding string, "SeSecurityPrivilege".</para>
    </param>
    <param name="lpLuid">
      <para>A pointer to a variable that receives the LUID by which the privilege is known on the system specified by the <i>lpSystemName</i> parameter.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>LookupPrivilegeValue</b> function supports only the privileges specified in the Defined Privileges section of Winnt.h. For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</para>
      <h4>Examples</h4>
      <para>For an example that uses this function, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/enabling-and-disabling-privileges-in-c--">Enabling and Disabling Privileges</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines LookupPrivilegeValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Basic Access Control Functions</seealso>
    <seealso cref="LookupPrivilegeDisplayName" />
    <seealso cref="LookupPrivilegeName" />
  </member>
  <member name="Windows.lstrcat">
    <summary>
      <para>Appends one string to another.
<b>Warning</b>  Do not use. Consider using <see cref="StringCchCat" /> instead. See Security Considerations.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPTSTR</b></para>
      <para>The first null-terminated string. This buffer must be large enough
to contain both strings.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPTSTR</b></para>
      <para>The null-terminated string to be appended to the string
specified in the <i>lpString1</i> parameter.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b></para>
      <para>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbCat" />
    <seealso cref="StringCbCatEx" />
    <seealso cref="StringCbCatN" />
    <seealso cref="StringCbCatNEx" />
    <seealso cref="StringCchCat" />
    <seealso cref="StringCchCatEx" />
    <seealso cref="StringCchCatN" />
    <seealso cref="StringCchCatNEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcatA">
    <summary>
      <para>Appends one string to another.
<b>Warning</b>  Do not use. Consider using <see cref="StringCchCat" /> instead. See Security Considerations.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPTSTR</b></para>
      <para>The first null-terminated string. This buffer must be large enough
to contain both strings.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPTSTR</b></para>
      <para>The null-terminated string to be appended to the string
specified in the <i>lpString1</i> parameter.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b></para>
      <para>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbCat" />
    <seealso cref="StringCbCatEx" />
    <seealso cref="StringCbCatN" />
    <seealso cref="StringCbCatNEx" />
    <seealso cref="StringCchCat" />
    <seealso cref="StringCchCatEx" />
    <seealso cref="StringCchCatN" />
    <seealso cref="StringCchCatNEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcatW">
    <summary>
      <para>Appends one string to another.
<b>Warning</b>  Do not use. Consider using <see cref="StringCchCat" /> instead. See Security Considerations.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPTSTR</b></para>
      <para>The first null-terminated string. This buffer must be large enough
to contain both strings.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPTSTR</b></para>
      <para>The null-terminated string to be appended to the string
specified in the <i>lpString1</i> parameter.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b></para>
      <para>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbCat" />
    <seealso cref="StringCbCatEx" />
    <seealso cref="StringCbCatN" />
    <seealso cref="StringCbCatNEx" />
    <seealso cref="StringCchCat" />
    <seealso cref="StringCchCatEx" />
    <seealso cref="StringCchCatN" />
    <seealso cref="StringCchCatNEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcat">
    <summary>
      <para>Appends one string to another.
<b>Warning</b>  Do not use. Consider using <see cref="StringCchCat" /> instead. See Security Considerations.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPTSTR</b></para>
      <para>The first null-terminated string. This buffer must be large enough
to contain both strings.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPTSTR</b></para>
      <para>The null-terminated string to be appended to the string
specified in the <i>lpString1</i> parameter.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b></para>
      <para>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbCat" />
    <seealso cref="StringCbCatEx" />
    <seealso cref="StringCbCatN" />
    <seealso cref="StringCbCatNEx" />
    <seealso cref="StringCchCat" />
    <seealso cref="StringCchCatEx" />
    <seealso cref="StringCchCatN" />
    <seealso cref="StringCchCatNEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcatA">
    <summary>
      <para>Appends one string to another.
<b>Warning</b>  Do not use. Consider using <see cref="StringCchCat" /> instead. See Security Considerations.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPTSTR</b></para>
      <para>The first null-terminated string. This buffer must be large enough
to contain both strings.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPTSTR</b></para>
      <para>The null-terminated string to be appended to the string
specified in the <i>lpString1</i> parameter.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b></para>
      <para>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbCat" />
    <seealso cref="StringCbCatEx" />
    <seealso cref="StringCbCatN" />
    <seealso cref="StringCbCatNEx" />
    <seealso cref="StringCchCat" />
    <seealso cref="StringCchCatEx" />
    <seealso cref="StringCchCatN" />
    <seealso cref="StringCchCatNEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcatW">
    <summary>
      <para>Appends one string to another.
<b>Warning</b>  Do not use. Consider using <see cref="StringCchCat" /> instead. See Security Considerations.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPTSTR</b></para>
      <para>The first null-terminated string. This buffer must be large enough
to contain both strings.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPTSTR</b></para>
      <para>The null-terminated string to be appended to the string
specified in the <i>lpString1</i> parameter.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b></para>
      <para>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbCat" />
    <seealso cref="StringCbCatEx" />
    <seealso cref="StringCbCatN" />
    <seealso cref="StringCbCatNEx" />
    <seealso cref="StringCchCat" />
    <seealso cref="StringCchCatEx" />
    <seealso cref="StringCchCatN" />
    <seealso cref="StringCchCatNEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcmp">
    <summary>
      <para>Compares two character strings. The comparison is case-sensitive.</para>
      <para>To perform a comparison that is not case-sensitive, use the <see cref="lstrcmpi" /> function.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The first null-terminated string to be compared.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>If the string pointed to by
<i>lpString1</i> is less than the string pointed to by
<i>lpString2</i>, the return value is negative. If the string pointed to by
<i>lpString1</i> is greater than the string pointed to by
<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>lstrcmp</b> function compares two strings by checking the first characters against each other, the second characters against each other, and so on until it finds an inequality or reaches the ends of the strings.</para>
      <para>Note that the <i>lpString1</i> and <i>lpString2</i> parameters must be null-terminated, otherwise the string comparison can be incorrect.</para>
      <para>The function calls <see cref="CompareStringEx" />, using the current thread locale, and subtracts 2 from the result, to maintain the C run-time conventions for comparing strings.</para>
      <para>The language (user locale) selected by the user at setup time, or through Control Panel, determines which string is greater (or whether the strings are the same). If no language (user locale) is selected, the system performs the comparison by using default values.</para>
      <para>With a double-byte character set (DBCS) version of the system, this function can compare two DBCS strings.</para>
      <para>The <b>lstrcmp</b> function uses a word sort, rather than a string sort. A word sort treats hyphens and apostrophes differently than it treats other symbols that are not alphanumeric, in order to ensure that words such as "coop" and "co-op" stay together within a sorted list. For a detailed discussion of word sorts and string sorts, see <a href="https://docs.microsoft.com//windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.</para>
      <h3>Security Remarks</h3>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/Intl/security-considerations--international-features">Security Considerations: International Features</a> for security considerations regarding choice of comparison functions.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcmp as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="CompareStringEx" />
    <seealso cref="CompareStringOrdinal" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcat" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrcpy" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcmpA">
    <summary>
      <para>Compares two character strings. The comparison is case-sensitive.</para>
      <para>To perform a comparison that is not case-sensitive, use the <see cref="lstrcmpi" /> function.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The first null-terminated string to be compared.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>If the string pointed to by
<i>lpString1</i> is less than the string pointed to by
<i>lpString2</i>, the return value is negative. If the string pointed to by
<i>lpString1</i> is greater than the string pointed to by
<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>lstrcmp</b> function compares two strings by checking the first characters against each other, the second characters against each other, and so on until it finds an inequality or reaches the ends of the strings.</para>
      <para>Note that the <i>lpString1</i> and <i>lpString2</i> parameters must be null-terminated, otherwise the string comparison can be incorrect.</para>
      <para>The function calls <see cref="CompareStringEx" />, using the current thread locale, and subtracts 2 from the result, to maintain the C run-time conventions for comparing strings.</para>
      <para>The language (user locale) selected by the user at setup time, or through Control Panel, determines which string is greater (or whether the strings are the same). If no language (user locale) is selected, the system performs the comparison by using default values.</para>
      <para>With a double-byte character set (DBCS) version of the system, this function can compare two DBCS strings.</para>
      <para>The <b>lstrcmp</b> function uses a word sort, rather than a string sort. A word sort treats hyphens and apostrophes differently than it treats other symbols that are not alphanumeric, in order to ensure that words such as "coop" and "co-op" stay together within a sorted list. For a detailed discussion of word sorts and string sorts, see <a href="https://docs.microsoft.com//windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.</para>
      <h3>Security Remarks</h3>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/Intl/security-considerations--international-features">Security Considerations: International Features</a> for security considerations regarding choice of comparison functions.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcmp as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="CompareStringEx" />
    <seealso cref="CompareStringOrdinal" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcat" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrcpy" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcmpW">
    <summary>
      <para>Compares two character strings. The comparison is case-sensitive.</para>
      <para>To perform a comparison that is not case-sensitive, use the <see cref="lstrcmpi" /> function.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The first null-terminated string to be compared.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>If the string pointed to by
<i>lpString1</i> is less than the string pointed to by
<i>lpString2</i>, the return value is negative. If the string pointed to by
<i>lpString1</i> is greater than the string pointed to by
<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>lstrcmp</b> function compares two strings by checking the first characters against each other, the second characters against each other, and so on until it finds an inequality or reaches the ends of the strings.</para>
      <para>Note that the <i>lpString1</i> and <i>lpString2</i> parameters must be null-terminated, otherwise the string comparison can be incorrect.</para>
      <para>The function calls <see cref="CompareStringEx" />, using the current thread locale, and subtracts 2 from the result, to maintain the C run-time conventions for comparing strings.</para>
      <para>The language (user locale) selected by the user at setup time, or through Control Panel, determines which string is greater (or whether the strings are the same). If no language (user locale) is selected, the system performs the comparison by using default values.</para>
      <para>With a double-byte character set (DBCS) version of the system, this function can compare two DBCS strings.</para>
      <para>The <b>lstrcmp</b> function uses a word sort, rather than a string sort. A word sort treats hyphens and apostrophes differently than it treats other symbols that are not alphanumeric, in order to ensure that words such as "coop" and "co-op" stay together within a sorted list. For a detailed discussion of word sorts and string sorts, see <a href="https://docs.microsoft.com//windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.</para>
      <h3>Security Remarks</h3>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/Intl/security-considerations--international-features">Security Considerations: International Features</a> for security considerations regarding choice of comparison functions.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcmp as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="CompareStringEx" />
    <seealso cref="CompareStringOrdinal" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcat" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrcpy" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcmpi">
    <summary>
      <para>Compares two character strings. The comparison is not case-sensitive.</para>
      <para>To perform a comparison that is case-sensitive, use the <see cref="lstrcmp" /> function.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The first null-terminated string to be compared.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>If the string pointed to by
<i>lpString1</i> is less than the string pointed to by
<i>lpString2</i>, the return value is negative. If the string pointed to by
<i>lpString1</i> is greater than the string pointed to by
<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>lstrcmpi</b> function compares two strings by checking the first characters against each other, the second characters against each other, and so on until it finds an inequality or reaches the ends of the strings.</para>
      <para>Note that the <i>lpString1</i> and <i>lpString2</i> parameters must be null-terminated, otherwise the string comparison can be incorrect.</para>
      <para>The function calls <see cref="CompareStringEx" />, using the current thread locale, and subtracts 2 from the result, to maintain the C run-time conventions for comparing strings.</para>
      <para>For some locales, the <b>lstrcmpi</b> function may be insufficient. If this occurs, use <see cref="CompareStringEx" /> to ensure proper comparison. For example, in Japan call  with the <b>NORM_IGNORECASE</b>, <b>NORM_IGNOREKANATYPE</b>, and  <b>NORM_IGNOREWIDTH</b>  values to achieve the most appropriate non-exact string comparison. The <b>NORM_IGNOREKANATYPE</b> and <b>NORM_IGNOREWIDTH</b> values are ignored in non-Asian locales, so you can set these values for all locales and be guaranteed to have a culturally correct "insensitive" sorting regardless of the locale. Note that specifying these values slows performance, so use them only when necessary.</para>
      <para>With a double-byte character set (DBCS) version of the system, this function can compare two DBCS strings.</para>
      <para>The <b>lstrcmpi</b> function uses a word sort, rather than a string sort. A word sort treats hyphens and apostrophes differently than it treats other symbols that are not alphanumeric, in order to ensure that words such as "coop" and "co-op" stay together within a sorted list. For a detailed discussion of word sorts and string sorts, see <a href="https://docs.microsoft.com//windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.</para>
      <h3>Security Remarks</h3>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/Intl/security-considerations--international-features">Security Considerations: International Features</a> for security considerations regarding choice of comparison functions.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcmpi as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="CompareStringEx" />
    <seealso cref="CompareStringOrdinal" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcat" />
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcpy" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcmpiA">
    <summary>
      <para>Compares two character strings. The comparison is not case-sensitive.</para>
      <para>To perform a comparison that is case-sensitive, use the <see cref="lstrcmp" /> function.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The first null-terminated string to be compared.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>If the string pointed to by
<i>lpString1</i> is less than the string pointed to by
<i>lpString2</i>, the return value is negative. If the string pointed to by
<i>lpString1</i> is greater than the string pointed to by
<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>lstrcmpi</b> function compares two strings by checking the first characters against each other, the second characters against each other, and so on until it finds an inequality or reaches the ends of the strings.</para>
      <para>Note that the <i>lpString1</i> and <i>lpString2</i> parameters must be null-terminated, otherwise the string comparison can be incorrect.</para>
      <para>The function calls <see cref="CompareStringEx" />, using the current thread locale, and subtracts 2 from the result, to maintain the C run-time conventions for comparing strings.</para>
      <para>For some locales, the <b>lstrcmpi</b> function may be insufficient. If this occurs, use <see cref="CompareStringEx" /> to ensure proper comparison. For example, in Japan call  with the <b>NORM_IGNORECASE</b>, <b>NORM_IGNOREKANATYPE</b>, and  <b>NORM_IGNOREWIDTH</b>  values to achieve the most appropriate non-exact string comparison. The <b>NORM_IGNOREKANATYPE</b> and <b>NORM_IGNOREWIDTH</b> values are ignored in non-Asian locales, so you can set these values for all locales and be guaranteed to have a culturally correct "insensitive" sorting regardless of the locale. Note that specifying these values slows performance, so use them only when necessary.</para>
      <para>With a double-byte character set (DBCS) version of the system, this function can compare two DBCS strings.</para>
      <para>The <b>lstrcmpi</b> function uses a word sort, rather than a string sort. A word sort treats hyphens and apostrophes differently than it treats other symbols that are not alphanumeric, in order to ensure that words such as "coop" and "co-op" stay together within a sorted list. For a detailed discussion of word sorts and string sorts, see <a href="https://docs.microsoft.com//windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.</para>
      <h3>Security Remarks</h3>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/Intl/security-considerations--international-features">Security Considerations: International Features</a> for security considerations regarding choice of comparison functions.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcmpi as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="CompareStringEx" />
    <seealso cref="CompareStringOrdinal" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcat" />
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcpy" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcmpiW">
    <summary>
      <para>Compares two character strings. The comparison is not case-sensitive.</para>
      <para>To perform a comparison that is case-sensitive, use the <see cref="lstrcmp" /> function.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The first null-terminated string to be compared.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>If the string pointed to by
<i>lpString1</i> is less than the string pointed to by
<i>lpString2</i>, the return value is negative. If the string pointed to by
<i>lpString1</i> is greater than the string pointed to by
<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>lstrcmpi</b> function compares two strings by checking the first characters against each other, the second characters against each other, and so on until it finds an inequality or reaches the ends of the strings.</para>
      <para>Note that the <i>lpString1</i> and <i>lpString2</i> parameters must be null-terminated, otherwise the string comparison can be incorrect.</para>
      <para>The function calls <see cref="CompareStringEx" />, using the current thread locale, and subtracts 2 from the result, to maintain the C run-time conventions for comparing strings.</para>
      <para>For some locales, the <b>lstrcmpi</b> function may be insufficient. If this occurs, use <see cref="CompareStringEx" /> to ensure proper comparison. For example, in Japan call  with the <b>NORM_IGNORECASE</b>, <b>NORM_IGNOREKANATYPE</b>, and  <b>NORM_IGNOREWIDTH</b>  values to achieve the most appropriate non-exact string comparison. The <b>NORM_IGNOREKANATYPE</b> and <b>NORM_IGNOREWIDTH</b> values are ignored in non-Asian locales, so you can set these values for all locales and be guaranteed to have a culturally correct "insensitive" sorting regardless of the locale. Note that specifying these values slows performance, so use them only when necessary.</para>
      <para>With a double-byte character set (DBCS) version of the system, this function can compare two DBCS strings.</para>
      <para>The <b>lstrcmpi</b> function uses a word sort, rather than a string sort. A word sort treats hyphens and apostrophes differently than it treats other symbols that are not alphanumeric, in order to ensure that words such as "coop" and "co-op" stay together within a sorted list. For a detailed discussion of word sorts and string sorts, see <a href="https://docs.microsoft.com//windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.</para>
      <h3>Security Remarks</h3>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/Intl/security-considerations--international-features">Security Considerations: International Features</a> for security considerations regarding choice of comparison functions.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcmpi as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="CompareStringEx" />
    <seealso cref="CompareStringOrdinal" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcat" />
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcpy" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcmpi">
    <summary>
      <para>Compares two character strings. The comparison is not case-sensitive.</para>
      <para>To perform a comparison that is case-sensitive, use the <see cref="lstrcmp" /> function.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The first null-terminated string to be compared.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>If the string pointed to by
<i>lpString1</i> is less than the string pointed to by
<i>lpString2</i>, the return value is negative. If the string pointed to by
<i>lpString1</i> is greater than the string pointed to by
<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>lstrcmpi</b> function compares two strings by checking the first characters against each other, the second characters against each other, and so on until it finds an inequality or reaches the ends of the strings.</para>
      <para>Note that the <i>lpString1</i> and <i>lpString2</i> parameters must be null-terminated, otherwise the string comparison can be incorrect.</para>
      <para>The function calls <see cref="CompareStringEx" />, using the current thread locale, and subtracts 2 from the result, to maintain the C run-time conventions for comparing strings.</para>
      <para>For some locales, the <b>lstrcmpi</b> function may be insufficient. If this occurs, use <see cref="CompareStringEx" /> to ensure proper comparison. For example, in Japan call  with the <b>NORM_IGNORECASE</b>, <b>NORM_IGNOREKANATYPE</b>, and  <b>NORM_IGNOREWIDTH</b>  values to achieve the most appropriate non-exact string comparison. The <b>NORM_IGNOREKANATYPE</b> and <b>NORM_IGNOREWIDTH</b> values are ignored in non-Asian locales, so you can set these values for all locales and be guaranteed to have a culturally correct "insensitive" sorting regardless of the locale. Note that specifying these values slows performance, so use them only when necessary.</para>
      <para>With a double-byte character set (DBCS) version of the system, this function can compare two DBCS strings.</para>
      <para>The <b>lstrcmpi</b> function uses a word sort, rather than a string sort. A word sort treats hyphens and apostrophes differently than it treats other symbols that are not alphanumeric, in order to ensure that words such as "coop" and "co-op" stay together within a sorted list. For a detailed discussion of word sorts and string sorts, see <a href="https://docs.microsoft.com//windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.</para>
      <h3>Security Remarks</h3>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/Intl/security-considerations--international-features">Security Considerations: International Features</a> for security considerations regarding choice of comparison functions.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcmpi as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="CompareStringEx" />
    <seealso cref="CompareStringOrdinal" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcat" />
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcpy" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcmpiA">
    <summary>
      <para>Compares two character strings. The comparison is not case-sensitive.</para>
      <para>To perform a comparison that is case-sensitive, use the <see cref="lstrcmp" /> function.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The first null-terminated string to be compared.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>If the string pointed to by
<i>lpString1</i> is less than the string pointed to by
<i>lpString2</i>, the return value is negative. If the string pointed to by
<i>lpString1</i> is greater than the string pointed to by
<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>lstrcmpi</b> function compares two strings by checking the first characters against each other, the second characters against each other, and so on until it finds an inequality or reaches the ends of the strings.</para>
      <para>Note that the <i>lpString1</i> and <i>lpString2</i> parameters must be null-terminated, otherwise the string comparison can be incorrect.</para>
      <para>The function calls <see cref="CompareStringEx" />, using the current thread locale, and subtracts 2 from the result, to maintain the C run-time conventions for comparing strings.</para>
      <para>For some locales, the <b>lstrcmpi</b> function may be insufficient. If this occurs, use <see cref="CompareStringEx" /> to ensure proper comparison. For example, in Japan call  with the <b>NORM_IGNORECASE</b>, <b>NORM_IGNOREKANATYPE</b>, and  <b>NORM_IGNOREWIDTH</b>  values to achieve the most appropriate non-exact string comparison. The <b>NORM_IGNOREKANATYPE</b> and <b>NORM_IGNOREWIDTH</b> values are ignored in non-Asian locales, so you can set these values for all locales and be guaranteed to have a culturally correct "insensitive" sorting regardless of the locale. Note that specifying these values slows performance, so use them only when necessary.</para>
      <para>With a double-byte character set (DBCS) version of the system, this function can compare two DBCS strings.</para>
      <para>The <b>lstrcmpi</b> function uses a word sort, rather than a string sort. A word sort treats hyphens and apostrophes differently than it treats other symbols that are not alphanumeric, in order to ensure that words such as "coop" and "co-op" stay together within a sorted list. For a detailed discussion of word sorts and string sorts, see <a href="https://docs.microsoft.com//windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.</para>
      <h3>Security Remarks</h3>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/Intl/security-considerations--international-features">Security Considerations: International Features</a> for security considerations regarding choice of comparison functions.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcmpi as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="CompareStringEx" />
    <seealso cref="CompareStringOrdinal" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcat" />
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcpy" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcmpiW">
    <summary>
      <para>Compares two character strings. The comparison is not case-sensitive.</para>
      <para>To perform a comparison that is case-sensitive, use the <see cref="lstrcmp" /> function.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The first null-terminated string to be compared.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>If the string pointed to by
<i>lpString1</i> is less than the string pointed to by
<i>lpString2</i>, the return value is negative. If the string pointed to by
<i>lpString1</i> is greater than the string pointed to by
<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>lstrcmpi</b> function compares two strings by checking the first characters against each other, the second characters against each other, and so on until it finds an inequality or reaches the ends of the strings.</para>
      <para>Note that the <i>lpString1</i> and <i>lpString2</i> parameters must be null-terminated, otherwise the string comparison can be incorrect.</para>
      <para>The function calls <see cref="CompareStringEx" />, using the current thread locale, and subtracts 2 from the result, to maintain the C run-time conventions for comparing strings.</para>
      <para>For some locales, the <b>lstrcmpi</b> function may be insufficient. If this occurs, use <see cref="CompareStringEx" /> to ensure proper comparison. For example, in Japan call  with the <b>NORM_IGNORECASE</b>, <b>NORM_IGNOREKANATYPE</b>, and  <b>NORM_IGNOREWIDTH</b>  values to achieve the most appropriate non-exact string comparison. The <b>NORM_IGNOREKANATYPE</b> and <b>NORM_IGNOREWIDTH</b> values are ignored in non-Asian locales, so you can set these values for all locales and be guaranteed to have a culturally correct "insensitive" sorting regardless of the locale. Note that specifying these values slows performance, so use them only when necessary.</para>
      <para>With a double-byte character set (DBCS) version of the system, this function can compare two DBCS strings.</para>
      <para>The <b>lstrcmpi</b> function uses a word sort, rather than a string sort. A word sort treats hyphens and apostrophes differently than it treats other symbols that are not alphanumeric, in order to ensure that words such as "coop" and "co-op" stay together within a sorted list. For a detailed discussion of word sorts and string sorts, see <a href="https://docs.microsoft.com//windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.</para>
      <h3>Security Remarks</h3>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/Intl/security-considerations--international-features">Security Considerations: International Features</a> for security considerations regarding choice of comparison functions.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcmpi as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="CompareStringEx" />
    <seealso cref="CompareStringOrdinal" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcat" />
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcpy" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcmp">
    <summary>
      <para>Compares two character strings. The comparison is case-sensitive.</para>
      <para>To perform a comparison that is not case-sensitive, use the <see cref="lstrcmpi" /> function.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The first null-terminated string to be compared.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>If the string pointed to by
<i>lpString1</i> is less than the string pointed to by
<i>lpString2</i>, the return value is negative. If the string pointed to by
<i>lpString1</i> is greater than the string pointed to by
<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>lstrcmp</b> function compares two strings by checking the first characters against each other, the second characters against each other, and so on until it finds an inequality or reaches the ends of the strings.</para>
      <para>Note that the <i>lpString1</i> and <i>lpString2</i> parameters must be null-terminated, otherwise the string comparison can be incorrect.</para>
      <para>The function calls <see cref="CompareStringEx" />, using the current thread locale, and subtracts 2 from the result, to maintain the C run-time conventions for comparing strings.</para>
      <para>The language (user locale) selected by the user at setup time, or through Control Panel, determines which string is greater (or whether the strings are the same). If no language (user locale) is selected, the system performs the comparison by using default values.</para>
      <para>With a double-byte character set (DBCS) version of the system, this function can compare two DBCS strings.</para>
      <para>The <b>lstrcmp</b> function uses a word sort, rather than a string sort. A word sort treats hyphens and apostrophes differently than it treats other symbols that are not alphanumeric, in order to ensure that words such as "coop" and "co-op" stay together within a sorted list. For a detailed discussion of word sorts and string sorts, see <a href="https://docs.microsoft.com//windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.</para>
      <h3>Security Remarks</h3>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/Intl/security-considerations--international-features">Security Considerations: International Features</a> for security considerations regarding choice of comparison functions.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcmp as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="CompareStringEx" />
    <seealso cref="CompareStringOrdinal" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcat" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrcpy" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcmpA">
    <summary>
      <para>Compares two character strings. The comparison is case-sensitive.</para>
      <para>To perform a comparison that is not case-sensitive, use the <see cref="lstrcmpi" /> function.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The first null-terminated string to be compared.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>If the string pointed to by
<i>lpString1</i> is less than the string pointed to by
<i>lpString2</i>, the return value is negative. If the string pointed to by
<i>lpString1</i> is greater than the string pointed to by
<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>lstrcmp</b> function compares two strings by checking the first characters against each other, the second characters against each other, and so on until it finds an inequality or reaches the ends of the strings.</para>
      <para>Note that the <i>lpString1</i> and <i>lpString2</i> parameters must be null-terminated, otherwise the string comparison can be incorrect.</para>
      <para>The function calls <see cref="CompareStringEx" />, using the current thread locale, and subtracts 2 from the result, to maintain the C run-time conventions for comparing strings.</para>
      <para>The language (user locale) selected by the user at setup time, or through Control Panel, determines which string is greater (or whether the strings are the same). If no language (user locale) is selected, the system performs the comparison by using default values.</para>
      <para>With a double-byte character set (DBCS) version of the system, this function can compare two DBCS strings.</para>
      <para>The <b>lstrcmp</b> function uses a word sort, rather than a string sort. A word sort treats hyphens and apostrophes differently than it treats other symbols that are not alphanumeric, in order to ensure that words such as "coop" and "co-op" stay together within a sorted list. For a detailed discussion of word sorts and string sorts, see <a href="https://docs.microsoft.com//windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.</para>
      <h3>Security Remarks</h3>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/Intl/security-considerations--international-features">Security Considerations: International Features</a> for security considerations regarding choice of comparison functions.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcmp as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="CompareStringEx" />
    <seealso cref="CompareStringOrdinal" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcat" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrcpy" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcmpW">
    <summary>
      <para>Compares two character strings. The comparison is case-sensitive.</para>
      <para>To perform a comparison that is not case-sensitive, use the <see cref="lstrcmpi" /> function.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The first null-terminated string to be compared.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>If the string pointed to by
<i>lpString1</i> is less than the string pointed to by
<i>lpString2</i>, the return value is negative. If the string pointed to by
<i>lpString1</i> is greater than the string pointed to by
<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</para>
    </returns>
    <remarks>
      <para>The <b>lstrcmp</b> function compares two strings by checking the first characters against each other, the second characters against each other, and so on until it finds an inequality or reaches the ends of the strings.</para>
      <para>Note that the <i>lpString1</i> and <i>lpString2</i> parameters must be null-terminated, otherwise the string comparison can be incorrect.</para>
      <para>The function calls <see cref="CompareStringEx" />, using the current thread locale, and subtracts 2 from the result, to maintain the C run-time conventions for comparing strings.</para>
      <para>The language (user locale) selected by the user at setup time, or through Control Panel, determines which string is greater (or whether the strings are the same). If no language (user locale) is selected, the system performs the comparison by using default values.</para>
      <para>With a double-byte character set (DBCS) version of the system, this function can compare two DBCS strings.</para>
      <para>The <b>lstrcmp</b> function uses a word sort, rather than a string sort. A word sort treats hyphens and apostrophes differently than it treats other symbols that are not alphanumeric, in order to ensure that words such as "coop" and "co-op" stay together within a sorted list. For a detailed discussion of word sorts and string sorts, see <a href="https://docs.microsoft.com//windows/desktop/Intl/handling-sorting-in-your-applications">Handling Sorting in Your Applications</a>.</para>
      <h3>Security Remarks</h3>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/Intl/security-considerations--international-features">Security Considerations: International Features</a> for security considerations regarding choice of comparison functions.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcmp as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="CompareStringEx" />
    <seealso cref="CompareStringOrdinal" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcat" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrcpy" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcpy">
    <summary>
      <para>Copies a string to a buffer.
<b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPTSTR</b></para>
      <para>A buffer to receive the contents of the string pointed to by the
<i>lpString2</i> parameter.
The buffer must be large enough to contain the string, including the
terminating null character.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPTSTR</b></para>
      <para>The null-terminated string to be copied.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b></para>
      <para>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
    <remarks>
      <para>With a double-byte character set (DBCS) version of the system, this function can be used
to copy a DBCS string.</para>
      <para>The <b>lstrcpy</b> function has an
undefined behavior if source and destination buffers overlap.</para>
      <h3>Security Remarks</h3>
      <para>Using this function incorrectly can compromise the security
of your application. This function uses structured exception handling (SEH) to catch
access violations and other errors. When this function catches SEH errors, it returns
<b>NULL</b> without null-terminating the string and without notifying the
caller of the error. The caller is not safe to assume that insufficient space is
the error condition.</para>
      <para>
        <i>lpString1</i> must be large enough to hold <i>lpString2</i></para>
      <para>and the closing '\0', otherwise a buffer overrun may occur.</para>
      <para>Buffer overflow situations are the cause of many security problems in applications and
can cause a denial of service attack against the application if an access violation occurs.
In the worst case, a buffer overrun may allow an attacker to inject executable code into
your process, especially if <i>lpString1</i> is a stack-based buffer.</para>
      <para>Consider using <see cref="StringCchCopy" /> instead; use either
<code>StringCchCopy(buffer, sizeof(buffer)/sizeof(buffer[0]), src);</code>,
being aware that <code>buffer</code> must not be a pointer or
use <code>StringCchCopy(buffer, ARRAYSIZE(buffer), src);</code>,
being aware that, when copying to a pointer, the caller is responsible for
passing in the size of the pointed-to memory in characters.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcpy as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbCopy" />
    <seealso cref="StringCbCopyEx" />
    <seealso cref="StringCbCopyN" />
    <seealso cref="StringCbCopyNEx" />
    <seealso cref="StringCchCopy" />
    <seealso cref="StringCchCopyEx" />
    <seealso cref="StringCchCopyN" />
    <seealso cref="StringCchCopyNEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcpyA">
    <summary>
      <para>Copies a string to a buffer.
<b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPTSTR</b></para>
      <para>A buffer to receive the contents of the string pointed to by the
<i>lpString2</i> parameter.
The buffer must be large enough to contain the string, including the
terminating null character.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPTSTR</b></para>
      <para>The null-terminated string to be copied.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b></para>
      <para>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
    <remarks>
      <para>With a double-byte character set (DBCS) version of the system, this function can be used
to copy a DBCS string.</para>
      <para>The <b>lstrcpy</b> function has an
undefined behavior if source and destination buffers overlap.</para>
      <h3>Security Remarks</h3>
      <para>Using this function incorrectly can compromise the security
of your application. This function uses structured exception handling (SEH) to catch
access violations and other errors. When this function catches SEH errors, it returns
<b>NULL</b> without null-terminating the string and without notifying the
caller of the error. The caller is not safe to assume that insufficient space is
the error condition.</para>
      <para>
        <i>lpString1</i> must be large enough to hold <i>lpString2</i></para>
      <para>and the closing '\0', otherwise a buffer overrun may occur.</para>
      <para>Buffer overflow situations are the cause of many security problems in applications and
can cause a denial of service attack against the application if an access violation occurs.
In the worst case, a buffer overrun may allow an attacker to inject executable code into
your process, especially if <i>lpString1</i> is a stack-based buffer.</para>
      <para>Consider using <see cref="StringCchCopy" /> instead; use either
<code>StringCchCopy(buffer, sizeof(buffer)/sizeof(buffer[0]), src);</code>,
being aware that <code>buffer</code> must not be a pointer or
use <code>StringCchCopy(buffer, ARRAYSIZE(buffer), src);</code>,
being aware that, when copying to a pointer, the caller is responsible for
passing in the size of the pointed-to memory in characters.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcpy as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbCopy" />
    <seealso cref="StringCbCopyEx" />
    <seealso cref="StringCbCopyN" />
    <seealso cref="StringCbCopyNEx" />
    <seealso cref="StringCchCopy" />
    <seealso cref="StringCchCopyEx" />
    <seealso cref="StringCchCopyN" />
    <seealso cref="StringCchCopyNEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcpyW">
    <summary>
      <para>Copies a string to a buffer.
<b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPTSTR</b></para>
      <para>A buffer to receive the contents of the string pointed to by the
<i>lpString2</i> parameter.
The buffer must be large enough to contain the string, including the
terminating null character.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPTSTR</b></para>
      <para>The null-terminated string to be copied.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b></para>
      <para>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
    <remarks>
      <para>With a double-byte character set (DBCS) version of the system, this function can be used
to copy a DBCS string.</para>
      <para>The <b>lstrcpy</b> function has an
undefined behavior if source and destination buffers overlap.</para>
      <h3>Security Remarks</h3>
      <para>Using this function incorrectly can compromise the security
of your application. This function uses structured exception handling (SEH) to catch
access violations and other errors. When this function catches SEH errors, it returns
<b>NULL</b> without null-terminating the string and without notifying the
caller of the error. The caller is not safe to assume that insufficient space is
the error condition.</para>
      <para>
        <i>lpString1</i> must be large enough to hold <i>lpString2</i></para>
      <para>and the closing '\0', otherwise a buffer overrun may occur.</para>
      <para>Buffer overflow situations are the cause of many security problems in applications and
can cause a denial of service attack against the application if an access violation occurs.
In the worst case, a buffer overrun may allow an attacker to inject executable code into
your process, especially if <i>lpString1</i> is a stack-based buffer.</para>
      <para>Consider using <see cref="StringCchCopy" /> instead; use either
<code>StringCchCopy(buffer, sizeof(buffer)/sizeof(buffer[0]), src);</code>,
being aware that <code>buffer</code> must not be a pointer or
use <code>StringCchCopy(buffer, ARRAYSIZE(buffer), src);</code>,
being aware that, when copying to a pointer, the caller is responsible for
passing in the size of the pointed-to memory in characters.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcpy as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbCopy" />
    <seealso cref="StringCbCopyEx" />
    <seealso cref="StringCbCopyN" />
    <seealso cref="StringCbCopyNEx" />
    <seealso cref="StringCchCopy" />
    <seealso cref="StringCchCopyEx" />
    <seealso cref="StringCchCopyN" />
    <seealso cref="StringCchCopyNEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcpyn">
    <summary>
      <para>Copies a specified number of characters from a source string into a buffer.
<b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPTSTR</b></para>
      <para>The destination buffer, which receives the copied characters. The buffer
must be large enough to contain the number of <b>TCHAR</b> values
specified by <i>iMaxLength</i>, including room
for a terminating null character.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The source string from which the function is to copy characters.</para>
    </param>
    <param name="iMaxLength">
      <para>Type: <b>int</b></para>
      <para>The number of <b>TCHAR</b> values to be copied from the
string pointed to by <i>lpString2</i> into the
buffer pointed to by <i>lpString1</i>, including
a terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>If the function succeeds, the return value is a pointer to the buffer.
The function can succeed even if the source string is greater than
<i>iMaxLength</i> characters.</para>
      <para>If the function fails, the return value is <b>NULL</b></para>
      <para>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
    <remarks>
      <para>The buffer pointed to by <i>lpString1</i> must
be large enough to include a terminating null character, and the string length
value specified by <i>iMaxLength</i> includes room
for a terminating null character.</para>
      <para>The <b>lstrcpyn</b> function has an undefined behavior if source
and destination buffers overlap.</para>
      <h3>Security Warning</h3>
      <para>Using this function incorrectly can compromise the security
of your application. This function uses structured exception handling (SEH) to catch
access violations and other errors. When this function catches SEH errors, it returns
<b>NULL</b> without null-terminating the string and without notifying the
caller of the error. The caller is not safe to assume that insufficient space is
the error condition.</para>
      <para>If the buffer pointed to by <i>lpString1</i> is not large
enough to contain the copied string, a buffer overrun can occur. When copying an entire
string, note that <b>sizeof</b> returns the number of bytes.
For example, if <i>lpString1</i> points to a buffer
<i>szString1</i> which is declared as
<code>TCHAR szString[100]</code>, then sizeof(szString1) gives the size of
the buffer in bytes rather than <b>WCHAR</b>, which could lead to a buffer
overflow for the Unicode version of the function.</para>
      <para>Buffer overflow situations are the cause
of many security problems in applications and can cause a denial of service attack against
the application if an access violation occurs. In the worst case, a buffer overrun may
allow an attacker to inject executable code into your process, especially if
<i>lpString1</i> is a stack-based buffer.</para>
      <para>Using <code>sizeof(szString1)/sizeof(szString1[0])</code></para>
      <para>gives the proper size of the buffer.</para>
      <para>Consider using <see cref="StringCchCopy" /> instead; use either
<code>StringCchCopy(buffer, sizeof(buffer)/sizeof(buffer[0]), src);</code>,
being aware that <code>buffer</code> must not be a pointer or
use <code>StringCchCopy(buffer, ARRAYSIZE(buffer), src);</code>,
being aware that, when copying to a pointer, the caller is responsible for
passing in the size of the pointed-to memory in characters.</para>
      <para>Review <a href="https://docs.microsoft.com//windows/desktop/AppUIStart/sec-ui">Security Considerations: Windows User Interface</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcpyn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbCopy" />
    <seealso cref="StringCbCopyEx" />
    <seealso cref="StringCbCopyN" />
    <seealso cref="StringCbCopyNEx" />
    <seealso cref="StringCbLength" />
    <seealso cref="StringCchCopy" />
    <seealso cref="StringCchCopyEx" />
    <seealso cref="StringCchCopyN" />
    <seealso cref="StringCchCopyNEx" />
    <seealso cref="StringCchLength" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcpynA">
    <summary>
      <para>Copies a specified number of characters from a source string into a buffer.
<b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPTSTR</b></para>
      <para>The destination buffer, which receives the copied characters. The buffer
must be large enough to contain the number of <b>TCHAR</b> values
specified by <i>iMaxLength</i>, including room
for a terminating null character.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The source string from which the function is to copy characters.</para>
    </param>
    <param name="iMaxLength">
      <para>Type: <b>int</b></para>
      <para>The number of <b>TCHAR</b> values to be copied from the
string pointed to by <i>lpString2</i> into the
buffer pointed to by <i>lpString1</i>, including
a terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>If the function succeeds, the return value is a pointer to the buffer.
The function can succeed even if the source string is greater than
<i>iMaxLength</i> characters.</para>
      <para>If the function fails, the return value is <b>NULL</b></para>
      <para>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
    <remarks>
      <para>The buffer pointed to by <i>lpString1</i> must
be large enough to include a terminating null character, and the string length
value specified by <i>iMaxLength</i> includes room
for a terminating null character.</para>
      <para>The <b>lstrcpyn</b> function has an undefined behavior if source
and destination buffers overlap.</para>
      <h3>Security Warning</h3>
      <para>Using this function incorrectly can compromise the security
of your application. This function uses structured exception handling (SEH) to catch
access violations and other errors. When this function catches SEH errors, it returns
<b>NULL</b> without null-terminating the string and without notifying the
caller of the error. The caller is not safe to assume that insufficient space is
the error condition.</para>
      <para>If the buffer pointed to by <i>lpString1</i> is not large
enough to contain the copied string, a buffer overrun can occur. When copying an entire
string, note that <b>sizeof</b> returns the number of bytes.
For example, if <i>lpString1</i> points to a buffer
<i>szString1</i> which is declared as
<code>TCHAR szString[100]</code>, then sizeof(szString1) gives the size of
the buffer in bytes rather than <b>WCHAR</b>, which could lead to a buffer
overflow for the Unicode version of the function.</para>
      <para>Buffer overflow situations are the cause
of many security problems in applications and can cause a denial of service attack against
the application if an access violation occurs. In the worst case, a buffer overrun may
allow an attacker to inject executable code into your process, especially if
<i>lpString1</i> is a stack-based buffer.</para>
      <para>Using <code>sizeof(szString1)/sizeof(szString1[0])</code></para>
      <para>gives the proper size of the buffer.</para>
      <para>Consider using <see cref="StringCchCopy" /> instead; use either
<code>StringCchCopy(buffer, sizeof(buffer)/sizeof(buffer[0]), src);</code>,
being aware that <code>buffer</code> must not be a pointer or
use <code>StringCchCopy(buffer, ARRAYSIZE(buffer), src);</code>,
being aware that, when copying to a pointer, the caller is responsible for
passing in the size of the pointed-to memory in characters.</para>
      <para>Review <a href="https://docs.microsoft.com//windows/desktop/AppUIStart/sec-ui">Security Considerations: Windows User Interface</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcpyn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbCopy" />
    <seealso cref="StringCbCopyEx" />
    <seealso cref="StringCbCopyN" />
    <seealso cref="StringCbCopyNEx" />
    <seealso cref="StringCbLength" />
    <seealso cref="StringCchCopy" />
    <seealso cref="StringCchCopyEx" />
    <seealso cref="StringCchCopyN" />
    <seealso cref="StringCchCopyNEx" />
    <seealso cref="StringCchLength" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcpynW">
    <summary>
      <para>Copies a specified number of characters from a source string into a buffer.
<b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPTSTR</b></para>
      <para>The destination buffer, which receives the copied characters. The buffer
must be large enough to contain the number of <b>TCHAR</b> values
specified by <i>iMaxLength</i>, including room
for a terminating null character.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The source string from which the function is to copy characters.</para>
    </param>
    <param name="iMaxLength">
      <para>Type: <b>int</b></para>
      <para>The number of <b>TCHAR</b> values to be copied from the
string pointed to by <i>lpString2</i> into the
buffer pointed to by <i>lpString1</i>, including
a terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>If the function succeeds, the return value is a pointer to the buffer.
The function can succeed even if the source string is greater than
<i>iMaxLength</i> characters.</para>
      <para>If the function fails, the return value is <b>NULL</b></para>
      <para>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
    <remarks>
      <para>The buffer pointed to by <i>lpString1</i> must
be large enough to include a terminating null character, and the string length
value specified by <i>iMaxLength</i> includes room
for a terminating null character.</para>
      <para>The <b>lstrcpyn</b> function has an undefined behavior if source
and destination buffers overlap.</para>
      <h3>Security Warning</h3>
      <para>Using this function incorrectly can compromise the security
of your application. This function uses structured exception handling (SEH) to catch
access violations and other errors. When this function catches SEH errors, it returns
<b>NULL</b> without null-terminating the string and without notifying the
caller of the error. The caller is not safe to assume that insufficient space is
the error condition.</para>
      <para>If the buffer pointed to by <i>lpString1</i> is not large
enough to contain the copied string, a buffer overrun can occur. When copying an entire
string, note that <b>sizeof</b> returns the number of bytes.
For example, if <i>lpString1</i> points to a buffer
<i>szString1</i> which is declared as
<code>TCHAR szString[100]</code>, then sizeof(szString1) gives the size of
the buffer in bytes rather than <b>WCHAR</b>, which could lead to a buffer
overflow for the Unicode version of the function.</para>
      <para>Buffer overflow situations are the cause
of many security problems in applications and can cause a denial of service attack against
the application if an access violation occurs. In the worst case, a buffer overrun may
allow an attacker to inject executable code into your process, especially if
<i>lpString1</i> is a stack-based buffer.</para>
      <para>Using <code>sizeof(szString1)/sizeof(szString1[0])</code></para>
      <para>gives the proper size of the buffer.</para>
      <para>Consider using <see cref="StringCchCopy" /> instead; use either
<code>StringCchCopy(buffer, sizeof(buffer)/sizeof(buffer[0]), src);</code>,
being aware that <code>buffer</code> must not be a pointer or
use <code>StringCchCopy(buffer, ARRAYSIZE(buffer), src);</code>,
being aware that, when copying to a pointer, the caller is responsible for
passing in the size of the pointed-to memory in characters.</para>
      <para>Review <a href="https://docs.microsoft.com//windows/desktop/AppUIStart/sec-ui">Security Considerations: Windows User Interface</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcpyn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbCopy" />
    <seealso cref="StringCbCopyEx" />
    <seealso cref="StringCbCopyN" />
    <seealso cref="StringCbCopyNEx" />
    <seealso cref="StringCbLength" />
    <seealso cref="StringCchCopy" />
    <seealso cref="StringCchCopyEx" />
    <seealso cref="StringCchCopyN" />
    <seealso cref="StringCchCopyNEx" />
    <seealso cref="StringCchLength" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcpyn">
    <summary>
      <para>Copies a specified number of characters from a source string into a buffer.
<b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPTSTR</b></para>
      <para>The destination buffer, which receives the copied characters. The buffer
must be large enough to contain the number of <b>TCHAR</b> values
specified by <i>iMaxLength</i>, including room
for a terminating null character.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The source string from which the function is to copy characters.</para>
    </param>
    <param name="iMaxLength">
      <para>Type: <b>int</b></para>
      <para>The number of <b>TCHAR</b> values to be copied from the
string pointed to by <i>lpString2</i> into the
buffer pointed to by <i>lpString1</i>, including
a terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>If the function succeeds, the return value is a pointer to the buffer.
The function can succeed even if the source string is greater than
<i>iMaxLength</i> characters.</para>
      <para>If the function fails, the return value is <b>NULL</b></para>
      <para>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
    <remarks>
      <para>The buffer pointed to by <i>lpString1</i> must
be large enough to include a terminating null character, and the string length
value specified by <i>iMaxLength</i> includes room
for a terminating null character.</para>
      <para>The <b>lstrcpyn</b> function has an undefined behavior if source
and destination buffers overlap.</para>
      <h3>Security Warning</h3>
      <para>Using this function incorrectly can compromise the security
of your application. This function uses structured exception handling (SEH) to catch
access violations and other errors. When this function catches SEH errors, it returns
<b>NULL</b> without null-terminating the string and without notifying the
caller of the error. The caller is not safe to assume that insufficient space is
the error condition.</para>
      <para>If the buffer pointed to by <i>lpString1</i> is not large
enough to contain the copied string, a buffer overrun can occur. When copying an entire
string, note that <b>sizeof</b> returns the number of bytes.
For example, if <i>lpString1</i> points to a buffer
<i>szString1</i> which is declared as
<code>TCHAR szString[100]</code>, then sizeof(szString1) gives the size of
the buffer in bytes rather than <b>WCHAR</b>, which could lead to a buffer
overflow for the Unicode version of the function.</para>
      <para>Buffer overflow situations are the cause
of many security problems in applications and can cause a denial of service attack against
the application if an access violation occurs. In the worst case, a buffer overrun may
allow an attacker to inject executable code into your process, especially if
<i>lpString1</i> is a stack-based buffer.</para>
      <para>Using <code>sizeof(szString1)/sizeof(szString1[0])</code></para>
      <para>gives the proper size of the buffer.</para>
      <para>Consider using <see cref="StringCchCopy" /> instead; use either
<code>StringCchCopy(buffer, sizeof(buffer)/sizeof(buffer[0]), src);</code>,
being aware that <code>buffer</code> must not be a pointer or
use <code>StringCchCopy(buffer, ARRAYSIZE(buffer), src);</code>,
being aware that, when copying to a pointer, the caller is responsible for
passing in the size of the pointed-to memory in characters.</para>
      <para>Review <a href="https://docs.microsoft.com//windows/desktop/AppUIStart/sec-ui">Security Considerations: Windows User Interface</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcpyn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbCopy" />
    <seealso cref="StringCbCopyEx" />
    <seealso cref="StringCbCopyN" />
    <seealso cref="StringCbCopyNEx" />
    <seealso cref="StringCbLength" />
    <seealso cref="StringCchCopy" />
    <seealso cref="StringCchCopyEx" />
    <seealso cref="StringCchCopyN" />
    <seealso cref="StringCchCopyNEx" />
    <seealso cref="StringCchLength" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcpynA">
    <summary>
      <para>Copies a specified number of characters from a source string into a buffer.
<b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPTSTR</b></para>
      <para>The destination buffer, which receives the copied characters. The buffer
must be large enough to contain the number of <b>TCHAR</b> values
specified by <i>iMaxLength</i>, including room
for a terminating null character.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The source string from which the function is to copy characters.</para>
    </param>
    <param name="iMaxLength">
      <para>Type: <b>int</b></para>
      <para>The number of <b>TCHAR</b> values to be copied from the
string pointed to by <i>lpString2</i> into the
buffer pointed to by <i>lpString1</i>, including
a terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>If the function succeeds, the return value is a pointer to the buffer.
The function can succeed even if the source string is greater than
<i>iMaxLength</i> characters.</para>
      <para>If the function fails, the return value is <b>NULL</b></para>
      <para>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
    <remarks>
      <para>The buffer pointed to by <i>lpString1</i> must
be large enough to include a terminating null character, and the string length
value specified by <i>iMaxLength</i> includes room
for a terminating null character.</para>
      <para>The <b>lstrcpyn</b> function has an undefined behavior if source
and destination buffers overlap.</para>
      <h3>Security Warning</h3>
      <para>Using this function incorrectly can compromise the security
of your application. This function uses structured exception handling (SEH) to catch
access violations and other errors. When this function catches SEH errors, it returns
<b>NULL</b> without null-terminating the string and without notifying the
caller of the error. The caller is not safe to assume that insufficient space is
the error condition.</para>
      <para>If the buffer pointed to by <i>lpString1</i> is not large
enough to contain the copied string, a buffer overrun can occur. When copying an entire
string, note that <b>sizeof</b> returns the number of bytes.
For example, if <i>lpString1</i> points to a buffer
<i>szString1</i> which is declared as
<code>TCHAR szString[100]</code>, then sizeof(szString1) gives the size of
the buffer in bytes rather than <b>WCHAR</b>, which could lead to a buffer
overflow for the Unicode version of the function.</para>
      <para>Buffer overflow situations are the cause
of many security problems in applications and can cause a denial of service attack against
the application if an access violation occurs. In the worst case, a buffer overrun may
allow an attacker to inject executable code into your process, especially if
<i>lpString1</i> is a stack-based buffer.</para>
      <para>Using <code>sizeof(szString1)/sizeof(szString1[0])</code></para>
      <para>gives the proper size of the buffer.</para>
      <para>Consider using <see cref="StringCchCopy" /> instead; use either
<code>StringCchCopy(buffer, sizeof(buffer)/sizeof(buffer[0]), src);</code>,
being aware that <code>buffer</code> must not be a pointer or
use <code>StringCchCopy(buffer, ARRAYSIZE(buffer), src);</code>,
being aware that, when copying to a pointer, the caller is responsible for
passing in the size of the pointed-to memory in characters.</para>
      <para>Review <a href="https://docs.microsoft.com//windows/desktop/AppUIStart/sec-ui">Security Considerations: Windows User Interface</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcpyn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbCopy" />
    <seealso cref="StringCbCopyEx" />
    <seealso cref="StringCbCopyN" />
    <seealso cref="StringCbCopyNEx" />
    <seealso cref="StringCbLength" />
    <seealso cref="StringCchCopy" />
    <seealso cref="StringCchCopyEx" />
    <seealso cref="StringCchCopyN" />
    <seealso cref="StringCchCopyNEx" />
    <seealso cref="StringCchLength" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcpynW">
    <summary>
      <para>Copies a specified number of characters from a source string into a buffer.
<b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPTSTR</b></para>
      <para>The destination buffer, which receives the copied characters. The buffer
must be large enough to contain the number of <b>TCHAR</b> values
specified by <i>iMaxLength</i>, including room
for a terminating null character.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The source string from which the function is to copy characters.</para>
    </param>
    <param name="iMaxLength">
      <para>Type: <b>int</b></para>
      <para>The number of <b>TCHAR</b> values to be copied from the
string pointed to by <i>lpString2</i> into the
buffer pointed to by <i>lpString1</i>, including
a terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>If the function succeeds, the return value is a pointer to the buffer.
The function can succeed even if the source string is greater than
<i>iMaxLength</i> characters.</para>
      <para>If the function fails, the return value is <b>NULL</b></para>
      <para>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
    <remarks>
      <para>The buffer pointed to by <i>lpString1</i> must
be large enough to include a terminating null character, and the string length
value specified by <i>iMaxLength</i> includes room
for a terminating null character.</para>
      <para>The <b>lstrcpyn</b> function has an undefined behavior if source
and destination buffers overlap.</para>
      <h3>Security Warning</h3>
      <para>Using this function incorrectly can compromise the security
of your application. This function uses structured exception handling (SEH) to catch
access violations and other errors. When this function catches SEH errors, it returns
<b>NULL</b> without null-terminating the string and without notifying the
caller of the error. The caller is not safe to assume that insufficient space is
the error condition.</para>
      <para>If the buffer pointed to by <i>lpString1</i> is not large
enough to contain the copied string, a buffer overrun can occur. When copying an entire
string, note that <b>sizeof</b> returns the number of bytes.
For example, if <i>lpString1</i> points to a buffer
<i>szString1</i> which is declared as
<code>TCHAR szString[100]</code>, then sizeof(szString1) gives the size of
the buffer in bytes rather than <b>WCHAR</b>, which could lead to a buffer
overflow for the Unicode version of the function.</para>
      <para>Buffer overflow situations are the cause
of many security problems in applications and can cause a denial of service attack against
the application if an access violation occurs. In the worst case, a buffer overrun may
allow an attacker to inject executable code into your process, especially if
<i>lpString1</i> is a stack-based buffer.</para>
      <para>Using <code>sizeof(szString1)/sizeof(szString1[0])</code></para>
      <para>gives the proper size of the buffer.</para>
      <para>Consider using <see cref="StringCchCopy" /> instead; use either
<code>StringCchCopy(buffer, sizeof(buffer)/sizeof(buffer[0]), src);</code>,
being aware that <code>buffer</code> must not be a pointer or
use <code>StringCchCopy(buffer, ARRAYSIZE(buffer), src);</code>,
being aware that, when copying to a pointer, the caller is responsible for
passing in the size of the pointed-to memory in characters.</para>
      <para>Review <a href="https://docs.microsoft.com//windows/desktop/AppUIStart/sec-ui">Security Considerations: Windows User Interface</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcpyn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbCopy" />
    <seealso cref="StringCbCopyEx" />
    <seealso cref="StringCbCopyN" />
    <seealso cref="StringCbCopyNEx" />
    <seealso cref="StringCbLength" />
    <seealso cref="StringCchCopy" />
    <seealso cref="StringCchCopyEx" />
    <seealso cref="StringCchCopyN" />
    <seealso cref="StringCchCopyNEx" />
    <seealso cref="StringCchLength" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcpy">
    <summary>
      <para>Copies a string to a buffer.
<b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPTSTR</b></para>
      <para>A buffer to receive the contents of the string pointed to by the
<i>lpString2</i> parameter.
The buffer must be large enough to contain the string, including the
terminating null character.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPTSTR</b></para>
      <para>The null-terminated string to be copied.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b></para>
      <para>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
    <remarks>
      <para>With a double-byte character set (DBCS) version of the system, this function can be used
to copy a DBCS string.</para>
      <para>The <b>lstrcpy</b> function has an
undefined behavior if source and destination buffers overlap.</para>
      <h3>Security Remarks</h3>
      <para>Using this function incorrectly can compromise the security
of your application. This function uses structured exception handling (SEH) to catch
access violations and other errors. When this function catches SEH errors, it returns
<b>NULL</b> without null-terminating the string and without notifying the
caller of the error. The caller is not safe to assume that insufficient space is
the error condition.</para>
      <para>
        <i>lpString1</i> must be large enough to hold <i>lpString2</i></para>
      <para>and the closing '\0', otherwise a buffer overrun may occur.</para>
      <para>Buffer overflow situations are the cause of many security problems in applications and
can cause a denial of service attack against the application if an access violation occurs.
In the worst case, a buffer overrun may allow an attacker to inject executable code into
your process, especially if <i>lpString1</i> is a stack-based buffer.</para>
      <para>Consider using <see cref="StringCchCopy" /> instead; use either
<code>StringCchCopy(buffer, sizeof(buffer)/sizeof(buffer[0]), src);</code>,
being aware that <code>buffer</code> must not be a pointer or
use <code>StringCchCopy(buffer, ARRAYSIZE(buffer), src);</code>,
being aware that, when copying to a pointer, the caller is responsible for
passing in the size of the pointed-to memory in characters.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcpy as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbCopy" />
    <seealso cref="StringCbCopyEx" />
    <seealso cref="StringCbCopyN" />
    <seealso cref="StringCbCopyNEx" />
    <seealso cref="StringCchCopy" />
    <seealso cref="StringCchCopyEx" />
    <seealso cref="StringCchCopyN" />
    <seealso cref="StringCchCopyNEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcpyA">
    <summary>
      <para>Copies a string to a buffer.
<b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPTSTR</b></para>
      <para>A buffer to receive the contents of the string pointed to by the
<i>lpString2</i> parameter.
The buffer must be large enough to contain the string, including the
terminating null character.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPTSTR</b></para>
      <para>The null-terminated string to be copied.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b></para>
      <para>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
    <remarks>
      <para>With a double-byte character set (DBCS) version of the system, this function can be used
to copy a DBCS string.</para>
      <para>The <b>lstrcpy</b> function has an
undefined behavior if source and destination buffers overlap.</para>
      <h3>Security Remarks</h3>
      <para>Using this function incorrectly can compromise the security
of your application. This function uses structured exception handling (SEH) to catch
access violations and other errors. When this function catches SEH errors, it returns
<b>NULL</b> without null-terminating the string and without notifying the
caller of the error. The caller is not safe to assume that insufficient space is
the error condition.</para>
      <para>
        <i>lpString1</i> must be large enough to hold <i>lpString2</i></para>
      <para>and the closing '\0', otherwise a buffer overrun may occur.</para>
      <para>Buffer overflow situations are the cause of many security problems in applications and
can cause a denial of service attack against the application if an access violation occurs.
In the worst case, a buffer overrun may allow an attacker to inject executable code into
your process, especially if <i>lpString1</i> is a stack-based buffer.</para>
      <para>Consider using <see cref="StringCchCopy" /> instead; use either
<code>StringCchCopy(buffer, sizeof(buffer)/sizeof(buffer[0]), src);</code>,
being aware that <code>buffer</code> must not be a pointer or
use <code>StringCchCopy(buffer, ARRAYSIZE(buffer), src);</code>,
being aware that, when copying to a pointer, the caller is responsible for
passing in the size of the pointed-to memory in characters.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcpy as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbCopy" />
    <seealso cref="StringCbCopyEx" />
    <seealso cref="StringCbCopyN" />
    <seealso cref="StringCbCopyNEx" />
    <seealso cref="StringCchCopy" />
    <seealso cref="StringCchCopyEx" />
    <seealso cref="StringCchCopyN" />
    <seealso cref="StringCchCopyNEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrcpyW">
    <summary>
      <para>Copies a string to a buffer.
<b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</para>
    </summary>
    <param name="lpString1">
      <para>Type: <b>LPTSTR</b></para>
      <para>A buffer to receive the contents of the string pointed to by the
<i>lpString2</i> parameter.
The buffer must be large enough to contain the string, including the
terminating null character.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPTSTR</b></para>
      <para>The null-terminated string to be copied.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b></para>
      <para>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
    <remarks>
      <para>With a double-byte character set (DBCS) version of the system, this function can be used
to copy a DBCS string.</para>
      <para>The <b>lstrcpy</b> function has an
undefined behavior if source and destination buffers overlap.</para>
      <h3>Security Remarks</h3>
      <para>Using this function incorrectly can compromise the security
of your application. This function uses structured exception handling (SEH) to catch
access violations and other errors. When this function catches SEH errors, it returns
<b>NULL</b> without null-terminating the string and without notifying the
caller of the error. The caller is not safe to assume that insufficient space is
the error condition.</para>
      <para>
        <i>lpString1</i> must be large enough to hold <i>lpString2</i></para>
      <para>and the closing '\0', otherwise a buffer overrun may occur.</para>
      <para>Buffer overflow situations are the cause of many security problems in applications and
can cause a denial of service attack against the application if an access violation occurs.
In the worst case, a buffer overrun may allow an attacker to inject executable code into
your process, especially if <i>lpString1</i> is a stack-based buffer.</para>
      <para>Consider using <see cref="StringCchCopy" /> instead; use either
<code>StringCchCopy(buffer, sizeof(buffer)/sizeof(buffer[0]), src);</code>,
being aware that <code>buffer</code> must not be a pointer or
use <code>StringCchCopy(buffer, ARRAYSIZE(buffer), src);</code>,
being aware that, when copying to a pointer, the caller is responsible for
passing in the size of the pointed-to memory in characters.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrcpy as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbCopy" />
    <seealso cref="StringCbCopyEx" />
    <seealso cref="StringCbCopyN" />
    <seealso cref="StringCbCopyNEx" />
    <seealso cref="StringCchCopy" />
    <seealso cref="StringCchCopyEx" />
    <seealso cref="StringCchCopyN" />
    <seealso cref="StringCchCopyNEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrlen" />
  </member>
  <member name="Windows.lstrlen">
    <summary>
      <para>Determines the length of the specified string (not including the terminating null character).</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated string to be checked.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>The function returns the length of the string, in characters. If <i>lpString</i> is <b>NULL</b>, the function returns 0.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrlen as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbLength" />
    <seealso cref="StringCchLength" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcat" />
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrcpy" />
  </member>
  <member name="Windows.lstrlenA">
    <summary>
      <para>Determines the length of the specified string (not including the terminating null character).</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated string to be checked.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>The function returns the length of the string, in characters. If <i>lpString</i> is <b>NULL</b>, the function returns 0.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrlen as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbLength" />
    <seealso cref="StringCchLength" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcat" />
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrcpy" />
  </member>
  <member name="Windows.lstrlenW">
    <summary>
      <para>Determines the length of the specified string (not including the terminating null character).</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated string to be checked.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>The function returns the length of the string, in characters. If <i>lpString</i> is <b>NULL</b>, the function returns 0.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrlen as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbLength" />
    <seealso cref="StringCchLength" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcat" />
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrcpy" />
  </member>
  <member name="Windows.lstrlen">
    <summary>
      <para>Determines the length of the specified string (not including the terminating null character).</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated string to be checked.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>The function returns the length of the string, in characters. If <i>lpString</i> is <b>NULL</b>, the function returns 0.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrlen as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbLength" />
    <seealso cref="StringCchLength" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcat" />
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrcpy" />
  </member>
  <member name="Windows.lstrlenA">
    <summary>
      <para>Determines the length of the specified string (not including the terminating null character).</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated string to be checked.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>The function returns the length of the string, in characters. If <i>lpString</i> is <b>NULL</b>, the function returns 0.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrlen as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbLength" />
    <seealso cref="StringCchLength" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcat" />
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrcpy" />
  </member>
  <member name="Windows.lstrlenW">
    <summary>
      <para>Determines the length of the specified string (not including the terminating null character).</para>
    </summary>
    <param name="lpString">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The null-terminated string to be checked.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>The function returns the length of the string, in characters. If <i>lpString</i> is <b>NULL</b>, the function returns 0.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines lstrlen as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StringCbLength" />
    <seealso cref="StringCchLength" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/strings">Strings</seealso>
    <seealso cref="lstrcat" />
    <seealso cref="lstrcmp" />
    <seealso cref="lstrcmpi" />
    <seealso cref="lstrcpy" />
  </member>
  <member name="Windows.MAKEINTATOM">
    <summary>
      <para>Converts the specified atom into a string, so it can be passed to functions which accept either atoms or strings.</para>
    </summary>
    <param name="i">
      <para>The numeric value to be made into an integer atom. This parameter can be either an integer atom or a string atom.</para>
    </param>
    <remarks>
      <para>Although the return value of the <b>MAKEINTATOM</b> macro is cast as an <b>LPTSTR</b> value, it cannot be used as a string pointer except when it is passed to atom-management functions that require an <b>LPTSTR</b> argument.</para>
    </remarks>
    <seealso cref="AddAtom" />
    <seealso cref="DeleteAtom" />
    <seealso cref="GetAtomName" />
    <seealso cref="GlobalAddAtom" />
    <seealso cref="GlobalDeleteAtom" />
    <seealso cref="GlobalGetAtomName" />
  </member>
  <member name="Windows.MapUserPhysicalPagesScatter">
    <summary>
      <para>Maps previously allocated physical memory pages at a specified address in an
<a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) region.</para>
      <para>
        <b>64-bit Windows on Itanium-based systems:  </b>Due to the difference in page sizes,
<b>MapUserPhysicalPagesScatter</b> is not
supported for 32-bit applications.</para>
    </summary>
    <param name="VirtualAddresses">
      <para>A pointer to an array of starting addresses of the regions of memory to remap.</para>
      <para>Each entry in
<i>VirtualAddresses</i> must be within the address range that the
<see cref="VirtualAlloc" /> function returns when the <a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) region is
allocated. The value in <i>NumberOfPages</i> indicates the size of the array. Entries can be from multiple Address Windowing Extensions (AWE) regions.</para>
    </param>
    <param name="NumberOfPages">
      <para>The size of the physical memory and virtual address space for which to establish translations, in pages.</para>
      <para>The
array at <i>VirtualAddresses</i> specifies the virtual address range.</para>
    </param>
    <param name="PageArray">
      <para>A pointer to an array of values that indicates how each corresponding page in
<i>VirtualAddresses</i> should be treated.</para>
      <para>A 0 (zero) indicates that the corresponding entry in
<i>VirtualAddresses</i> should be unmapped, and any nonzero value that it has should be mapped.</para>
      <para>If this parameter is <b>NULL</b>, then every address in the <i>VirtualAddresses</i> array is
unmapped.</para>
      <para>The value in <i>NumberOfPages</i> indicates the size of the array.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b>, and the function does not map or unmap—partial or
otherwise. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The physical pages may be unmapped, but they are not freed. You must call
<see cref="FreeUserPhysicalPages" /> to free the physical
pages.</para>
      <para>You can specify any number of physical memory pages, but the memory cannot extend outside the virtual
address space that is allocated by <see cref="VirtualAlloc" />. Any
existing address maps are automatically overwritten with the new translations, and the old translations are
unmapped.</para>
      <para>You cannot map physical memory pages outside the range that is specified in
<see cref="AllocateUserPhysicalPages" />. You can map
multiple regions simultaneously, but they cannot overlap.</para>
      <para>Physical pages can be located at any physical address, but do not make assumptions about the contiguity of the
physical pages.</para>
      <para>In a multiprocessor environment, this function maintains hardware translation buffer coherence. On return
from this function, all threads on all processors are guaranteed to see the correct mapping.</para>
      <para>To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0500 or later. For more
information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows
Headers</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</seealso>
    <seealso cref="AllocateUserPhysicalPages" />
    <seealso cref="FreeUserPhysicalPages" />
    <seealso cref="MapUserPhysicalPages" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">Memory Management Functions</seealso>
  </member>
  <member name="Windows.MapViewOfFileExNuma">
    <summary>
      <para>Maps a view of a file mapping into the address space of a calling process and specifies the NUMA node
for the physical memory.</para>
    </summary>
    <param name="hFileMappingObject">
      <para>A handle to a file mapping object. The
<see cref="CreateFileMappingNuma" /> and
<see cref="OpenFileMapping" /> functions return this handle.</para>
    </param>
    <param name="dwDesiredAccess">
      <para>The type of access to a file mapping object, which determines the page protection of the pages. This
parameter can be one of the following values, or a bitwise OR combination of multiple values where appropriate.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FILE_MAP_ALL_ACCESS</b>
          </description>
          <description>
            <para>A read/write view of the file is mapped.  The file mapping object must have been created with
<b>PAGE_READWRITE</b> or <b>PAGE_EXECUTE_READWRITE</b> protection.</para>
            <para>When used with <b>MapViewOfFileExNuma</b>, <b>FILE_MAP_ALL_ACCESS</b> is equivalent to
<b>FILE_MAP_WRITE</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_MAP_READ</b>
          </description>
          <description>
            <para>A read-only view of the file is mapped. An attempt to write to the file view results in an access
violation.</para>
            <para>The file mapping object must have been created with <b>PAGE_READONLY</b>,
<b>PAGE_READWRITE</b>, <b>PAGE_EXECUTE_READ</b>, or
<b>PAGE_EXECUTE_READWRITE</b> protection.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_MAP_WRITE</b>
          </description>
          <description>
            <para>A read/write view of the file is mapped. The file mapping object must have been created with
<b>PAGE_READWRITE</b> or <b>PAGE_EXECUTE_READWRITE</b> protection.</para>
            <para>When used with <b>MapViewOfFileExNuma</b>,
<code>(FILE_MAP_WRITE | FILE_MAP_READ)</code> is equivalent to <b>FILE_MAP_WRITE</b>.</para>
          </description>
        </item>
      </list>
      <para>Using bitwise OR, you can combine the values above with these values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>FILE_MAP_COPY</b>
          </description>
          <description>
            <para>A copy-on-write view of the file is mapped. The file mapping object must have been created with
<b>PAGE_READONLY</b>, <b>PAGE_READ_EXECUTE</b>,
<b>PAGE_WRITECOPY</b>, <b>PAGE_EXECUTE_WRITECOPY</b>,
<b>PAGE_READWRITE</b>, or <b>PAGE_EXECUTE_READWRITE</b> protection.</para>
            <para>When a process writes to a copy-on-write page, the system copies the original page to a new page that is
private to the process. The new page is backed by the paging file. The protection of the new page changes
from copy-on-write to read/write.</para>
            <para>When copy-on-write access is specified, the system and process commit
charge taken is for the entire view because the calling process can potentially write to every page in the
view, making all pages private. The contents of the new page are never written back to the original file and
are lost when the view is unmapped.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_MAP_EXECUTE</b>
          </description>
          <description>
            <para>An executable view of the file is mapped (mapped memory can be run as code). The file mapping object must
have been created with <b>PAGE_EXECUTE_READ</b>,
<b>PAGE_EXECUTE_WRITECOPY</b>, or <b>PAGE_EXECUTE_READWRITE</b></para>
            <para>protection.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_MAP_LARGE_PAGES</b>
          </description>
          <description>
            <para>Starting with Windows 10, version 1703, this flag specifies that the view should be mapped using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>. The size of the view must be a multiple of the size of a
large page reported by the
<see cref="GetLargePageMinimum" /> function, and the file-mapping object must have been created using the <b>SEC_LARGE_PAGES</b> option. If you provide a non-null value for <i>lpBaseAddress</i>, then the value must be a multiple of <b>GetLargePageMinimum</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FILE_MAP_TARGETS_INVALID</b>
          </description>
          <description>
            <para>Sets all the locations in the mapped file as invalid targets for Control Flow Guard (CFG). This flag is similar to <b>PAGE_TARGETS_INVALID</b>. Use this flag in combination with the execute access right <b>FILE_MAP_EXECUTE</b>. Any indirect call to locations in those pages will fail CFG checks, and the process will be terminated. The default behavior for executable pages allocated is to be marked valid call targets for CFG.</para>
          </description>
        </item>
      </list>
      <para>For file-mapping objects created with the <b>SEC_IMAGE</b> attribute, the
<i>dwDesiredAccess</i> parameter has no effect, and should be set to any valid value such as
<b>FILE_MAP_READ</b>.</para>
      <para>For more information  about access to file mapping objects, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="dwFileOffsetHigh">
      <para>The high-order <b>DWORD</b> of the file offset where the view is to begin.</para>
    </param>
    <param name="dwFileOffsetLow">
      <para>The low-order <b>DWORD</b> of the file offset where the view is to begin. The
combination of the high and low offsets must specify an offset within the file mapping. They must also match the
memory allocation granularity of the system. That is, the offset must be a multiple of the allocation
granularity. To obtain the memory allocation granularity of the system, use the
<see cref="GetSystemInfo" /> function, which fills in the members of
a <see cref="SYSTEM_INFO" /> structure.</para>
    </param>
    <param name="dwNumberOfBytesToMap">
      <para>The number of bytes of a file mapping to map to a view. All bytes must be within the maximum size specified
by <see cref="CreateFileMapping" />. If this parameter is 0
(zero), the mapping extends from the specified offset to the end of the file mapping.</para>
    </param>
    <param name="lpBaseAddress">
      <para>A pointer to the memory address in the calling process address space where mapping begins. This must be a
multiple of the system's memory allocation granularity, or the function fails. To determine the memory
allocation granularity of the system, use the
<see cref="GetSystemInfo" /> function. If there is not enough
address space at the specified address, the function fails.</para>
      <para>If the <i>lpBaseAddress</i> parameter is <b>NULL</b>, the operating
system chooses the mapping address.</para>
      <para>While it is possible to specify an address that is safe now (not used by the operating system), there is no
guarantee that the address will remain safe over time. Therefore, it is better to let the operating system
choose the address. In this case, you would not store pointers in the memory mapped file; you would store
offsets from the base of the file mapping so that the mapping can be used at any address.</para>
    </param>
    <param name="nndPreferred">
      <para>The NUMA node where the physical memory should reside.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NUMA_NO_PREFERRED_NODE</b>
                </description>
              </item>
              <item>
                <description>0xffffffff</description>
              </item>
            </list>
          </description>
          <description>
            <para>No NUMA node is preferred. This is the same as calling the
<see cref="MapViewOfFileEx" /> function.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the starting address of the mapped view.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call the <see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>Mapping a file makes the specified portion of the file visible in the address space of the calling
process.</para>
      <para>For files that are larger than the address space, you can map only a small portion of the file data at one
time. When the first view is complete, then you unmap it and map a new view.</para>
      <para>To obtain the size of a view, use the
<see cref="VirtualQueryEx" /> function.</para>
      <para>The initial contents of the pages in a file mapping object backed by the page file are 0 (zero).</para>
      <para>If a suggested mapping address is supplied, the file is mapped at the specified address (rounded down to the
nearest 64-KB boundary) if there is enough address space at the specified address. If there is not enough address
space, the function fails.</para>
      <para>Typically, the suggested address is used to specify that a file should be mapped at the same address in
multiple processes. This requires the region of address space to be available in all involved processes. No other
memory allocation can take place in the region that is used for mapping, including the use of the
<see cref="VirtualAllocExNuma" /> function to reserve memory.</para>
      <para>If the <i>lpBaseAddress</i> parameter specifies a base offset, the function succeeds if the
specified memory region is not already in use by the calling process. The system does not ensure that the same
memory region is available for the memory mapped file in other 32-bit processes.</para>
      <para>Multiple views of a file (or a file mapping object and its mapped file) are <i>coherent</i></para>
      <para>if they contain identical data at a specified time. This occurs if the file views are derived from the same file
mapping object. A process can duplicate a file mapping object handle into another process by using the
<see cref="DuplicateHandle" /> function, or another process can open
a file mapping object by name by using the
<see cref="OpenFileMapping" /> function.</para>
      <para>With one important exception, file views derived from any file mapping object that is backed by the same file
are coherent or identical at a specific time. Coherency is guaranteed for views within a process and for views
that are mapped by different processes.</para>
      <para>The exception is related to remote files. Although
<b>MapViewOfFileExNuma</b> works with remote files, it
does not keep them coherent. For example, if two computers both map a file as writable, and both change the same
page, each computer only sees its own writes to the page. When the data gets updated on the disk, it is not
merged.</para>
      <para>A mapped view of a file is not guaranteed to be coherent with a file being accessed by the
<see cref="ReadFile" /> or
<see cref="WriteFile" /> function.</para>
      <para>To guard against <b>EXCEPTION_IN_PAGE_ERROR</b> exceptions, use structured exception
handling to protect any code that writes to or reads from a memory mapped view of a file other than the page file.
For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/reading-and-writing-from-a-file-view">Reading and Writing From a File View</a>.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>To have a file with executable permissions, an application must call
the <see cref="CreateFileMappingNuma" /> function with either
<b>PAGE_EXECUTE_READWRITE</b> or <b>PAGE_EXECUTE_READ</b></para>
      <para>and then call the <b>MapViewOfFileExNuma</b> function
with <b>FILE_MAP_EXECUTE</b> | <b>FILE_MAP_WRITE</b> or
<b>FILE_MAP_EXECUTE</b> | <b>FILE_MAP_READ</b>.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso cref="CreateFileMappingNuma" />
    <seealso cref="DuplicateHandle" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">File Mapping Functions</seealso>
    <seealso cref="GetSystemInfo" />
    <seealso cref="MapViewOfFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/numa-support">NUMA Support</seealso>
    <seealso cref="OpenFileMapping" />
    <seealso cref="ReadFile" />
    <seealso cref="SYSTEM_INFO" />
    <seealso cref="UnmapViewOfFile" />
    <seealso cref="VirtualAlloc" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.MoveFile">
    <summary>
      <para>Moves an existing file or a directory, including its children.</para>
      <para>To specify how to move the file, use the
<see cref="MoveFileEx" /> or
<see cref="MoveFileWithProgress" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name for the file or directory. The new name must not already exist. A new file may be on a
different file system or drive. A new directory must be on the same drive.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>MoveFile</b> function will move (rename) either a file or a
directory (including its children) either in the same directory or across directories. The one caveat is that the
<b>MoveFile</b> function will fail on directory moves when the
destination is on a different volume.</para>
      <para>If a file is moved across volumes, <b>MoveFile</b> does not move
the security descriptor with the file. The file will be assigned the default security descriptor in the
destination directory.</para>
      <para>The <b>MoveFile</b> function coordinates its operation with the
link tracking service, so link sources can be tracked as they are moved.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>See comment</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>See comment</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support rename of alternate data streams on file shares with continuous availability capability.</para>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFileEx" />
    <seealso cref="MoveFileTransacted" />
    <seealso cref="MoveFileWithProgress" />
  </member>
  <member name="Windows.MoveFileA">
    <summary>
      <para>Moves an existing file or a directory, including its children.</para>
      <para>To specify how to move the file, use the
<see cref="MoveFileEx" /> or
<see cref="MoveFileWithProgress" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name for the file or directory. The new name must not already exist. A new file may be on a
different file system or drive. A new directory must be on the same drive.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>MoveFile</b> function will move (rename) either a file or a
directory (including its children) either in the same directory or across directories. The one caveat is that the
<b>MoveFile</b> function will fail on directory moves when the
destination is on a different volume.</para>
      <para>If a file is moved across volumes, <b>MoveFile</b> does not move
the security descriptor with the file. The file will be assigned the default security descriptor in the
destination directory.</para>
      <para>The <b>MoveFile</b> function coordinates its operation with the
link tracking service, so link sources can be tracked as they are moved.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>See comment</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>See comment</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support rename of alternate data streams on file shares with continuous availability capability.</para>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFileEx" />
    <seealso cref="MoveFileTransacted" />
    <seealso cref="MoveFileWithProgress" />
  </member>
  <member name="Windows.MoveFileW">
    <summary>
      <para>Moves an existing file or a directory, including its children.</para>
      <para>To specify how to move the file, use the
<see cref="MoveFileEx" /> or
<see cref="MoveFileWithProgress" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name for the file or directory. The new name must not already exist. A new file may be on a
different file system or drive. A new directory must be on the same drive.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>MoveFile</b> function will move (rename) either a file or a
directory (including its children) either in the same directory or across directories. The one caveat is that the
<b>MoveFile</b> function will fail on directory moves when the
destination is on a different volume.</para>
      <para>If a file is moved across volumes, <b>MoveFile</b> does not move
the security descriptor with the file. The file will be assigned the default security descriptor in the
destination directory.</para>
      <para>The <b>MoveFile</b> function coordinates its operation with the
link tracking service, so link sources can be tracked as they are moved.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>See comment</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>See comment</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support rename of alternate data streams on file shares with continuous availability capability.</para>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFileEx" />
    <seealso cref="MoveFileTransacted" />
    <seealso cref="MoveFileWithProgress" />
  </member>
  <member name="Windows.MoveFile">
    <summary>
      <para>Moves an existing file or a directory, including its children.</para>
      <para>To specify how to move the file, use the
<see cref="MoveFileEx" /> or
<see cref="MoveFileWithProgress" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name for the file or directory. The new name must not already exist. A new file may be on a
different file system or drive. A new directory must be on the same drive.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>MoveFile</b> function will move (rename) either a file or a
directory (including its children) either in the same directory or across directories. The one caveat is that the
<b>MoveFile</b> function will fail on directory moves when the
destination is on a different volume.</para>
      <para>If a file is moved across volumes, <b>MoveFile</b> does not move
the security descriptor with the file. The file will be assigned the default security descriptor in the
destination directory.</para>
      <para>The <b>MoveFile</b> function coordinates its operation with the
link tracking service, so link sources can be tracked as they are moved.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>See comment</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>See comment</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support rename of alternate data streams on file shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines MoveFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFileEx" />
    <seealso cref="MoveFileTransacted" />
    <seealso cref="MoveFileWithProgress" />
  </member>
  <member name="Windows.MoveFileA">
    <summary>
      <para>Moves an existing file or a directory, including its children.</para>
      <para>To specify how to move the file, use the
<see cref="MoveFileEx" /> or
<see cref="MoveFileWithProgress" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name for the file or directory. The new name must not already exist. A new file may be on a
different file system or drive. A new directory must be on the same drive.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>MoveFile</b> function will move (rename) either a file or a
directory (including its children) either in the same directory or across directories. The one caveat is that the
<b>MoveFile</b> function will fail on directory moves when the
destination is on a different volume.</para>
      <para>If a file is moved across volumes, <b>MoveFile</b> does not move
the security descriptor with the file. The file will be assigned the default security descriptor in the
destination directory.</para>
      <para>The <b>MoveFile</b> function coordinates its operation with the
link tracking service, so link sources can be tracked as they are moved.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>See comment</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>See comment</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support rename of alternate data streams on file shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines MoveFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFileEx" />
    <seealso cref="MoveFileTransacted" />
    <seealso cref="MoveFileWithProgress" />
  </member>
  <member name="Windows.MoveFileW">
    <summary>
      <para>Moves an existing file or a directory, including its children.</para>
      <para>To specify how to move the file, use the
<see cref="MoveFileEx" /> or
<see cref="MoveFileWithProgress" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name for the file or directory. The new name must not already exist. A new file may be on a
different file system or drive. A new directory must be on the same drive.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>MoveFile</b> function will move (rename) either a file or a
directory (including its children) either in the same directory or across directories. The one caveat is that the
<b>MoveFile</b> function will fail on directory moves when the
destination is on a different volume.</para>
      <para>If a file is moved across volumes, <b>MoveFile</b> does not move
the security descriptor with the file. The file will be assigned the default security descriptor in the
destination directory.</para>
      <para>The <b>MoveFile</b> function coordinates its operation with the
link tracking service, so link sources can be tracked as they are moved.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>See comment</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>See comment</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support rename of alternate data streams on file shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines MoveFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFileEx" />
    <seealso cref="MoveFileTransacted" />
    <seealso cref="MoveFileWithProgress" />
  </member>
  <member name="Windows.MoveFileEx">
    <summary>
      <para>Moves an existing file or directory, including its children, with various move options.</para>
      <para>The <see cref="MoveFileWithProgress" /> function is equivalent
to the <b>MoveFileEx</b> function, except that
<b>MoveFileWithProgress</b> allows you to provide a
callback function that receives progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the
file cannot exist on a remote share, because delayed operations are performed before the network is
available.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory on the local computer.</para>
      <para>When moving a file, the destination can be on a different file system or volume. If the destination is on
another drive, you must set the <b>MOVEFILE_COPY_ALLOWED</b> flag in
<i>dwFlags</i>.</para>
      <para>When moving a directory, the destination must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and
<i>lpNewFileName</i> is  <b>NULL</b>,
<b>MoveFileEx</b> registers the
<i>lpExistingFileName</i> file to be deleted when the system restarts. If
<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart
only if the directory is empty.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </description>
              </item>
              <item>
                <description>2 (0x2)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file is to be moved to a different volume, the function simulates the move by using the
<see cref="CopyFile" /> and
<see cref="DeleteFile" /> functions.</para>
            <para>If the  file is successfully copied to a different volume and the original file is unable to be deleted,
the function succeeds leaving the source file intact.</para>
            <para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </description>
              </item>
              <item>
                <description>16 (0x10)</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserved for future use.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </description>
              </item>
              <item>
                <description>4 (0x4)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system does not move the file until the operating system is restarted. The system moves the file
immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter
enables the function to delete paging files from previous startups.</para>
            <para>This value can be used only if the process is in the context of a user who belongs to the administrators
group or the LocalSystem account.</para>
            <para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </description>
              </item>
              <item>
                <description>32 (0x20)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function fails if the source file is a link source, but the file cannot be tracked after the move.
This situation can occur if the destination is a volume formatted with the FAT file system.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </description>
              </item>
              <item>
                <description>1 (0x1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with
the contents of the <i>lpExistingFileName</i> file, provided that security requirements
regarding access control lists (ACLs) are met. For more information, see the Remarks section of this
topic.</para>
            <para>If <i>lpNewFileName</i> names an existing directory, an error is reported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </description>
              </item>
              <item>
                <description>8 (0x8)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function does not return until the file is actually moved on the disk.</para>
            <para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk
before the function returns. The flush occurs at the end of the copy operation.</para>
            <para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the <i>dwFlags</i> parameter specifies
<b>MOVEFILE_DELAY_UNTIL_REBOOT</b>,
<b>MoveFileEx</b> fails if it cannot access the registry. The
function stores the locations of the files to be renamed at restart in the following registry value:
<b>HKEY_LOCAL_MACHINE</b>\<b>SYSTEM</b>\<b>CurrentControlSet</b>\<b>Control</b>\<b>Session Manager</b>\<b>PendingFileRenameOperations</b></para>
      <para>This registry  value is of type <b>REG_MULTI_SZ</b>. Each rename operation stores one
of the following NULL-terminated strings, depending on whether the rename is a delete or not:</para>
      <list type="bullet">
        <item>
          <description>
            <i>szDstFile</i>\0\0
</description>
        </item>
        <item>
          <description>
            <i>szSrcFile</i>\0<i>szDstFile</i>\0
</description>
        </item>
      </list>
      <para>The string <i>szDstFile</i>\0\0 indicates that the file
<i>szDstFile</i> is to be deleted on reboot. The string
<i>szSrcFile</i>\0<i>szDstFile</i>\0 indicates that
<i>szSrcFile</i> is to be renamed <i>szDstFile</i> on reboot.</para>
      <para>
        <b>Note</b>  Although \0\0 is technically not allowed in a <b>REG_MULTI_SZ</b> node, it can because
the file is considered to be renamed to a null name.</para>
      <para>The system uses these registry entries to complete the operations at restart in the same order that they were
issued. For example, the following code fragment creates registry entries that delete
<i>szDstFile</i> and rename <i>szSrcFile</i> to be
<i>szDstFile</i> at restart:</para>
      <code>MoveFileEx(szDstFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
MoveFileEx(szSrcFile, szDstFile, MOVEFILE_DELAY_UNTIL_REBOOT);

</code>
      <para>Because the actual move and deletion operations specified with the
<b>MOVEFILE_DELAY_UNTIL_REBOOT</b> flag take place after the calling application has ceased
running, the return value cannot reflect success or failure in moving or deleting the file. Rather, it reflects
success or failure in placing the appropriate entries into the registry.</para>
      <para>The system deletes a directory that is tagged for deletion with the
<b>MOVEFILE_DELAY_UNTIL_REBOOT</b> flag only if it is empty. To ensure deletion of directories,
move or delete all files from the directory before attempting to delete it. Files may be in the directory at boot
time, but they must be deleted or moved before the system can delete the directory.</para>
      <para>The move and deletion operations are carried out at boot time in the same order that they are specified in the
calling application. To delete a directory that has files in it at boot time, first delete the files.</para>
      <para>If a file is moved across volumes, <b>MoveFileEx</b> does not
move the security descriptor with the file. The file is assigned the default security descriptor in the
destination directory.</para>
      <para>The <b>MoveFileEx</b> function coordinates its operation with
the <a href="https://docs.microsoft.com//windows/desktop/FileIO/distributed-link-tracking-and-object-identifiers">link tracking</a> service,
so link sources can be tracked as they are moved.</para>
      <para>To delete or rename a file, you must have either delete permission on the file or delete child permission in
the parent directory. If you set up a directory with all access except delete and delete child and the ACLs of
new files are inherited, then you should be able to create a file without being able to delete it. However, you
can then create a file, and get all the access you request on the handle that is returned to you at the time that
you create the file. If you request delete permission at the time you create the file, you can delete or rename
the file with that handle but not with any other handle.  For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</seealso>
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="MoveFileTransacted" />
    <seealso cref="MoveFileWithProgress" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.MoveFileExA">
    <summary>
      <para>Moves an existing file or directory, including its children, with various move options.</para>
      <para>The <see cref="MoveFileWithProgress" /> function is equivalent
to the <b>MoveFileEx</b> function, except that
<b>MoveFileWithProgress</b> allows you to provide a
callback function that receives progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the
file cannot exist on a remote share, because delayed operations are performed before the network is
available.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory on the local computer.</para>
      <para>When moving a file, the destination can be on a different file system or volume. If the destination is on
another drive, you must set the <b>MOVEFILE_COPY_ALLOWED</b> flag in
<i>dwFlags</i>.</para>
      <para>When moving a directory, the destination must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and
<i>lpNewFileName</i> is  <b>NULL</b>,
<b>MoveFileEx</b> registers the
<i>lpExistingFileName</i> file to be deleted when the system restarts. If
<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart
only if the directory is empty.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </description>
              </item>
              <item>
                <description>2 (0x2)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file is to be moved to a different volume, the function simulates the move by using the
<see cref="CopyFile" /> and
<see cref="DeleteFile" /> functions.</para>
            <para>If the  file is successfully copied to a different volume and the original file is unable to be deleted,
the function succeeds leaving the source file intact.</para>
            <para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </description>
              </item>
              <item>
                <description>16 (0x10)</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserved for future use.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </description>
              </item>
              <item>
                <description>4 (0x4)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system does not move the file until the operating system is restarted. The system moves the file
immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter
enables the function to delete paging files from previous startups.</para>
            <para>This value can be used only if the process is in the context of a user who belongs to the administrators
group or the LocalSystem account.</para>
            <para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </description>
              </item>
              <item>
                <description>32 (0x20)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function fails if the source file is a link source, but the file cannot be tracked after the move.
This situation can occur if the destination is a volume formatted with the FAT file system.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </description>
              </item>
              <item>
                <description>1 (0x1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with
the contents of the <i>lpExistingFileName</i> file, provided that security requirements
regarding access control lists (ACLs) are met. For more information, see the Remarks section of this
topic.</para>
            <para>If <i>lpNewFileName</i> names an existing directory, an error is reported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </description>
              </item>
              <item>
                <description>8 (0x8)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function does not return until the file is actually moved on the disk.</para>
            <para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk
before the function returns. The flush occurs at the end of the copy operation.</para>
            <para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the <i>dwFlags</i> parameter specifies
<b>MOVEFILE_DELAY_UNTIL_REBOOT</b>,
<b>MoveFileEx</b> fails if it cannot access the registry. The
function stores the locations of the files to be renamed at restart in the following registry value:
<b>HKEY_LOCAL_MACHINE</b>\<b>SYSTEM</b>\<b>CurrentControlSet</b>\<b>Control</b>\<b>Session Manager</b>\<b>PendingFileRenameOperations</b></para>
      <para>This registry  value is of type <b>REG_MULTI_SZ</b>. Each rename operation stores one
of the following NULL-terminated strings, depending on whether the rename is a delete or not:</para>
      <list type="bullet">
        <item>
          <description>
            <i>szDstFile</i>\0\0
</description>
        </item>
        <item>
          <description>
            <i>szSrcFile</i>\0<i>szDstFile</i>\0
</description>
        </item>
      </list>
      <para>The string <i>szDstFile</i>\0\0 indicates that the file
<i>szDstFile</i> is to be deleted on reboot. The string
<i>szSrcFile</i>\0<i>szDstFile</i>\0 indicates that
<i>szSrcFile</i> is to be renamed <i>szDstFile</i> on reboot.</para>
      <para>
        <b>Note</b>  Although \0\0 is technically not allowed in a <b>REG_MULTI_SZ</b> node, it can because
the file is considered to be renamed to a null name.</para>
      <para>The system uses these registry entries to complete the operations at restart in the same order that they were
issued. For example, the following code fragment creates registry entries that delete
<i>szDstFile</i> and rename <i>szSrcFile</i> to be
<i>szDstFile</i> at restart:</para>
      <code>MoveFileEx(szDstFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
MoveFileEx(szSrcFile, szDstFile, MOVEFILE_DELAY_UNTIL_REBOOT);

</code>
      <para>Because the actual move and deletion operations specified with the
<b>MOVEFILE_DELAY_UNTIL_REBOOT</b> flag take place after the calling application has ceased
running, the return value cannot reflect success or failure in moving or deleting the file. Rather, it reflects
success or failure in placing the appropriate entries into the registry.</para>
      <para>The system deletes a directory that is tagged for deletion with the
<b>MOVEFILE_DELAY_UNTIL_REBOOT</b> flag only if it is empty. To ensure deletion of directories,
move or delete all files from the directory before attempting to delete it. Files may be in the directory at boot
time, but they must be deleted or moved before the system can delete the directory.</para>
      <para>The move and deletion operations are carried out at boot time in the same order that they are specified in the
calling application. To delete a directory that has files in it at boot time, first delete the files.</para>
      <para>If a file is moved across volumes, <b>MoveFileEx</b> does not
move the security descriptor with the file. The file is assigned the default security descriptor in the
destination directory.</para>
      <para>The <b>MoveFileEx</b> function coordinates its operation with
the <a href="https://docs.microsoft.com//windows/desktop/FileIO/distributed-link-tracking-and-object-identifiers">link tracking</a> service,
so link sources can be tracked as they are moved.</para>
      <para>To delete or rename a file, you must have either delete permission on the file or delete child permission in
the parent directory. If you set up a directory with all access except delete and delete child and the ACLs of
new files are inherited, then you should be able to create a file without being able to delete it. However, you
can then create a file, and get all the access you request on the handle that is returned to you at the time that
you create the file. If you request delete permission at the time you create the file, you can delete or rename
the file with that handle but not with any other handle.  For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</seealso>
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="MoveFileTransacted" />
    <seealso cref="MoveFileWithProgress" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.MoveFileExW">
    <summary>
      <para>Moves an existing file or directory, including its children, with various move options.</para>
      <para>The <see cref="MoveFileWithProgress" /> function is equivalent
to the <b>MoveFileEx</b> function, except that
<b>MoveFileWithProgress</b> allows you to provide a
callback function that receives progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the
file cannot exist on a remote share, because delayed operations are performed before the network is
available.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory on the local computer.</para>
      <para>When moving a file, the destination can be on a different file system or volume. If the destination is on
another drive, you must set the <b>MOVEFILE_COPY_ALLOWED</b> flag in
<i>dwFlags</i>.</para>
      <para>When moving a directory, the destination must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and
<i>lpNewFileName</i> is  <b>NULL</b>,
<b>MoveFileEx</b> registers the
<i>lpExistingFileName</i> file to be deleted when the system restarts. If
<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart
only if the directory is empty.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </description>
              </item>
              <item>
                <description>2 (0x2)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file is to be moved to a different volume, the function simulates the move by using the
<see cref="CopyFile" /> and
<see cref="DeleteFile" /> functions.</para>
            <para>If the  file is successfully copied to a different volume and the original file is unable to be deleted,
the function succeeds leaving the source file intact.</para>
            <para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </description>
              </item>
              <item>
                <description>16 (0x10)</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserved for future use.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </description>
              </item>
              <item>
                <description>4 (0x4)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system does not move the file until the operating system is restarted. The system moves the file
immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter
enables the function to delete paging files from previous startups.</para>
            <para>This value can be used only if the process is in the context of a user who belongs to the administrators
group or the LocalSystem account.</para>
            <para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </description>
              </item>
              <item>
                <description>32 (0x20)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function fails if the source file is a link source, but the file cannot be tracked after the move.
This situation can occur if the destination is a volume formatted with the FAT file system.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </description>
              </item>
              <item>
                <description>1 (0x1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with
the contents of the <i>lpExistingFileName</i> file, provided that security requirements
regarding access control lists (ACLs) are met. For more information, see the Remarks section of this
topic.</para>
            <para>If <i>lpNewFileName</i> names an existing directory, an error is reported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </description>
              </item>
              <item>
                <description>8 (0x8)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function does not return until the file is actually moved on the disk.</para>
            <para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk
before the function returns. The flush occurs at the end of the copy operation.</para>
            <para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the <i>dwFlags</i> parameter specifies
<b>MOVEFILE_DELAY_UNTIL_REBOOT</b>,
<b>MoveFileEx</b> fails if it cannot access the registry. The
function stores the locations of the files to be renamed at restart in the following registry value:
<b>HKEY_LOCAL_MACHINE</b>\<b>SYSTEM</b>\<b>CurrentControlSet</b>\<b>Control</b>\<b>Session Manager</b>\<b>PendingFileRenameOperations</b></para>
      <para>This registry  value is of type <b>REG_MULTI_SZ</b>. Each rename operation stores one
of the following NULL-terminated strings, depending on whether the rename is a delete or not:</para>
      <list type="bullet">
        <item>
          <description>
            <i>szDstFile</i>\0\0
</description>
        </item>
        <item>
          <description>
            <i>szSrcFile</i>\0<i>szDstFile</i>\0
</description>
        </item>
      </list>
      <para>The string <i>szDstFile</i>\0\0 indicates that the file
<i>szDstFile</i> is to be deleted on reboot. The string
<i>szSrcFile</i>\0<i>szDstFile</i>\0 indicates that
<i>szSrcFile</i> is to be renamed <i>szDstFile</i> on reboot.</para>
      <para>
        <b>Note</b>  Although \0\0 is technically not allowed in a <b>REG_MULTI_SZ</b> node, it can because
the file is considered to be renamed to a null name.</para>
      <para>The system uses these registry entries to complete the operations at restart in the same order that they were
issued. For example, the following code fragment creates registry entries that delete
<i>szDstFile</i> and rename <i>szSrcFile</i> to be
<i>szDstFile</i> at restart:</para>
      <code>MoveFileEx(szDstFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
MoveFileEx(szSrcFile, szDstFile, MOVEFILE_DELAY_UNTIL_REBOOT);

</code>
      <para>Because the actual move and deletion operations specified with the
<b>MOVEFILE_DELAY_UNTIL_REBOOT</b> flag take place after the calling application has ceased
running, the return value cannot reflect success or failure in moving or deleting the file. Rather, it reflects
success or failure in placing the appropriate entries into the registry.</para>
      <para>The system deletes a directory that is tagged for deletion with the
<b>MOVEFILE_DELAY_UNTIL_REBOOT</b> flag only if it is empty. To ensure deletion of directories,
move or delete all files from the directory before attempting to delete it. Files may be in the directory at boot
time, but they must be deleted or moved before the system can delete the directory.</para>
      <para>The move and deletion operations are carried out at boot time in the same order that they are specified in the
calling application. To delete a directory that has files in it at boot time, first delete the files.</para>
      <para>If a file is moved across volumes, <b>MoveFileEx</b> does not
move the security descriptor with the file. The file is assigned the default security descriptor in the
destination directory.</para>
      <para>The <b>MoveFileEx</b> function coordinates its operation with
the <a href="https://docs.microsoft.com//windows/desktop/FileIO/distributed-link-tracking-and-object-identifiers">link tracking</a> service,
so link sources can be tracked as they are moved.</para>
      <para>To delete or rename a file, you must have either delete permission on the file or delete child permission in
the parent directory. If you set up a directory with all access except delete and delete child and the ACLs of
new files are inherited, then you should be able to create a file without being able to delete it. However, you
can then create a file, and get all the access you request on the handle that is returned to you at the time that
you create the file. If you request delete permission at the time you create the file, you can delete or rename
the file with that handle but not with any other handle.  For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</seealso>
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="MoveFileTransacted" />
    <seealso cref="MoveFileWithProgress" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.MoveFileEx">
    <summary>
      <para>Moves an existing file or directory, including its children, with various move options.</para>
      <para>The <see cref="MoveFileWithProgress" /> function is equivalent
to the <b>MoveFileEx</b> function, except that
<b>MoveFileWithProgress</b> allows you to provide a
callback function that receives progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the
file cannot exist on a remote share, because delayed operations are performed before the network is
available.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory on the local computer.</para>
      <para>When moving a file, the destination can be on a different file system or volume. If the destination is on
another drive, you must set the <b>MOVEFILE_COPY_ALLOWED</b> flag in
<i>dwFlags</i>.</para>
      <para>When moving a directory, the destination must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and
<i>lpNewFileName</i> is  <b>NULL</b>,
<b>MoveFileEx</b> registers the
<i>lpExistingFileName</i> file to be deleted when the system restarts. If
<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart
only if the directory is empty.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </description>
              </item>
              <item>
                <description>2 (0x2)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file is to be moved to a different volume, the function simulates the move by using the
<see cref="CopyFile" /> and
<see cref="DeleteFile" /> functions.</para>
            <para>If the  file is successfully copied to a different volume and the original file is unable to be deleted,
the function succeeds leaving the source file intact.</para>
            <para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </description>
              </item>
              <item>
                <description>16 (0x10)</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserved for future use.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </description>
              </item>
              <item>
                <description>4 (0x4)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system does not move the file until the operating system is restarted. The system moves the file
immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter
enables the function to delete paging files from previous startups.</para>
            <para>This value can be used only if the process is in the context of a user who belongs to the administrators
group or the LocalSystem account.</para>
            <para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </description>
              </item>
              <item>
                <description>32 (0x20)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function fails if the source file is a link source, but the file cannot be tracked after the move.
This situation can occur if the destination is a volume formatted with the FAT file system.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </description>
              </item>
              <item>
                <description>1 (0x1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with
the contents of the <i>lpExistingFileName</i> file, provided that security requirements
regarding access control lists (ACLs) are met. For more information, see the Remarks section of this
topic.</para>
            <para>If <i>lpNewFileName</i> names an existing directory, an error is reported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </description>
              </item>
              <item>
                <description>8 (0x8)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function does not return until the file is actually moved on the disk.</para>
            <para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk
before the function returns. The flush occurs at the end of the copy operation.</para>
            <para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the <i>dwFlags</i> parameter specifies
<b>MOVEFILE_DELAY_UNTIL_REBOOT</b>,
<b>MoveFileEx</b> fails if it cannot access the registry. The
function stores the locations of the files to be renamed at restart in the following registry value:
<b>HKEY_LOCAL_MACHINE</b>\<b>SYSTEM</b>\<b>CurrentControlSet</b>\<b>Control</b>\<b>Session Manager</b>\<b>PendingFileRenameOperations</b></para>
      <para>This registry  value is of type <b>REG_MULTI_SZ</b>. Each rename operation stores one
of the following NULL-terminated strings, depending on whether the rename is a delete or not:</para>
      <list type="bullet">
        <item>
          <description>
            <i>szDstFile</i>\0\0
</description>
        </item>
        <item>
          <description>
            <i>szSrcFile</i>\0<i>szDstFile</i>\0
</description>
        </item>
      </list>
      <para>The string <i>szDstFile</i>\0\0 indicates that the file
<i>szDstFile</i> is to be deleted on reboot. The string
<i>szSrcFile</i>\0<i>szDstFile</i>\0 indicates that
<i>szSrcFile</i> is to be renamed <i>szDstFile</i> on reboot.</para>
      <para>
        <b>Note</b>  Although \0\0 is technically not allowed in a <b>REG_MULTI_SZ</b> node, it can because
the file is considered to be renamed to a null name.</para>
      <para>The system uses these registry entries to complete the operations at restart in the same order that they were
issued. For example, the following code fragment creates registry entries that delete
<i>szDstFile</i> and rename <i>szSrcFile</i> to be
<i>szDstFile</i> at restart:</para>
      <code>MoveFileEx(szDstFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
MoveFileEx(szSrcFile, szDstFile, MOVEFILE_DELAY_UNTIL_REBOOT);

</code>
      <para>Because the actual move and deletion operations specified with the
<b>MOVEFILE_DELAY_UNTIL_REBOOT</b> flag take place after the calling application has ceased
running, the return value cannot reflect success or failure in moving or deleting the file. Rather, it reflects
success or failure in placing the appropriate entries into the registry.</para>
      <para>The system deletes a directory that is tagged for deletion with the
<b>MOVEFILE_DELAY_UNTIL_REBOOT</b> flag only if it is empty. To ensure deletion of directories,
move or delete all files from the directory before attempting to delete it. Files may be in the directory at boot
time, but they must be deleted or moved before the system can delete the directory.</para>
      <para>The move and deletion operations are carried out at boot time in the same order that they are specified in the
calling application. To delete a directory that has files in it at boot time, first delete the files.</para>
      <para>If a file is moved across volumes, <b>MoveFileEx</b> does not
move the security descriptor with the file. The file is assigned the default security descriptor in the
destination directory.</para>
      <para>The <b>MoveFileEx</b> function coordinates its operation with
the <a href="https://docs.microsoft.com//windows/desktop/FileIO/distributed-link-tracking-and-object-identifiers">link tracking</a> service,
so link sources can be tracked as they are moved.</para>
      <para>To delete or rename a file, you must have either delete permission on the file or delete child permission in
the parent directory. If you set up a directory with all access except delete and delete child and the ACLs of
new files are inherited, then you should be able to create a file without being able to delete it. However, you
can then create a file, and get all the access you request on the handle that is returned to you at the time that
you create the file. If you request delete permission at the time you create the file, you can delete or rename
the file with that handle but not with any other handle.  For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</seealso>
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="MoveFileTransacted" />
    <seealso cref="MoveFileWithProgress" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.MoveFileExA">
    <summary>
      <para>Moves an existing file or directory, including its children, with various move options.</para>
      <para>The <see cref="MoveFileWithProgress" /> function is equivalent
to the <b>MoveFileEx</b> function, except that
<b>MoveFileWithProgress</b> allows you to provide a
callback function that receives progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the
file cannot exist on a remote share, because delayed operations are performed before the network is
available.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory on the local computer.</para>
      <para>When moving a file, the destination can be on a different file system or volume. If the destination is on
another drive, you must set the <b>MOVEFILE_COPY_ALLOWED</b> flag in
<i>dwFlags</i>.</para>
      <para>When moving a directory, the destination must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and
<i>lpNewFileName</i> is  <b>NULL</b>,
<b>MoveFileEx</b> registers the
<i>lpExistingFileName</i> file to be deleted when the system restarts. If
<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart
only if the directory is empty.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </description>
              </item>
              <item>
                <description>2 (0x2)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file is to be moved to a different volume, the function simulates the move by using the
<see cref="CopyFile" /> and
<see cref="DeleteFile" /> functions.</para>
            <para>If the  file is successfully copied to a different volume and the original file is unable to be deleted,
the function succeeds leaving the source file intact.</para>
            <para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </description>
              </item>
              <item>
                <description>16 (0x10)</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserved for future use.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </description>
              </item>
              <item>
                <description>4 (0x4)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system does not move the file until the operating system is restarted. The system moves the file
immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter
enables the function to delete paging files from previous startups.</para>
            <para>This value can be used only if the process is in the context of a user who belongs to the administrators
group or the LocalSystem account.</para>
            <para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </description>
              </item>
              <item>
                <description>32 (0x20)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function fails if the source file is a link source, but the file cannot be tracked after the move.
This situation can occur if the destination is a volume formatted with the FAT file system.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </description>
              </item>
              <item>
                <description>1 (0x1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with
the contents of the <i>lpExistingFileName</i> file, provided that security requirements
regarding access control lists (ACLs) are met. For more information, see the Remarks section of this
topic.</para>
            <para>If <i>lpNewFileName</i> names an existing directory, an error is reported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </description>
              </item>
              <item>
                <description>8 (0x8)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function does not return until the file is actually moved on the disk.</para>
            <para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk
before the function returns. The flush occurs at the end of the copy operation.</para>
            <para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the <i>dwFlags</i> parameter specifies
<b>MOVEFILE_DELAY_UNTIL_REBOOT</b>,
<b>MoveFileEx</b> fails if it cannot access the registry. The
function stores the locations of the files to be renamed at restart in the following registry value:
<b>HKEY_LOCAL_MACHINE</b>\<b>SYSTEM</b>\<b>CurrentControlSet</b>\<b>Control</b>\<b>Session Manager</b>\<b>PendingFileRenameOperations</b></para>
      <para>This registry  value is of type <b>REG_MULTI_SZ</b>. Each rename operation stores one
of the following NULL-terminated strings, depending on whether the rename is a delete or not:</para>
      <list type="bullet">
        <item>
          <description>
            <i>szDstFile</i>\0\0
</description>
        </item>
        <item>
          <description>
            <i>szSrcFile</i>\0<i>szDstFile</i>\0
</description>
        </item>
      </list>
      <para>The string <i>szDstFile</i>\0\0 indicates that the file
<i>szDstFile</i> is to be deleted on reboot. The string
<i>szSrcFile</i>\0<i>szDstFile</i>\0 indicates that
<i>szSrcFile</i> is to be renamed <i>szDstFile</i> on reboot.</para>
      <para>
        <b>Note</b>  Although \0\0 is technically not allowed in a <b>REG_MULTI_SZ</b> node, it can because
the file is considered to be renamed to a null name.</para>
      <para>The system uses these registry entries to complete the operations at restart in the same order that they were
issued. For example, the following code fragment creates registry entries that delete
<i>szDstFile</i> and rename <i>szSrcFile</i> to be
<i>szDstFile</i> at restart:</para>
      <code>MoveFileEx(szDstFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
MoveFileEx(szSrcFile, szDstFile, MOVEFILE_DELAY_UNTIL_REBOOT);

</code>
      <para>Because the actual move and deletion operations specified with the
<b>MOVEFILE_DELAY_UNTIL_REBOOT</b> flag take place after the calling application has ceased
running, the return value cannot reflect success or failure in moving or deleting the file. Rather, it reflects
success or failure in placing the appropriate entries into the registry.</para>
      <para>The system deletes a directory that is tagged for deletion with the
<b>MOVEFILE_DELAY_UNTIL_REBOOT</b> flag only if it is empty. To ensure deletion of directories,
move or delete all files from the directory before attempting to delete it. Files may be in the directory at boot
time, but they must be deleted or moved before the system can delete the directory.</para>
      <para>The move and deletion operations are carried out at boot time in the same order that they are specified in the
calling application. To delete a directory that has files in it at boot time, first delete the files.</para>
      <para>If a file is moved across volumes, <b>MoveFileEx</b> does not
move the security descriptor with the file. The file is assigned the default security descriptor in the
destination directory.</para>
      <para>The <b>MoveFileEx</b> function coordinates its operation with
the <a href="https://docs.microsoft.com//windows/desktop/FileIO/distributed-link-tracking-and-object-identifiers">link tracking</a> service,
so link sources can be tracked as they are moved.</para>
      <para>To delete or rename a file, you must have either delete permission on the file or delete child permission in
the parent directory. If you set up a directory with all access except delete and delete child and the ACLs of
new files are inherited, then you should be able to create a file without being able to delete it. However, you
can then create a file, and get all the access you request on the handle that is returned to you at the time that
you create the file. If you request delete permission at the time you create the file, you can delete or rename
the file with that handle but not with any other handle.  For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</seealso>
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="MoveFileTransacted" />
    <seealso cref="MoveFileWithProgress" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.MoveFileExW">
    <summary>
      <para>Moves an existing file or directory, including its children, with various move options.</para>
      <para>The <see cref="MoveFileWithProgress" /> function is equivalent
to the <b>MoveFileEx</b> function, except that
<b>MoveFileWithProgress</b> allows you to provide a
callback function that receives progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the
file cannot exist on a remote share, because delayed operations are performed before the network is
available.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory on the local computer.</para>
      <para>When moving a file, the destination can be on a different file system or volume. If the destination is on
another drive, you must set the <b>MOVEFILE_COPY_ALLOWED</b> flag in
<i>dwFlags</i>.</para>
      <para>When moving a directory, the destination must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and
<i>lpNewFileName</i> is  <b>NULL</b>,
<b>MoveFileEx</b> registers the
<i>lpExistingFileName</i> file to be deleted when the system restarts. If
<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart
only if the directory is empty.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </description>
              </item>
              <item>
                <description>2 (0x2)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file is to be moved to a different volume, the function simulates the move by using the
<see cref="CopyFile" /> and
<see cref="DeleteFile" /> functions.</para>
            <para>If the  file is successfully copied to a different volume and the original file is unable to be deleted,
the function succeeds leaving the source file intact.</para>
            <para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </description>
              </item>
              <item>
                <description>16 (0x10)</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserved for future use.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </description>
              </item>
              <item>
                <description>4 (0x4)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system does not move the file until the operating system is restarted. The system moves the file
immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter
enables the function to delete paging files from previous startups.</para>
            <para>This value can be used only if the process is in the context of a user who belongs to the administrators
group or the LocalSystem account.</para>
            <para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </description>
              </item>
              <item>
                <description>32 (0x20)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function fails if the source file is a link source, but the file cannot be tracked after the move.
This situation can occur if the destination is a volume formatted with the FAT file system.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </description>
              </item>
              <item>
                <description>1 (0x1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with
the contents of the <i>lpExistingFileName</i> file, provided that security requirements
regarding access control lists (ACLs) are met. For more information, see the Remarks section of this
topic.</para>
            <para>If <i>lpNewFileName</i> names an existing directory, an error is reported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </description>
              </item>
              <item>
                <description>8 (0x8)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function does not return until the file is actually moved on the disk.</para>
            <para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk
before the function returns. The flush occurs at the end of the copy operation.</para>
            <para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the <i>dwFlags</i> parameter specifies
<b>MOVEFILE_DELAY_UNTIL_REBOOT</b>,
<b>MoveFileEx</b> fails if it cannot access the registry. The
function stores the locations of the files to be renamed at restart in the following registry value:
<b>HKEY_LOCAL_MACHINE</b>\<b>SYSTEM</b>\<b>CurrentControlSet</b>\<b>Control</b>\<b>Session Manager</b>\<b>PendingFileRenameOperations</b></para>
      <para>This registry  value is of type <b>REG_MULTI_SZ</b>. Each rename operation stores one
of the following NULL-terminated strings, depending on whether the rename is a delete or not:</para>
      <list type="bullet">
        <item>
          <description>
            <i>szDstFile</i>\0\0
</description>
        </item>
        <item>
          <description>
            <i>szSrcFile</i>\0<i>szDstFile</i>\0
</description>
        </item>
      </list>
      <para>The string <i>szDstFile</i>\0\0 indicates that the file
<i>szDstFile</i> is to be deleted on reboot. The string
<i>szSrcFile</i>\0<i>szDstFile</i>\0 indicates that
<i>szSrcFile</i> is to be renamed <i>szDstFile</i> on reboot.</para>
      <para>
        <b>Note</b>  Although \0\0 is technically not allowed in a <b>REG_MULTI_SZ</b> node, it can because
the file is considered to be renamed to a null name.</para>
      <para>The system uses these registry entries to complete the operations at restart in the same order that they were
issued. For example, the following code fragment creates registry entries that delete
<i>szDstFile</i> and rename <i>szSrcFile</i> to be
<i>szDstFile</i> at restart:</para>
      <code>MoveFileEx(szDstFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
MoveFileEx(szSrcFile, szDstFile, MOVEFILE_DELAY_UNTIL_REBOOT);

</code>
      <para>Because the actual move and deletion operations specified with the
<b>MOVEFILE_DELAY_UNTIL_REBOOT</b> flag take place after the calling application has ceased
running, the return value cannot reflect success or failure in moving or deleting the file. Rather, it reflects
success or failure in placing the appropriate entries into the registry.</para>
      <para>The system deletes a directory that is tagged for deletion with the
<b>MOVEFILE_DELAY_UNTIL_REBOOT</b> flag only if it is empty. To ensure deletion of directories,
move or delete all files from the directory before attempting to delete it. Files may be in the directory at boot
time, but they must be deleted or moved before the system can delete the directory.</para>
      <para>The move and deletion operations are carried out at boot time in the same order that they are specified in the
calling application. To delete a directory that has files in it at boot time, first delete the files.</para>
      <para>If a file is moved across volumes, <b>MoveFileEx</b> does not
move the security descriptor with the file. The file is assigned the default security descriptor in the
destination directory.</para>
      <para>The <b>MoveFileEx</b> function coordinates its operation with
the <a href="https://docs.microsoft.com//windows/desktop/FileIO/distributed-link-tracking-and-object-identifiers">link tracking</a> service,
so link sources can be tracked as they are moved.</para>
      <para>To delete or rename a file, you must have either delete permission on the file or delete child permission in
the parent directory. If you set up a directory with all access except delete and delete child and the ACLs of
new files are inherited, then you should be able to create a file without being able to delete it. However, you
can then create a file, and get all the access you request on the handle that is returned to you at the time that
you create the file. If you request delete permission at the time you create the file, you can delete or rename
the file with that handle but not with any other handle.  For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-using-a-temporary-file">Creating and Using a Temporary File</a>.</para>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso cref="DeleteFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</seealso>
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="MoveFileTransacted" />
    <seealso cref="MoveFileWithProgress" />
    <seealso cref="WritePrivateProfileString" />
  </member>
  <member name="Windows.MoveFile">
    <summary>
      <para>Moves an existing file or a directory, including its children.</para>
      <para>To specify how to move the file, use the
<see cref="MoveFileEx" /> or
<see cref="MoveFileWithProgress" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name for the file or directory. The new name must not already exist. A new file may be on a
different file system or drive. A new directory must be on the same drive.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>MoveFile</b> function will move (rename) either a file or a
directory (including its children) either in the same directory or across directories. The one caveat is that the
<b>MoveFile</b> function will fail on directory moves when the
destination is on a different volume.</para>
      <para>If a file is moved across volumes, <b>MoveFile</b> does not move
the security descriptor with the file. The file will be assigned the default security descriptor in the
destination directory.</para>
      <para>The <b>MoveFile</b> function coordinates its operation with the
link tracking service, so link sources can be tracked as they are moved.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>See comment</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>See comment</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support rename of alternate data streams on file shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines MoveFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFileEx" />
    <seealso cref="MoveFileTransacted" />
    <seealso cref="MoveFileWithProgress" />
  </member>
  <member name="Windows.MoveFileA">
    <summary>
      <para>Moves an existing file or a directory, including its children.</para>
      <para>To specify how to move the file, use the
<see cref="MoveFileEx" /> or
<see cref="MoveFileWithProgress" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name for the file or directory. The new name must not already exist. A new file may be on a
different file system or drive. A new directory must be on the same drive.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>MoveFile</b> function will move (rename) either a file or a
directory (including its children) either in the same directory or across directories. The one caveat is that the
<b>MoveFile</b> function will fail on directory moves when the
destination is on a different volume.</para>
      <para>If a file is moved across volumes, <b>MoveFile</b> does not move
the security descriptor with the file. The file will be assigned the default security descriptor in the
destination directory.</para>
      <para>The <b>MoveFile</b> function coordinates its operation with the
link tracking service, so link sources can be tracked as they are moved.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>See comment</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>See comment</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support rename of alternate data streams on file shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines MoveFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFileEx" />
    <seealso cref="MoveFileTransacted" />
    <seealso cref="MoveFileWithProgress" />
  </member>
  <member name="Windows.MoveFileW">
    <summary>
      <para>Moves an existing file or a directory, including its children.</para>
      <para>To specify how to move the file, use the
<see cref="MoveFileEx" /> or
<see cref="MoveFileWithProgress" /> function.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name for the file or directory. The new name must not already exist. A new file may be on a
different file system or drive. A new directory must be on the same drive.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>MoveFile</b> function will move (rename) either a file or a
directory (including its children) either in the same directory or across directories. The one caveat is that the
<b>MoveFile</b> function will fail on directory moves when the
destination is on a different volume.</para>
      <para>If a file is moved across volumes, <b>MoveFile</b> does not move
the security descriptor with the file. The file will be assigned the default security descriptor in the
destination directory.</para>
      <para>The <b>MoveFile</b> function coordinates its operation with the
link tracking service, so link sources can be tracked as they are moved.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>See comment</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>See comment</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support rename of alternate data streams on file shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines MoveFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFileEx" />
    <seealso cref="MoveFileTransacted" />
    <seealso cref="MoveFileWithProgress" />
  </member>
  <member name="Windows.MoveFileWithProgress">
    <summary>
      <para>Moves a file or directory, including its children. You can provide a callback function that receives
progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of the existing file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the
file cannot exist on a remote share because delayed operations are performed before the network is
available.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory  on the local computer.</para>
      <para>When moving a file, <i>lpNewFileName</i> can be on a different file system or volume. If
<i>lpNewFileName</i> is on another drive, you must set the
<b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>.</para>
      <para>When moving a directory, <i>lpExistingFileName</i> and
<i>lpNewFileName</i> must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and
<i>lpNewFileName</i> is <b>NULL</b>,
<b>MoveFileWithProgress</b> registers
<i>lpExistingFileName</i> to be deleted when the system restarts. The function fails if it
cannot access the registry to store the information about the delete operation. If
<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart
only if the directory is empty.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpProgressRoutine">
      <para>A pointer to a <a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback
function that is called each time another portion of the file has been moved. The callback function can be
useful if you provide a user interface that displays the progress of the operation. This parameter can be
<b>NULL</b>.</para>
    </param>
    <param name="lpData">
      <para>An argument to be passed to the
<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This
parameter can be <b>NULL</b>.</para>
    </param>
    <param name="dwFlags">
      <para>The move options. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </description>
              </item>
              <item>
                <description>2 (0x2)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file is to be moved to a different volume, the function simulates the move by using the
<see cref="CopyFile" /> and
<see cref="DeleteFile" /> functions.</para>
            <para>If the  file is successfully copied to a different volume and the original file is unable to be deleted,
the function succeeds leaving the source file intact.</para>
            <para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </description>
              </item>
              <item>
                <description>16 (0x10)</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserved for future use.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </description>
              </item>
              <item>
                <description>4 (0x4)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system does not move the file until the operating system is restarted. The system moves the file
immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter
enables the function to delete paging files from previous startups.</para>
            <para>This value can only be used if the process is in the context of a user who belongs to the administrators
group or the LocalSystem account.</para>
            <para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </description>
              </item>
              <item>
                <description>32 (0x20)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function fails if the source file is a link source, but the file cannot be tracked after the move.
This situation can occur if the destination is a volume formatted with the FAT file system.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </description>
              </item>
              <item>
                <description>1 (0x1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with
the contents of the <i>lpExistingFileName</i> file.</para>
            <para>This value cannot be used if <i>lpNewFileName</i> or
<i>lpExistingFileName</i> names a directory.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </description>
              </item>
              <item>
                <description>8 (0x8)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function does not return until the file has actually been moved on the disk.</para>
            <para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk
before the function returns. The flush occurs at the end of the copy operation.</para>
            <para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns
<b>PROGRESS_CANCEL</b> due to the user canceling the operation,
<b>MoveFileWithProgress</b> will return zero and
<see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns
<b>PROGRESS_STOP</b> due to the user stopping the operation,
<b>MoveFileWithProgress</b> will return zero and
<see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
    </returns>
    <remarks>
      <para>The <b>MoveFileWithProgress</b> function coordinates its operation with the link
tracking service, so link sources can be tracked as they are moved.</para>
      <para>To delete or rename a file, you must have either delete permission on the file or delete child permission in
the parent directory. If you set up a directory with all access except delete and delete child and the ACLs of new
files are inherited, then you should be able to create a file without being able to delete it. However, you can
then create a file, and you will get all the access you request on the handle returned to you at the time you
create the file. If you requested delete permission at the time you created the file, you could delete or rename
the file with that handle but not with any other.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>CsvFs will do redirected IO for compressed files.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines MoveFileWithProgress as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFileEx" />
    <seealso cref="MoveFileTransacted" />
  </member>
  <member name="Windows.MoveFileWithProgressA">
    <summary>
      <para>Moves a file or directory, including its children. You can provide a callback function that receives
progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of the existing file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the
file cannot exist on a remote share because delayed operations are performed before the network is
available.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory  on the local computer.</para>
      <para>When moving a file, <i>lpNewFileName</i> can be on a different file system or volume. If
<i>lpNewFileName</i> is on another drive, you must set the
<b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>.</para>
      <para>When moving a directory, <i>lpExistingFileName</i> and
<i>lpNewFileName</i> must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and
<i>lpNewFileName</i> is <b>NULL</b>,
<b>MoveFileWithProgress</b> registers
<i>lpExistingFileName</i> to be deleted when the system restarts. The function fails if it
cannot access the registry to store the information about the delete operation. If
<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart
only if the directory is empty.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpProgressRoutine">
      <para>A pointer to a <a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback
function that is called each time another portion of the file has been moved. The callback function can be
useful if you provide a user interface that displays the progress of the operation. This parameter can be
<b>NULL</b>.</para>
    </param>
    <param name="lpData">
      <para>An argument to be passed to the
<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This
parameter can be <b>NULL</b>.</para>
    </param>
    <param name="dwFlags">
      <para>The move options. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </description>
              </item>
              <item>
                <description>2 (0x2)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file is to be moved to a different volume, the function simulates the move by using the
<see cref="CopyFile" /> and
<see cref="DeleteFile" /> functions.</para>
            <para>If the  file is successfully copied to a different volume and the original file is unable to be deleted,
the function succeeds leaving the source file intact.</para>
            <para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </description>
              </item>
              <item>
                <description>16 (0x10)</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserved for future use.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </description>
              </item>
              <item>
                <description>4 (0x4)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system does not move the file until the operating system is restarted. The system moves the file
immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter
enables the function to delete paging files from previous startups.</para>
            <para>This value can only be used if the process is in the context of a user who belongs to the administrators
group or the LocalSystem account.</para>
            <para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </description>
              </item>
              <item>
                <description>32 (0x20)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function fails if the source file is a link source, but the file cannot be tracked after the move.
This situation can occur if the destination is a volume formatted with the FAT file system.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </description>
              </item>
              <item>
                <description>1 (0x1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with
the contents of the <i>lpExistingFileName</i> file.</para>
            <para>This value cannot be used if <i>lpNewFileName</i> or
<i>lpExistingFileName</i> names a directory.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </description>
              </item>
              <item>
                <description>8 (0x8)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function does not return until the file has actually been moved on the disk.</para>
            <para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk
before the function returns. The flush occurs at the end of the copy operation.</para>
            <para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns
<b>PROGRESS_CANCEL</b> due to the user canceling the operation,
<b>MoveFileWithProgress</b> will return zero and
<see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns
<b>PROGRESS_STOP</b> due to the user stopping the operation,
<b>MoveFileWithProgress</b> will return zero and
<see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
    </returns>
    <remarks>
      <para>The <b>MoveFileWithProgress</b> function coordinates its operation with the link
tracking service, so link sources can be tracked as they are moved.</para>
      <para>To delete or rename a file, you must have either delete permission on the file or delete child permission in
the parent directory. If you set up a directory with all access except delete and delete child and the ACLs of new
files are inherited, then you should be able to create a file without being able to delete it. However, you can
then create a file, and you will get all the access you request on the handle returned to you at the time you
create the file. If you requested delete permission at the time you created the file, you could delete or rename
the file with that handle but not with any other.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>CsvFs will do redirected IO for compressed files.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines MoveFileWithProgress as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFileEx" />
    <seealso cref="MoveFileTransacted" />
  </member>
  <member name="Windows.MoveFileWithProgressW">
    <summary>
      <para>Moves a file or directory, including its children. You can provide a callback function that receives
progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of the existing file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the
file cannot exist on a remote share because delayed operations are performed before the network is
available.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory  on the local computer.</para>
      <para>When moving a file, <i>lpNewFileName</i> can be on a different file system or volume. If
<i>lpNewFileName</i> is on another drive, you must set the
<b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>.</para>
      <para>When moving a directory, <i>lpExistingFileName</i> and
<i>lpNewFileName</i> must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and
<i>lpNewFileName</i> is <b>NULL</b>,
<b>MoveFileWithProgress</b> registers
<i>lpExistingFileName</i> to be deleted when the system restarts. The function fails if it
cannot access the registry to store the information about the delete operation. If
<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart
only if the directory is empty.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpProgressRoutine">
      <para>A pointer to a <a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback
function that is called each time another portion of the file has been moved. The callback function can be
useful if you provide a user interface that displays the progress of the operation. This parameter can be
<b>NULL</b>.</para>
    </param>
    <param name="lpData">
      <para>An argument to be passed to the
<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This
parameter can be <b>NULL</b>.</para>
    </param>
    <param name="dwFlags">
      <para>The move options. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </description>
              </item>
              <item>
                <description>2 (0x2)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file is to be moved to a different volume, the function simulates the move by using the
<see cref="CopyFile" /> and
<see cref="DeleteFile" /> functions.</para>
            <para>If the  file is successfully copied to a different volume and the original file is unable to be deleted,
the function succeeds leaving the source file intact.</para>
            <para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </description>
              </item>
              <item>
                <description>16 (0x10)</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserved for future use.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </description>
              </item>
              <item>
                <description>4 (0x4)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system does not move the file until the operating system is restarted. The system moves the file
immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter
enables the function to delete paging files from previous startups.</para>
            <para>This value can only be used if the process is in the context of a user who belongs to the administrators
group or the LocalSystem account.</para>
            <para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </description>
              </item>
              <item>
                <description>32 (0x20)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function fails if the source file is a link source, but the file cannot be tracked after the move.
This situation can occur if the destination is a volume formatted with the FAT file system.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </description>
              </item>
              <item>
                <description>1 (0x1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with
the contents of the <i>lpExistingFileName</i> file.</para>
            <para>This value cannot be used if <i>lpNewFileName</i> or
<i>lpExistingFileName</i> names a directory.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </description>
              </item>
              <item>
                <description>8 (0x8)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function does not return until the file has actually been moved on the disk.</para>
            <para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk
before the function returns. The flush occurs at the end of the copy operation.</para>
            <para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns
<b>PROGRESS_CANCEL</b> due to the user canceling the operation,
<b>MoveFileWithProgress</b> will return zero and
<see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns
<b>PROGRESS_STOP</b> due to the user stopping the operation,
<b>MoveFileWithProgress</b> will return zero and
<see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
    </returns>
    <remarks>
      <para>The <b>MoveFileWithProgress</b> function coordinates its operation with the link
tracking service, so link sources can be tracked as they are moved.</para>
      <para>To delete or rename a file, you must have either delete permission on the file or delete child permission in
the parent directory. If you set up a directory with all access except delete and delete child and the ACLs of new
files are inherited, then you should be able to create a file without being able to delete it. However, you can
then create a file, and you will get all the access you request on the handle returned to you at the time you
create the file. If you requested delete permission at the time you created the file, you could delete or rename
the file with that handle but not with any other.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>CsvFs will do redirected IO for compressed files.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines MoveFileWithProgress as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFileEx" />
    <seealso cref="MoveFileTransacted" />
  </member>
  <member name="Windows.MoveFileWithProgress">
    <summary>
      <para>Moves a file or directory, including its children. You can provide a callback function that receives
progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of the existing file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the
file cannot exist on a remote share because delayed operations are performed before the network is
available.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory  on the local computer.</para>
      <para>When moving a file, <i>lpNewFileName</i> can be on a different file system or volume. If
<i>lpNewFileName</i> is on another drive, you must set the
<b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>.</para>
      <para>When moving a directory, <i>lpExistingFileName</i> and
<i>lpNewFileName</i> must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and
<i>lpNewFileName</i> is <b>NULL</b>,
<b>MoveFileWithProgress</b> registers
<i>lpExistingFileName</i> to be deleted when the system restarts. The function fails if it
cannot access the registry to store the information about the delete operation. If
<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart
only if the directory is empty.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpProgressRoutine">
      <para>A pointer to a <a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback
function that is called each time another portion of the file has been moved. The callback function can be
useful if you provide a user interface that displays the progress of the operation. This parameter can be
<b>NULL</b>.</para>
    </param>
    <param name="lpData">
      <para>An argument to be passed to the
<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This
parameter can be <b>NULL</b>.</para>
    </param>
    <param name="dwFlags">
      <para>The move options. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </description>
              </item>
              <item>
                <description>2 (0x2)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file is to be moved to a different volume, the function simulates the move by using the
<see cref="CopyFile" /> and
<see cref="DeleteFile" /> functions.</para>
            <para>If the  file is successfully copied to a different volume and the original file is unable to be deleted,
the function succeeds leaving the source file intact.</para>
            <para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </description>
              </item>
              <item>
                <description>16 (0x10)</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserved for future use.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </description>
              </item>
              <item>
                <description>4 (0x4)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system does not move the file until the operating system is restarted. The system moves the file
immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter
enables the function to delete paging files from previous startups.</para>
            <para>This value can only be used if the process is in the context of a user who belongs to the administrators
group or the LocalSystem account.</para>
            <para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </description>
              </item>
              <item>
                <description>32 (0x20)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function fails if the source file is a link source, but the file cannot be tracked after the move.
This situation can occur if the destination is a volume formatted with the FAT file system.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </description>
              </item>
              <item>
                <description>1 (0x1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with
the contents of the <i>lpExistingFileName</i> file.</para>
            <para>This value cannot be used if <i>lpNewFileName</i> or
<i>lpExistingFileName</i> names a directory.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </description>
              </item>
              <item>
                <description>8 (0x8)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function does not return until the file has actually been moved on the disk.</para>
            <para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk
before the function returns. The flush occurs at the end of the copy operation.</para>
            <para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns
<b>PROGRESS_CANCEL</b> due to the user canceling the operation,
<b>MoveFileWithProgress</b> will return zero and
<see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns
<b>PROGRESS_STOP</b> due to the user stopping the operation,
<b>MoveFileWithProgress</b> will return zero and
<see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
    </returns>
    <remarks>
      <para>The <b>MoveFileWithProgress</b> function coordinates its operation with the link
tracking service, so link sources can be tracked as they are moved.</para>
      <para>To delete or rename a file, you must have either delete permission on the file or delete child permission in
the parent directory. If you set up a directory with all access except delete and delete child and the ACLs of new
files are inherited, then you should be able to create a file without being able to delete it. However, you can
then create a file, and you will get all the access you request on the handle returned to you at the time you
create the file. If you requested delete permission at the time you created the file, you could delete or rename
the file with that handle but not with any other.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>CsvFs will do redirected IO for compressed files.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines MoveFileWithProgress as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFileEx" />
    <seealso cref="MoveFileTransacted" />
  </member>
  <member name="Windows.MoveFileWithProgressA">
    <summary>
      <para>Moves a file or directory, including its children. You can provide a callback function that receives
progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of the existing file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the
file cannot exist on a remote share because delayed operations are performed before the network is
available.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory  on the local computer.</para>
      <para>When moving a file, <i>lpNewFileName</i> can be on a different file system or volume. If
<i>lpNewFileName</i> is on another drive, you must set the
<b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>.</para>
      <para>When moving a directory, <i>lpExistingFileName</i> and
<i>lpNewFileName</i> must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and
<i>lpNewFileName</i> is <b>NULL</b>,
<b>MoveFileWithProgress</b> registers
<i>lpExistingFileName</i> to be deleted when the system restarts. The function fails if it
cannot access the registry to store the information about the delete operation. If
<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart
only if the directory is empty.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpProgressRoutine">
      <para>A pointer to a <a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback
function that is called each time another portion of the file has been moved. The callback function can be
useful if you provide a user interface that displays the progress of the operation. This parameter can be
<b>NULL</b>.</para>
    </param>
    <param name="lpData">
      <para>An argument to be passed to the
<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This
parameter can be <b>NULL</b>.</para>
    </param>
    <param name="dwFlags">
      <para>The move options. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </description>
              </item>
              <item>
                <description>2 (0x2)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file is to be moved to a different volume, the function simulates the move by using the
<see cref="CopyFile" /> and
<see cref="DeleteFile" /> functions.</para>
            <para>If the  file is successfully copied to a different volume and the original file is unable to be deleted,
the function succeeds leaving the source file intact.</para>
            <para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </description>
              </item>
              <item>
                <description>16 (0x10)</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserved for future use.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </description>
              </item>
              <item>
                <description>4 (0x4)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system does not move the file until the operating system is restarted. The system moves the file
immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter
enables the function to delete paging files from previous startups.</para>
            <para>This value can only be used if the process is in the context of a user who belongs to the administrators
group or the LocalSystem account.</para>
            <para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </description>
              </item>
              <item>
                <description>32 (0x20)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function fails if the source file is a link source, but the file cannot be tracked after the move.
This situation can occur if the destination is a volume formatted with the FAT file system.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </description>
              </item>
              <item>
                <description>1 (0x1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with
the contents of the <i>lpExistingFileName</i> file.</para>
            <para>This value cannot be used if <i>lpNewFileName</i> or
<i>lpExistingFileName</i> names a directory.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </description>
              </item>
              <item>
                <description>8 (0x8)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function does not return until the file has actually been moved on the disk.</para>
            <para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk
before the function returns. The flush occurs at the end of the copy operation.</para>
            <para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns
<b>PROGRESS_CANCEL</b> due to the user canceling the operation,
<b>MoveFileWithProgress</b> will return zero and
<see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns
<b>PROGRESS_STOP</b> due to the user stopping the operation,
<b>MoveFileWithProgress</b> will return zero and
<see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
    </returns>
    <remarks>
      <para>The <b>MoveFileWithProgress</b> function coordinates its operation with the link
tracking service, so link sources can be tracked as they are moved.</para>
      <para>To delete or rename a file, you must have either delete permission on the file or delete child permission in
the parent directory. If you set up a directory with all access except delete and delete child and the ACLs of new
files are inherited, then you should be able to create a file without being able to delete it. However, you can
then create a file, and you will get all the access you request on the handle returned to you at the time you
create the file. If you requested delete permission at the time you created the file, you could delete or rename
the file with that handle but not with any other.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>CsvFs will do redirected IO for compressed files.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines MoveFileWithProgress as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFileEx" />
    <seealso cref="MoveFileTransacted" />
  </member>
  <member name="Windows.MoveFileWithProgressW">
    <summary>
      <para>Moves a file or directory, including its children. You can provide a callback function that receives
progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the
<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of the existing file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the
file cannot exist on a remote share because delayed operations are performed before the network is
available.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory  on the local computer.</para>
      <para>When moving a file, <i>lpNewFileName</i> can be on a different file system or volume. If
<i>lpNewFileName</i> is on another drive, you must set the
<b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>.</para>
      <para>When moving a directory, <i>lpExistingFileName</i> and
<i>lpNewFileName</i> must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and
<i>lpNewFileName</i> is <b>NULL</b>,
<b>MoveFileWithProgress</b> registers
<i>lpExistingFileName</i> to be deleted when the system restarts. The function fails if it
cannot access the registry to store the information about the delete operation. If
<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart
only if the directory is empty.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend
"\?" to the path. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a>.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\?". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <param name="lpProgressRoutine">
      <para>A pointer to a <a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback
function that is called each time another portion of the file has been moved. The callback function can be
useful if you provide a user interface that displays the progress of the operation. This parameter can be
<b>NULL</b>.</para>
    </param>
    <param name="lpData">
      <para>An argument to be passed to the
<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This
parameter can be <b>NULL</b>.</para>
    </param>
    <param name="dwFlags">
      <para>The move options. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </description>
              </item>
              <item>
                <description>2 (0x2)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the file is to be moved to a different volume, the function simulates the move by using the
<see cref="CopyFile" /> and
<see cref="DeleteFile" /> functions.</para>
            <para>If the  file is successfully copied to a different volume and the original file is unable to be deleted,
the function succeeds leaving the source file intact.</para>
            <para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </description>
              </item>
              <item>
                <description>16 (0x10)</description>
              </item>
            </list>
          </description>
          <description>
            <para>Reserved for future use.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </description>
              </item>
              <item>
                <description>4 (0x4)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system does not move the file until the operating system is restarted. The system moves the file
immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter
enables the function to delete paging files from previous startups.</para>
            <para>This value can only be used if the process is in the context of a user who belongs to the administrators
group or the LocalSystem account.</para>
            <para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </description>
              </item>
              <item>
                <description>32 (0x20)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function fails if the source file is a link source, but the file cannot be tracked after the move.
This situation can occur if the destination is a volume formatted with the FAT file system.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </description>
              </item>
              <item>
                <description>1 (0x1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with
the contents of the <i>lpExistingFileName</i> file.</para>
            <para>This value cannot be used if <i>lpNewFileName</i> or
<i>lpExistingFileName</i> names a directory.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </description>
              </item>
              <item>
                <description>8 (0x8)</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function does not return until the file has actually been moved on the disk.</para>
            <para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk
before the function returns. The flush occurs at the end of the copy operation.</para>
            <para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns
<b>PROGRESS_CANCEL</b> due to the user canceling the operation,
<b>MoveFileWithProgress</b> will return zero and
<see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns
<b>PROGRESS_STOP</b> due to the user stopping the operation,
<b>MoveFileWithProgress</b> will return zero and
<see cref="GetLastError" /> will return
<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
    </returns>
    <remarks>
      <para>The <b>MoveFileWithProgress</b> function coordinates its operation with the link
tracking service, so link sources can be tracked as they are moved.</para>
      <para>To delete or rename a file, you must have either delete permission on the file or delete child permission in
the parent directory. If you set up a directory with all access except delete and delete child and the ACLs of new
files are inherited, then you should be able to create a file without being able to delete it. However, you can
then create a file, and you will get all the access you request on the handle returned to you at the time you
create the file. If you requested delete permission at the time you created the file, you could delete or rename
the file with that handle but not with any other.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>CsvFs will do redirected IO for compressed files.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines MoveFileWithProgress as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CopyFileEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="MoveFileEx" />
    <seealso cref="MoveFileTransacted" />
  </member>
  <member name="Windows.MulDiv">
    <summary>
      <para>Multiplies two 32-bit values and then divides the 64-bit result by a third 32-bit value. The final result is rounded to the nearest integer.</para>
    </summary>
    <param name="nNumber">
      <para>The multiplicand.</para>
    </param>
    <param name="nNumerator">
      <para>The multiplier.</para>
    </param>
    <param name="nDenominator">
      <para>The number by which the result of the multiplication operation is to be divided.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the result of the multiplication and division, rounded to the nearest integer. If the result is a positive half integer (ends in .5), it is rounded up. If the result is a negative half integer, it is rounded down.</para>
      <para>If either an overflow occurred or <i>nDenominator</i> was 0, the return value is -1.</para>
    </returns>
    <seealso cref="Int32x32To64" />
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg/large-integers">Large Integers</seealso>
    <seealso cref="UInt32x32To64" />
  </member>
  <member name="Windows.NotifyChangeEventLog">
    <summary>
      <para>Enables an application to receive notification when an event is written to the specified event log. When the event is written to the log, the specified event object is set to the signaled state.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to an event log. The
<see cref="OpenEventLog" />  function returns this handle.</para>
    </param>
    <param name="hEvent">
      <para>A handle to a manual-reset or auto-reset event object. Use the
<see cref="CreateEvent" /> function to create the event object.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>NotifyChangeEventLog</b> function does not work with remote handles. If the <i>hEventLog</i> parameter is the handle to an event log on a remote computer, <b>NotifyChangeEventLog</b> returns zero, and
<see cref="GetLastError" /> returns <b>ERROR_INVALID_HANDLE</b>.</para>
      <para>If the thread is not waiting on the event when the system calls <see cref="PulseEvent" />, the thread will not receive the notification. Therefore, you should create a separate thread to wait for notifications.</para>
      <para>The system will continue to notify you of changes until you close the handle to the event log. To close the event log, use the
<see cref="CloseEventLog" /> or
<see cref="DeregisterEventSource" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/EventLog/receiving-event-notification">Receiving Event Notification</a>.</para>
    </remarks>
    <seealso cref="CloseEventLog" />
    <seealso cref="CreateEvent" />
    <seealso cref="DeregisterEventSource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
  </member>
  <member name="Windows.ObjectCloseAuditAlarm">
    <summary>
      <para>The <b>ObjectCloseAuditAlarm</b> function generates an audit message in the security event log when a handle to a private object is deleted. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>A unique value representing the client's handle to the object. This should be the same value that was passed to the
<see cref="AccessCheckAndAuditAlarm" /> or <see cref="ObjectOpenAuditAlarm" /> function.</para>
    </param>
    <param name="GenerateOnClose">
      <para>Specifies a flag set by a call to the <see cref="AccessCheckAndAuditAlarm" /> or <b>ObjectCloseAuditAlarm</b> function when the object handle is created. If this flag is <b>TRUE</b>, the function generates an audit message. If it is <b>FALSE</b>, the function does not generate an audit message.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>ObjectCloseAuditAlarm</b> function requires the calling application to have the SE_AUDIT_NAME privilege enabled. The test for this privilege is always performed against the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a>, allowing the calling process to impersonate a client.</para>
    </remarks>
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control Overview</seealso>
    <seealso cref="ObjectDeleteAuditAlarm" />
    <seealso cref="ObjectOpenAuditAlarm" />
    <seealso cref="ObjectPrivilegeAuditAlarm" />
  </member>
  <member name="Windows.ObjectCloseAuditAlarmA">
    <summary>
      <para>The <b>ObjectCloseAuditAlarm</b> function generates an audit message in the security event log when a handle to a private object is deleted. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>A unique value representing the client's handle to the object. This should be the same value that was passed to the
<see cref="AccessCheckAndAuditAlarm" /> or <see cref="ObjectOpenAuditAlarm" /> function.</para>
    </param>
    <param name="GenerateOnClose">
      <para>Specifies a flag set by a call to the <see cref="AccessCheckAndAuditAlarm" /> or <b>ObjectCloseAuditAlarm</b> function when the object handle is created. If this flag is <b>TRUE</b>, the function generates an audit message. If it is <b>FALSE</b>, the function does not generate an audit message.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>ObjectCloseAuditAlarm</b> function requires the calling application to have the SE_AUDIT_NAME privilege enabled. The test for this privilege is always performed against the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a>, allowing the calling process to impersonate a client.</para>
    </remarks>
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control Overview</seealso>
    <seealso cref="ObjectDeleteAuditAlarm" />
    <seealso cref="ObjectOpenAuditAlarm" />
    <seealso cref="ObjectPrivilegeAuditAlarm" />
  </member>
  <member name="Windows.ObjectCloseAuditAlarmW">
    <summary>
      <para>The <b>ObjectCloseAuditAlarm</b> function generates an audit message in the security event log when a handle to a private object is deleted. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>A unique value representing the client's handle to the object. This should be the same value that was passed to the
<see cref="AccessCheckAndAuditAlarm" /> or <see cref="ObjectOpenAuditAlarm" /> function.</para>
    </param>
    <param name="GenerateOnClose">
      <para>Specifies a flag set by a call to the <see cref="AccessCheckAndAuditAlarm" /> or <b>ObjectCloseAuditAlarm</b> function when the object handle is created. If this flag is <b>TRUE</b>, the function generates an audit message. If it is <b>FALSE</b>, the function does not generate an audit message.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>ObjectCloseAuditAlarm</b> function requires the calling application to have the SE_AUDIT_NAME privilege enabled. The test for this privilege is always performed against the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a>, allowing the calling process to impersonate a client.</para>
    </remarks>
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control Overview</seealso>
    <seealso cref="ObjectDeleteAuditAlarm" />
    <seealso cref="ObjectOpenAuditAlarm" />
    <seealso cref="ObjectPrivilegeAuditAlarm" />
  </member>
  <member name="Windows.ObjectDeleteAuditAlarm">
    <summary>
      <para>The <b>ObjectDeleteAuditAlarm</b> function generates audit messages when an object is deleted. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>Specifies a unique value representing the client's handle to the object. This must be the same value that was passed to the
<see cref="AccessCheckAndAuditAlarm" /> or
<see cref="ObjectOpenAuditAlarm" /> function.</para>
    </param>
    <param name="GenerateOnClose">
      <para>Specifies a flag set by a call to the
<see cref="AccessCheckAndAuditAlarm" /> or
<see cref="ObjectOpenAuditAlarm" /> function when the object handle is created.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>ObjectDeleteAuditAlarm</b> function requires the calling application to have the SE_AUDIT_NAME privilege enabled. The test for this privilege is always performed against the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a>, allowing the calling process to impersonate a client.</para>
    </remarks>
    <seealso cref="AccessCheck" />
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso cref="AreAllAccessesGranted" />
    <seealso cref="AreAnyAccessesGranted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="MapGenericMask" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="ObjectOpenAuditAlarm" />
    <seealso cref="ObjectPrivilegeAuditAlarm" />
    <seealso cref="PrivilegeCheck" />
    <seealso cref="PrivilegedServiceAuditAlarm" />
  </member>
  <member name="Windows.ObjectDeleteAuditAlarmA">
    <summary>
      <para>The <b>ObjectDeleteAuditAlarm</b> function generates audit messages when an object is deleted. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>Specifies a unique value representing the client's handle to the object. This must be the same value that was passed to the
<see cref="AccessCheckAndAuditAlarm" /> or
<see cref="ObjectOpenAuditAlarm" /> function.</para>
    </param>
    <param name="GenerateOnClose">
      <para>Specifies a flag set by a call to the
<see cref="AccessCheckAndAuditAlarm" /> or
<see cref="ObjectOpenAuditAlarm" /> function when the object handle is created.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>ObjectDeleteAuditAlarm</b> function requires the calling application to have the SE_AUDIT_NAME privilege enabled. The test for this privilege is always performed against the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a>, allowing the calling process to impersonate a client.</para>
    </remarks>
    <seealso cref="AccessCheck" />
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso cref="AreAllAccessesGranted" />
    <seealso cref="AreAnyAccessesGranted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="MapGenericMask" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="ObjectOpenAuditAlarm" />
    <seealso cref="ObjectPrivilegeAuditAlarm" />
    <seealso cref="PrivilegeCheck" />
    <seealso cref="PrivilegedServiceAuditAlarm" />
  </member>
  <member name="Windows.ObjectDeleteAuditAlarmW">
    <summary>
      <para>The <b>ObjectDeleteAuditAlarm</b> function generates audit messages when an object is deleted. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>Specifies a unique value representing the client's handle to the object. This must be the same value that was passed to the
<see cref="AccessCheckAndAuditAlarm" /> or
<see cref="ObjectOpenAuditAlarm" /> function.</para>
    </param>
    <param name="GenerateOnClose">
      <para>Specifies a flag set by a call to the
<see cref="AccessCheckAndAuditAlarm" /> or
<see cref="ObjectOpenAuditAlarm" /> function when the object handle is created.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>ObjectDeleteAuditAlarm</b> function requires the calling application to have the SE_AUDIT_NAME privilege enabled. The test for this privilege is always performed against the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a>, allowing the calling process to impersonate a client.</para>
    </remarks>
    <seealso cref="AccessCheck" />
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso cref="AreAllAccessesGranted" />
    <seealso cref="AreAnyAccessesGranted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="MapGenericMask" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="ObjectOpenAuditAlarm" />
    <seealso cref="ObjectPrivilegeAuditAlarm" />
    <seealso cref="PrivilegeCheck" />
    <seealso cref="PrivilegedServiceAuditAlarm" />
  </member>
  <member name="Windows.ObjectOpenAuditAlarm">
    <summary>
      <para>The <b>ObjectOpenAuditAlarm</b> function generates audit messages when a client application attempts to gain access to an object or to create a new one. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a <b>null</b>-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>A pointer to a unique value representing the client's handle to the object. If the access is denied, this parameter is ignored.</para>
      <para>For cross-platform compatibility, the value addressed by this pointer must be sizeof(LPVOID) bytes long.</para>
    </param>
    <param name="ObjectTypeName">
      <para>A pointer to a <b>null</b>-terminated string specifying the type of object to which the client is requesting access. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="ObjectName">
      <para>A pointer to a <b>null</b>-terminated string specifying the name of the object to which the client is requesting access. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="pSecurityDescriptor">
      <para>A pointer to the
<see cref="SECURITY_DESCRIPTOR" /> structure for the object being accessed.</para>
    </param>
    <param name="ClientToken">
      <para>Identifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> representing the client requesting the operation. This handle must be obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access.</para>
    </param>
    <param name="DesiredAccess">
      <para>Specifies the desired <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a>. This mask must have been previously mapped by the <see cref="MapGenericMask" /> function to contain no generic access rights.</para>
    </param>
    <param name="GrantedAccess">
      <para>Specifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> indicating which access rights are granted. This access mask is intended to be the same value set by one of the access-checking functions in its <i>GrantedAccess</i> parameter. Examples of access-checking functions include <see cref="AccessCheckAndAuditAlarm" /> and <see cref="AccessCheck" />.</para>
    </param>
    <param name="Privileges">
      <para>A pointer to a
<see cref="PRIVILEGE_SET" /> structure that specifies the set of <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a> required for the access attempt. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="ObjectCreation">
      <para>Specifies a flag that determines whether the application creates a new object when access is granted. When this value is <b>TRUE</b>, the application creates a new object; when it is <b>FALSE</b>, the application opens an existing object.</para>
    </param>
    <param name="AccessGranted">
      <para>Specifies a flag indicating whether access was granted or denied in a previous call to an access-checking function, such as <see cref="AccessCheck" />. If access was granted, this value is <b>TRUE</b>. If not, it is <b>FALSE</b>.</para>
    </param>
    <param name="GenerateOnClose">
      <para>A pointer to a flag set by the audit-generation routine when the function returns. This value must be passed to the
<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>ObjectOpenAuditAlarm</b> function requires the calling application to have the SE_AUDIT_NAME privilege enabled. The test for this privilege is always performed against the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a>, not the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> of the thread. This allows the calling process to impersonate a client during the call.</para>
    </remarks>
    <seealso cref="AccessCheck" />
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso cref="AreAllAccessesGranted" />
    <seealso cref="AreAnyAccessesGranted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="MapGenericMask" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="ObjectDeleteAuditAlarm" />
    <seealso cref="ObjectPrivilegeAuditAlarm" />
    <seealso cref="PRIVILEGE_SET" />
    <seealso cref="PrivilegeCheck" />
    <seealso cref="PrivilegedServiceAuditAlarm" />
    <seealso cref="SECURITY_DESCRIPTOR" />
  </member>
  <member name="Windows.ObjectOpenAuditAlarmA">
    <summary>
      <para>The <b>ObjectOpenAuditAlarm</b> function generates audit messages when a client application attempts to gain access to an object or to create a new one. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a <b>null</b>-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>A pointer to a unique value representing the client's handle to the object. If the access is denied, this parameter is ignored.</para>
      <para>For cross-platform compatibility, the value addressed by this pointer must be sizeof(LPVOID) bytes long.</para>
    </param>
    <param name="ObjectTypeName">
      <para>A pointer to a <b>null</b>-terminated string specifying the type of object to which the client is requesting access. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="ObjectName">
      <para>A pointer to a <b>null</b>-terminated string specifying the name of the object to which the client is requesting access. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="pSecurityDescriptor">
      <para>A pointer to the
<see cref="SECURITY_DESCRIPTOR" /> structure for the object being accessed.</para>
    </param>
    <param name="ClientToken">
      <para>Identifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> representing the client requesting the operation. This handle must be obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access.</para>
    </param>
    <param name="DesiredAccess">
      <para>Specifies the desired <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a>. This mask must have been previously mapped by the <see cref="MapGenericMask" /> function to contain no generic access rights.</para>
    </param>
    <param name="GrantedAccess">
      <para>Specifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> indicating which access rights are granted. This access mask is intended to be the same value set by one of the access-checking functions in its <i>GrantedAccess</i> parameter. Examples of access-checking functions include <see cref="AccessCheckAndAuditAlarm" /> and <see cref="AccessCheck" />.</para>
    </param>
    <param name="Privileges">
      <para>A pointer to a
<see cref="PRIVILEGE_SET" /> structure that specifies the set of <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a> required for the access attempt. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="ObjectCreation">
      <para>Specifies a flag that determines whether the application creates a new object when access is granted. When this value is <b>TRUE</b>, the application creates a new object; when it is <b>FALSE</b>, the application opens an existing object.</para>
    </param>
    <param name="AccessGranted">
      <para>Specifies a flag indicating whether access was granted or denied in a previous call to an access-checking function, such as <see cref="AccessCheck" />. If access was granted, this value is <b>TRUE</b>. If not, it is <b>FALSE</b>.</para>
    </param>
    <param name="GenerateOnClose">
      <para>A pointer to a flag set by the audit-generation routine when the function returns. This value must be passed to the
<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>ObjectOpenAuditAlarm</b> function requires the calling application to have the SE_AUDIT_NAME privilege enabled. The test for this privilege is always performed against the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a>, not the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> of the thread. This allows the calling process to impersonate a client during the call.</para>
    </remarks>
    <seealso cref="AccessCheck" />
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso cref="AreAllAccessesGranted" />
    <seealso cref="AreAnyAccessesGranted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="MapGenericMask" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="ObjectDeleteAuditAlarm" />
    <seealso cref="ObjectPrivilegeAuditAlarm" />
    <seealso cref="PRIVILEGE_SET" />
    <seealso cref="PrivilegeCheck" />
    <seealso cref="PrivilegedServiceAuditAlarm" />
    <seealso cref="SECURITY_DESCRIPTOR" />
  </member>
  <member name="Windows.ObjectOpenAuditAlarmW">
    <summary>
      <para>The <b>ObjectOpenAuditAlarm</b> function generates audit messages when a client application attempts to gain access to an object or to create a new one. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a <b>null</b>-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="HandleId">
      <para>A pointer to a unique value representing the client's handle to the object. If the access is denied, this parameter is ignored.</para>
      <para>For cross-platform compatibility, the value addressed by this pointer must be sizeof(LPVOID) bytes long.</para>
    </param>
    <param name="ObjectTypeName">
      <para>A pointer to a <b>null</b>-terminated string specifying the type of object to which the client is requesting access. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="ObjectName">
      <para>A pointer to a <b>null</b>-terminated string specifying the name of the object to which the client is requesting access. This string appears in any audit message that the function generates.</para>
    </param>
    <param name="pSecurityDescriptor">
      <para>A pointer to the
<see cref="SECURITY_DESCRIPTOR" /> structure for the object being accessed.</para>
    </param>
    <param name="ClientToken">
      <para>Identifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> representing the client requesting the operation. This handle must be obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access.</para>
    </param>
    <param name="DesiredAccess">
      <para>Specifies the desired <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a>. This mask must have been previously mapped by the <see cref="MapGenericMask" /> function to contain no generic access rights.</para>
    </param>
    <param name="GrantedAccess">
      <para>Specifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> indicating which access rights are granted. This access mask is intended to be the same value set by one of the access-checking functions in its <i>GrantedAccess</i> parameter. Examples of access-checking functions include <see cref="AccessCheckAndAuditAlarm" /> and <see cref="AccessCheck" />.</para>
    </param>
    <param name="Privileges">
      <para>A pointer to a
<see cref="PRIVILEGE_SET" /> structure that specifies the set of <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a> required for the access attempt. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="ObjectCreation">
      <para>Specifies a flag that determines whether the application creates a new object when access is granted. When this value is <b>TRUE</b>, the application creates a new object; when it is <b>FALSE</b>, the application opens an existing object.</para>
    </param>
    <param name="AccessGranted">
      <para>Specifies a flag indicating whether access was granted or denied in a previous call to an access-checking function, such as <see cref="AccessCheck" />. If access was granted, this value is <b>TRUE</b>. If not, it is <b>FALSE</b>.</para>
    </param>
    <param name="GenerateOnClose">
      <para>A pointer to a flag set by the audit-generation routine when the function returns. This value must be passed to the
<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>ObjectOpenAuditAlarm</b> function requires the calling application to have the SE_AUDIT_NAME privilege enabled. The test for this privilege is always performed against the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a>, not the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> of the thread. This allows the calling process to impersonate a client during the call.</para>
    </remarks>
    <seealso cref="AccessCheck" />
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso cref="AreAllAccessesGranted" />
    <seealso cref="AreAnyAccessesGranted" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso cref="MapGenericMask" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="ObjectDeleteAuditAlarm" />
    <seealso cref="ObjectPrivilegeAuditAlarm" />
    <seealso cref="PRIVILEGE_SET" />
    <seealso cref="PrivilegeCheck" />
    <seealso cref="PrivilegedServiceAuditAlarm" />
    <seealso cref="SECURITY_DESCRIPTOR" />
  </member>
  <member name="Windows.ObjectPrivilegeAuditAlarm">
    <summary>
      <para>The <b>ObjectPrivilegeAuditAlarm</b> function generates an audit message in the security event log. A protected server can use this function to log attempts by a client to use a specified set of <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a> with an open handle to a private object. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in the audit message.</para>
    </param>
    <param name="HandleId">
      <para>A pointer to a unique value representing the client's handle to the object.</para>
    </param>
    <param name="ClientToken">
      <para>Identifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> representing the client that requested the operation. This handle must have been obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access. The function uses this token to get the identity of the client for the audit message.</para>
    </param>
    <param name="DesiredAccess">
      <para>Specifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> indicating the privileged access types being used or whose use is being attempted. The access mask can be mapped by the
<see cref="MapGenericMask" /> function so it does not contain any generic access types.</para>
    </param>
    <param name="Privileges">
      <para>A pointer to a
<see cref="PRIVILEGE_SET" /> structure containing the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a> that the client attempted to use. The names of the privileges appear in the audit message.</para>
    </param>
    <param name="AccessGranted">
      <para>Indicates whether the client's attempt to use the privileges was successful. If this value is <b>TRUE</b>, the audit message indicates success. If this value is <b>FALSE</b>, the audit message indicates failure.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>ObjectPrivilegeAuditAlarm</b> function does not check the client's access to the object or check the client's access token to determine whether the privileges are held or enabled. Typically, you call the
<see cref="PrivilegeCheck" /> function to determine whether the specified privileges are enabled in the access token, call the
<see cref="AccessCheck" /> function to check the client's access to the object, and then call <b>ObjectPrivilegeAuditAlarm</b> to log the results.</para>
      <para>The <b>ObjectPrivilegeAuditAlarm</b> function requires the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> to have SE_AUDIT_NAME privilege enabled. The test for this privilege is always performed against the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling process, not the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> of the thread. This allows the calling process to impersonate a client during the call.</para>
    </remarks>
    <seealso cref="AccessCheck" />
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control Overview</seealso>
    <seealso cref="MapGenericMask" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="ObjectOpenAuditAlarm" />
    <seealso cref="PRIVILEGE_SET" />
    <seealso cref="PrivilegeCheck" />
    <seealso cref="PrivilegedServiceAuditAlarm" />
  </member>
  <member name="Windows.ObjectPrivilegeAuditAlarmA">
    <summary>
      <para>The <b>ObjectPrivilegeAuditAlarm</b> function generates an audit message in the security event log. A protected server can use this function to log attempts by a client to use a specified set of <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a> with an open handle to a private object. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in the audit message.</para>
    </param>
    <param name="HandleId">
      <para>A pointer to a unique value representing the client's handle to the object.</para>
    </param>
    <param name="ClientToken">
      <para>Identifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> representing the client that requested the operation. This handle must have been obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access. The function uses this token to get the identity of the client for the audit message.</para>
    </param>
    <param name="DesiredAccess">
      <para>Specifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> indicating the privileged access types being used or whose use is being attempted. The access mask can be mapped by the
<see cref="MapGenericMask" /> function so it does not contain any generic access types.</para>
    </param>
    <param name="Privileges">
      <para>A pointer to a
<see cref="PRIVILEGE_SET" /> structure containing the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a> that the client attempted to use. The names of the privileges appear in the audit message.</para>
    </param>
    <param name="AccessGranted">
      <para>Indicates whether the client's attempt to use the privileges was successful. If this value is <b>TRUE</b>, the audit message indicates success. If this value is <b>FALSE</b>, the audit message indicates failure.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>ObjectPrivilegeAuditAlarm</b> function does not check the client's access to the object or check the client's access token to determine whether the privileges are held or enabled. Typically, you call the
<see cref="PrivilegeCheck" /> function to determine whether the specified privileges are enabled in the access token, call the
<see cref="AccessCheck" /> function to check the client's access to the object, and then call <b>ObjectPrivilegeAuditAlarm</b> to log the results.</para>
      <para>The <b>ObjectPrivilegeAuditAlarm</b> function requires the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> to have SE_AUDIT_NAME privilege enabled. The test for this privilege is always performed against the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling process, not the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> of the thread. This allows the calling process to impersonate a client during the call.</para>
    </remarks>
    <seealso cref="AccessCheck" />
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control Overview</seealso>
    <seealso cref="MapGenericMask" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="ObjectOpenAuditAlarm" />
    <seealso cref="PRIVILEGE_SET" />
    <seealso cref="PrivilegeCheck" />
    <seealso cref="PrivilegedServiceAuditAlarm" />
  </member>
  <member name="Windows.ObjectPrivilegeAuditAlarmW">
    <summary>
      <para>The <b>ObjectPrivilegeAuditAlarm</b> function generates an audit message in the security event log. A protected server can use this function to log attempts by a client to use a specified set of <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a> with an open handle to a private object. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in the audit message.</para>
    </param>
    <param name="HandleId">
      <para>A pointer to a unique value representing the client's handle to the object.</para>
    </param>
    <param name="ClientToken">
      <para>Identifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> representing the client that requested the operation. This handle must have been obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access. The function uses this token to get the identity of the client for the audit message.</para>
    </param>
    <param name="DesiredAccess">
      <para>Specifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> indicating the privileged access types being used or whose use is being attempted. The access mask can be mapped by the
<see cref="MapGenericMask" /> function so it does not contain any generic access types.</para>
    </param>
    <param name="Privileges">
      <para>A pointer to a
<see cref="PRIVILEGE_SET" /> structure containing the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a> that the client attempted to use. The names of the privileges appear in the audit message.</para>
    </param>
    <param name="AccessGranted">
      <para>Indicates whether the client's attempt to use the privileges was successful. If this value is <b>TRUE</b>, the audit message indicates success. If this value is <b>FALSE</b>, the audit message indicates failure.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>ObjectPrivilegeAuditAlarm</b> function does not check the client's access to the object or check the client's access token to determine whether the privileges are held or enabled. Typically, you call the
<see cref="PrivilegeCheck" /> function to determine whether the specified privileges are enabled in the access token, call the
<see cref="AccessCheck" /> function to check the client's access to the object, and then call <b>ObjectPrivilegeAuditAlarm</b> to log the results.</para>
      <para>The <b>ObjectPrivilegeAuditAlarm</b> function requires the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> to have SE_AUDIT_NAME privilege enabled. The test for this privilege is always performed against the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling process, not the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> of the thread. This allows the calling process to impersonate a client during the call.</para>
    </remarks>
    <seealso cref="AccessCheck" />
    <seealso cref="AccessCheckAndAuditAlarm" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control Overview</seealso>
    <seealso cref="MapGenericMask" />
    <seealso cref="ObjectCloseAuditAlarm" />
    <seealso cref="ObjectOpenAuditAlarm" />
    <seealso cref="PRIVILEGE_SET" />
    <seealso cref="PrivilegeCheck" />
    <seealso cref="PrivilegedServiceAuditAlarm" />
  </member>
  <member name="Windows.OpenBackupEventLog">
    <summary>
      <para>Opens a handle to a backup event log created by the <see cref="BackupEventLog" /> function.</para>
    </summary>
    <param name="lpUNCServerName">
      <para>The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</para>
    </param>
    <param name="lpFileName">
      <para>The full path of the backup file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the backup event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the backup filename specifies a remote server, the <i>lpUNCServerName</i> parameter must be <b>NULL</b>.</para>
      <para>When this function is used on Windows Vista and later computers, only backup event logs that were saved with the <b>BackupEventLog</b> function on Windows Vista and later computers can be opened.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines OpenBackupEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BackupEventLog" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
  </member>
  <member name="Windows.OpenBackupEventLogA">
    <summary>
      <para>Opens a handle to a backup event log created by the <see cref="BackupEventLog" /> function.</para>
    </summary>
    <param name="lpUNCServerName">
      <para>The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</para>
    </param>
    <param name="lpFileName">
      <para>The full path of the backup file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the backup event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the backup filename specifies a remote server, the <i>lpUNCServerName</i> parameter must be <b>NULL</b>.</para>
      <para>When this function is used on Windows Vista and later computers, only backup event logs that were saved with the <b>BackupEventLog</b> function on Windows Vista and later computers can be opened.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines OpenBackupEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BackupEventLog" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
  </member>
  <member name="Windows.OpenBackupEventLogW">
    <summary>
      <para>Opens a handle to a backup event log created by the <see cref="BackupEventLog" /> function.</para>
    </summary>
    <param name="lpUNCServerName">
      <para>The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</para>
    </param>
    <param name="lpFileName">
      <para>The full path of the backup file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the backup event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the backup filename specifies a remote server, the <i>lpUNCServerName</i> parameter must be <b>NULL</b>.</para>
      <para>When this function is used on Windows Vista and later computers, only backup event logs that were saved with the <b>BackupEventLog</b> function on Windows Vista and later computers can be opened.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines OpenBackupEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BackupEventLog" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
  </member>
  <member name="Windows.OpenBackupEventLog">
    <summary>
      <para>Opens a handle to a backup event log created by the <see cref="BackupEventLog" /> function.</para>
    </summary>
    <param name="lpUNCServerName">
      <para>The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</para>
    </param>
    <param name="lpFileName">
      <para>The full path of the backup file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the backup event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the backup filename specifies a remote server, the <i>lpUNCServerName</i> parameter must be <b>NULL</b>.</para>
      <para>When this function is used on Windows Vista and later computers, only backup event logs that were saved with the <b>BackupEventLog</b> function on Windows Vista and later computers can be opened.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines OpenBackupEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BackupEventLog" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
  </member>
  <member name="Windows.OpenBackupEventLogA">
    <summary>
      <para>Opens a handle to a backup event log created by the <see cref="BackupEventLog" /> function.</para>
    </summary>
    <param name="lpUNCServerName">
      <para>The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</para>
    </param>
    <param name="lpFileName">
      <para>The full path of the backup file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the backup event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the backup filename specifies a remote server, the <i>lpUNCServerName</i> parameter must be <b>NULL</b>.</para>
      <para>When this function is used on Windows Vista and later computers, only backup event logs that were saved with the <b>BackupEventLog</b> function on Windows Vista and later computers can be opened.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines OpenBackupEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BackupEventLog" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
  </member>
  <member name="Windows.OpenBackupEventLogW">
    <summary>
      <para>Opens a handle to a backup event log created by the <see cref="BackupEventLog" /> function.</para>
    </summary>
    <param name="lpUNCServerName">
      <para>The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</para>
    </param>
    <param name="lpFileName">
      <para>The full path of the backup file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the backup event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the backup filename specifies a remote server, the <i>lpUNCServerName</i> parameter must be <b>NULL</b>.</para>
      <para>When this function is used on Windows Vista and later computers, only backup event logs that were saved with the <b>BackupEventLog</b> function on Windows Vista and later computers can be opened.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines OpenBackupEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BackupEventLog" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
  </member>
  <member name="Windows.OpenEncryptedFileRaw">
    <summary>
      <para>Opens an encrypted file in order to backup (export) or restore (import)
the file.  This is one of a group of Encrypted File System (EFS) functions that is intended  to implement backup and restore functionality, while maintaining files in their encrypted state.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be opened. The string must consist of characters from the Windows character set.</para>
    </param>
    <param name="ulFlags">
      <para>The operation to be performed. This parameter may be one of the
following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>Open the file for export
(backup).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_FOR_IMPORT</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is being opened for import
(restore).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_FOR_DIR</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Import (restore) a directory containing encrypted files.  This must be combined with one of the previous two flags to indicate the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OVERWRITE_HIDDEN</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Overwrite a hidden file on import.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="pvContext">
      <para>The address of a  context
block that must be presented in subsequent calls to
<see cref="ReadEncryptedFileRaw" />, <see cref="WriteEncryptedFileRaw" />, or
<see cref="CloseEncryptedFileRaw" />.  Do not modify it.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, it returns a nonzero error code defined in
WinError.h. You can use <see cref="FormatMessage" /> with the
<b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of
the error.</para>
    </returns>
    <remarks>
      <para>The caller must either have read or write access to the file, or it must have backup privilege <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeBackupPrivilege</a> on the machine on which the files reside in order for the call to succeed.</para>
      <para>To back up an encrypted file, call <b>OpenEncryptedFileRaw</b> to open the
file and then call <see cref="ReadEncryptedFileRaw" />. When the backup is
complete, call <see cref="CloseEncryptedFileRaw" />.</para>
      <para>To restore an encrypted file, call <b>OpenEncryptedFileRaw</b>, specifying
<b>CREATE_FOR_IMPORT</b> in the <i>ulFlags</i> parameter, and then call
<see cref="WriteEncryptedFileRaw" /> once. When the operation is completed, call
<see cref="CloseEncryptedFileRaw" />.</para>
      <para>
        <b>OpenEncryptedFileRaw</b> fails if <i>lpFileName</i> exceeds <b>MAX_PATH</b> characters when opening an encrypted file on a remote machine.</para>
      <para>If the caller does not have access to the key for the file, the caller needs <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeBackupPrivilege</a> to export encrypted files or SeRestorePrivilege to import encrypted files.</para>
      <para>The  <see cref="BackupRead" /> and <see cref="BackupWrite" /> functions handle backup and restore of unencrypted files.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines OpenEncryptedFileRaw as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BackupRead" />
    <seealso cref="BackupWrite" />
    <seealso cref="CloseEncryptedFileRaw" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="ReadEncryptedFileRaw" />
    <seealso cref="WriteEncryptedFileRaw" />
  </member>
  <member name="Windows.OpenEncryptedFileRawA">
    <summary>
      <para>Opens an encrypted file in order to backup (export) or restore (import)
the file.  This is one of a group of Encrypted File System (EFS) functions that is intended  to implement backup and restore functionality, while maintaining files in their encrypted state.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be opened. The string must consist of characters from the Windows character set.</para>
    </param>
    <param name="ulFlags">
      <para>The operation to be performed. This parameter may be one of the
following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>Open the file for export
(backup).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_FOR_IMPORT</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is being opened for import
(restore).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_FOR_DIR</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Import (restore) a directory containing encrypted files.  This must be combined with one of the previous two flags to indicate the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OVERWRITE_HIDDEN</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Overwrite a hidden file on import.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="pvContext">
      <para>The address of a  context
block that must be presented in subsequent calls to
<see cref="ReadEncryptedFileRaw" />, <see cref="WriteEncryptedFileRaw" />, or
<see cref="CloseEncryptedFileRaw" />.  Do not modify it.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, it returns a nonzero error code defined in
WinError.h. You can use <see cref="FormatMessage" /> with the
<b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of
the error.</para>
    </returns>
    <remarks>
      <para>The caller must either have read or write access to the file, or it must have backup privilege <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeBackupPrivilege</a> on the machine on which the files reside in order for the call to succeed.</para>
      <para>To back up an encrypted file, call <b>OpenEncryptedFileRaw</b> to open the
file and then call <see cref="ReadEncryptedFileRaw" />. When the backup is
complete, call <see cref="CloseEncryptedFileRaw" />.</para>
      <para>To restore an encrypted file, call <b>OpenEncryptedFileRaw</b>, specifying
<b>CREATE_FOR_IMPORT</b> in the <i>ulFlags</i> parameter, and then call
<see cref="WriteEncryptedFileRaw" /> once. When the operation is completed, call
<see cref="CloseEncryptedFileRaw" />.</para>
      <para>
        <b>OpenEncryptedFileRaw</b> fails if <i>lpFileName</i> exceeds <b>MAX_PATH</b> characters when opening an encrypted file on a remote machine.</para>
      <para>If the caller does not have access to the key for the file, the caller needs <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeBackupPrivilege</a> to export encrypted files or SeRestorePrivilege to import encrypted files.</para>
      <para>The  <see cref="BackupRead" /> and <see cref="BackupWrite" /> functions handle backup and restore of unencrypted files.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines OpenEncryptedFileRaw as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BackupRead" />
    <seealso cref="BackupWrite" />
    <seealso cref="CloseEncryptedFileRaw" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="ReadEncryptedFileRaw" />
    <seealso cref="WriteEncryptedFileRaw" />
  </member>
  <member name="Windows.OpenEncryptedFileRawW">
    <summary>
      <para>Opens an encrypted file in order to backup (export) or restore (import)
the file.  This is one of a group of Encrypted File System (EFS) functions that is intended  to implement backup and restore functionality, while maintaining files in their encrypted state.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be opened. The string must consist of characters from the Windows character set.</para>
    </param>
    <param name="ulFlags">
      <para>The operation to be performed. This parameter may be one of the
following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>Open the file for export
(backup).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_FOR_IMPORT</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is being opened for import
(restore).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_FOR_DIR</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Import (restore) a directory containing encrypted files.  This must be combined with one of the previous two flags to indicate the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OVERWRITE_HIDDEN</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Overwrite a hidden file on import.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="pvContext">
      <para>The address of a  context
block that must be presented in subsequent calls to
<see cref="ReadEncryptedFileRaw" />, <see cref="WriteEncryptedFileRaw" />, or
<see cref="CloseEncryptedFileRaw" />.  Do not modify it.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, it returns a nonzero error code defined in
WinError.h. You can use <see cref="FormatMessage" /> with the
<b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of
the error.</para>
    </returns>
    <remarks>
      <para>The caller must either have read or write access to the file, or it must have backup privilege <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeBackupPrivilege</a> on the machine on which the files reside in order for the call to succeed.</para>
      <para>To back up an encrypted file, call <b>OpenEncryptedFileRaw</b> to open the
file and then call <see cref="ReadEncryptedFileRaw" />. When the backup is
complete, call <see cref="CloseEncryptedFileRaw" />.</para>
      <para>To restore an encrypted file, call <b>OpenEncryptedFileRaw</b>, specifying
<b>CREATE_FOR_IMPORT</b> in the <i>ulFlags</i> parameter, and then call
<see cref="WriteEncryptedFileRaw" /> once. When the operation is completed, call
<see cref="CloseEncryptedFileRaw" />.</para>
      <para>
        <b>OpenEncryptedFileRaw</b> fails if <i>lpFileName</i> exceeds <b>MAX_PATH</b> characters when opening an encrypted file on a remote machine.</para>
      <para>If the caller does not have access to the key for the file, the caller needs <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeBackupPrivilege</a> to export encrypted files or SeRestorePrivilege to import encrypted files.</para>
      <para>The  <see cref="BackupRead" /> and <see cref="BackupWrite" /> functions handle backup and restore of unencrypted files.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines OpenEncryptedFileRaw as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BackupRead" />
    <seealso cref="BackupWrite" />
    <seealso cref="CloseEncryptedFileRaw" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="ReadEncryptedFileRaw" />
    <seealso cref="WriteEncryptedFileRaw" />
  </member>
  <member name="Windows.OpenEncryptedFileRaw">
    <summary>
      <para>Opens an encrypted file in order to backup (export) or restore (import)
the file.  This is one of a group of Encrypted File System (EFS) functions that is intended  to implement backup and restore functionality, while maintaining files in their encrypted state.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be opened. The string must consist of characters from the Windows character set.</para>
    </param>
    <param name="ulFlags">
      <para>The operation to be performed. This parameter may be one of the
following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>Open the file for export
(backup).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_FOR_IMPORT</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is being opened for import
(restore).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_FOR_DIR</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Import (restore) a directory containing encrypted files.  This must be combined with one of the previous two flags to indicate the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OVERWRITE_HIDDEN</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Overwrite a hidden file on import.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="pvContext">
      <para>The address of a  context
block that must be presented in subsequent calls to
<see cref="ReadEncryptedFileRaw" />, <see cref="WriteEncryptedFileRaw" />, or
<see cref="CloseEncryptedFileRaw" />.  Do not modify it.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, it returns a nonzero error code defined in
WinError.h. You can use <see cref="FormatMessage" /> with the
<b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of
the error.</para>
    </returns>
    <remarks>
      <para>The caller must either have read or write access to the file, or it must have backup privilege <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeBackupPrivilege</a> on the machine on which the files reside in order for the call to succeed.</para>
      <para>To back up an encrypted file, call <b>OpenEncryptedFileRaw</b> to open the
file and then call <see cref="ReadEncryptedFileRaw" />. When the backup is
complete, call <see cref="CloseEncryptedFileRaw" />.</para>
      <para>To restore an encrypted file, call <b>OpenEncryptedFileRaw</b>, specifying
<b>CREATE_FOR_IMPORT</b> in the <i>ulFlags</i> parameter, and then call
<see cref="WriteEncryptedFileRaw" /> once. When the operation is completed, call
<see cref="CloseEncryptedFileRaw" />.</para>
      <para>
        <b>OpenEncryptedFileRaw</b> fails if <i>lpFileName</i> exceeds <b>MAX_PATH</b> characters when opening an encrypted file on a remote machine.</para>
      <para>If the caller does not have access to the key for the file, the caller needs <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeBackupPrivilege</a> to export encrypted files or SeRestorePrivilege to import encrypted files.</para>
      <para>The  <see cref="BackupRead" /> and <see cref="BackupWrite" /> functions handle backup and restore of unencrypted files.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines OpenEncryptedFileRaw as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BackupRead" />
    <seealso cref="BackupWrite" />
    <seealso cref="CloseEncryptedFileRaw" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="ReadEncryptedFileRaw" />
    <seealso cref="WriteEncryptedFileRaw" />
  </member>
  <member name="Windows.OpenEncryptedFileRawA">
    <summary>
      <para>Opens an encrypted file in order to backup (export) or restore (import)
the file.  This is one of a group of Encrypted File System (EFS) functions that is intended  to implement backup and restore functionality, while maintaining files in their encrypted state.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be opened. The string must consist of characters from the Windows character set.</para>
    </param>
    <param name="ulFlags">
      <para>The operation to be performed. This parameter may be one of the
following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>Open the file for export
(backup).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_FOR_IMPORT</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is being opened for import
(restore).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_FOR_DIR</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Import (restore) a directory containing encrypted files.  This must be combined with one of the previous two flags to indicate the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OVERWRITE_HIDDEN</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Overwrite a hidden file on import.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="pvContext">
      <para>The address of a  context
block that must be presented in subsequent calls to
<see cref="ReadEncryptedFileRaw" />, <see cref="WriteEncryptedFileRaw" />, or
<see cref="CloseEncryptedFileRaw" />.  Do not modify it.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, it returns a nonzero error code defined in
WinError.h. You can use <see cref="FormatMessage" /> with the
<b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of
the error.</para>
    </returns>
    <remarks>
      <para>The caller must either have read or write access to the file, or it must have backup privilege <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeBackupPrivilege</a> on the machine on which the files reside in order for the call to succeed.</para>
      <para>To back up an encrypted file, call <b>OpenEncryptedFileRaw</b> to open the
file and then call <see cref="ReadEncryptedFileRaw" />. When the backup is
complete, call <see cref="CloseEncryptedFileRaw" />.</para>
      <para>To restore an encrypted file, call <b>OpenEncryptedFileRaw</b>, specifying
<b>CREATE_FOR_IMPORT</b> in the <i>ulFlags</i> parameter, and then call
<see cref="WriteEncryptedFileRaw" /> once. When the operation is completed, call
<see cref="CloseEncryptedFileRaw" />.</para>
      <para>
        <b>OpenEncryptedFileRaw</b> fails if <i>lpFileName</i> exceeds <b>MAX_PATH</b> characters when opening an encrypted file on a remote machine.</para>
      <para>If the caller does not have access to the key for the file, the caller needs <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeBackupPrivilege</a> to export encrypted files or SeRestorePrivilege to import encrypted files.</para>
      <para>The  <see cref="BackupRead" /> and <see cref="BackupWrite" /> functions handle backup and restore of unencrypted files.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines OpenEncryptedFileRaw as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BackupRead" />
    <seealso cref="BackupWrite" />
    <seealso cref="CloseEncryptedFileRaw" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="ReadEncryptedFileRaw" />
    <seealso cref="WriteEncryptedFileRaw" />
  </member>
  <member name="Windows.OpenEncryptedFileRawW">
    <summary>
      <para>Opens an encrypted file in order to backup (export) or restore (import)
the file.  This is one of a group of Encrypted File System (EFS) functions that is intended  to implement backup and restore functionality, while maintaining files in their encrypted state.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be opened. The string must consist of characters from the Windows character set.</para>
    </param>
    <param name="ulFlags">
      <para>The operation to be performed. This parameter may be one of the
following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>Open the file for export
(backup).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_FOR_IMPORT</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is being opened for import
(restore).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CREATE_FOR_DIR</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Import (restore) a directory containing encrypted files.  This must be combined with one of the previous two flags to indicate the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OVERWRITE_HIDDEN</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Overwrite a hidden file on import.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="pvContext">
      <para>The address of a  context
block that must be presented in subsequent calls to
<see cref="ReadEncryptedFileRaw" />, <see cref="WriteEncryptedFileRaw" />, or
<see cref="CloseEncryptedFileRaw" />.  Do not modify it.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, it returns a nonzero error code defined in
WinError.h. You can use <see cref="FormatMessage" /> with the
<b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of
the error.</para>
    </returns>
    <remarks>
      <para>The caller must either have read or write access to the file, or it must have backup privilege <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeBackupPrivilege</a> on the machine on which the files reside in order for the call to succeed.</para>
      <para>To back up an encrypted file, call <b>OpenEncryptedFileRaw</b> to open the
file and then call <see cref="ReadEncryptedFileRaw" />. When the backup is
complete, call <see cref="CloseEncryptedFileRaw" />.</para>
      <para>To restore an encrypted file, call <b>OpenEncryptedFileRaw</b>, specifying
<b>CREATE_FOR_IMPORT</b> in the <i>ulFlags</i> parameter, and then call
<see cref="WriteEncryptedFileRaw" /> once. When the operation is completed, call
<see cref="CloseEncryptedFileRaw" />.</para>
      <para>
        <b>OpenEncryptedFileRaw</b> fails if <i>lpFileName</i> exceeds <b>MAX_PATH</b> characters when opening an encrypted file on a remote machine.</para>
      <para>If the caller does not have access to the key for the file, the caller needs <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeBackupPrivilege</a> to export encrypted files or SeRestorePrivilege to import encrypted files.</para>
      <para>The  <see cref="BackupRead" /> and <see cref="BackupWrite" /> functions handle backup and restore of unencrypted files.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines OpenEncryptedFileRaw as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BackupRead" />
    <seealso cref="BackupWrite" />
    <seealso cref="CloseEncryptedFileRaw" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="ReadEncryptedFileRaw" />
    <seealso cref="WriteEncryptedFileRaw" />
  </member>
  <member name="Windows.OpenEventLog">
    <summary>
      <para>Opens a handle to the specified event log.</para>
    </summary>
    <param name="lpUNCServerName">
      <para>The Universal Naming Convention (UNC) name of the remote server on which the event log is to be opened. If this parameter is <b>NULL</b>, the local computer is used.</para>
    </param>
    <param name="lpSourceName">
      <para>The name of the log.</para>
      <para>If you specify a custom log and it cannot be found, the event logging service opens the <b>Application</b> log; however, there will be no associated message or category string file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to an event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To close the handle to the event log, use the
<see cref="CloseEventLog" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/querying-for-event-source-messages">Querying for Event Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines OpenEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ClearEventLog" />
    <seealso cref="CloseEventLog" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/eventlog-key">Eventlog Key</seealso>
    <seealso cref="ReadEventLog" />
    <seealso cref="ReportEvent" />
  </member>
  <member name="Windows.OpenEventLogA">
    <summary>
      <para>Opens a handle to the specified event log.</para>
    </summary>
    <param name="lpUNCServerName">
      <para>The Universal Naming Convention (UNC) name of the remote server on which the event log is to be opened. If this parameter is <b>NULL</b>, the local computer is used.</para>
    </param>
    <param name="lpSourceName">
      <para>The name of the log.</para>
      <para>If you specify a custom log and it cannot be found, the event logging service opens the <b>Application</b> log; however, there will be no associated message or category string file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to an event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To close the handle to the event log, use the
<see cref="CloseEventLog" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/querying-for-event-source-messages">Querying for Event Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines OpenEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ClearEventLog" />
    <seealso cref="CloseEventLog" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/eventlog-key">Eventlog Key</seealso>
    <seealso cref="ReadEventLog" />
    <seealso cref="ReportEvent" />
  </member>
  <member name="Windows.OpenEventLogW">
    <summary>
      <para>Opens a handle to the specified event log.</para>
    </summary>
    <param name="lpUNCServerName">
      <para>The Universal Naming Convention (UNC) name of the remote server on which the event log is to be opened. If this parameter is <b>NULL</b>, the local computer is used.</para>
    </param>
    <param name="lpSourceName">
      <para>The name of the log.</para>
      <para>If you specify a custom log and it cannot be found, the event logging service opens the <b>Application</b> log; however, there will be no associated message or category string file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to an event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To close the handle to the event log, use the
<see cref="CloseEventLog" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/querying-for-event-source-messages">Querying for Event Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines OpenEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ClearEventLog" />
    <seealso cref="CloseEventLog" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/eventlog-key">Eventlog Key</seealso>
    <seealso cref="ReadEventLog" />
    <seealso cref="ReportEvent" />
  </member>
  <member name="Windows.OpenEventLog">
    <summary>
      <para>Opens a handle to the specified event log.</para>
    </summary>
    <param name="lpUNCServerName">
      <para>The Universal Naming Convention (UNC) name of the remote server on which the event log is to be opened. If this parameter is <b>NULL</b>, the local computer is used.</para>
    </param>
    <param name="lpSourceName">
      <para>The name of the log.</para>
      <para>If you specify a custom log and it cannot be found, the event logging service opens the <b>Application</b> log; however, there will be no associated message or category string file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to an event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To close the handle to the event log, use the
<see cref="CloseEventLog" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/querying-for-event-source-messages">Querying for Event Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines OpenEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ClearEventLog" />
    <seealso cref="CloseEventLog" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/eventlog-key">Eventlog Key</seealso>
    <seealso cref="ReadEventLog" />
    <seealso cref="ReportEvent" />
  </member>
  <member name="Windows.OpenEventLogA">
    <summary>
      <para>Opens a handle to the specified event log.</para>
    </summary>
    <param name="lpUNCServerName">
      <para>The Universal Naming Convention (UNC) name of the remote server on which the event log is to be opened. If this parameter is <b>NULL</b>, the local computer is used.</para>
    </param>
    <param name="lpSourceName">
      <para>The name of the log.</para>
      <para>If you specify a custom log and it cannot be found, the event logging service opens the <b>Application</b> log; however, there will be no associated message or category string file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to an event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To close the handle to the event log, use the
<see cref="CloseEventLog" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/querying-for-event-source-messages">Querying for Event Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines OpenEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ClearEventLog" />
    <seealso cref="CloseEventLog" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/eventlog-key">Eventlog Key</seealso>
    <seealso cref="ReadEventLog" />
    <seealso cref="ReportEvent" />
  </member>
  <member name="Windows.OpenEventLogW">
    <summary>
      <para>Opens a handle to the specified event log.</para>
    </summary>
    <param name="lpUNCServerName">
      <para>The Universal Naming Convention (UNC) name of the remote server on which the event log is to be opened. If this parameter is <b>NULL</b>, the local computer is used.</para>
    </param>
    <param name="lpSourceName">
      <para>The name of the log.</para>
      <para>If you specify a custom log and it cannot be found, the event logging service opens the <b>Application</b> log; however, there will be no associated message or category string file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to an event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To close the handle to the event log, use the
<see cref="CloseEventLog" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/querying-for-event-source-messages">Querying for Event Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines OpenEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ClearEventLog" />
    <seealso cref="CloseEventLog" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/eventlog-key">Eventlog Key</seealso>
    <seealso cref="ReadEventLog" />
    <seealso cref="ReportEvent" />
  </member>
  <member name="Windows.OpenFile">
    <summary>
      <para>Creates, opens, reopens, or deletes a file.
<b>Note</b>  This function has limited capabilities and is not recommended. For new application development, use the
<see cref="CreateFile" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>The string must consist of characters from the 8-bit Windows character set. The
<b>OpenFile</b> function does not support Unicode file names or
opening named pipes.</para>
    </param>
    <param name="lpReOpenBuff">
      <para>A pointer to the <see cref="OFSTRUCT" /> structure that receives
information about a file when it is first opened.</para>
      <para>The structure can be used in subsequent calls to the
<b>OpenFile</b> function to see an open file.</para>
      <para>The <see cref="OFSTRUCT" /> structure contains a path string
member with a length that is limited to <b>OFS_MAXPATHNAME</b> characters, which is 128
characters. Because of this, you cannot use the <b>OpenFile</b></para>
      <para>function to open a file with a path length that exceeds 128 characters. The
<see cref="CreateFile" /> function does not have this path
length limitation.</para>
    </param>
    <param name="uStyle">
      <para>The action to be taken.</para>
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OF_CANCEL</b>
                </description>
              </item>
              <item>
                <description>0x00000800</description>
              </item>
            </list>
          </description>
          <description>
            <para>Ignored.</para>
            <para>To produce a dialog box containing a <b>Cancel</b> button, use
<b>OF_PROMPT</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OF_CREATE</b>
                </description>
              </item>
              <item>
                <description>0x00001000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Creates a new file.</para>
            <para>If the file exists, it is truncated to zero (0) length.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OF_DELETE</b>
                </description>
              </item>
              <item>
                <description>0x00000200</description>
              </item>
            </list>
          </description>
          <description>
            <para>Deletes a file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OF_EXIST</b>
                </description>
              </item>
              <item>
                <description>0x00004000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Opens a file and then closes it.</para>
            <para>Use this to test for the existence of a file.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OF_PARSE</b>
                </description>
              </item>
              <item>
                <description>0x00000100</description>
              </item>
            </list>
          </description>
          <description>
            <para>Fills the <see cref="OFSTRUCT" /> structure, but does not do
anything else.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OF_PROMPT</b>
                </description>
              </item>
              <item>
                <description>0x00002000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Displays a dialog box if a requested file does not exist.</para>
            <para>A dialog box informs a user that the system cannot find a file, and it contains
<b>Retry</b> and <b>Cancel</b> buttons. The
<b>Cancel</b> button directs <b>OpenFile</b></para>
            <para>to return a file-not-found error message.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OF_READ</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Opens a file for reading only.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OF_READWRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Opens a file with read/write permissions.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OF_REOPEN</b>
                </description>
              </item>
              <item>
                <description>0x00008000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Opens a file by using information in the reopen buffer.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OF_SHARE_COMPAT</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>For MS-DOS–based file systems, opens a file with compatibility mode, allows any
process on a specified computer to open the file any number of times.</para>
            <para>Other efforts to open a file with other sharing modes fail. This flag is mapped to the
<b>FILE_SHARE_READ</b>|<b>FILE_SHARE_WRITE</b> flags of the
<see cref="CreateFile" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OF_SHARE_DENY_NONE</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>Opens a file without denying read or write access to other processes.</para>
            <para>On MS-DOS-based file systems, if the file has been opened in compatibility mode by any other process, the
function fails.</para>
            <para>This flag is mapped to the
<b>FILE_SHARE_READ</b>|<b>FILE_SHARE_WRITE</b> flags of the
<see cref="CreateFile" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OF_SHARE_DENY_READ</b>
                </description>
              </item>
              <item>
                <description>0x00000030</description>
              </item>
            </list>
          </description>
          <description>
            <para>Opens a file and denies read access to other processes.</para>
            <para>On MS-DOS-based file systems, if the file has been opened in compatibility mode, or for read access by any
other process, the function fails.</para>
            <para>This flag is mapped to the <b>FILE_SHARE_WRITE</b> flag of the
<see cref="CreateFile" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OF_SHARE_DENY_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>Opens a file and denies write access to other processes.</para>
            <para>On MS-DOS-based file systems, if a file has been opened in compatibility mode, or for write access by any
other process, the function fails.</para>
            <para>This flag is mapped to the <b>FILE_SHARE_READ</b> flag of the
<see cref="CreateFile" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OF_SHARE_EXCLUSIVE</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Opens a file with exclusive mode, and denies both read/write access to other processes. If a file has been
opened in any other mode for read/write access, even by the current process, the function fails.</para>
          </description>
        </item>
        <item>
          <description>
            <b>OF_VERIFY</b>
          </description>
          <description>
            <para>Verifies that the date and time of a file are the same as when it was opened previously.</para>
            <para>This is useful as an extra check for read-only files.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>OF_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Opens a file for write access only.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies a file handle to use when performing file I/O. To close the file, call the <see cref="CloseHandle" /> function using this handle.</para>
      <para>If the function fails, the return value is <b>HFILE_ERROR</b>. To get extended error
information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If the <i>lpFileName</i> parameter specifies a file name and extension only, this function
searches for a matching file in the following directories and the order shown:</para>
      <list type="number">
        <item>
          <description>
            <para>The directory where an application is loaded.</para>
          </description>
        </item>
        <item>
          <description>
            <para>The current directory.</para>
          </description>
        </item>
        <item>
          <description>
            <para>The Windows system directory.</para>
            <para>Use the <see cref="GetSystemDirectory" /> function to get the
path of this directory.</para>
          </description>
        </item>
        <item>
          <description>
            <para>The 16-bit Windows system directory.</para>
            <para>There is not a function that retrieves the path of this directory, but it is searched.</para>
          </description>
        </item>
        <item>
          <description>
            <para>The Windows directory.</para>
            <para>Use the <see cref="GetWindowsDirectory" /> function to get
the path of this directory.</para>
          </description>
        </item>
        <item>
          <description>
            <para>The directories that are listed in the PATH environment variable.</para>
          </description>
        </item>
      </list>
      <para>The <i>lpFileName</i> parameter cannot contain wildcard characters.</para>
      <para>The <b>OpenFile</b> function does not support the
<b>OF_SEARCH</b> flag that the 16-bit Windows
<b>OpenFile</b> function supports. The
<b>OF_SEARCH</b> flag directs the system to search for a matching file even when a file name
includes a full path. Use the <see cref="SearchPath" /> function to search
for a file.</para>
      <para>A sharing violation occurs if an attempt is made to open a file or directory for deletion on a remote machine
when the value of the <i>uStyle</i> parameter is the <b>OF_DELETE</b> access
flag OR'ed with any other access flag, and the remote file or directory has not been opened with
<b>FILE_SHARE_DELETE</b> share access. To avoid the sharing violation in this scenario, open
the remote file or directory with <b>OF_DELETE</b> access only, or call
<see cref="DeleteFile" /> without first opening the file or directory for
deletion.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>CsvFs will do redirected IO for compressed files.</para>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="OFSTRUCT" />
    <seealso cref="SearchPath" />
  </member>
  <member name="Windows.OpenFileById">
    <summary>
      <para>Opens the file that matches the specified identifier.</para>
    </summary>
    <param name="hVolumeHint">
      <para>A handle to any file on a volume or share on which the file to be opened is stored.</para>
    </param>
    <param name="lpFileId">
      <para>A pointer to a <see cref="FILE_ID_DESCRIPTOR" /> that identifies
the file to open.</para>
    </param>
    <param name="dwDesiredAccess">
      <para>The access to the object. Access can be read, write, or both.</para>
      <para>For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access
Rights</a>. You cannot request an access mode that conflicts with the sharing mode that is specified in an
open request that has an open handle.</para>
      <para>If this parameter is zero (0), the application can query file and device attributes without accessing a
device. This is useful for an application to determine the size of a floppy disk drive and the formats it
supports without requiring a floppy in a drive. It can also be used to test for the existence of a file or
directory without opening them for read or write access.</para>
    </param>
    <param name="dwShareMode">
      <para>The sharing mode of an object, which can be read, write, both, or none.</para>
      <para>You cannot request a sharing mode that conflicts with the access mode that is specified in an open request
that has an open handle, because that would result in the following sharing violation:
(<b>ERROR_SHARING_VIOLATION</b>). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</para>
      <para>If this parameter is zero (0) and <b>OpenFileById</b></para>
      <para>succeeds, the object cannot be shared and cannot be opened again until the handle is closed. For more
information, see the Remarks section of this topic.</para>
      <para>The sharing options remain in effect until you close the handle to an object.</para>
      <para>To enable a processes to share an object while another process has the object open, use a combination of one
or more of the following values to specify the access mode they can request to open the object.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SHARE_DELETE</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables subsequent open operations on an object to request delete access.</para>
            <para>Otherwise, other processes cannot open the object if they request delete access.</para>
            <para>If this flag is not specified, but the object has been opened for delete access, the function fails.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SHARE_READ</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables subsequent open operations on an object to request read access.</para>
            <para>Otherwise, other processes cannot open the object if they request read access.</para>
            <para>If this flag is not specified, but the object has been opened for read access, the function fails.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SHARE_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables subsequent open operations on an object to request write access.</para>
            <para>Otherwise, other processes cannot open the object if they request write access.</para>
            <para>If this flag is not specified, but the object has been opened for write access or has a file mapping with
write access, the function fails.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpSecurityAttributes">
      <para>Reserved.</para>
    </param>
    <param name="dwFlagsAndAttributes">
      <para>The file flags.</para>
      <para>When <b>OpenFileById</b> opens a file, it combines the file
flags with existing file attributes, and ignores any supplied file attributes. This parameter can include any
combination of the following flags.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_BACKUP_SEMANTICS</b>
                </description>
              </item>
              <item>
                <description>0x02000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file is being opened for a backup or restore operation. The system ensures that the calling process
overrides file security checks when the process has <b>SE_BACKUP_NAME</b> and
<b>SE_RESTORE_NAME</b> privileges. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecBP/changing-privileges-in-a-token">Changing Privileges in a Token</a>.</para>
            <para>You must set this flag to obtain a handle to a directory. A directory handle can be passed to some
functions  instead of a file handle. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/obtaining-a-handle-to-a-directory">Directory Handles</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_NO_BUFFERING</b>
                </description>
              </item>
              <item>
                <description>0x20000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system opens a file with no system caching. This flag does not affect hard disk caching. When combined
with <b>FILE_FLAG_OVERLAPPED</b>, the flag gives maximum asynchronous performance, because
the I/O does not rely on the synchronous operations of the memory manager. However, some I/O operations take
more time, because data is not being held in the cache. Also, the file metadata may still be cached. To flush
the metadata to disk, use the <see cref="FlushFileBuffers" /></para>
            <para>function.</para>
            <para>An application must meet certain requirements when working with files that are opened with
<b>FILE_FLAG_NO_BUFFERING</b>:</para>
            <list type="bullet">
              <item>
                <description>File access must begin at byte offsets within a file that are integer multiples of the volume sector
size.</description>
              </item>
              <item>
                <description>File access must be for numbers of bytes that are integer multiples of the volume sector size. For
example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1024, 1536, or
2048 bytes, but not of 335, 981, or 7171 bytes.</description>
              </item>
              <item>
                <description>Buffer addresses for read and write operations should be sector aligned, which means aligned on
addresses in memory that are integer multiples of the volume sector size. Depending on the disk, this
requirement may not be enforced.</description>
              </item>
            </list>
            <para>One way to align buffers on integer multiples of the volume sector size is to use
<see cref="VirtualAlloc" /> to allocate the buffers. It allocates
memory that is aligned on addresses that are integer multiples of the operating system's memory page size.
Because both memory page and volume sector sizes are powers of 2, this memory is also aligned on addresses
that are integer multiples of a volume sector size. Memory pages are 4-8 KB in size; sectors are 512 bytes
(hard disks) or 2048 bytes (CD), and therefore, volume sectors can never be larger than memory pages.</para>
            <para>An application can determine a volume sector size by calling the
<see cref="GetDiskFreeSpace" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_OPEN_NO_RECALL</b>
                </description>
              </item>
              <item>
                <description>0x00100000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file data is requested, but it should continue to be located in remote storage. It should not be
transported back to local storage. This flag is for use by remote storage systems.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_OPEN_REPARSE_POINT</b>
                </description>
              </item>
              <item>
                <description>0x00200000</description>
              </item>
            </list>
          </description>
          <description>
            <para>When this flag is used, normal <a href="https://docs.microsoft.com//windows/desktop/FileIO/reparse-points">reparse point</a></para>
            <para>processing does not occur, and <b>OpenFileById</b> attempts
to open the reparse point. When a file is opened, a file handle is returned, whether or not the filter that
controls the reparse point is operational. This flag cannot be used with the
<b>CREATE_ALWAYS</b> flag. If the file is not a reparse point, then this flag is
ignored.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_OVERLAPPED</b>
                </description>
              </item>
              <item>
                <description>0x40000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The file is being opened or created for asynchronous I/O. When the operation is complete, the event
specified to the call in the <see cref="OVERLAPPED" /> structure is
set to the signaled state. Operations that take a significant amount of time to process return
<b>ERROR_IO_PENDING</b>.</para>
            <para>If this flag is specified, the file can be used for simultaneous read and write operations. The system does
not maintain the file pointer, therefore you must pass the file position to the read and write functions in
the <see cref="OVERLAPPED" />  structure or update the file
pointer.</para>
            <para>If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write
functions specify an <see cref="OVERLAPPED" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_RANDOM_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x10000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file is accessed randomly. The system can use this as a hint to optimize file caching.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_SEQUENTIAL_SCAN</b>
                </description>
              </item>
              <item>
                <description>0x08000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>A file is accessed sequentially from beginning to end. The system can use this as a hint to optimize file
caching. If an application moves the file pointer for random access, optimum caching may not occur. However,
correct operation is still guaranteed.</para>
            <para>Specifying this flag can increase performance for applications that read large files using sequential
access. Performance gains can be even more noticeable for applications that read large files mostly
sequentially, but occasionally skip over small ranges of bytes.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_WRITE_THROUGH</b>
                </description>
              </item>
              <item>
                <description>0x80000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The system writes through any intermediate cache and goes directly to disk.</para>
            <para>If <b>FILE_FLAG_NO_BUFFERING</b> is not also specified, so that system caching is in
effect, then the data is written to the system cache, but is flushed to disk without delay.</para>
            <para>If <b>FILE_FLAG_NO_BUFFERING</b> is also specified, so that system caching is not in
effect, then the data is immediately flushed to disk without going through the system cache. The operating
system also requests a write-through the hard disk cache to persistent media. However, not all hardware
supports this write-through capability.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to a specified file.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended
error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Use the <see cref="CloseHandle" /> function to close an object handle
that <b>OpenFileById</b> returns.</para>
      <para>If you call <b>OpenFileById</b> on a file that is pending
deletion as a result of a previous call to <see cref="DeleteFile" />, the
function fails. The operating system delays file deletion until all handles to the file are closed.
<see cref="GetLastError" /> returns
<b>ERROR_ACCESS_DENIED</b>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-mask">ACCESS_MASK</seealso>
    <seealso cref="CloseHandle" />
    <seealso cref="CreateFile" />
    <seealso cref="DeleteFile" />
    <seealso cref="FILE_ID_DESCRIPTOR" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFileInformationByHandleEx" />
    <seealso cref="GetOverlappedResult" />
    <seealso cref="OVERLAPPED" />
    <seealso cref="OpenFile" />
    <seealso cref="ReadFile" />
    <seealso cref="WriteFile" />
  </member>
  <member name="Windows.OpenFileMapping">
    <summary>
      <para>Opens a named file mapping object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the file mapping object. This access is checked against any security descriptor on the target
file mapping object. For a list of values, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this parameter is <b>TRUE</b>, a process created by the
<see cref="CreateProcess" /> function can inherit the handle;
otherwise, the handle cannot be inherited.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object to be opened. If there is an open handle to a file mapping object by
this name and the security descriptor on the mapping object does not conflict with the
<i>dwDesiredAccess</i> parameter, the open operation succeeds. The name can have a
"Global\" or "Local\" prefix to explicitly open an object in the global or
session namespace. The remainder of the name can contain any character except the backslash character (\). For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user
switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next
user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal
Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified file mapping object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle that <b>OpenFileMapping</b> returns can be used
with any function that requires a handle to a file mapping object.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>When it is no longer needed, the caller should call release the handle returned by
<b>OpenFileMapping</b> with a call to
<see cref="CloseHandle" />.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-named-shared-memory">Creating Named Shared Memory</a>.</para>
    </remarks>
    <seealso cref="CreateFileMapping" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">File Mapping Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/sharing-files-and-memory">Sharing Files and Memory</seealso>
  </member>
  <member name="Windows.OpenFileMappingA">
    <summary>
      <para>Opens a named file mapping object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the file mapping object. This access is checked against any security descriptor on the target
file mapping object. For a list of values, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this parameter is <b>TRUE</b>, a process created by the
<see cref="CreateProcess" /> function can inherit the handle;
otherwise, the handle cannot be inherited.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object to be opened. If there is an open handle to a file mapping object by
this name and the security descriptor on the mapping object does not conflict with the
<i>dwDesiredAccess</i> parameter, the open operation succeeds. The name can have a
"Global\" or "Local\" prefix to explicitly open an object in the global or
session namespace. The remainder of the name can contain any character except the backslash character (\). For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user
switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next
user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal
Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified file mapping object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle that <b>OpenFileMapping</b> returns can be used
with any function that requires a handle to a file mapping object.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>When it is no longer needed, the caller should call release the handle returned by
<b>OpenFileMapping</b> with a call to
<see cref="CloseHandle" />.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-named-shared-memory">Creating Named Shared Memory</a>.</para>
    </remarks>
    <seealso cref="CreateFileMapping" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">File Mapping Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/sharing-files-and-memory">Sharing Files and Memory</seealso>
  </member>
  <member name="Windows.OpenFileMappingW">
    <summary>
      <para>Opens a named file mapping object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the file mapping object. This access is checked against any security descriptor on the target
file mapping object. For a list of values, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this parameter is <b>TRUE</b>, a process created by the
<see cref="CreateProcess" /> function can inherit the handle;
otherwise, the handle cannot be inherited.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object to be opened. If there is an open handle to a file mapping object by
this name and the security descriptor on the mapping object does not conflict with the
<i>dwDesiredAccess</i> parameter, the open operation succeeds. The name can have a
"Global\" or "Local\" prefix to explicitly open an object in the global or
session namespace. The remainder of the name can contain any character except the backslash character (\). For
more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user
switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next
user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal
Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified file mapping object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information,
call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The handle that <b>OpenFileMapping</b> returns can be used
with any function that requires a handle to a file mapping object.</para>
      <para>When modifying a file through a mapped view, the last modification timestamp may not be updated automatically.
If required, the caller should use <see cref="SetFileTime" /> to set the
timestamp.</para>
      <para>When it is no longer needed, the caller should call release the handle returned by
<b>OpenFileMapping</b> with a call to
<see cref="CloseHandle" />.</para>
      <para>In Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/creating-named-shared-memory">Creating Named Shared Memory</a>.</para>
    </remarks>
    <seealso cref="CreateFileMapping" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/memory-management-functions">File Mapping Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/sharing-files-and-memory">Sharing Files and Memory</seealso>
  </member>
  <member name="Windows.OpenJobObject">
    <summary>
      <para>Opens an existing job object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the job object. This parameter can be one or more of the
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/job-object-security-and-access-rights">job object access rights</a>. This access right is checked against any security descriptor for the object.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</para>
    </param>
    <param name="lpName">
      <para>The name of the job to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the job. The handle provides the requested access to the job.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To associate a process with a job, use the
<see cref="AssignProcessToJobObject" /> function.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="AssignProcessToJobObject" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/job-objects">Job Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
  </member>
  <member name="Windows.OpenJobObjectA">
    <summary>
      <para>Opens an existing job object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the job object. This parameter can be one or more of the
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/job-object-security-and-access-rights">job object access rights</a>. This access right is checked against any security descriptor for the object.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</para>
    </param>
    <param name="lpName">
      <para>The name of the job to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the job. The handle provides the requested access to the job.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To associate a process with a job, use the
<see cref="AssignProcessToJobObject" /> function.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="AssignProcessToJobObject" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/job-objects">Job Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
  </member>
  <member name="Windows.OpenJobObjectW">
    <summary>
      <para>Opens an existing job object.</para>
    </summary>
    <param name="dwDesiredAccess">
      <para>The access to the job object. This parameter can be one or more of the
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/job-object-security-and-access-rights">job object access rights</a>. This access right is checked against any security descriptor for the object.</para>
    </param>
    <param name="bInheritHandle">
      <para>If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</para>
    </param>
    <param name="lpName">
      <para>The name of the job to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see
<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the job. The handle provides the requested access to the job.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To associate a process with a job, use the
<see cref="AssignProcessToJobObject" /> function.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="AssignProcessToJobObject" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/job-objects">Job Objects</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
  </member>
  <member name="Windows.OpenPrivateNamespace">
    <summary>
      <para>Opens a private namespace.</para>
    </summary>
    <param name="lpBoundaryDescriptor">
      <para>A descriptor that defines how the namespace is to be isolated. The <see cref="CreateBoundaryDescriptor" /> function creates a boundary descriptor.</para>
    </param>
    <param name="lpAliasPrefix">
      <para>The prefix for the namespace. To create an object in this namespace, specify the object name as <i>prefix</i>\<i>objectname</i>.</para>
    </param>
    <returns>
      <para>The function returns the handle to the existing namespace.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0600 or later.</para>
    </remarks>
    <seealso cref="ClosePrivateNamespace" />
    <seealso cref="CreateBoundaryDescriptor" />
    <seealso cref="CreatePrivateNamespace" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</seealso>
  </member>
  <member name="Windows.OpenPrivateNamespaceA">
    <summary>
      <para>Opens a private namespace.</para>
    </summary>
    <param name="lpBoundaryDescriptor">
      <para>A descriptor that defines how the namespace is to be isolated. The <see cref="CreateBoundaryDescriptor" /> function creates a boundary descriptor.</para>
    </param>
    <param name="lpAliasPrefix">
      <para>The prefix for the namespace. To create an object in this namespace, specify the object name as <i>prefix</i>\<i>objectname</i>.</para>
    </param>
    <returns>
      <para>The function returns the handle to the existing namespace.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0600 or later.</para>
    </remarks>
    <seealso cref="ClosePrivateNamespace" />
    <seealso cref="CreateBoundaryDescriptor" />
    <seealso cref="CreatePrivateNamespace" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</seealso>
  </member>
  <member name="Windows.OpenPrivateNamespaceW">
    <summary>
      <para>Opens a private namespace.</para>
    </summary>
    <param name="lpBoundaryDescriptor">
      <para>A descriptor that defines how the namespace is to be isolated. The <see cref="CreateBoundaryDescriptor" /> function creates a boundary descriptor.</para>
    </param>
    <param name="lpAliasPrefix">
      <para>The prefix for the namespace. To create an object in this namespace, specify the object name as <i>prefix</i>\<i>objectname</i>.</para>
    </param>
    <returns>
      <para>The function returns the handle to the existing namespace.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0600 or later.</para>
    </remarks>
    <seealso cref="ClosePrivateNamespace" />
    <seealso cref="CreateBoundaryDescriptor" />
    <seealso cref="CreatePrivateNamespace" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</seealso>
  </member>
  <member name="Windows.OperationEnd">
    <summary>
      <para>Notifies the system that the application is about to end an operation</para>
      <para>Every call to <see cref="OperationStart" /> must be followed by a call to <b>OperationEnd</b>, otherwise the operation's record of file access patterns is discarded after 10 seconds.</para>
    </summary>
    <param name="OperationEndParams">
      <para>An <see cref="_OPERATION_END_PARAMETERS" /> structure that specifies <b>VERSION</b>, <b>OPERATION_ID</b> and <b>FLAGS</b>.</para>
    </param>
    <returns>
      <para>
        <b>TRUE</b> for all valid parameters and <b>FALSE</b> otherwise.  To get extended error information, call <b>GetLastError</b>.</para>
    </returns>
    <remarks>
      <para>The version of the <see cref="_OPERATION_END_PARAMETERS" /> structure is defined as <b>OPERATION_API_VERSION</b> in the Windows SDK.</para>
      <para>The  <b>OperationEnd</b> function is safe to call on any thread.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oprec/operation-id">OPERATION_ID</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oprec/-operation-portal">Operation Recorder</seealso>
    <seealso cref="OperationStart" />
    <seealso cref="_OPERATION_END_PARAMETERS" />
    <seealso cref="_OPERATION_START_PARAMETERS" />
  </member>
  <member name="Windows.OperationStart">
    <summary>
      <para>Notifies the system that the application is about to start an operation.</para>
      <para>If an application calls <b>OperationStart</b> with a valid <a href="https://docs.microsoft.com//previous-versions/windows/desktop/oprec/operation-id">OPERATION_ID</a> value, the system records the specified operation’s file access patterns until <see cref="OperationEnd" /> is called for the same operation ID. This record is stored in a <i>filename.pf</i> prefetch file. Every call to <b>OperationStart</b> must be followed by a call to <b>OperationEnd</b>, otherwise the operation's record is discarded after 10 seconds.</para>
      <para>If an application calls <b>OperationStart</b> for an operation ID for which a prefetch file exists, the system loads the operation's files into memory prior to running the operation. The recording process remains the same and the system updates the appropriate <i>filename.pf</i> prefetch file.</para>
    </summary>
    <param name="OperationStartParams">
      <para>An <see cref="_OPERATION_START_PARAMETERS" /> structure that specifies <b>VERSION</b>, <b>OPERATION_ID</b> and <b>FLAGS</b>.</para>
    </param>
    <returns>
      <para>
        <b>TRUE</b> for all valid parameters and <b>FALSE</b> otherwise.  To get extended error information, call <b>GetLastError</b>.</para>
    </returns>
    <remarks>
      <para>The version of the <see cref="_OPERATION_START_PARAMETERS" /> structure is defined as <b>OPERATION_API_VERSION</b> in the Windows SDK.</para>
      <para>Because the <b>OperationStart</b> function is synchronous, it can take several seconds to return. This should be avoided in UI threads for the best responsiveness.</para>
      <para>There is a single instance of the operation recorder in a process. Although the operation  recorder APIs can be called from multiple threads within the process, all calls act on the single instance.</para>
      <para>Application launch tracing lasts for the first 10 second of the process lifetime.  <b>OperationStart</b> should be called after the end of application launch tracing by the system.</para>
      <para>Every call to <b>OperationStart</b> must be followed by a call to <see cref="OperationEnd" />. Otherwise, the operation trace will be discarded after about 10s.</para>
      <para>The maximum number of operations that can be recorded on a given system is configurable. If this maximum is exceeded, the least recently used prefetch files are replaced.</para>
      <para>On Windows 8, this functionality requires the Superfetch service to be enabled. Windows 8 will have the service enabled by default.
For Windows Server 2012, this prefetching functionality needs to be enabled and disabled as required. This can be done using CIM based PowerShell cmdlets.  The prefetcher functionality can be exposed using the <a href="https://docs.microsoft.com//windows/desktop/WmiSdk/cimclas">CIM class</a>  of the <b>CIM_PrefetcherService</b>.</para>
      <h4>Examples</h4>
      <code>    BOOL Success;
    DWORD ErrorCode;
    OPERATION_START_PARAMETERS OpStart;
    OPERATION_END_PARAMETERS OpEnd;

    // We want to notify Windows that we are going to be performing some
    // disk-bound work that repeatedly access the same file data. The system will
    // try to record data about our activity to make future operations faster.

    ZeroMemory(&amp;amp;amp;amp;amp;amp;amp;OpStart, sizeof(OpStart));
    OpStart.Version = OPERATION_API_VERSION;
    OpStart.OperationId = MY_OPERATION_ID_1;

    ZeroMemory(&amp;amp;amp;amp;amp;amp;amp;OpEnd, sizeof(OpEnd));
    OpEnd.Version = OPERATION_API_VERSION;
    OpEnd.OperationId = MY_OPERATION_ID_1;

    // We want the system to only record activity in this thread.

    OpStart.Flags = OPERATION_START_TRACE_CURRENT_THREAD;
    OpEnd.Flags = 0;

    Success = OperationStart(&amp;amp;amp;amp;amp;amp;amp;OpStart);

    if (!Success) {
        ErrorCode = GetLastError();
        fprintf(stderr, "OperationStart failed: %d\n", ErrorCode);

        // We could not notify the system about our operation. That's OK.

                  }

    // Perform the disk-bound work that should be recorded here.
    // This may involve opening/reading many files or loading
    // and running many DLLs.

    Success = OperationEnd(&amp;amp;amp;amp;amp;amp;amp;OpEnd);

    if (!Success) {
        fprintf(stderr, "OperationEnd failed: %d\n", GetLastError());
                  }


</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oprec/operation-id">OPERATION_ID</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/oprec/-operation-portal">Operation Recorder</seealso>
    <seealso cref="OperationEnd" />
    <seealso cref="_OPERATION_END_PARAMETERS" />
    <seealso cref="_OPERATION_START_PARAMETERS" />
  </member>
  <member name="Windows.PowerClearRequest">
    <summary>
      <para>Decrements the count of power requests of the specified type for a power request object.</para>
    </summary>
    <param name="PowerRequest">
      <para>A handle to a power request object.</para>
    </param>
    <param name="RequestType">
      <para>The power request type to be decremented. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>PowerRequestDisplayRequired</b>
          </description>
          <description>
            <para>The display remains on even if there is no user input for an extended period of time.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PowerRequestSystemRequired</b>
          </description>
          <description>
            <para>The system continues to run instead of entering sleep after a period of user inactivity.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PowerRequestAwayModeRequired</b>
          </description>
          <description>
            <para>The system enters away mode instead of sleep. In away mode, the system continues to run but turns off audio and video to give the appearance of sleep.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PowerRequestExecutionRequired</b>
          </description>
          <description>
            <para>The calling process continues to run instead of being suspended or terminated by process lifetime management mechanisms. When and how long the process is allowed to run depends on the operating system and  power policy settings.</para>
            <para>When a <b>PowerRequestExecutionRequired</b> request is active, it implies <b>PowerRequestSystemRequired</b>.</para>
            <para>The <b>PowerRequestExecutionRequired</b> request type can be used only by applications. Services cannot use this request type.</para>
            <para>
              <b>Windows 7 and Windows Server 2008 R2:  </b>This request type is supported starting with Windows 8 and Windows Server 2012.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="PowerCreateRequest" />
    <seealso cref="PowerSetRequest" />
  </member>
  <member name="Windows.PowerCreateRequest">
    <summary>
      <para>Creates a new power request object.</para>
    </summary>
    <param name="Context">
      <para>Points to a <see cref="REASON_CONTEXT" /> structure that contains information about the power request.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the power request object.</para>
      <para>If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When the power request object is no longer needed, use the <see cref="CloseHandle" /> function to free the handle and clean up the object.</para>
    </remarks>
    <seealso cref="PowerClearRequest" />
    <seealso cref="PowerSetRequest" />
  </member>
  <member name="Windows.PowerSetRequest">
    <summary>
      <para>Increments the count of power requests of the specified type for a power request object.</para>
    </summary>
    <param name="PowerRequest">
      <para>A handle to a power request object.</para>
    </param>
    <param name="RequestType">
      <para>The power request type to be incremented. This parameter can be one of the following values.</para>
      <para>| Value  | Description |
|--------|-------------|
| PowerRequestDisplayRequired | The display remains on even if there is no user input for an extended period of time.<br /><br /><b>Note: </b>A <b>PowerRequestSystemRequired</b> must be taken in addition to a <b>PowerRequestDisplayRequired</b> to ensure the display stays on and the system does not enter sleep for the duration of the request. |
| PowerRequestSystemRequired | The system continues to run instead of entering sleep after a period of user inactivity. |
| PowerRequestAwayModeRequired | The system enters away mode instead of sleep in response to explicit action by the user. In away mode, the system continues to run but turns off audio and video to give the appearance of sleep. <b>PowerRequestAwayModeRequired</b> is only applicable on Traditional Sleep (S3) systems. |
| PowerRequestExecutionRequired | The calling process continues to run instead of being suspended or terminated by process lifetime management mechanisms. When and how long the process is allowed to run depends on the operating system and  power policy settings.<br /><br />On Traditional Sleep (S3) systems, an active <b>PowerRequestExecutionRequired</b> request implies <b>PowerRequestSystemRequired</b>. |</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, it returns zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>On Modern Standby systems on DC power, power requests are terminated after 5 minutes.</para>
      <para>Except for <b>PowerRequestAwayModeRequired</b> on Traditional Sleep (S3) systems, power requests are terminated upon user-initiated system sleep entry (power button, lid close or selecting <b>Sleep</b> from the <b>Start</b> menu).</para>
      <para>To conserve power and provide the best user experience, applications that use power requests should follow these best practices:</para>
      <list type="bullet">
        <item>
          <description>When creating a power request, provide a localized text string that describes the reason for the request in the <see cref="REASON_CONTEXT" /> structure.</description>
        </item>
        <item>
          <description>Call <b>PowerSetRequest</b> immediately before the scenario that requires the request.</description>
        </item>
        <item>
          <description>Call <see cref="PowerClearRequest" /> to decrement the reference count for the request as soon as the scenario is finished.</description>
        </item>
        <item>
          <description>Clean up all request objects and associated handles before the process exits or the service stops.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="PowerClearRequest" />
    <seealso cref="PowerCreateRequest" />
  </member>
  <member name="Windows.PrepareTape">
    <summary>
      <para>The
<b>PrepareTape</b> function prepares the tape to be accessed or removed.</para>
    </summary>
    <param name="hDevice">
      <para>Handle to the device preparing the tape. This handle is created by using the
<see cref="CreateFile" /> function.</para>
    </param>
    <param name="dwOperation">
      <para>Tape device preparation. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_FORMAT</b>
                </description>
              </item>
              <item>
                <description>5L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Performs a low-level format of the tape. Currently, only the QIC117 device supports this feature.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_LOAD</b>
                </description>
              </item>
              <item>
                <description>0L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Loads the tape and moves the tape to the beginning.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_LOCK</b>
                </description>
              </item>
              <item>
                <description>3L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Locks the tape ejection mechanism so that the tape is not ejected accidentally.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_TENSION</b>
                </description>
              </item>
              <item>
                <description>2L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Adjusts the tension by moving the tape to the end of the tape and back to the beginning. This option is not supported by all devices. This value is ignored if it is not supported.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_UNLOAD</b>
                </description>
              </item>
              <item>
                <description>1L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Moves the tape to the beginning for removal from the device. After a successful unload operation, the device returns errors to applications that attempt to access the tape, until the tape is loaded again.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_UNLOCK</b>
                </description>
              </item>
              <item>
                <description>4L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Unlocks the tape ejection mechanism.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="bImmediate">
      <para>If this parameter is <b>TRUE</b>, the function returns immediately. If it is <b>FALSE</b>, the function does not return until the operation has been completed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, it can return one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_BEGINNING_OF_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1102L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to access data before the beginning-of-medium marker failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_BUS_RESET</b>
                </description>
              </item>
              <item>
                <description>1111L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A reset condition was detected on the bus.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_DEVICE_NOT_PARTITIONED</b>
                </description>
              </item>
              <item>
                <description>1107L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The partition information could not be found when a tape was being loaded.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_END_OF_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1100L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The end-of-tape marker was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_FILEMARK_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1101L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A filemark was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_INVALID_BLOCK_LENGTH</b>
                </description>
              </item>
              <item>
                <description>1106L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The block size is incorrect on a new tape in a multivolume partition.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_MEDIA_CHANGED</b>
                </description>
              </item>
              <item>
                <description>1110L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape that was in the drive has been replaced or removed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NO_DATA_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1104L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The end-of-data marker was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NO_MEDIA_IN_DRIVE</b>
                </description>
              </item>
              <item>
                <description>1112L</description>
              </item>
            </list>
          </description>
          <description>
            <para>There is no media in the drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NOT_SUPPORTED</b>
                </description>
              </item>
              <item>
                <description>50L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape driver does not support a requested function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_PARTITION_FAILURE</b>
                </description>
              </item>
              <item>
                <description>1105L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape could not be partitioned.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_SETMARK_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1103L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A setmark was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_UNABLE_TO_LOCK_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1108L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to lock the ejection mechanism failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1109L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to unload the tape failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_WRITE_PROTECT</b>
                </description>
              </item>
              <item>
                <description>19L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The media is write protected.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Some tape devices do not support certain tape operations. See your tape device documentation and use the
<see cref="GetTapeParameters" /> function to determine your tape device's capabilities.</para>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="GetTapeParameters" />
  </member>
  <member name="Windows.PrivilegedServiceAuditAlarm">
    <summary>
      <para>The <b>PrivilegedServiceAuditAlarm</b> function generates an audit message in the security event log. A protected server can use this function to log attempts by a client to use a specified set of <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a>.</para>
      <para>Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string specifying the name of the subsystem calling the function. This information appears in the security event log record.</para>
    </param>
    <param name="ServiceName">
      <para>A pointer to a null-terminated string specifying the name of the privileged subsystem service. This information appears in the security event log record.</para>
    </param>
    <param name="ClientToken">
      <para>Identifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> representing the client that requested the operation. This handle must have been obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access. The function uses this token to get the identity of the client for the security event log record.</para>
    </param>
    <param name="Privileges">
      <para>A pointer to a
<see cref="PRIVILEGE_SET" /> structure containing the privileges that the client attempted to use. The names of the privileges appear in the security event log record.</para>
    </param>
    <param name="AccessGranted">
      <para>Indicates whether the client's attempt to use the privileges was successful. If this value is <b>TRUE</b>, the security event log record indicates success. If this value is <b>FALSE</b>, the security event log record indicates failure.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>PrivilegedServiceAuditAlarm</b> function does not check the client's access token to determine whether the privileges are held or enabled. Typically, you first call the
<see cref="PrivilegeCheck" /> function to determine whether the specified privileges are enabled in the access token, and then call <b>PrivilegedServiceAuditAlarm</b> to log the results.</para>
      <para>The <b>PrivilegedServiceAuditAlarm</b> function requires the calling process to have SE_AUDIT_NAME privilege enabled. The test for this privilege is always performed against the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling process. This allows the calling process to impersonate a client during the call.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control Overview</seealso>
    <seealso cref="ObjectPrivilegeAuditAlarm" />
    <seealso cref="PRIVILEGE_SET" />
    <seealso cref="PrivilegeCheck" />
  </member>
  <member name="Windows.PrivilegedServiceAuditAlarmA">
    <summary>
      <para>The <b>PrivilegedServiceAuditAlarm</b> function generates an audit message in the security event log. A protected server can use this function to log attempts by a client to use a specified set of <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a>.</para>
      <para>Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string specifying the name of the subsystem calling the function. This information appears in the security event log record.</para>
    </param>
    <param name="ServiceName">
      <para>A pointer to a null-terminated string specifying the name of the privileged subsystem service. This information appears in the security event log record.</para>
    </param>
    <param name="ClientToken">
      <para>Identifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> representing the client that requested the operation. This handle must have been obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access. The function uses this token to get the identity of the client for the security event log record.</para>
    </param>
    <param name="Privileges">
      <para>A pointer to a
<see cref="PRIVILEGE_SET" /> structure containing the privileges that the client attempted to use. The names of the privileges appear in the security event log record.</para>
    </param>
    <param name="AccessGranted">
      <para>Indicates whether the client's attempt to use the privileges was successful. If this value is <b>TRUE</b>, the security event log record indicates success. If this value is <b>FALSE</b>, the security event log record indicates failure.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>PrivilegedServiceAuditAlarm</b> function does not check the client's access token to determine whether the privileges are held or enabled. Typically, you first call the
<see cref="PrivilegeCheck" /> function to determine whether the specified privileges are enabled in the access token, and then call <b>PrivilegedServiceAuditAlarm</b> to log the results.</para>
      <para>The <b>PrivilegedServiceAuditAlarm</b> function requires the calling process to have SE_AUDIT_NAME privilege enabled. The test for this privilege is always performed against the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling process. This allows the calling process to impersonate a client during the call.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control Overview</seealso>
    <seealso cref="ObjectPrivilegeAuditAlarm" />
    <seealso cref="PRIVILEGE_SET" />
    <seealso cref="PrivilegeCheck" />
  </member>
  <member name="Windows.PrivilegedServiceAuditAlarmW">
    <summary>
      <para>The <b>PrivilegedServiceAuditAlarm</b> function generates an audit message in the security event log. A protected server can use this function to log attempts by a client to use a specified set of <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a>.</para>
      <para>Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">
      <para>A pointer to a null-terminated string specifying the name of the subsystem calling the function. This information appears in the security event log record.</para>
    </param>
    <param name="ServiceName">
      <para>A pointer to a null-terminated string specifying the name of the privileged subsystem service. This information appears in the security event log record.</para>
    </param>
    <param name="ClientToken">
      <para>Identifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> representing the client that requested the operation. This handle must have been obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access. The function uses this token to get the identity of the client for the security event log record.</para>
    </param>
    <param name="Privileges">
      <para>A pointer to a
<see cref="PRIVILEGE_SET" /> structure containing the privileges that the client attempted to use. The names of the privileges appear in the security event log record.</para>
    </param>
    <param name="AccessGranted">
      <para>Indicates whether the client's attempt to use the privileges was successful. If this value is <b>TRUE</b>, the security event log record indicates success. If this value is <b>FALSE</b>, the security event log record indicates failure.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>PrivilegedServiceAuditAlarm</b> function does not check the client's access token to determine whether the privileges are held or enabled. Typically, you first call the
<see cref="PrivilegeCheck" /> function to determine whether the specified privileges are enabled in the access token, and then call <b>PrivilegedServiceAuditAlarm</b> to log the results.</para>
      <para>The <b>PrivilegedServiceAuditAlarm</b> function requires the calling process to have SE_AUDIT_NAME privilege enabled. The test for this privilege is always performed against the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> of the calling process. This allows the calling process to impersonate a client during the call.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Client/Server Access Control Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/client-server-access-control">Client/Server Access Control Overview</seealso>
    <seealso cref="ObjectPrivilegeAuditAlarm" />
    <seealso cref="PRIVILEGE_SET" />
    <seealso cref="PrivilegeCheck" />
  </member>
  <member name="Windows.PulseEvent">
    <summary>
      <para>Sets the specified event object to the signaled state and then resets it to the nonsignaled state after releasing the appropriate number of waiting threads.
<b>Note</b>  This function is unreliable and should not be used. It exists mainly for backward compatibility. For more information, see Remarks.</para>
    </summary>
    <param name="hEvent">
      <para>A handle to the event object. The
<see cref="CreateEvent" /> or
<see cref="OpenEvent" /> function returns this handle.</para>
      <para>The handle must have the EVENT_MODIFY_STATE access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>A thread waiting on a synchronization object can be momentarily removed from the wait state  by a kernel-mode APC, and then returned to the wait state after the APC is complete.  If the call to  <b>PulseEvent</b> occurs during the time when the thread has been   removed from the wait state, the thread will not be released  because  <b>PulseEvent</b> releases only those threads that are waiting at the moment it is called.  Therefore,  <b>PulseEvent</b> is unreliable and should  not be  used by new applications.
Instead, use <a href="https://docs.microsoft.com//windows/desktop/Sync/condition-variables">condition variables</a>.</para>
      <para>For a manual-reset event object, all waiting threads that can be released immediately are released. The function then resets the event object's state to nonsignaled and returns.</para>
      <para>For an auto-reset event object, the function resets the state to nonsignaled and returns after releasing a single waiting thread, even if multiple threads are waiting.</para>
      <para>If no threads are waiting, or if no thread can be released immediately,
<b>PulseEvent</b> simply sets the event object's state to nonsignaled and returns.</para>
      <para>Note that for a thread using the multiple-object
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a> to wait for all specified objects to be signaled,
<b>PulseEvent</b> can set the event object's state to signaled and reset it to nonsignaled without causing the wait function to return. This happens if not all of the specified objects are simultaneously signaled.</para>
      <para>Use extreme caution when using  <see cref="SignalObjectAndWait" />  and <b>PulseEvent</b> with Windows 7, since using these APIs among multiple threads can cause an application to deadlock. Threads that are signaled by <b>SignalObjectAndWait</b>  call <b>PulseEvent</b> to signal the waiting object of the <b>SignalObjectAndWait</b> call. In some circumstances, the caller of <b>SignalObjectAndWait</b> can't receive signal state of the waiting object in time, causing a deadlock.</para>
    </remarks>
    <seealso cref="CreateEvent" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/event-objects">Event Objects</seealso>
    <seealso cref="OpenEvent" />
    <seealso cref="ResetEvent" />
    <seealso cref="SetEvent" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
  </member>
  <member name="Windows.PurgeComm">
    <summary>
      <para>Discards all characters from the output or input buffer of a specified communications resource. It can also terminate pending read or write operations on the resource.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the communications resource. The
<see cref="CreateFile" /> function returns this handle.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PURGE_RXABORT</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Terminates all outstanding overlapped read operations and returns immediately, even if the read operations have not been completed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PURGE_RXCLEAR</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Clears the input buffer (if the device driver has one).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PURGE_TXABORT</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Terminates all outstanding overlapped write operations and returns immediately, even if the write operations have not been completed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PURGE_TXCLEAR</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Clears the output buffer (if the device driver has one).</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If a thread uses
<b>PurgeComm</b> to flush an output buffer, the deleted characters are not transmitted. To empty the output buffer while ensuring that the contents are transmitted, call the
<see cref="FlushFileBuffers" /> function (a synchronous operation). Note, however, that <b>FlushFileBuffers</b> is subject to flow control but not to write time-outs, and it will not return until all pending write operations have been transmitted.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="CreateFile" />
  </member>
  <member name="Windows.QueryActCtxSettingsW">
    <summary>
      <para>The <b>QueryActCtxSettingsW</b> function specifies the activation context, and the namespace and name of the attribute that is to be queried.</para>
    </summary>
    <param name="dwFlags">
      <para>This value must be 0.</para>
    </param>
    <param name="hActCtx">
      <para>A handle to the activation context that is being queried.</para>
    </param>
    <param name="settingsNameSpace">
      <para>A pointer to a string that contains the value <b>"http://schemas.microsoft.com/SMI/2005/WindowsSettings"</b> or <b>NULL</b>. These values are equivalent.</para>
      <para>
        <b>Windows 8 and Windows Server 2012:  </b>A pointer to a string that contains the value <b>"http://schemas.microsoft.com/SMI/2011/WindowsSettings"</b> is also a valid parameter.  A <b>NULL</b> is still equivalent to the previous value.</para>
    </param>
    <param name="settingName">
      <para>The name of the attribute to be queried.</para>
    </param>
    <param name="pvBuffer">
      <para>A pointer to the buffer that receives the query result.</para>
    </param>
    <param name="dwBuffer">
      <para>The size of the buffer  in characters that receives the query result.</para>
    </param>
    <param name="pdwWrittenOrRequired">
      <para>A pointer to a value which is the number of characters written to the buffer specified by <i>pvBuffer</i> or that is required to hold the query result.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling
<see cref="GetLastError" />. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
  </member>
  <member name="Windows.QueryActCtxW">
    <summary>
      <para>The
<b>QueryActCtxW</b> function queries the activation context.</para>
    </summary>
    <param name="dwFlags">
      <para>This parameter should be set to one of the following flag bits.</para>
      <list type="table">
        <listheader>
          <description>Flag</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX</b>
          </description>
          <description>
            <b>QueryActCtxW</b> queries the activation context active on the thread instead of the context specified by <i>hActCtx</i>. This is usually the last activation context passed to
<see cref="ActivateActCtx" />. If
<b>ActivateActCtx</b> has not been called, the active activation context can be the activation context used by the executable of the current process. In other cases, the operating system  determines the active activation context. For example, when the callback function to a new thread is called, the active activation context may be the context that was active when you created the thread by calling <see cref="CreateThread" />.
</description>
        </item>
        <item>
          <description>
            <b>QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE</b>
          </description>
          <description>
            <b>QueryActCtxW</b> interprets <i>hActCtx</i> as an <b>HMODULE</b> data type and queries an activation context that is associated with a DLL or EXE.
<para>When a DLL or EXE is loaded, the loader checks for a manifest stored in a resource. If the loader finds an RT_MANIFEST resource with a resource identifier set to ISOLATIONAWARE_MANIFEST_ RESOURCE_ID, the loader associates the resulting activation context with the DLL or EXE. This is the activation context that
<b>QueryActCtxW</b> queries when the QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE flag has been set.</para></description>
        </item>
        <item>
          <description>
            <b>QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS</b>
          </description>
          <description>
            <b>QueryActCtxW</b> interprets <i>hActCtx</i> as an address within a DLL or EXE and queries an activation context that has been associated with the DLL or EXE. This can be any address within the DLL or EXE. For example, the address of any function within a DLL or EXE or the address of any static data, such as a constant string.
<para>When a DLL or EXE is loaded, the loader checks for a manifest stored in a resource in the same way as QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE.</para></description>
        </item>
      </list>
    </param>
    <param name="hActCtx">
      <para>Handle to the activation context that is being queried.</para>
    </param>
    <param name="pvSubInstance">
      <para>Index of the assembly, or assembly and file combination, in the activation context. The meaning of the <i>pvSubInstance</i> depends on the option specified by the value of the <i>ulInfoClass</i> parameter.</para>
      <para>This parameter may be null.</para>
      <list type="table">
        <listheader>
          <description>ulInfoClass Option</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>AssemblyDetailedInformationInActivationContext</b>
          </description>
          <description>
            <para>Pointer to a <b>DWORD</b> that specifies the index of the assembly within the activation context. This is the activation context that
<b>QueryActCtxW</b> queries.</para>
          </description>
        </item>
        <item>
          <description>
            <b>FileInformationInAssemblyOfAssemblyInActivationContext</b>
          </description>
          <description>
            <para>Pointer to an
<see cref="ACTIVATION_CONTEXT_QUERY_INDEX" /> structure. If
<b>QueryActCtxW</b> is called with this option and the function succeeds, the returned buffer contains information for a file in the assembly. This information is in the form of the
<see cref="ASSEMBLY_FILE_DETAILED_INFORMATION" /> structure.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="ulInfoClass">
      <para>This parameter can have only the values shown in the following table.</para>
      <list type="table">
        <listheader>
          <description>Option</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ActivationContextBasicInformation</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Not available.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ActivationContextDetailedInformation</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>If
<b>QueryActCtxW</b> is called with this option and the function succeeds, the returned buffer contains detailed information about the activation context. This information is in the form of the
<see cref="ACTIVATION_CONTEXT_DETAILED_INFORMATION" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>AssemblyDetailedInformationInActivationContext</b>
                </description>
              </item>
              <item>
                <description>3</description>
              </item>
            </list>
          </description>
          <description>
            <para>If
<b>QueryActCtxW</b> is called with this option and the function succeeds, the buffer contains information about the assembly that has the index specified in <i>pvSubInstance</i>. This information is in the form of the
<see cref="ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FileInformationInAssemblyOfAssemblyInActivationContext</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Information about a file in one of the assemblies in Activation Context. The <i>pvSubInstance</i> parameter must point to an
<see cref="ACTIVATION_CONTEXT_QUERY_INDEX" /> structure. If
<b>QueryActCtxW</b> is called with this option and the function succeeds, the returned buffer contains information for a file in the assembly. This information is in the form of the
<see cref="ASSEMBLY_FILE_DETAILED_INFORMATION" /> structure.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RunlevelInformationInActivationContext</b>
                </description>
              </item>
              <item>
                <description>5</description>
              </item>
            </list>
          </description>
          <description>
            <para>If
<b>QueryActCtxW</b> is called with this option and the function succeeds, the buffer contains information about requested run level of the activation context. This information is in the form of the
<see cref="ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION" /> structure.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>This value is not available.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>CompatibilityInformationInActivationContext</b>
                </description>
              </item>
              <item>
                <description>6</description>
              </item>
            </list>
          </description>
          <description>
            <para>If
<b>QueryActCtxW</b> is called with this option and the function succeeds, the buffer contains information about requested compatibility context. This information is in the form of the
<see cref="ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION" /> structure.</para>
            <para>
              <b>Windows Server 2008 and earlier, and Windows Vista and earlier:  </b>This value is not available. This option is available beginning with Windows Server 2008 R2 and Windows 7.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="pvBuffer">
      <para>Pointer to a buffer that holds the returned information. This parameter is optional. If <i>pvBuffer</i> is <b>null</b>, then <i>cbBuffer</i> must be zero. If the size of the buffer pointed to by <i>pvBuffer</i> is too small,
<b>QueryActCtxW</b> returns ERROR_INSUFFICIENT_BUFFER and no data is written into the buffer. See the Remarks section for the method you can use to determine the required size of the buffer.</para>
    </param>
    <param name="cbBuffer">
      <para>Size of the buffer in bytes pointed to by <i>pvBuffer</i>. This parameter is optional.</para>
    </param>
    <param name="pcbWrittenOrRequired">
      <para>Number of bytes written or required. The parameter <i>pcbWrittenOrRequired</i> can only be <b>NULL</b> when <i>pvBuffer</i> is <b>NULL</b>. If <i>pcbWrittenOrRequired</i> is non-<b>NULL</b>, it is filled with the number of bytes required to store the returned buffer.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling
<see cref="GetLastError" />. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
    <remarks>
      <para>The parameter <i>cbBuffer</i> specifies the size in bytes of the buffer pointed to by <i>pvBuffer</i>. If <i>pvBuffer</i> is <b>NULL</b>, then <i>cbBuffer</i> must be 0. The parameter <i>pcbWrittenOrRequired</i> can only be <b>NULL</b> if <i>pvBuffer</i> is <b>NULL</b>. If <i>pcbWrittenOrRequired</i> is non-<b>NULL</b> on return, it is filled with the number of bytes required to store the returned information. When the information data returned is larger than the provided buffer,
<b>QueryActCtxW</b> returns ERROR_INSUFFICIENT_BUFFER and no data is written to the buffer pointed to by <i>pvBuffer</i>.</para>
      <para>The following example shows the method of calling first with a small buffer and then recalling if the buffer is too small.</para>
      <code>SIZE_T cbRequired;
PVOID pvData = NULL;
SIZE_T cbAvailable = 0;

if (!QueryActCtxW(..., pvData, cbAvailable, &amp;amp;amp;amp;amp;amp;amp;cbRequired) &amp;amp;amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp;amp;amp; (GetLastError()== ERROR_INSUFFICIENT_BUFFER))
{
    // Allocate enough space to store the returned buffer, fail if too small
    if (NULL == (pvData = HeapAlloc(GetProcessHeap(), 0, cbRequired)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    cbAvailable = cbRequired;
    // Try again, this should succeed.
    if (QueryActCtxW(..., pvData, cbAvailable, &amp;amp;amp;amp;amp;amp;amp;cbRequired))
    {
        // Use the returned data in pvData
    }
    HeapFree(GetProcessHeap(), 0, pvData);
    pvData = NULL;
}
</code>
    </remarks>
  </member>
  <member name="Windows.QueryDosDevice">
    <summary>
      <para>Retrieves information about MS-DOS device names. The function can obtain the current
mapping for a particular MS-DOS device name. The function can also obtain a list of all existing MS-DOS device
names.</para>
      <para>MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path into
a corresponding path uses these junctions to map MS-DOS devices and drive letters. The
<b>QueryDosDevice</b> function enables an application to query
the names of the junctions used to implement the MS-DOS device namespace as well as the value of each specific
junction.</para>
    </summary>
    <param name="lpDeviceName">
      <para>An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing
backslash; for example, use "C:", not "C:\".</para>
      <para>This parameter can be <b>NULL</b>. In that case, the
<b>QueryDosDevice</b> function will store a list of all
existing MS-DOS device names into the buffer pointed to by <i>lpTargetPath</i>.</para>
    </param>
    <param name="lpTargetPath">
      <para>A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or
more null-terminated strings. The final null-terminated string is followed by an additional
<b>NULL</b>.</para>
      <para>If <i>lpDeviceName</i> is non-<b>NULL</b>, the function retrieves
information about the particular MS-DOS device specified by <i>lpDeviceName</i>. The first
null-terminated string stored into the buffer is the current mapping for the device. The other null-terminated
strings represent undeleted prior mappings for the device.</para>
      <para>If <i>lpDeviceName</i> is <b>NULL</b>, the function retrieves a list of
all existing MS-DOS device names. Each null-terminated string stored into the buffer is the name of an existing
MS-DOS device, for example, \Device\HarddiskVolume1 or \Device\Floppy0.</para>
    </param>
    <param name="ucchMax">
      <para>The maximum number of <b>TCHARs</b> that can be stored into the buffer pointed to by
<i>lpTargetPath</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of <b>TCHARs</b> stored into
the buffer pointed to by <i>lpTargetPath</i>.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the buffer is too small, the function fails and the last error code is
<b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
    </returns>
    <remarks>
      <para>The <see cref="DefineDosDevice" /> function enables an application
to create and modify the junctions used to implement the MS-DOS device namespace.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>
        <b>QueryDosDevice</b> first searches the Local MS-DOS
Device namespace for the specified device name. If the device name is not found, the function will then search
the Global MS-DOS Device namespace.</para>
      <para>When all existing MS-DOS device names are queried, the list of device names that are returned is dependent on
whether it is running in the "LocalSystem" context. If so, only the device names included in the Global MS-DOS
Device namespace will be returned. If not, a concatenation of the device names in the Global and Local MS-DOS
Device namespaces will be returned. If a device name exists in both namespaces,
<b>QueryDosDevice</b> will return the entry in the Local MS-DOS
Device namespace.</para>
      <para>For more information on the Global and Local MS-DOS Device namespaces and changes to the accessibility of
MS-DOS device names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a></para>
      <para>or <a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso cref="DefineDosDevice" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.QueryDosDeviceA">
    <summary>
      <para>Retrieves information about MS-DOS device names. The function can obtain the current
mapping for a particular MS-DOS device name. The function can also obtain a list of all existing MS-DOS device
names.</para>
      <para>MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path into
a corresponding path uses these junctions to map MS-DOS devices and drive letters. The
<b>QueryDosDevice</b> function enables an application to query
the names of the junctions used to implement the MS-DOS device namespace as well as the value of each specific
junction.</para>
    </summary>
    <param name="lpDeviceName">
      <para>An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing
backslash; for example, use "C:", not "C:\".</para>
      <para>This parameter can be <b>NULL</b>. In that case, the
<b>QueryDosDevice</b> function will store a list of all
existing MS-DOS device names into the buffer pointed to by <i>lpTargetPath</i>.</para>
    </param>
    <param name="lpTargetPath">
      <para>A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or
more null-terminated strings. The final null-terminated string is followed by an additional
<b>NULL</b>.</para>
      <para>If <i>lpDeviceName</i> is non-<b>NULL</b>, the function retrieves
information about the particular MS-DOS device specified by <i>lpDeviceName</i>. The first
null-terminated string stored into the buffer is the current mapping for the device. The other null-terminated
strings represent undeleted prior mappings for the device.</para>
      <para>If <i>lpDeviceName</i> is <b>NULL</b>, the function retrieves a list of
all existing MS-DOS device names. Each null-terminated string stored into the buffer is the name of an existing
MS-DOS device, for example, \Device\HarddiskVolume1 or \Device\Floppy0.</para>
    </param>
    <param name="ucchMax">
      <para>The maximum number of <b>TCHARs</b> that can be stored into the buffer pointed to by
<i>lpTargetPath</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of <b>TCHARs</b> stored into
the buffer pointed to by <i>lpTargetPath</i>.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the buffer is too small, the function fails and the last error code is
<b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
    </returns>
    <remarks>
      <para>The <see cref="DefineDosDevice" /> function enables an application
to create and modify the junctions used to implement the MS-DOS device namespace.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>
        <b>QueryDosDevice</b> first searches the Local MS-DOS
Device namespace for the specified device name. If the device name is not found, the function will then search
the Global MS-DOS Device namespace.</para>
      <para>When all existing MS-DOS device names are queried, the list of device names that are returned is dependent on
whether it is running in the "LocalSystem" context. If so, only the device names included in the Global MS-DOS
Device namespace will be returned. If not, a concatenation of the device names in the Global and Local MS-DOS
Device namespaces will be returned. If a device name exists in both namespaces,
<b>QueryDosDevice</b> will return the entry in the Local MS-DOS
Device namespace.</para>
      <para>For more information on the Global and Local MS-DOS Device namespaces and changes to the accessibility of
MS-DOS device names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a></para>
      <para>or <a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso cref="DefineDosDevice" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.QueryDosDeviceW">
    <summary>
      <para>Retrieves information about MS-DOS device names. The function can obtain the current
mapping for a particular MS-DOS device name. The function can also obtain a list of all existing MS-DOS device
names.</para>
      <para>MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path into
a corresponding path uses these junctions to map MS-DOS devices and drive letters. The
<b>QueryDosDevice</b> function enables an application to query
the names of the junctions used to implement the MS-DOS device namespace as well as the value of each specific
junction.</para>
    </summary>
    <param name="lpDeviceName">
      <para>An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing
backslash; for example, use "C:", not "C:\".</para>
      <para>This parameter can be <b>NULL</b>. In that case, the
<b>QueryDosDevice</b> function will store a list of all
existing MS-DOS device names into the buffer pointed to by <i>lpTargetPath</i>.</para>
    </param>
    <param name="lpTargetPath">
      <para>A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or
more null-terminated strings. The final null-terminated string is followed by an additional
<b>NULL</b>.</para>
      <para>If <i>lpDeviceName</i> is non-<b>NULL</b>, the function retrieves
information about the particular MS-DOS device specified by <i>lpDeviceName</i>. The first
null-terminated string stored into the buffer is the current mapping for the device. The other null-terminated
strings represent undeleted prior mappings for the device.</para>
      <para>If <i>lpDeviceName</i> is <b>NULL</b>, the function retrieves a list of
all existing MS-DOS device names. Each null-terminated string stored into the buffer is the name of an existing
MS-DOS device, for example, \Device\HarddiskVolume1 or \Device\Floppy0.</para>
    </param>
    <param name="ucchMax">
      <para>The maximum number of <b>TCHARs</b> that can be stored into the buffer pointed to by
<i>lpTargetPath</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the number of <b>TCHARs</b> stored into
the buffer pointed to by <i>lpTargetPath</i>.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the buffer is too small, the function fails and the last error code is
<b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
    </returns>
    <remarks>
      <para>The <see cref="DefineDosDevice" /> function enables an application
to create and modify the junctions used to implement the MS-DOS device namespace.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>
        <b>QueryDosDevice</b> first searches the Local MS-DOS
Device namespace for the specified device name. If the device name is not found, the function will then search
the Global MS-DOS Device namespace.</para>
      <para>When all existing MS-DOS device names are queried, the list of device names that are returned is dependent on
whether it is running in the "LocalSystem" context. If so, only the device names included in the Global MS-DOS
Device namespace will be returned. If not, a concatenation of the device names in the Global and Local MS-DOS
Device namespaces will be returned. If a device name exists in both namespaces,
<b>QueryDosDevice</b> will return the entry in the Local MS-DOS
Device namespace.</para>
      <para>For more information on the Global and Local MS-DOS Device namespaces and changes to the accessibility of
MS-DOS device names, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Memory/obtaining-a-file-name-from-a-file-handle">Obtaining a File Name From a File Handle</a></para>
      <para>or <a href="https://docs.microsoft.com//windows/desktop/FileIO/displaying-volume-paths">Displaying Volume Paths</a>.</para>
    </remarks>
    <seealso cref="DefineDosDevice" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.QueryFullProcessImageName">
    <summary>
      <para>Retrieves the full name of the executable image for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. This handle must be created with the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>The name should use the Win32 path format.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PROCESS_NAME_NATIVE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The name should use the native system path format.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpExeName">
      <para>The path to the executable image. If the function succeeds, this string is null-terminated.</para>
    </param>
    <param name="lpdwSize">
      <para>On input, specifies the size of the <i>lpExeName</i> buffer, in characters. On success, receives the number of characters written to the buffer, not including the null-terminating character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines QueryFullProcessImageName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetModuleFileNameEx" />
    <seealso cref="GetProcessImageFileName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
  </member>
  <member name="Windows.QueryFullProcessImageNameA">
    <summary>
      <para>Retrieves the full name of the executable image for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. This handle must be created with the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>The name should use the Win32 path format.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PROCESS_NAME_NATIVE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The name should use the native system path format.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpExeName">
      <para>The path to the executable image. If the function succeeds, this string is null-terminated.</para>
    </param>
    <param name="lpdwSize">
      <para>On input, specifies the size of the <i>lpExeName</i> buffer, in characters. On success, receives the number of characters written to the buffer, not including the null-terminating character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines QueryFullProcessImageName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetModuleFileNameEx" />
    <seealso cref="GetProcessImageFileName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
  </member>
  <member name="Windows.QueryFullProcessImageNameW">
    <summary>
      <para>Retrieves the full name of the executable image for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. This handle must be created with the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>The name should use the Win32 path format.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PROCESS_NAME_NATIVE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The name should use the native system path format.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpExeName">
      <para>The path to the executable image. If the function succeeds, this string is null-terminated.</para>
    </param>
    <param name="lpdwSize">
      <para>On input, specifies the size of the <i>lpExeName</i> buffer, in characters. On success, receives the number of characters written to the buffer, not including the null-terminating character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines QueryFullProcessImageName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetModuleFileNameEx" />
    <seealso cref="GetProcessImageFileName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
  </member>
  <member name="Windows.QueryFullProcessImageName">
    <summary>
      <para>Retrieves the full name of the executable image for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. This handle must be created with the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>The name should use the Win32 path format.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PROCESS_NAME_NATIVE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The name should use the native system path format.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpExeName">
      <para>The path to the executable image. If the function succeeds, this string is null-terminated.</para>
    </param>
    <param name="lpdwSize">
      <para>On input, specifies the size of the <i>lpExeName</i> buffer, in characters. On success, receives the number of characters written to the buffer, not including the null-terminating character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines QueryFullProcessImageName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetModuleFileNameEx" />
    <seealso cref="GetProcessImageFileName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
  </member>
  <member name="Windows.QueryFullProcessImageNameA">
    <summary>
      <para>Retrieves the full name of the executable image for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. This handle must be created with the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>The name should use the Win32 path format.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PROCESS_NAME_NATIVE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The name should use the native system path format.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpExeName">
      <para>The path to the executable image. If the function succeeds, this string is null-terminated.</para>
    </param>
    <param name="lpdwSize">
      <para>On input, specifies the size of the <i>lpExeName</i> buffer, in characters. On success, receives the number of characters written to the buffer, not including the null-terminating character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines QueryFullProcessImageName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetModuleFileNameEx" />
    <seealso cref="GetProcessImageFileName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
  </member>
  <member name="Windows.QueryFullProcessImageNameW">
    <summary>
      <para>Retrieves the full name of the executable image for the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process. This handle must be created with the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>The name should use the Win32 path format.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PROCESS_NAME_NATIVE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The name should use the native system path format.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpExeName">
      <para>The path to the executable image. If the function succeeds, this string is null-terminated.</para>
    </param>
    <param name="lpdwSize">
      <para>On input, specifies the size of the <i>lpExeName</i> buffer, in characters. On success, receives the number of characters written to the buffer, not including the null-terminating character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines QueryFullProcessImageName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetModuleFileNameEx" />
    <seealso cref="GetProcessImageFileName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
  </member>
  <member name="Windows.QueryThreadProfiling">
    <summary>
      <para>Determines whether thread profiling is enabled for the specified thread.</para>
    </summary>
    <param name="ThreadHandle">
      <para>The handle to the thread of interest.</para>
    </param>
    <param name="Enabled">
      <para>Is <b>TRUE</b> if thread profiling is enabled for the specified thread; otherwise, <b>FALSE</b>.</para>
    </param>
    <returns>
      <para>Returns ERROR_SUCCESS if the call is successful; otherwise, a system error code (see Winerror.h).</para>
    </returns>
    <seealso cref="DisableThreadProfiling" />
    <seealso cref="EnableThreadProfiling" />
  </member>
  <member name="Windows.QueryUmsThreadInformation">
    <summary>
      <para>Retrieves information about the specified user-mode scheduling (UMS) worker thread.</para>
    </summary>
    <param name="UmsThread">
      <para>A pointer to a UMS thread context.</para>
    </param>
    <param name="UmsThreadInfoClass">
      <para>A UMS_THREAD_INFO_CLASS value that specifies the kind of information to retrieve.</para>
    </param>
    <param name="UmsThreadInformation">
      <para>A pointer to a buffer to receive the specified information. The required size of this buffer depends on the specified information class.</para>
      <para>If the information class is <b>UmsThreadContext</b> or <b>UmsThreadTeb</b>, the buffer must be <code>sizeof(PVOID)</code>.</para>
      <para>If the information class is <b>UmsThreadIsSuspended</b> or <b>UmsThreadIsTerminated</b>, the buffer must be <code>sizeof(BOOLEAN)</code>.</para>
    </param>
    <param name="UmsThreadInformationLength">
      <para>The size of the <i>UmsThreadInformation</i> buffer, in bytes.</para>
    </param>
    <param name="ReturnLength">
      <para>A pointer to a ULONG variable. On output, this parameter receives the number of bytes written to the <i>UmsThreadInformation</i> buffer.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. Possible error values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INFO_LENGTH_MISMATCH</b>
            </para>
          </description>
          <description>
            <para>The buffer is too small for the requested information.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_INFO_CLASS</b>
            </para>
          </description>
          <description>
            <para>The specified information class is not supported.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>QueryUmsThreadInformation</b> function retrieves information about the specified UMS worker thread such as its application-defined context, its thread execution block (<see cref="TEB" />), and whether the thread is suspended or terminated.</para>
      <para>The underlying structures for UMS worker threads are managed by the system. Information that is not exposed through <b>QueryUmsThreadInformation</b> should be considered reserved.</para>
    </remarks>
    <seealso cref="SetUmsThreadInformation" />
    <seealso cref="UMS_THREAD_INFO_CLASS" />
  </member>
  <member name="Windows.ReadEncryptedFileRaw">
    <summary>
      <para>Backs up (export) encrypted files.  This is one of a group of Encrypted File System (EFS)
functions that is intended  to implement backup and restore functionality, while maintaining files in their
encrypted state.</para>
    </summary>
    <param name="pfExportCallback">
      <para>A pointer to the export callback function. The system calls the callback function multiple times, each time
passing a block of the file's data to the callback function until the entire file has been read. For more
information, see <a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-pfe_export_func">ExportCallback</a>.</para>
    </param>
    <param name="pvCallbackContext">
      <para>A pointer to an application-defined and allocated context block. The system passes this pointer to the
callback function as a parameter so that the callback function can have access to application-specific data.
This can be a structure and can contain any data the application needs, such as the handle to the file that will
contain the backup copy of the encrypted file.</para>
    </param>
    <param name="pvContext">
      <para>A pointer to a system-defined context block. The context block is returned by the
<see cref="OpenEncryptedFileRaw" /> function. Do not modify
it.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, it returns a nonzero error code defined in WinError.h. You can use
<see cref="FormatMessage" /> with the
<b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of the error.</para>
    </returns>
    <remarks>
      <para>The file being backed up is not decrypted;  it is backed up in its encrypted state.</para>
      <para>To back up an encrypted file, call
<see cref="OpenEncryptedFileRaw" /> to open the file. Then call
<b>ReadEncryptedFileRaw</b>, passing it the address of an
application-defined export callback function. The system calls this callback function multiple times until the
entire file's contents have been read and backed up.  When the backup is complete, call
<see cref="CloseEncryptedFileRaw" /> to free resources and close
the file. See <a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-pfe_export_func">ExportCallback</a> for details about how to
declare the export callback function.</para>
      <para>To restore an encrypted file, call
<see cref="OpenEncryptedFileRaw" />, specifying
<b>CREATE_FOR_IMPORT</b> in the <i>ulFlags</i> parameter. Then call
<see cref="WriteEncryptedFileRaw" />, passing it the address of
an application-defined import callback function. The system calls this callback function multiple times until the
entire file's contents have been read and restored. When the restore is complete, call
<see cref="CloseEncryptedFileRaw" /> to free resources and close
the file. See <a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-pfe_import_func">ImportCallback</a> for details about how to
declare the import callback function.</para>
      <para>This function is intended for the backup of only encrypted files; see
<see cref="BackupRead" /> for backup of unencrypted files.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
    </remarks>
    <seealso cref="BackupRead" />
    <seealso cref="CloseEncryptedFileRaw" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="OpenEncryptedFileRaw" />
    <seealso cref="WriteEncryptedFileRaw" />
  </member>
  <member name="Windows.ReadEventLog">
    <summary>
      <para>Reads the specified number of entries from the specified event log. The function can be used to read log entries in chronological or reverse chronological order.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log to be read. The
<see cref="OpenEventLog" /> function returns this handle.</para>
    </param>
    <param name="dwReadFlags">
      <para>Use the following flag values to indicate how to read the log file. This parameter must include one of the following values (the flags are mutually exclusive).</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_SEEK_READ</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Begin reading from the record specified in the <i>dwRecordOffset</i> parameter.</para>
            <para>This option may  not work with large log files if the function cannot determine the log file's size. For details, see Knowledge Base article, 177199.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_SEQUENTIAL_READ</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Read the records sequentially.</para>
            <para>If this is the first read operation, the EVENTLOG_FORWARDS_READ EVENTLOG_BACKWARDS_READ flags determines which record is read first.</para>
          </description>
        </item>
      </list>
      <para>You must specify one of the following flags to indicate the direction for successive read operations (the flags are mutually exclusive).</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_FORWARDS_READ</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The log is read in chronological order (oldest to newest).</para>
            <para>The default.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_BACKWARDS_READ</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The log is read in reverse chronological order (newest to oldest).</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwRecordOffset">
      <para>The record number of the log-entry at which the read operation should start. This parameter is ignored unless <i>dwReadFlags</i> includes the <b>EVENTLOG_SEEK_READ</b> flag.</para>
    </param>
    <param name="lpBuffer">
      <para>An application-allocated buffer that will receive one or more <see cref="EVENTLOGRECORD" /> structures. This parameter cannot be <b>NULL</b>, even if the <i>nNumberOfBytesToRead</i> parameter is zero.</para>
      <para>The maximum size of this buffer is 0x7ffff bytes.</para>
    </param>
    <param name="nNumberOfBytesToRead">
      <para>The size of the <i>lpBuffer</i> buffer, in bytes. This function will read as many log entries as will fit in the buffer; the function will not return partial entries.</para>
    </param>
    <param name="pnBytesRead">
      <para>A pointer to a variable that receives the number of bytes read by the function.</para>
    </param>
    <param name="pnMinNumberOfBytesNeeded">
      <para>A pointer to a variable that receives the required size of the <i>lpBuffer</i> buffer. This value is valid only if this function returns zero and
<see cref="GetLastError" /> returns <b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When this function returns successfully, the read position in the event  log is adjusted by the number of records read.</para>
      <para>
        <b>Note</b>  The configured file name for this source may also be the configured file name for other sources (several sources can exist as subkeys under a single log). Therefore, this function may return events that were logged by more than one source.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/querying-for-event-source-messages">Querying for Event Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines ReadEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ClearEventLog" />
    <seealso cref="CloseEventLog" />
    <seealso cref="EVENTLOGRECORD" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
    <seealso cref="ReportEvent" />
  </member>
  <member name="Windows.ReadEventLogA">
    <summary>
      <para>Reads the specified number of entries from the specified event log. The function can be used to read log entries in chronological or reverse chronological order.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log to be read. The
<see cref="OpenEventLog" /> function returns this handle.</para>
    </param>
    <param name="dwReadFlags">
      <para>Use the following flag values to indicate how to read the log file. This parameter must include one of the following values (the flags are mutually exclusive).</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_SEEK_READ</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Begin reading from the record specified in the <i>dwRecordOffset</i> parameter.</para>
            <para>This option may  not work with large log files if the function cannot determine the log file's size. For details, see Knowledge Base article, 177199.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_SEQUENTIAL_READ</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Read the records sequentially.</para>
            <para>If this is the first read operation, the EVENTLOG_FORWARDS_READ EVENTLOG_BACKWARDS_READ flags determines which record is read first.</para>
          </description>
        </item>
      </list>
      <para>You must specify one of the following flags to indicate the direction for successive read operations (the flags are mutually exclusive).</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_FORWARDS_READ</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The log is read in chronological order (oldest to newest).</para>
            <para>The default.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_BACKWARDS_READ</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The log is read in reverse chronological order (newest to oldest).</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwRecordOffset">
      <para>The record number of the log-entry at which the read operation should start. This parameter is ignored unless <i>dwReadFlags</i> includes the <b>EVENTLOG_SEEK_READ</b> flag.</para>
    </param>
    <param name="lpBuffer">
      <para>An application-allocated buffer that will receive one or more <see cref="EVENTLOGRECORD" /> structures. This parameter cannot be <b>NULL</b>, even if the <i>nNumberOfBytesToRead</i> parameter is zero.</para>
      <para>The maximum size of this buffer is 0x7ffff bytes.</para>
    </param>
    <param name="nNumberOfBytesToRead">
      <para>The size of the <i>lpBuffer</i> buffer, in bytes. This function will read as many log entries as will fit in the buffer; the function will not return partial entries.</para>
    </param>
    <param name="pnBytesRead">
      <para>A pointer to a variable that receives the number of bytes read by the function.</para>
    </param>
    <param name="pnMinNumberOfBytesNeeded">
      <para>A pointer to a variable that receives the required size of the <i>lpBuffer</i> buffer. This value is valid only if this function returns zero and
<see cref="GetLastError" /> returns <b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When this function returns successfully, the read position in the event  log is adjusted by the number of records read.</para>
      <para>
        <b>Note</b>  The configured file name for this source may also be the configured file name for other sources (several sources can exist as subkeys under a single log). Therefore, this function may return events that were logged by more than one source.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/querying-for-event-source-messages">Querying for Event Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines ReadEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ClearEventLog" />
    <seealso cref="CloseEventLog" />
    <seealso cref="EVENTLOGRECORD" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
    <seealso cref="ReportEvent" />
  </member>
  <member name="Windows.ReadEventLogW">
    <summary>
      <para>Reads the specified number of entries from the specified event log. The function can be used to read log entries in chronological or reverse chronological order.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log to be read. The
<see cref="OpenEventLog" /> function returns this handle.</para>
    </param>
    <param name="dwReadFlags">
      <para>Use the following flag values to indicate how to read the log file. This parameter must include one of the following values (the flags are mutually exclusive).</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_SEEK_READ</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Begin reading from the record specified in the <i>dwRecordOffset</i> parameter.</para>
            <para>This option may  not work with large log files if the function cannot determine the log file's size. For details, see Knowledge Base article, 177199.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_SEQUENTIAL_READ</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Read the records sequentially.</para>
            <para>If this is the first read operation, the EVENTLOG_FORWARDS_READ EVENTLOG_BACKWARDS_READ flags determines which record is read first.</para>
          </description>
        </item>
      </list>
      <para>You must specify one of the following flags to indicate the direction for successive read operations (the flags are mutually exclusive).</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_FORWARDS_READ</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The log is read in chronological order (oldest to newest).</para>
            <para>The default.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_BACKWARDS_READ</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The log is read in reverse chronological order (newest to oldest).</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwRecordOffset">
      <para>The record number of the log-entry at which the read operation should start. This parameter is ignored unless <i>dwReadFlags</i> includes the <b>EVENTLOG_SEEK_READ</b> flag.</para>
    </param>
    <param name="lpBuffer">
      <para>An application-allocated buffer that will receive one or more <see cref="EVENTLOGRECORD" /> structures. This parameter cannot be <b>NULL</b>, even if the <i>nNumberOfBytesToRead</i> parameter is zero.</para>
      <para>The maximum size of this buffer is 0x7ffff bytes.</para>
    </param>
    <param name="nNumberOfBytesToRead">
      <para>The size of the <i>lpBuffer</i> buffer, in bytes. This function will read as many log entries as will fit in the buffer; the function will not return partial entries.</para>
    </param>
    <param name="pnBytesRead">
      <para>A pointer to a variable that receives the number of bytes read by the function.</para>
    </param>
    <param name="pnMinNumberOfBytesNeeded">
      <para>A pointer to a variable that receives the required size of the <i>lpBuffer</i> buffer. This value is valid only if this function returns zero and
<see cref="GetLastError" /> returns <b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When this function returns successfully, the read position in the event  log is adjusted by the number of records read.</para>
      <para>
        <b>Note</b>  The configured file name for this source may also be the configured file name for other sources (several sources can exist as subkeys under a single log). Therefore, this function may return events that were logged by more than one source.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/querying-for-event-source-messages">Querying for Event Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines ReadEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ClearEventLog" />
    <seealso cref="CloseEventLog" />
    <seealso cref="EVENTLOGRECORD" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
    <seealso cref="ReportEvent" />
  </member>
  <member name="Windows.ReadEventLog">
    <summary>
      <para>Reads the specified number of entries from the specified event log. The function can be used to read log entries in chronological or reverse chronological order.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log to be read. The
<see cref="OpenEventLog" /> function returns this handle.</para>
    </param>
    <param name="dwReadFlags">
      <para>Use the following flag values to indicate how to read the log file. This parameter must include one of the following values (the flags are mutually exclusive).</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_SEEK_READ</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Begin reading from the record specified in the <i>dwRecordOffset</i> parameter.</para>
            <para>This option may  not work with large log files if the function cannot determine the log file's size. For details, see Knowledge Base article, 177199.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_SEQUENTIAL_READ</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Read the records sequentially.</para>
            <para>If this is the first read operation, the EVENTLOG_FORWARDS_READ EVENTLOG_BACKWARDS_READ flags determines which record is read first.</para>
          </description>
        </item>
      </list>
      <para>You must specify one of the following flags to indicate the direction for successive read operations (the flags are mutually exclusive).</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_FORWARDS_READ</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The log is read in chronological order (oldest to newest).</para>
            <para>The default.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_BACKWARDS_READ</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The log is read in reverse chronological order (newest to oldest).</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwRecordOffset">
      <para>The record number of the log-entry at which the read operation should start. This parameter is ignored unless <i>dwReadFlags</i> includes the <b>EVENTLOG_SEEK_READ</b> flag.</para>
    </param>
    <param name="lpBuffer">
      <para>An application-allocated buffer that will receive one or more <see cref="EVENTLOGRECORD" /> structures. This parameter cannot be <b>NULL</b>, even if the <i>nNumberOfBytesToRead</i> parameter is zero.</para>
      <para>The maximum size of this buffer is 0x7ffff bytes.</para>
    </param>
    <param name="nNumberOfBytesToRead">
      <para>The size of the <i>lpBuffer</i> buffer, in bytes. This function will read as many log entries as will fit in the buffer; the function will not return partial entries.</para>
    </param>
    <param name="pnBytesRead">
      <para>A pointer to a variable that receives the number of bytes read by the function.</para>
    </param>
    <param name="pnMinNumberOfBytesNeeded">
      <para>A pointer to a variable that receives the required size of the <i>lpBuffer</i> buffer. This value is valid only this function returns zero and
<see cref="GetLastError" /> returns <b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When this function returns successfully, the read position in the event  log is adjusted by the number of records read.</para>
      <para>
        <b>Note</b>  The configured file name for this source may also be the configured file name for other sources (several sources can exist as subkeys under a single log). Therefore, this function may return events that were logged by more than one source.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/querying-for-event-source-messages">Querying for Event Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines ReadEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ClearEventLog" />
    <seealso cref="CloseEventLog" />
    <seealso cref="EVENTLOGRECORD" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
    <seealso cref="ReportEvent" />
  </member>
  <member name="Windows.ReadEventLogA">
    <summary>
      <para>Reads the specified number of entries from the specified event log. The function can be used to read log entries in chronological or reverse chronological order.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log to be read. The
<see cref="OpenEventLog" /> function returns this handle.</para>
    </param>
    <param name="dwReadFlags">
      <para>Use the following flag values to indicate how to read the log file. This parameter must include one of the following values (the flags are mutually exclusive).</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_SEEK_READ</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Begin reading from the record specified in the <i>dwRecordOffset</i> parameter.</para>
            <para>This option may  not work with large log files if the function cannot determine the log file's size. For details, see Knowledge Base article, 177199.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_SEQUENTIAL_READ</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Read the records sequentially.</para>
            <para>If this is the first read operation, the EVENTLOG_FORWARDS_READ EVENTLOG_BACKWARDS_READ flags determines which record is read first.</para>
          </description>
        </item>
      </list>
      <para>You must specify one of the following flags to indicate the direction for successive read operations (the flags are mutually exclusive).</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_FORWARDS_READ</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The log is read in chronological order (oldest to newest).</para>
            <para>The default.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_BACKWARDS_READ</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The log is read in reverse chronological order (newest to oldest).</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwRecordOffset">
      <para>The record number of the log-entry at which the read operation should start. This parameter is ignored unless <i>dwReadFlags</i> includes the <b>EVENTLOG_SEEK_READ</b> flag.</para>
    </param>
    <param name="lpBuffer">
      <para>An application-allocated buffer that will receive one or more <see cref="EVENTLOGRECORD" /> structures. This parameter cannot be <b>NULL</b>, even if the <i>nNumberOfBytesToRead</i> parameter is zero.</para>
      <para>The maximum size of this buffer is 0x7ffff bytes.</para>
    </param>
    <param name="nNumberOfBytesToRead">
      <para>The size of the <i>lpBuffer</i> buffer, in bytes. This function will read as many log entries as will fit in the buffer; the function will not return partial entries.</para>
    </param>
    <param name="pnBytesRead">
      <para>A pointer to a variable that receives the number of bytes read by the function.</para>
    </param>
    <param name="pnMinNumberOfBytesNeeded">
      <para>A pointer to a variable that receives the required size of the <i>lpBuffer</i> buffer. This value is valid only this function returns zero and
<see cref="GetLastError" /> returns <b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When this function returns successfully, the read position in the event  log is adjusted by the number of records read.</para>
      <para>
        <b>Note</b>  The configured file name for this source may also be the configured file name for other sources (several sources can exist as subkeys under a single log). Therefore, this function may return events that were logged by more than one source.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/querying-for-event-source-messages">Querying for Event Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines ReadEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ClearEventLog" />
    <seealso cref="CloseEventLog" />
    <seealso cref="EVENTLOGRECORD" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
    <seealso cref="ReportEvent" />
  </member>
  <member name="Windows.ReadEventLogW">
    <summary>
      <para>Reads the specified number of entries from the specified event log. The function can be used to read log entries in chronological or reverse chronological order.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log to be read. The
<see cref="OpenEventLog" /> function returns this handle.</para>
    </param>
    <param name="dwReadFlags">
      <para>Use the following flag values to indicate how to read the log file. This parameter must include one of the following values (the flags are mutually exclusive).</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_SEEK_READ</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Begin reading from the record specified in the <i>dwRecordOffset</i> parameter.</para>
            <para>This option may  not work with large log files if the function cannot determine the log file's size. For details, see Knowledge Base article, 177199.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_SEQUENTIAL_READ</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Read the records sequentially.</para>
            <para>If this is the first read operation, the EVENTLOG_FORWARDS_READ EVENTLOG_BACKWARDS_READ flags determines which record is read first.</para>
          </description>
        </item>
      </list>
      <para>You must specify one of the following flags to indicate the direction for successive read operations (the flags are mutually exclusive).</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_FORWARDS_READ</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The log is read in chronological order (oldest to newest).</para>
            <para>The default.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_BACKWARDS_READ</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The log is read in reverse chronological order (newest to oldest).</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwRecordOffset">
      <para>The record number of the log-entry at which the read operation should start. This parameter is ignored unless <i>dwReadFlags</i> includes the <b>EVENTLOG_SEEK_READ</b> flag.</para>
    </param>
    <param name="lpBuffer">
      <para>An application-allocated buffer that will receive one or more <see cref="EVENTLOGRECORD" /> structures. This parameter cannot be <b>NULL</b>, even if the <i>nNumberOfBytesToRead</i> parameter is zero.</para>
      <para>The maximum size of this buffer is 0x7ffff bytes.</para>
    </param>
    <param name="nNumberOfBytesToRead">
      <para>The size of the <i>lpBuffer</i> buffer, in bytes. This function will read as many log entries as will fit in the buffer; the function will not return partial entries.</para>
    </param>
    <param name="pnBytesRead">
      <para>A pointer to a variable that receives the number of bytes read by the function.</para>
    </param>
    <param name="pnMinNumberOfBytesNeeded">
      <para>A pointer to a variable that receives the required size of the <i>lpBuffer</i> buffer. This value is valid only this function returns zero and
<see cref="GetLastError" /> returns <b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>When this function returns successfully, the read position in the event  log is adjusted by the number of records read.</para>
      <para>
        <b>Note</b>  The configured file name for this source may also be the configured file name for other sources (several sources can exist as subkeys under a single log). Therefore, this function may return events that were logged by more than one source.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/querying-for-event-source-messages">Querying for Event Information</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines ReadEventLog as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ClearEventLog" />
    <seealso cref="CloseEventLog" />
    <seealso cref="EVENTLOGRECORD" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
    <seealso cref="ReportEvent" />
  </member>
  <member name="Windows.ReadThreadProfilingData">
    <summary>
      <para>Reads the specified profiling data associated with the thread.</para>
    </summary>
    <param name="PerformanceDataHandle">
      <para>The handle that the <see cref="EnableThreadProfiling" /> function returned.</para>
    </param>
    <param name="Flags">
      <para>One or more of the following flags that specify the counter data to read. The flags must have been set when you called the <see cref="EnableThreadProfiling" /> function.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>READ_THREAD_PROFILING_FLAG_DISPATCHING</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Get the thread profiling data.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>READ_THREAD_PROFILING_FLAG_HARDWARE_COUNTERS</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Get the hardware performance counters data.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="PerformanceData">
      <para>A <see cref="PERFORMANCE_DATA" /> structure that contains the thread profiling and hardware counter data.</para>
    </param>
    <returns>
      <para>Returns ERROR_SUCCESS if the call is successful; otherwise, a system error code (see Winerror.h).</para>
    </returns>
    <seealso cref="EnableThreadProfiling" />
  </member>
  <member name="Windows.RegisterApplicationRecoveryCallback">
    <summary>
      <para>Registers the active instance of an application for recovery.</para>
    </summary>
    <param name="pRecoveyCallback">
      <para>A pointer to the recovery callback function. For more information, see <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa373202(v=vs.85)">ApplicationRecoveryCallback</a>.</para>
    </param>
    <param name="pvParameter">
      <para>A pointer to a variable to be passed to the callback function. Can be <b>NULL</b>.</para>
    </param>
    <param name="dwPingInterval">
      <para>The recovery ping interval, in milliseconds. By default, the interval is 5 seconds (RECOVERY_DEFAULT_PING_INTERVAL). The maximum interval is 5 minutes. If you specify zero, the default interval is used.</para>
      <para>You must call the <see cref="ApplicationRecoveryInProgress" /> function within the specified interval to indicate to ARR that you are still actively recovering; otherwise, WER terminates recovery. Typically, you perform recovery in a loop with each iteration lasting no longer than the ping interval. Each iteration performs a block of recovery work followed by a call to <b>ApplicationRecoveryInProgress</b>. Since you also use <b>ApplicationRecoveryInProgress</b> to determine if the user wants to cancel recovery, you should consider a smaller interval, so you do not perform a lot of work unnecessarily.</para>
    </param>
    <param name="dwFlags">
      <para>Reserved for future use. Set to zero.</para>
    </param>
    <returns>
      <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>E_FAIL</b>
            </para>
          </description>
          <description>
            <para>Internal error; the registration failed.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>The ping interval cannot be more than five minutes.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If the  application encounters an unhandled exception or becomes unresponsive, Windows Error Reporting (WER) calls the specified recovery callback. You should use the callback to save data and state information. You can use the information if you also call  the <see cref="RegisterApplicationRestart" /> function to request that WER restart the application.</para>
      <para>WER will not call your recovery callback if an installer wants to  update a component of your application. To save data and state information in the update case, you should handle the <a href="https://docs.microsoft.com//windows/desktop/Shutdown/wm-queryendsession">WM_QUERYENDSESSION</a> and <a href="https://docs.microsoft.com//windows/desktop/Shutdown/wm-endsession">WM_ENDSESSION</a> messages. For details, see each message. The timeout for responding to these messages is five seconds. Most of the available recovery time is in the <a href="https://docs.microsoft.com//windows/desktop/winmsg/wm-close">WM_CLOSE</a> message for which you have 30 seconds.</para>
      <para>A console application that can be updated uses the CTRL_C_EVENT notification to initiate recovery (for details, see the <a href="https://docs.microsoft.com//windows/console/handlerroutine">HandlerRoutine</a> callback function). The timeout for the handler to complete is 30 seconds.</para>
      <para>Applications should consider saving data and state information on a periodic bases to shorten the amount of time required for recovery.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa373202(v=vs.85)">ApplicationRecoveryCallback</seealso>
    <seealso cref="ApplicationRecoveryInProgress" />
    <seealso cref="RegisterApplicationRestart" />
    <seealso cref="UnregisterApplicationRecoveryCallback" />
  </member>
  <member name="Windows.RegisterApplicationRestart">
    <summary>
      <para>Registers the active instance of an application for restart.</para>
    </summary>
    <param name="pwzCommandline">
      <para>A pointer to a Unicode string that specifies the command-line arguments for the application when it is restarted. The maximum size of the command line that you can specify is RESTART_MAX_CMD_LINE characters. Do not include the name of the executable in the command line; this function adds it for you.</para>
      <para>If this parameter is <b>NULL</b> or an empty string, the previously registered command line is removed. If the argument contains spaces, use quotes around the argument.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be 0 or one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESTART_NO_CRASH</b>
                </description>
              </item>
              <item>
                <description>1</description>
              </item>
            </list>
          </description>
          <description>
            <para>Do not restart the process if it terminates due to an unhandled exception.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESTART_NO_HANG</b>
                </description>
              </item>
              <item>
                <description>2</description>
              </item>
            </list>
          </description>
          <description>
            <para>Do not restart the process if it terminates due to the  application not responding.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESTART_NO_PATCH</b>
                </description>
              </item>
              <item>
                <description>4</description>
              </item>
            </list>
          </description>
          <description>
            <para>Do not restart the process if it terminates due to the installation of  an update.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>RESTART_NO_REBOOT</b>
                </description>
              </item>
              <item>
                <description>8</description>
              </item>
            </list>
          </description>
          <description>
            <para>Do not restart the process if the computer is restarted as the result of an update.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>E_FAIL</b>
            </para>
          </description>
          <description>
            <para>Internal error.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_INVALIDARG</b>
            </para>
          </description>
          <description>
            <para>The specified command line is too long.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Your initial registration for restart must occur before the application encounters an unhandled exception or becomes unresponsive. You could then call this function from inside your recovery callback to update the command line.</para>
      <para>For a Windows application that is being updated, the last opportunity to call this function is while processing the <a href="https://docs.microsoft.com//windows/desktop/Shutdown/wm-queryendsession">WM_QUERYENDSESSION</a> message. For a console application that is being updated, the registration must occur before the installer tries to shutdown the application (you need to keep the registration current; you cannot call this function when handling the CTRL_C_EVENT notification).</para>
      <para>If you register for restart and the application encounters an unhandled exception or is not responsive, the user is offered the opportunity to restart the application; the application is not automatically restarted without the user's consent. However, if the application is being updated and requires a restart, the application is restarted automatically.</para>
      <para>To prevent cyclical restarts, the system will only restart the application if it has been
running for a minimum of 60 seconds.</para>
      <para>Note that for an application to be restarted when the update requires a computer restart, the installer must call the <see cref="ExitWindowsEx" /> function with the EWX_RESTARTAPPS flag set or the <see cref="InitiateShutdown" /> function with the SHUTDOWN_RESTARTAPPS flag set.</para>
    </remarks>
    <seealso cref="UnregisterApplicationRestart" />
  </member>
  <member name="Windows.RegisterEventSource">
    <summary>
      <para>Retrieves a registered handle to the specified event log.</para>
    </summary>
    <param name="lpUNCServerName">
      <para>The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</para>
    </param>
    <param name="lpSourceName">
      <para>The name of the <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-sources">event source</a> whose handle is to be retrieved. The source name must be a subkey of a log under the <b>Eventlog</b> registry key.
Note that the <b>Security</b> log is for system use only.</para>
      <para>
        <b>Note</b>  This string must not contain characters prohibited in XML Attributes, with the exception of XML Escape sequences such as <b>&amp;lt  &amp;gl</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The function returns <b>ERROR_ACCESS_DENIED</b> if <i>lpSourceName</i> specifies the <b>Security</b> event log.</para>
    </returns>
    <remarks>
      <para>If the source name cannot be found, the event logging service uses the <b>Application</b> log. Although events will be reported , the events will not include descriptions because there are no message and category message files for looking up descriptions related to the event identifiers.</para>
      <para>To close the handle to the event log, use the
<see cref="DeregisterEventSource" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/reporting-an-event">Reporting an Event</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines RegisterEventSource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeregisterEventSource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-sources">Event Sources</seealso>
    <seealso cref="ReportEvent" />
  </member>
  <member name="Windows.RegisterEventSourceA">
    <summary>
      <para>Retrieves a registered handle to the specified event log.</para>
    </summary>
    <param name="lpUNCServerName">
      <para>The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</para>
    </param>
    <param name="lpSourceName">
      <para>The name of the <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-sources">event source</a> whose handle is to be retrieved. The source name must be a subkey of a log under the <b>Eventlog</b> registry key.
Note that the <b>Security</b> log is for system use only.</para>
      <para>
        <b>Note</b>  This string must not contain characters prohibited in XML Attributes, with the exception of XML Escape sequences such as <b>&amp;lt  &amp;gl</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The function returns <b>ERROR_ACCESS_DENIED</b> if <i>lpSourceName</i> specifies the <b>Security</b> event log.</para>
    </returns>
    <remarks>
      <para>If the source name cannot be found, the event logging service uses the <b>Application</b> log. Although events will be reported , the events will not include descriptions because there are no message and category message files for looking up descriptions related to the event identifiers.</para>
      <para>To close the handle to the event log, use the
<see cref="DeregisterEventSource" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/reporting-an-event">Reporting an Event</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines RegisterEventSource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeregisterEventSource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-sources">Event Sources</seealso>
    <seealso cref="ReportEvent" />
  </member>
  <member name="Windows.RegisterEventSourceW">
    <summary>
      <para>Retrieves a registered handle to the specified event log.</para>
    </summary>
    <param name="lpUNCServerName">
      <para>The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</para>
    </param>
    <param name="lpSourceName">
      <para>The name of the <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-sources">event source</a> whose handle is to be retrieved. The source name must be a subkey of a log under the <b>Eventlog</b> registry key.
Note that the <b>Security</b> log is for system use only.</para>
      <para>
        <b>Note</b>  This string must not contain characters prohibited in XML Attributes, with the exception of XML Escape sequences such as <b>&amp;lt  &amp;gl</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The function returns <b>ERROR_ACCESS_DENIED</b> if <i>lpSourceName</i> specifies the <b>Security</b> event log.</para>
    </returns>
    <remarks>
      <para>If the source name cannot be found, the event logging service uses the <b>Application</b> log. Although events will be reported , the events will not include descriptions because there are no message and category message files for looking up descriptions related to the event identifiers.</para>
      <para>To close the handle to the event log, use the
<see cref="DeregisterEventSource" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/reporting-an-event">Reporting an Event</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines RegisterEventSource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeregisterEventSource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-sources">Event Sources</seealso>
    <seealso cref="ReportEvent" />
  </member>
  <member name="Windows.RegisterEventSource">
    <summary>
      <para>Retrieves a registered handle to the specified event log.</para>
    </summary>
    <param name="lpUNCServerName">
      <para>The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</para>
    </param>
    <param name="lpSourceName">
      <para>The name of the <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-sources">event source</a> whose handle is to be retrieved. The source name must be a subkey of a log under the <b>Eventlog</b> registry key.
Note that the <b>Security</b> log is for system use only.</para>
      <para>
        <b>Note</b>  This string must not contain characters prohibited in XML Attributes, with the exception of XML Escape sequences such as <b>&lt;</b> or <b>&gt;</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The function returns <b>ERROR_ACCESS_DENIED</b> if <i>lpSourceName</i> specifies the <b>Security</b> event log.</para>
    </returns>
    <remarks>
      <para>If the source name cannot be found, the event logging service uses the <b>Application</b> log. Although events will be reported , the events will not include descriptions because there are no message and category message files for looking up descriptions related to the event identifiers.</para>
      <para>To close the handle to the event log, use the
<see cref="DeregisterEventSource" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/reporting-an-event">Reporting an Event</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines RegisterEventSource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeregisterEventSource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-sources">Event Sources</seealso>
    <seealso cref="ReportEvent" />
  </member>
  <member name="Windows.RegisterEventSourceA">
    <summary>
      <para>Retrieves a registered handle to the specified event log.</para>
    </summary>
    <param name="lpUNCServerName">
      <para>The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</para>
    </param>
    <param name="lpSourceName">
      <para>The name of the <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-sources">event source</a> whose handle is to be retrieved. The source name must be a subkey of a log under the <b>Eventlog</b> registry key.
Note that the <b>Security</b> log is for system use only.</para>
      <para>
        <b>Note</b>  This string must not contain characters prohibited in XML Attributes, with the exception of XML Escape sequences such as <b>&lt;</b> or <b>&gt;</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The function returns <b>ERROR_ACCESS_DENIED</b> if <i>lpSourceName</i> specifies the <b>Security</b> event log.</para>
    </returns>
    <remarks>
      <para>If the source name cannot be found, the event logging service uses the <b>Application</b> log. Although events will be reported , the events will not include descriptions because there are no message and category message files for looking up descriptions related to the event identifiers.</para>
      <para>To close the handle to the event log, use the
<see cref="DeregisterEventSource" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/reporting-an-event">Reporting an Event</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines RegisterEventSource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeregisterEventSource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-sources">Event Sources</seealso>
    <seealso cref="ReportEvent" />
  </member>
  <member name="Windows.RegisterEventSourceW">
    <summary>
      <para>Retrieves a registered handle to the specified event log.</para>
    </summary>
    <param name="lpUNCServerName">
      <para>The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</para>
    </param>
    <param name="lpSourceName">
      <para>The name of the <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-sources">event source</a> whose handle is to be retrieved. The source name must be a subkey of a log under the <b>Eventlog</b> registry key.
Note that the <b>Security</b> log is for system use only.</para>
      <para>
        <b>Note</b>  This string must not contain characters prohibited in XML Attributes, with the exception of XML Escape sequences such as <b>&lt;</b> or <b>&gt;</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>The function returns <b>ERROR_ACCESS_DENIED</b> if <i>lpSourceName</i> specifies the <b>Security</b> event log.</para>
    </returns>
    <remarks>
      <para>If the source name cannot be found, the event logging service uses the <b>Application</b> log. Although events will be reported , the events will not include descriptions because there are no message and category message files for looking up descriptions related to the event identifiers.</para>
      <para>To close the handle to the event log, use the
<see cref="DeregisterEventSource" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/reporting-an-event">Reporting an Event</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines RegisterEventSource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeregisterEventSource" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-sources">Event Sources</seealso>
    <seealso cref="ReportEvent" />
  </member>
  <member name="Windows.RegisterWaitForSingleObject">
    <summary>
      <para>Directs a wait thread in the <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-pooling">thread pool</a> to wait on the object. The wait thread queues the specified callback function to the thread pool when one of the following occurs:</para>
      <list type="bullet">
        <item>
          <description>The specified object is in the signaled state.</description>
        </item>
        <item>
          <description>The time-out interval elapses.</description>
        </item>
      </list>
    </summary>
    <param name="phNewWaitObject">
      <para>A pointer to a variable that receives a wait handle on return. Note that a wait handle cannot be used in functions that require an object handle, such as
<see cref="CloseHandle" />.</para>
    </param>
    <param name="hObject">
      <para>A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section.</para>
      <para>If this handle is closed while the wait is still pending, the function's behavior is undefined.</para>
      <para>The handles must have the <b>SYNCHRONIZE</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.</para>
    </param>
    <param name="Callback">
      <para>A pointer to the application-defined function of type <b>WAITORTIMERCALLBACK</b> to be executed when <i>hObject</i> is in the signaled state, or <i>dwMilliseconds</i> elapses. For more information, see
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms687066(v=vs.85)">WaitOrTimerCallback</a>.</para>
    </param>
    <param name="Context">
      <para>A single value that is passed to the callback function.</para>
    </param>
    <param name="dwMilliseconds">
      <para>The time-out interval, in milliseconds. The function returns if the interval elapses, even if the object's state is nonsignaled. If <i>dwMilliseconds</i> is zero, the function tests the object's state and returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function's time-out interval never elapses.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <para>For information about using these values with objects that remain signaled, see the Remarks section.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WT_EXECUTEDEFAULT</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>By default, the callback function is queued to a non-I/O worker thread.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WT_EXECUTEINIOTHREAD</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>This flag is not used.</para>
            <para>
              <b>Windows Server 2003 and Windows XP:  </b>The callback function is queued to an I/O worker thread. This flag should be used if the function should be executed in a thread that waits in an alertable state.</para>
            <para>I/O worker threads were removed starting with Windows Vista and Windows Server 2008.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WT_EXECUTEINPERSISTENTTHREAD</b>
                </description>
              </item>
              <item>
                <description>0x00000080</description>
              </item>
            </list>
          </description>
          <description>
            <para>The callback function is queued to a thread that never terminates. It does not guarantee that the same thread is used each time. This flag should be used only for short tasks or it could affect other wait operations.</para>
            <para>This flag must be set if the thread calls functions that use APCs. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/asynchronous-procedure-calls">Asynchronous Procedure Calls</a>.</para>
            <para>Note that currently no worker thread is truly persistent, although no worker thread will terminate if there are any pending I/O requests.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WT_EXECUTEINWAITTHREAD</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The callback function is invoked by the wait thread itself. This flag should be used only for short tasks or it could affect other wait operations.</para>
            <para>Deadlocks can occur if some other thread acquires an exclusive lock and calls the
<see cref="UnregisterWait" /> or
<a href="https://docs.microsoft.com//windows/desktop/Sync/unregisterwaitex">UnregisterWaitEx</a> function while the callback function is trying to acquire the same lock.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WT_EXECUTELONGFUNCTION</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>The callback function can perform a long wait. This flag helps the system to decide if it should create a new thread.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WT_EXECUTEONLYONCE</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The thread will no longer wait on the handle after the callback function has been called once. Otherwise, the timer is reset every time the wait operation completes until the wait operation is canceled.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>WT_TRANSFER_IMPERSONATION</b>
                </description>
              </item>
              <item>
                <description>0x00000100</description>
              </item>
            </list>
          </description>
          <description>
            <para>Callback functions will use the current access token, whether it is a process or impersonation token. If this flag is not specified, callback functions execute only with the process token.</para>
            <para>
              <b>Windows XP:  </b>This flag is not supported until Windows XP with SP2 and Windows Server 2003.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>New wait threads are created automatically when required. The wait operation is performed by a wait thread from the thread pool. The callback routine is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses. If <i>dwFlags</i> is not <b>WT_EXECUTEONLYONCE</b>, the timer is reset every time the event is signaled or the time-out interval elapses.</para>
      <para>When the wait is completed, you must call the
<see cref="UnregisterWait" /> or
<a href="https://docs.microsoft.com//windows/desktop/Sync/unregisterwaitex">UnregisterWaitEx</a> function to cancel the wait operation. (Even wait operations that use <b>WT_EXECUTEONLYONCE</b> must be canceled.) Do not make a blocking call to either of these functions from within the callback function.</para>
      <para>Note that you should not pulse an event object passed to
<b>RegisterWaitForSingleObject</b>, because the wait thread might not detect that the event is signaled before it is reset. You should not register an object that remains signaled (such as a manual reset event or terminated process) unless you set the <b>WT_EXECUTEONLYONCE</b> or <b>WT_EXECUTEINWAITTHREAD</b> flag. For other flags,  the callback function might be called too many times before the event is reset.</para>
      <para>The function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore object is decreased by one.</para>
      <para>The
<b>RegisterWaitForSingleObject</b> function can wait for the following objects:</para>
      <list type="bullet">
        <item>
          <description>Change notification</description>
        </item>
        <item>
          <description>Console input</description>
        </item>
        <item>
          <description>Event</description>
        </item>
        <item>
          <description>Memory resource notification</description>
        </item>
        <item>
          <description>Mutex</description>
        </item>
        <item>
          <description>Process</description>
        </item>
        <item>
          <description>Semaphore</description>
        </item>
        <item>
          <description>Thread</description>
        </item>
        <item>
          <description>Waitable timer</description>
        </item>
      </list>
      <para>For more information, see
<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-objects">Synchronization Objects</a>.</para>
      <para>By default, the thread pool has a maximum of 500 threads. To raise this limit, use the <b>WT_SET_MAX_THREADPOOL_THREAD</b> macro defined in WinNT.h.</para>
      <code>#define WT_SET_MAX_THREADPOOL_THREADS(Flags,Limit) \
    ((Flags)|=(Limit)&lt;&lt;16)
</code>
      <para>Use this macro when specifying the <i>dwFlags</i> parameter. The macro parameters are the desired flags and the new limit (up to (2&lt;&lt;16)-1 threads). However, note that your application can improve its performance by keeping the number of worker threads low.</para>
      <para>The work item and all functions it calls must be thread-pool safe. Therefore, you cannot call an asynchronous call that requires a persistent thread, such as the
<see cref="RegNotifyChangeKeyValue" /> function, from the default callback environment. Instead, set the thread pool maximum equal to the thread pool minimum using the <see cref="SetThreadpoolThreadMaximum" /> and <see cref="SetThreadpoolThreadMinimum" /> functions, or create your own thread using the <see cref="CreateThread" /> function. (For the original thread pool API, specify <b>WT_EXECUTEINPERSISTENTTHREAD</b> using the <see cref="QueueUserWorkItem" /> function.)</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-pooling">Thread Pooling</seealso>
    <seealso cref="UnregisterWait" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/unregisterwaitex">UnregisterWaitEx</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">Wait Functions</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms687066(v=vs.85)">WaitOrTimerCallback</seealso>
  </member>
  <member name="Windows.ReleaseActCtx">
    <summary>
      <para>The
<b>ReleaseActCtx</b> function decrements the reference count of the specified activation context.</para>
    </summary>
    <param name="hActCtx">
      <para>Handle to the
<see cref="ACTCTX" /> structure that contains information on the activation context for which the reference count is to be decremented.</para>
    </param>
    <returns>
      <para>This function does not return a value. On successful completion, the activation context reference count is decremented. The recipient of the reference-counted object must decrement the reference count when the object is no longer required.</para>
    </returns>
    <remarks>
      <para>When the reference count of an activation context becomes zero, the activation context structure is deallocated. Activation contexts have not been implemented as kernel objects, therefore, kernel handler functions cannot be used for activation contexts.</para>
      <para>If the value of the <i>hActCtx</i> parameter is a null handle, this function does nothing and no error condition occurs.</para>
    </remarks>
    <seealso cref="ACTCTX" />
    <seealso cref="AddRefActCtx" />
  </member>
  <member name="Windows.RemoveSecureMemoryCacheCallback">
    <summary>
      <para>Unregisters a callback function that was previously registered with the <see cref="AddSecureMemoryCacheCallback" /> function.</para>
    </summary>
    <param name="pfnCallBack">
      <para>A pointer to the application-defined <a href="https://docs.microsoft.com//windows/desktop/api/winnt/nc-winnt-psecure_memory_cache_callback">SecureMemoryCacheCallback</a> function to remove.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>.</para>
      <para>If the function fails, it returns <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or later. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="AddSecureMemoryCacheCallback" />
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winnt/nc-winnt-psecure_memory_cache_callback">SecureMemoryCacheCallback</seealso>
  </member>
  <member name="Windows.ReOpenFile">
    <summary>
      <para>Reopens the specified file system object with different access rights, sharing mode, and
flags.</para>
    </summary>
    <param name="hOriginalFile">
      <para>A handle to the object to be reopened. The object must have been created by the
<see cref="CreateFile" /> function.</para>
    </param>
    <param name="dwDesiredAccess">
      <para>The required access to the object. For a list of values, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>. You
cannot request an access mode that conflicts with the sharing mode specified in a previous open request whose
handle is still open.</para>
      <para>If this parameter is zero (0), the application can query device attributes without accessing the device. This
is useful if an application wants to determine the size of a floppy disk drive and the formats it supports
without requiring a floppy in the drive.</para>
    </param>
    <param name="dwShareMode">
      <para>The sharing mode of the object. You cannot request a sharing mode that conflicts with the access mode
specified in a previous open request whose handle is still open.</para>
      <para>If this parameter is zero (0) and <see cref="CreateFile" /> succeeds,
the object cannot be shared and cannot be opened again until the handle is closed.</para>
      <para>To enable other processes to share the object while your process has it open, use a combination of one or
more of the following values to specify the type of access they can request when they open the object. These
sharing options remain in effect until you close the handle to the object.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SHARE_DELETE</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables subsequent open operations on the object to request delete access. Otherwise, other processes
cannot open the object if they request delete access.</para>
            <para>If the object has already been opened with delete access, the sharing mode must include this flag.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SHARE_READ</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables subsequent open operations on the object to request read access. Otherwise, other processes cannot
open the object if they request read access.</para>
            <para>If the object has already been opened with read access, the sharing mode must include this flag.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SHARE_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables subsequent open operations on the object to request write access. Otherwise, other processes cannot
open the object if they request write access.</para>
            <para>If the object has already been opened with write access, the sharing mode must include this flag.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwFlagsAndAttributes">
      <para>The file flags. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_BACKUP_SEMANTICS</b>
                </description>
              </item>
              <item>
                <description>0x02000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates that the file is being opened or created for a backup or restore operation. The system ensures
that the calling process overrides file security checks, provided it has the
<b>SE_BACKUP_NAME</b> and <b>SE_RESTORE_NAME</b> privileges. For more
information, see
<a href="https://docs.microsoft.com//windows/desktop/SecBP/changing-privileges-in-a-token">Changing Privileges in a Token</a>.</para>
            <para>You can also set this flag to obtain a handle to a directory. Where indicated, a directory handle can be
passed to some functions in place of a file handle.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_DELETE_ON_CLOSE</b>
                </description>
              </item>
              <item>
                <description>0x04000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates that the operating system is to delete the file immediately after all of its handles have been
closed, not just the specified handle but also any other open or duplicated handles.</para>
            <para>Subsequent open requests for the file fail, unless <b>FILE_SHARE_DELETE</b> is used.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_NO_BUFFERING</b>
                </description>
              </item>
              <item>
                <description>0x20000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Instructs the system to open the file with no intermediate buffering or caching. When combined with
<b>FILE_FLAG_OVERLAPPED</b>, the flag gives maximum asynchronous performance, because the
I/O does not rely on the synchronous operations of the memory manager. However, some I/O operations take
longer, because data is not being held in the cache.</para>
            <para>An application must meet specific requirements when working with files opened with
<b>FILE_FLAG_NO_BUFFERING</b>:</para>
            <list type="bullet">
              <item>
                <description>File access must begin at byte offsets within the file that are integer multiples of the volume sector
size.</description>
              </item>
              <item>
                <description>File access must be for numbers of bytes that are integer multiples of the volume sector size. For
example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1024, 1536, or
2048 bytes, but not of 335, 981, or 7171 bytes.</description>
              </item>
              <item>
                <description>Buffer addresses for read and write operations should be sector aligned (aligned on addresses in memory
that are integer multiples of the volume sector size). Depending on the disk, this requirement may not be
enforced.</description>
              </item>
            </list>
            <para>One way to align buffers on integer multiples of the volume sector size is to use
<see cref="VirtualAlloc" /> to allocate the buffers. It allocates
memory that is aligned on addresses that are integer multiples of the operating system memory page size.
Because both memory page and volume sector sizes are powers of 2, this memory is also aligned on addresses
that are integer multiples of a volume sector size. Memory pages are 4-8 KB in size; sectors are 512 bytes
(hard disks) or 2048 bytes (CD), and therefore, volume sectors can never be larger than memory pages.</para>
            <para>An application can determine a volume sector size by calling the
<see cref="GetDiskFreeSpace" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_OPEN_NO_RECALL</b>
                </description>
              </item>
              <item>
                <description>0x00100000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates that the file data is requested, but it should continue to reside in remote storage. It should
not be transported back to local storage. This flag is intended for use by remote storage systems.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_OPEN_REPARSE_POINT</b>
                </description>
              </item>
              <item>
                <description>0x00200000</description>
              </item>
            </list>
          </description>
          <description>
            <para>When this flag is used, normal <a href="https://docs.microsoft.com//windows/desktop/FileIO/reparse-points">reparse point</a></para>
            <para>processing does not occur, and <b>ReOpenFile</b> attempts to
open the reparse point. When a file is opened, a file handle is returned, whether or not the filter that
controls the reparse point is operational. This flag cannot be used with the
<b>CREATE_ALWAYS</b> flag. If the file is not a reparse point, then this flag is ignored.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_OVERLAPPED</b>
                </description>
              </item>
              <item>
                <description>0x40000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Instructs the system to initialize the object, so that operations that take a significant amount of time to
process return <b>ERROR_IO_PENDING</b>. When the operation is finished, the specified event is set to the signaled
state.</para>
            <para>When you specify <b>FILE_FLAG_OVERLAPPED</b>, the file read and write functions
<b>must</b> specify an
<see cref="OVERLAPPED" /> structure. That is, when
<b>FILE_FLAG_OVERLAPPED</b> is specified, an application <b>must</b></para>
            <para>perform overlapped reading and writing.</para>
            <para>When <b>FILE_FLAG_OVERLAPPED</b> is specified, the system does not maintain the file
pointer. The file position must be passed as part of the <i>lpOverlapped</i> parameter
(pointing to an <see cref="OVERLAPPED" /> structure) to the file
read and write functions.</para>
            <para>This flag also enables more than one operation to be performed simultaneously with the handle (a
simultaneous read and write operation, for example).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_POSIX_SEMANTICS</b>
                </description>
              </item>
              <item>
                <description>0x01000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates that the file is to be accessed according to POSIX rules. This includes allowing multiple files
with names, differing only in case, for file systems that support such naming. Use care when using this
option because files created with this flag may not be accessible by applications written for MS-DOS or
16-bit Windows.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_RANDOM_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x10000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates that the file is accessed randomly. The system can use this as a hint to optimize file
caching.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_SEQUENTIAL_SCAN</b>
                </description>
              </item>
              <item>
                <description>0x08000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates that the file is to be accessed sequentially from beginning to end. The system can use this as a
hint to optimize file caching. If an application moves the file pointer for random access, optimum caching
may not occur; however, correct operation is still guaranteed.</para>
            <para>Specifying this flag can increase performance for applications that read large files using sequential
access. Performance gains can be even more noticeable for applications that read large files mostly
sequentially, but occasionally skip over small ranges of bytes.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_FLAG_WRITE_THROUGH</b>
                </description>
              </item>
              <item>
                <description>0x80000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Instructs the system to write through any intermediate cache and go directly to disk. The system can still
cache write operations, but cannot lazily flush them.</para>
          </description>
        </item>
      </list>
      <para>If the handle represents the client side of a named pipe, the <i>dwFlags</i> parameter can
also contain Security Quality of Service information. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/impersonation-levels">Impersonation Levels</a>. When the calling
application specifies the <b>SECURITY_SQOS_PRESENT</b> flag, the
<i>dwFlags</i> parameter can contain one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>SECURITY_ANONYMOUS</b>
          </description>
          <description>
            <para>Impersonate the client at the Anonymous impersonation level.</para>
          </description>
        </item>
        <item>
          <description>
            <b>SECURITY_CONTEXT_TRACKING</b>
          </description>
          <description>
            <para>The security tracking mode is dynamic. If this flag is not specified, the security tracking mode is
static.</para>
          </description>
        </item>
        <item>
          <description>
            <b>SECURITY_DELEGATION</b>
          </description>
          <description>
            <para>Impersonate the client at the Delegation impersonation level.</para>
          </description>
        </item>
        <item>
          <description>
            <b>SECURITY_EFFECTIVE_ONLY</b>
          </description>
          <description>
            <para>Only the enabled aspects of the client security context are available to the server. If you do not specify
this flag, all aspects of the client security context are available.</para>
            <para>This allows the client to limit the groups and privileges that a server can use while impersonating the
client.</para>
          </description>
        </item>
        <item>
          <description>
            <b>SECURITY_IDENTIFICATION</b>
          </description>
          <description>
            <para>Impersonate the client at the Identification impersonation level.</para>
          </description>
        </item>
        <item>
          <description>
            <b>SECURITY_IMPERSONATION</b>
          </description>
          <description>
            <para>Impersonate the client at the Impersonation impersonation level.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified file.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended
error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <i>dwFlags</i> parameter cannot contain any of the file attribute flags
(<b>FILE_ATTRIBUTE_*</b>). These can only be specified when the file is created.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.ReportEvent">
    <summary>
      <para>Writes an entry at the end of the specified event log.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log. The
<see cref="RegisterEventSource" /> function returns this handle.</para>
      <para>As of Windows XP with SP2, this parameter cannot be a handle to the <b>Security</b> log. To write an event to the <b>Security</b> log, use the <see cref="AuthzReportSecurityEvent" /> function.</para>
    </param>
    <param name="wType">
      <para>The type of event to be logged. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_SUCCESS</b>
                </description>
              </item>
              <item>
                <description>0x0000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Information event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_AUDIT_FAILURE</b>
                </description>
              </item>
              <item>
                <description>0x0010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Failure Audit event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_AUDIT_SUCCESS</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Success Audit event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_ERROR_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Error event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_INFORMATION_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Information event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_WARNING_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Warning event</para>
          </description>
        </item>
      </list>
      <para>For more information about event types, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-types">Event Types</a>.</para>
    </param>
    <param name="wCategory">
      <para>The event category. This is source-specific information; the category can have any value. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-categories">Event Categories</a>.</para>
    </param>
    <param name="dwEventID">
      <para>The event identifier. The event identifier specifies the entry in the message file associated with the event source. For more information, see <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-identifiers">Event Identifiers</a>.</para>
    </param>
    <param name="lpUserSid">
      <para>A pointer to the current user's security identifier. This parameter can be <b>NULL</b> if the security identifier is not required.</para>
    </param>
    <param name="wNumStrings">
      <para>The number of insert strings in the array pointed to by the <i>lpStrings</i> parameter. A value of zero indicates that no strings are present.</para>
    </param>
    <param name="dwDataSize">
      <para>The number of bytes of event-specific raw (binary) data to write to the log. If this parameter is zero, no event-specific data is present.</para>
    </param>
    <param name="lpStrings">
      <para>A pointer to a buffer containing an array of null-terminated strings that are merged into the message before Event Viewer displays the string to the user. This parameter must be a valid pointer (or <b>NULL</b>), even if <i>wNumStrings</i> is zero. Each string is limited to 31,839  characters.</para>
      <para>
        <b>Prior to Windows Vista:  </b>Each string is limited to 32K characters.</para>
    </param>
    <param name="lpRawData">
      <para>A pointer to the buffer containing the binary data. This parameter must be a valid pointer (or <b>NULL</b>), even if the <i>dwDataSize</i> parameter is zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero, indicating that the entry was written to the log.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />, which returns one of the following extended error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One of the parameters is not valid.</para>
            <para>This error is returned on Windows Server 2003 if the  message data to be logged is too large. This error is returned by the RPC server on Windows Server 2003 if the <i>dwDataSize</i> parameter is larger than 261,991 (0x3ff67).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Insufficient memory resources are available to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_S_INVALID_BOUND</b>
            </para>
          </description>
          <description>
            <para>The array bounds are invalid.</para>
            <para>This error is returned if the  message data to be logged is too large. On Windows Vista and later, this error is returned if the <i>dwDataSize</i> parameter is larger than 61,440 (0xf000).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_X_BAD_STUB_DATA</b>
            </para>
          </description>
          <description>
            <para>The stub received bad data.</para>
            <para>This error is returned on Windows XP if the  message data to be logged is too large. This error is returned by the RPC server on Windows XP, if the <i>dwDataSize</i> parameter is larger than 262,143 (0x3ffff).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function is used to log an event. The entry is written to the end of the configured log for the source identified by the <i>hEventLog</i> parameter. The
<b>ReportEvent</b> function adds the time, the entry's length, and the offsets before storing the entry in the log. To enable the function to add the user name, you must supply the user's SID in the <i>lpUserSid</i> parameter.</para>
      <para>There are different size limits on the size of the message data that can be logged depending on the version of Windows used by both the client where the application is run and the server where the message is logged. The server is determined by the <i>lpUNCServerName</i> parameter passed to the <see cref="RegisterEventSource" /> function. Different errors are returned when the size limit is exceeded that depend on the version of Windows.</para>
      <para>If the string that you log contains %<i>n</i>, where <i>n</i> is an integer value (for example, %1), the event viewer treats it as an insertion string. Because an IPv6 address can contain this character sequence, you must provide a format specifier (<i>!S!</i>) to log an event message that contains an IPv6 address. This specifier tells the formatting code to use the string literally and not perform any further expansions (for example, "my IPv6 address is: %1!S!").</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/reporting-an-event">Reporting an Event</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines ReportEvent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ClearEventLog" />
    <seealso cref="CloseEventLog" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-log-file-format">Event Log File Format</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
    <seealso cref="ReadEventLog" />
    <seealso cref="RegisterEventSource" />
  </member>
  <member name="Windows.ReportEventA">
    <summary>
      <para>Writes an entry at the end of the specified event log.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log. The
<see cref="RegisterEventSource" /> function returns this handle.</para>
      <para>As of Windows XP with SP2, this parameter cannot be a handle to the <b>Security</b> log. To write an event to the <b>Security</b> log, use the <see cref="AuthzReportSecurityEvent" /> function.</para>
    </param>
    <param name="wType">
      <para>The type of event to be logged. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_SUCCESS</b>
                </description>
              </item>
              <item>
                <description>0x0000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Information event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_AUDIT_FAILURE</b>
                </description>
              </item>
              <item>
                <description>0x0010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Failure Audit event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_AUDIT_SUCCESS</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Success Audit event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_ERROR_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Error event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_INFORMATION_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Information event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_WARNING_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Warning event</para>
          </description>
        </item>
      </list>
      <para>For more information about event types, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-types">Event Types</a>.</para>
    </param>
    <param name="wCategory">
      <para>The event category. This is source-specific information; the category can have any value. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-categories">Event Categories</a>.</para>
    </param>
    <param name="dwEventID">
      <para>The event identifier. The event identifier specifies the entry in the message file associated with the event source. For more information, see <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-identifiers">Event Identifiers</a>.</para>
    </param>
    <param name="lpUserSid">
      <para>A pointer to the current user's security identifier. This parameter can be <b>NULL</b> if the security identifier is not required.</para>
    </param>
    <param name="wNumStrings">
      <para>The number of insert strings in the array pointed to by the <i>lpStrings</i> parameter. A value of zero indicates that no strings are present.</para>
    </param>
    <param name="dwDataSize">
      <para>The number of bytes of event-specific raw (binary) data to write to the log. If this parameter is zero, no event-specific data is present.</para>
    </param>
    <param name="lpStrings">
      <para>A pointer to a buffer containing an array of null-terminated strings that are merged into the message before Event Viewer displays the string to the user. This parameter must be a valid pointer (or <b>NULL</b>), even if <i>wNumStrings</i> is zero. Each string is limited to 31,839  characters.</para>
      <para>
        <b>Prior to Windows Vista:  </b>Each string is limited to 32K characters.</para>
    </param>
    <param name="lpRawData">
      <para>A pointer to the buffer containing the binary data. This parameter must be a valid pointer (or <b>NULL</b>), even if the <i>dwDataSize</i> parameter is zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero, indicating that the entry was written to the log.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />, which returns one of the following extended error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One of the parameters is not valid.</para>
            <para>This error is returned on Windows Server 2003 if the  message data to be logged is too large. This error is returned by the RPC server on Windows Server 2003 if the <i>dwDataSize</i> parameter is larger than 261,991 (0x3ff67).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Insufficient memory resources are available to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_S_INVALID_BOUND</b>
            </para>
          </description>
          <description>
            <para>The array bounds are invalid.</para>
            <para>This error is returned if the  message data to be logged is too large. On Windows Vista and later, this error is returned if the <i>dwDataSize</i> parameter is larger than 61,440 (0xf000).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_X_BAD_STUB_DATA</b>
            </para>
          </description>
          <description>
            <para>The stub received bad data.</para>
            <para>This error is returned on Windows XP if the  message data to be logged is too large. This error is returned by the RPC server on Windows XP, if the <i>dwDataSize</i> parameter is larger than 262,143 (0x3ffff).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function is used to log an event. The entry is written to the end of the configured log for the source identified by the <i>hEventLog</i> parameter. The
<b>ReportEvent</b> function adds the time, the entry's length, and the offsets before storing the entry in the log. To enable the function to add the user name, you must supply the user's SID in the <i>lpUserSid</i> parameter.</para>
      <para>There are different size limits on the size of the message data that can be logged depending on the version of Windows used by both the client where the application is run and the server where the message is logged. The server is determined by the <i>lpUNCServerName</i> parameter passed to the <see cref="RegisterEventSource" /> function. Different errors are returned when the size limit is exceeded that depend on the version of Windows.</para>
      <para>If the string that you log contains %<i>n</i>, where <i>n</i> is an integer value (for example, %1), the event viewer treats it as an insertion string. Because an IPv6 address can contain this character sequence, you must provide a format specifier (<i>!S!</i>) to log an event message that contains an IPv6 address. This specifier tells the formatting code to use the string literally and not perform any further expansions (for example, "my IPv6 address is: %1!S!").</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/reporting-an-event">Reporting an Event</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines ReportEvent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ClearEventLog" />
    <seealso cref="CloseEventLog" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-log-file-format">Event Log File Format</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
    <seealso cref="ReadEventLog" />
    <seealso cref="RegisterEventSource" />
  </member>
  <member name="Windows.ReportEventW">
    <summary>
      <para>Writes an entry at the end of the specified event log.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log. The
<see cref="RegisterEventSource" /> function returns this handle.</para>
      <para>As of Windows XP with SP2, this parameter cannot be a handle to the <b>Security</b> log. To write an event to the <b>Security</b> log, use the <see cref="AuthzReportSecurityEvent" /> function.</para>
    </param>
    <param name="wType">
      <para>The type of event to be logged. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_SUCCESS</b>
                </description>
              </item>
              <item>
                <description>0x0000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Information event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_AUDIT_FAILURE</b>
                </description>
              </item>
              <item>
                <description>0x0010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Failure Audit event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_AUDIT_SUCCESS</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Success Audit event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_ERROR_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Error event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_INFORMATION_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Information event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_WARNING_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Warning event</para>
          </description>
        </item>
      </list>
      <para>For more information about event types, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-types">Event Types</a>.</para>
    </param>
    <param name="wCategory">
      <para>The event category. This is source-specific information; the category can have any value. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-categories">Event Categories</a>.</para>
    </param>
    <param name="dwEventID">
      <para>The event identifier. The event identifier specifies the entry in the message file associated with the event source. For more information, see <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-identifiers">Event Identifiers</a>.</para>
    </param>
    <param name="lpUserSid">
      <para>A pointer to the current user's security identifier. This parameter can be <b>NULL</b> if the security identifier is not required.</para>
    </param>
    <param name="wNumStrings">
      <para>The number of insert strings in the array pointed to by the <i>lpStrings</i> parameter. A value of zero indicates that no strings are present.</para>
    </param>
    <param name="dwDataSize">
      <para>The number of bytes of event-specific raw (binary) data to write to the log. If this parameter is zero, no event-specific data is present.</para>
    </param>
    <param name="lpStrings">
      <para>A pointer to a buffer containing an array of null-terminated strings that are merged into the message before Event Viewer displays the string to the user. This parameter must be a valid pointer (or <b>NULL</b>), even if <i>wNumStrings</i> is zero. Each string is limited to 31,839  characters.</para>
      <para>
        <b>Prior to Windows Vista:  </b>Each string is limited to 32K characters.</para>
    </param>
    <param name="lpRawData">
      <para>A pointer to the buffer containing the binary data. This parameter must be a valid pointer (or <b>NULL</b>), even if the <i>dwDataSize</i> parameter is zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero, indicating that the entry was written to the log.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />, which returns one of the following extended error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One of the parameters is not valid.</para>
            <para>This error is returned on Windows Server 2003 if the  message data to be logged is too large. This error is returned by the RPC server on Windows Server 2003 if the <i>dwDataSize</i> parameter is larger than 261,991 (0x3ff67).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Insufficient memory resources are available to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_S_INVALID_BOUND</b>
            </para>
          </description>
          <description>
            <para>The array bounds are invalid.</para>
            <para>This error is returned if the  message data to be logged is too large. On Windows Vista and later, this error is returned if the <i>dwDataSize</i> parameter is larger than 61,440 (0xf000).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_X_BAD_STUB_DATA</b>
            </para>
          </description>
          <description>
            <para>The stub received bad data.</para>
            <para>This error is returned on Windows XP if the  message data to be logged is too large. This error is returned by the RPC server on Windows XP, if the <i>dwDataSize</i> parameter is larger than 262,143 (0x3ffff).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function is used to log an event. The entry is written to the end of the configured log for the source identified by the <i>hEventLog</i> parameter. The
<b>ReportEvent</b> function adds the time, the entry's length, and the offsets before storing the entry in the log. To enable the function to add the user name, you must supply the user's SID in the <i>lpUserSid</i> parameter.</para>
      <para>There are different size limits on the size of the message data that can be logged depending on the version of Windows used by both the client where the application is run and the server where the message is logged. The server is determined by the <i>lpUNCServerName</i> parameter passed to the <see cref="RegisterEventSource" /> function. Different errors are returned when the size limit is exceeded that depend on the version of Windows.</para>
      <para>If the string that you log contains %<i>n</i>, where <i>n</i> is an integer value (for example, %1), the event viewer treats it as an insertion string. Because an IPv6 address can contain this character sequence, you must provide a format specifier (<i>!S!</i>) to log an event message that contains an IPv6 address. This specifier tells the formatting code to use the string literally and not perform any further expansions (for example, "my IPv6 address is: %1!S!").</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/reporting-an-event">Reporting an Event</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines ReportEvent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ClearEventLog" />
    <seealso cref="CloseEventLog" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-log-file-format">Event Log File Format</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
    <seealso cref="ReadEventLog" />
    <seealso cref="RegisterEventSource" />
  </member>
  <member name="Windows.ReportEvent">
    <summary>
      <para>Writes an entry at the end of the specified event log.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log. The
<see cref="RegisterEventSource" /> function returns this handle.</para>
      <para>As of Windows XP with SP2, this parameter cannot be a handle to the <b>Security</b> log. To write an event to the <b>Security</b> log, use the <see cref="AuthzReportSecurityEvent" /> function.</para>
    </param>
    <param name="wType">
      <para>The type of event to be logged. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_SUCCESS</b>
                </description>
              </item>
              <item>
                <description>0x0000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Information event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_AUDIT_FAILURE</b>
                </description>
              </item>
              <item>
                <description>0x0010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Failure Audit event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_AUDIT_SUCCESS</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Success Audit event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_ERROR_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Error event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_INFORMATION_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Information event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_WARNING_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Warning event</para>
          </description>
        </item>
      </list>
      <para>For more information about event types, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-types">Event Types</a>.</para>
    </param>
    <param name="wCategory">
      <para>The event category. This is source-specific information; the category can have any value. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-categories">Event Categories</a>.</para>
    </param>
    <param name="dwEventID">
      <para>The event identifier. The event identifier specifies the entry in the message file associated with the event source. For more information, see <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-identifiers">Event Identifiers</a>.</para>
    </param>
    <param name="lpUserSid">
      <para>A pointer to the current user's security identifier. This parameter can be <b>NULL</b> if the security identifier is not required.</para>
    </param>
    <param name="wNumStrings">
      <para>The number of insert strings in the array pointed to by the <i>lpStrings</i> parameter. A value of zero indicates that no strings are present.</para>
    </param>
    <param name="dwDataSize">
      <para>The number of bytes of event-specific raw (binary) data to write to the log. If this parameter is zero, no event-specific data is present.</para>
    </param>
    <param name="lpStrings">
      <para>A pointer to a buffer containing an array of null-terminated strings that are merged into the message before Event Viewer displays the string to the user. This parameter must be a valid pointer (or <b>NULL</b>), even if <i>wNumStrings</i> is zero. Each string is limited to 31,839  characters.</para>
      <para>
        <b>Prior to Windows Vista:  </b>Each string is limited to 32K characters.</para>
    </param>
    <param name="lpRawData">
      <para>A pointer to the buffer containing the binary data. This parameter must be a valid pointer (or <b>NULL</b>), even if the <i>dwDataSize</i> parameter is zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero, indicating that the entry was written to the log.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />, which returns one of the following extended error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One of the parameters is not valid.</para>
            <para>This error is returned on Windows Server 2003 if the  message data to be logged is too large. This error is returned by the RPC server on Windows Server 2003 if the <i>dwDataSize</i> parameter is larger than 261,991 (0x3ff67).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Insufficient memory resources are available to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_S_INVALID_BOUND</b>
            </para>
          </description>
          <description>
            <para>The array bounds are invalid.</para>
            <para>This error is returned if the  message data to be logged is too large. On Windows Vista and later, this error is returned if the <i>dwDataSize</i> parameter is larger than 61,440 (0xf000).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_X_BAD_STUB_DATA</b>
            </para>
          </description>
          <description>
            <para>The stub received bad data.</para>
            <para>This error is returned on Windows XP if the  message data to be logged is too large. This error is returned by the RPC server on Windows XP, if the <i>dwDataSize</i> parameter is larger than 262,143 (0x3ffff).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function is used to log an event. The entry is written to the end of the configured log for the source identified by the <i>hEventLog</i> parameter. The
<b>ReportEvent</b> function adds the time, the entry's length, and the offsets before storing the entry in the log. To enable the function to add the user name, you must supply the user's SID in the <i>lpUserSid</i> parameter.</para>
      <para>There are different size limits on the size of the message data that can be logged depending on the version of Windows used by both the client where the application is run and the server where the message is logged. The server is determined by the <i>lpUNCServerName</i> parameter passed to the <see cref="RegisterEventSource" /> function. Different errors are returned when the size limit is exceeded that depend on the version of Windows.</para>
      <para>If the string that you log contains %<i>n</i>, where <i>n</i> is an integer value (for example, %1), the event viewer treats it as an insertion string. Because an IPv6 address can contain this character sequence, you must provide a format specifier (<i>!S!</i>) to log an event message that contains an IPv6 address. This specifier tells the formatting code to use the string literally and not perform any further expansions (for example, "my IPv6 address is: %1!S!").</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/reporting-an-event">Reporting an Event</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines ReportEvent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ClearEventLog" />
    <seealso cref="CloseEventLog" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-log-file-format">Event Log File Format</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
    <seealso cref="ReadEventLog" />
    <seealso cref="RegisterEventSource" />
  </member>
  <member name="Windows.ReportEventA">
    <summary>
      <para>Writes an entry at the end of the specified event log.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log. The
<see cref="RegisterEventSource" /> function returns this handle.</para>
      <para>As of Windows XP with SP2, this parameter cannot be a handle to the <b>Security</b> log. To write an event to the <b>Security</b> log, use the <see cref="AuthzReportSecurityEvent" /> function.</para>
    </param>
    <param name="wType">
      <para>The type of event to be logged. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_SUCCESS</b>
                </description>
              </item>
              <item>
                <description>0x0000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Information event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_AUDIT_FAILURE</b>
                </description>
              </item>
              <item>
                <description>0x0010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Failure Audit event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_AUDIT_SUCCESS</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Success Audit event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_ERROR_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Error event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_INFORMATION_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Information event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_WARNING_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Warning event</para>
          </description>
        </item>
      </list>
      <para>For more information about event types, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-types">Event Types</a>.</para>
    </param>
    <param name="wCategory">
      <para>The event category. This is source-specific information; the category can have any value. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-categories">Event Categories</a>.</para>
    </param>
    <param name="dwEventID">
      <para>The event identifier. The event identifier specifies the entry in the message file associated with the event source. For more information, see <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-identifiers">Event Identifiers</a>.</para>
    </param>
    <param name="lpUserSid">
      <para>A pointer to the current user's security identifier. This parameter can be <b>NULL</b> if the security identifier is not required.</para>
    </param>
    <param name="wNumStrings">
      <para>The number of insert strings in the array pointed to by the <i>lpStrings</i> parameter. A value of zero indicates that no strings are present.</para>
    </param>
    <param name="dwDataSize">
      <para>The number of bytes of event-specific raw (binary) data to write to the log. If this parameter is zero, no event-specific data is present.</para>
    </param>
    <param name="lpStrings">
      <para>A pointer to a buffer containing an array of null-terminated strings that are merged into the message before Event Viewer displays the string to the user. This parameter must be a valid pointer (or <b>NULL</b>), even if <i>wNumStrings</i> is zero. Each string is limited to 31,839  characters.</para>
      <para>
        <b>Prior to Windows Vista:  </b>Each string is limited to 32K characters.</para>
    </param>
    <param name="lpRawData">
      <para>A pointer to the buffer containing the binary data. This parameter must be a valid pointer (or <b>NULL</b>), even if the <i>dwDataSize</i> parameter is zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero, indicating that the entry was written to the log.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />, which returns one of the following extended error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One of the parameters is not valid.</para>
            <para>This error is returned on Windows Server 2003 if the  message data to be logged is too large. This error is returned by the RPC server on Windows Server 2003 if the <i>dwDataSize</i> parameter is larger than 261,991 (0x3ff67).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Insufficient memory resources are available to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_S_INVALID_BOUND</b>
            </para>
          </description>
          <description>
            <para>The array bounds are invalid.</para>
            <para>This error is returned if the  message data to be logged is too large. On Windows Vista and later, this error is returned if the <i>dwDataSize</i> parameter is larger than 61,440 (0xf000).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_X_BAD_STUB_DATA</b>
            </para>
          </description>
          <description>
            <para>The stub received bad data.</para>
            <para>This error is returned on Windows XP if the  message data to be logged is too large. This error is returned by the RPC server on Windows XP, if the <i>dwDataSize</i> parameter is larger than 262,143 (0x3ffff).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function is used to log an event. The entry is written to the end of the configured log for the source identified by the <i>hEventLog</i> parameter. The
<b>ReportEvent</b> function adds the time, the entry's length, and the offsets before storing the entry in the log. To enable the function to add the user name, you must supply the user's SID in the <i>lpUserSid</i> parameter.</para>
      <para>There are different size limits on the size of the message data that can be logged depending on the version of Windows used by both the client where the application is run and the server where the message is logged. The server is determined by the <i>lpUNCServerName</i> parameter passed to the <see cref="RegisterEventSource" /> function. Different errors are returned when the size limit is exceeded that depend on the version of Windows.</para>
      <para>If the string that you log contains %<i>n</i>, where <i>n</i> is an integer value (for example, %1), the event viewer treats it as an insertion string. Because an IPv6 address can contain this character sequence, you must provide a format specifier (<i>!S!</i>) to log an event message that contains an IPv6 address. This specifier tells the formatting code to use the string literally and not perform any further expansions (for example, "my IPv6 address is: %1!S!").</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/reporting-an-event">Reporting an Event</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines ReportEvent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ClearEventLog" />
    <seealso cref="CloseEventLog" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-log-file-format">Event Log File Format</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
    <seealso cref="ReadEventLog" />
    <seealso cref="RegisterEventSource" />
  </member>
  <member name="Windows.ReportEventW">
    <summary>
      <para>Writes an entry at the end of the specified event log.</para>
    </summary>
    <param name="hEventLog">
      <para>A handle to the event log. The
<see cref="RegisterEventSource" /> function returns this handle.</para>
      <para>As of Windows XP with SP2, this parameter cannot be a handle to the <b>Security</b> log. To write an event to the <b>Security</b> log, use the <see cref="AuthzReportSecurityEvent" /> function.</para>
    </param>
    <param name="wType">
      <para>The type of event to be logged. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_SUCCESS</b>
                </description>
              </item>
              <item>
                <description>0x0000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Information event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_AUDIT_FAILURE</b>
                </description>
              </item>
              <item>
                <description>0x0010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Failure Audit event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_AUDIT_SUCCESS</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Success Audit event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_ERROR_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Error event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_INFORMATION_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>Information event</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EVENTLOG_WARNING_TYPE</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Warning event</para>
          </description>
        </item>
      </list>
      <para>For more information about event types, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-types">Event Types</a>.</para>
    </param>
    <param name="wCategory">
      <para>The event category. This is source-specific information; the category can have any value. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-categories">Event Categories</a>.</para>
    </param>
    <param name="dwEventID">
      <para>The event identifier. The event identifier specifies the entry in the message file associated with the event source. For more information, see <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-identifiers">Event Identifiers</a>.</para>
    </param>
    <param name="lpUserSid">
      <para>A pointer to the current user's security identifier. This parameter can be <b>NULL</b> if the security identifier is not required.</para>
    </param>
    <param name="wNumStrings">
      <para>The number of insert strings in the array pointed to by the <i>lpStrings</i> parameter. A value of zero indicates that no strings are present.</para>
    </param>
    <param name="dwDataSize">
      <para>The number of bytes of event-specific raw (binary) data to write to the log. If this parameter is zero, no event-specific data is present.</para>
    </param>
    <param name="lpStrings">
      <para>A pointer to a buffer containing an array of null-terminated strings that are merged into the message before Event Viewer displays the string to the user. This parameter must be a valid pointer (or <b>NULL</b>), even if <i>wNumStrings</i> is zero. Each string is limited to 31,839  characters.</para>
      <para>
        <b>Prior to Windows Vista:  </b>Each string is limited to 32K characters.</para>
    </param>
    <param name="lpRawData">
      <para>A pointer to the buffer containing the binary data. This parameter must be a valid pointer (or <b>NULL</b>), even if the <i>dwDataSize</i> parameter is zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero, indicating that the entry was written to the log.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />, which returns one of the following extended error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>One of the parameters is not valid.</para>
            <para>This error is returned on Windows Server 2003 if the  message data to be logged is too large. This error is returned by the RPC server on Windows Server 2003 if the <i>dwDataSize</i> parameter is larger than 261,991 (0x3ff67).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_NOT_ENOUGH_MEMORY</b>
            </para>
          </description>
          <description>
            <para>Insufficient memory resources are available to complete the operation.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_S_INVALID_BOUND</b>
            </para>
          </description>
          <description>
            <para>The array bounds are invalid.</para>
            <para>This error is returned if the  message data to be logged is too large. On Windows Vista and later, this error is returned if the <i>dwDataSize</i> parameter is larger than 61,440 (0xf000).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>RPC_X_BAD_STUB_DATA</b>
            </para>
          </description>
          <description>
            <para>The stub received bad data.</para>
            <para>This error is returned on Windows XP if the  message data to be logged is too large. This error is returned by the RPC server on Windows XP, if the <i>dwDataSize</i> parameter is larger than 262,143 (0x3ffff).</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>Other</b>
            </para>
          </description>
          <description>
            <para>Use
<see cref="FormatMessage" /> to obtain the message string for the returned error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function is used to log an event. The entry is written to the end of the configured log for the source identified by the <i>hEventLog</i> parameter. The
<b>ReportEvent</b> function adds the time, the entry's length, and the offsets before storing the entry in the log. To enable the function to add the user name, you must supply the user's SID in the <i>lpUserSid</i> parameter.</para>
      <para>There are different size limits on the size of the message data that can be logged depending on the version of Windows used by both the client where the application is run and the server where the message is logged. The server is determined by the <i>lpUNCServerName</i> parameter passed to the <see cref="RegisterEventSource" /> function. Different errors are returned when the size limit is exceeded that depend on the version of Windows.</para>
      <para>If the string that you log contains %<i>n</i>, where <i>n</i> is an integer value (for example, %1), the event viewer treats it as an insertion string. Because an IPv6 address can contain this character sequence, you must provide a format specifier (<i>!S!</i>) to log an event message that contains an IPv6 address. This specifier tells the formatting code to use the string literally and not perform any further expansions (for example, "my IPv6 address is: %1!S!").</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/EventLog/reporting-an-event">Reporting an Event</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines ReportEvent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="ClearEventLog" />
    <seealso cref="CloseEventLog" />
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-log-file-format">Event Log File Format</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/EventLog/event-logging-functions">Event Logging Functions</seealso>
    <seealso cref="OpenEventLog" />
    <seealso cref="ReadEventLog" />
    <seealso cref="RegisterEventSource" />
  </member>
  <member name="Windows.SetCommBreak">
    <summary>
      <para>Suspends character transmission for a specified communications device and places the transmission line in a break state until the
<see cref="ClearCommBreak" /> function is called.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the communications device. The
<see cref="CreateFile" /> function returns this handle.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="ClearCommBreak" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="CreateFile" />
  </member>
  <member name="Windows.SetCommConfig">
    <summary>
      <para>Sets the current configuration of a communications device.</para>
    </summary>
    <param name="hCommDev">
      <para>A handle to the open communications device. The
<see cref="CreateFile" /> function returns this handle.</para>
    </param>
    <param name="lpCC">
      <para>A pointer to a
<see cref="COMMCONFIG" /> structure.</para>
    </param>
    <param name="dwSize">
      <para>The size of the structure pointed to by <i>lpCC</i>, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="COMMCONFIG" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="CreateFile" />
    <seealso cref="GetCommConfig" />
  </member>
  <member name="Windows.SetCommMask">
    <summary>
      <para>Specifies a set of events to be monitored for a communications device.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the communications device. The
<see cref="CreateFile" /> function returns this handle.</para>
    </param>
    <param name="dwEvtMask">
      <para>The events to be enabled. A value of zero disables all events. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_BREAK</b>
                </description>
              </item>
              <item>
                <description>0x0040</description>
              </item>
            </list>
          </description>
          <description>
            <para>A break was detected on input.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_CTS</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The CTS (clear-to-send) signal changed state.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_DSR</b>
                </description>
              </item>
              <item>
                <description>0x0010</description>
              </item>
            </list>
          </description>
          <description>
            <para>The DSR (data-set-ready) signal changed state.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_ERR</b>
                </description>
              </item>
              <item>
                <description>0x0080</description>
              </item>
            </list>
          </description>
          <description>
            <para>A line-status error occurred. Line-status errors are <b>CE_FRAME</b>, <b>CE_OVERRUN</b>, and <b>CE_RXPARITY</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_RING</b>
                </description>
              </item>
              <item>
                <description>0x0100</description>
              </item>
            </list>
          </description>
          <description>
            <para>A ring indicator was detected.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_RLSD</b>
                </description>
              </item>
              <item>
                <description>0x0020</description>
              </item>
            </list>
          </description>
          <description>
            <para>The RLSD (receive-line-signal-detect) signal changed state.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_RXCHAR</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>A character was received and placed in the input buffer.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_RXFLAG</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The event character was received and placed in the input buffer. The event character is specified in the device's
<see cref="DCB" /> structure, which is applied to a serial port by using the
<see cref="SetCommState" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_TXEMPTY</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The last character in the output buffer was sent.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>SetCommMask</b> function specifies the set of events that can be monitored for a particular communications resource. A handle to the communications resource can be specified in a call to the
<see cref="WaitCommEvent" /> function, which waits for one of the events to occur. To get the current event mask of a communications resource, use the
<see cref="GetCommMask" /> function.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/DevIO/monitoring-communications-events">Monitoring Communications Events</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="CreateFile" />
    <seealso cref="DCB" />
    <seealso cref="GetCommMask" />
    <seealso cref="SetCommState" />
    <seealso cref="WaitCommEvent" />
  </member>
  <member name="Windows.SetCommState">
    <summary>
      <para>Configures a communications device according to the specifications in a device-control block (a
<see cref="DCB" /> structure). The function reinitializes all hardware and control settings, but it does not empty output or input queues.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the communications device. The
<see cref="CreateFile" /> function returns this handle.</para>
    </param>
    <param name="lpDCB">
      <para>A pointer to a
<see cref="DCB" /> structure that contains the configuration information for the specified communications device.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>SetCommState</b> function uses a
<see cref="DCB" /> structure to specify the desired configuration. The
<see cref="GetCommState" /> function returns the current configuration.</para>
      <para>To set only a few members of the
<see cref="DCB" /> structure, you should modify a
<b>DCB</b> structure that has been filled in by a call to
<see cref="GetCommState" />. This ensures that the other members of the
<b>DCB</b> structure have appropriate values.</para>
      <para>The
<b>SetCommState</b> function fails if the <b>XonChar</b> member of the
<see cref="DCB" /> structure is equal to the <b>XoffChar</b> member.</para>
      <para>When
<b>SetCommState</b> is used to configure the 8250, the following restrictions apply to the values for the
<see cref="DCB" /> structure's <b>ByteSize</b> and <b>StopBits</b> members:</para>
      <para>The number of data bits must be 5 to 8 bits.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/DevIO/configuring-a-communications-resource">Configuring a Communications Resource</a>.</para>
    </remarks>
    <seealso cref="BuildCommDCB" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="CreateFile" />
    <seealso cref="DCB" />
    <seealso cref="GetCommState" />
  </member>
  <member name="Windows.SetCommTimeouts">
    <summary>
      <para>Sets the time-out parameters for all read and write operations on a specified communications device.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the communications device. The
<see cref="CreateFile" /> function returns this handle.</para>
    </param>
    <param name="lpCommTimeouts">
      <para>A pointer to a
<see cref="COMMTIMEOUTS" /> structure that contains the new time-out values.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <seealso cref="COMMTIMEOUTS" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="GetCommTimeouts" />
    <seealso cref="ReadFile" />
    <seealso cref="ReadFileEx" />
    <seealso cref="WriteFile" />
    <seealso cref="WriteFileEx" />
  </member>
  <member name="Windows.SetCurrentDirectory">
    <summary>
      <para>Changes the current directory for the current process.</para>
    </summary>
    <param name="lpPathName">
      <para>The path to the new current directory. This parameter may specify a relative path or a full path. In either case, the full path of the specified directory is calculated and stored as the current directory.</para>
      <para>For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.</para>
      <para>The final character before the null character must be a backslash ('\'). If you do not specify the backslash, it will be added for you; therefore, specify <b>MAX_PATH</b>-2 characters for the path unless you  include the trailing backslash, in which case, specify <b>MAX_PATH</b>-1 characters for the path.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>SetCurrentDirectoryW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Each process has a single current directory made up of two parts:</para>
      <list type="bullet">
        <item>
          <description>A disk designator that is either a drive letter followed by a colon, or a server name and share name (\\<i>servername</i>\<i>sharename</i>)</description>
        </item>
        <item>
          <description>A directory on the disk designator</description>
        </item>
      </list>
      <para>The current directory is shared by all threads of the process:
If one thread changes the current directory, it affects all threads
in the process.
Multithreaded applications and shared library code should avoid
calling the <b>SetCurrentDirectory</b> function due to the risk of
affecting relative path calculations being performed by other threads.
Conversely,
multithreaded applications and shared library code should avoid
using relative paths so that they are unaffected by changes to the
current directory performed by other threads.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/changing-the-current-directory">Changing the Current Directory</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="GetCurrentDirectory" />
    <seealso cref="GetFullPathName" />
  </member>
  <member name="Windows.SetCurrentDirectoryA">
    <summary>
      <para>Changes the current directory for the current process.</para>
    </summary>
    <param name="lpPathName">
      <para>The path to the new current directory. This parameter may specify a relative path or a full path. In either case, the full path of the specified directory is calculated and stored as the current directory.</para>
      <para>For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.</para>
      <para>The final character before the null character must be a backslash ('\'). If you do not specify the backslash, it will be added for you; therefore, specify <b>MAX_PATH</b>-2 characters for the path unless you  include the trailing backslash, in which case, specify <b>MAX_PATH</b>-1 characters for the path.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>SetCurrentDirectoryW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Each process has a single current directory made up of two parts:</para>
      <list type="bullet">
        <item>
          <description>A disk designator that is either a drive letter followed by a colon, or a server name and share name (\\<i>servername</i>\<i>sharename</i>)</description>
        </item>
        <item>
          <description>A directory on the disk designator</description>
        </item>
      </list>
      <para>The current directory is shared by all threads of the process:
If one thread changes the current directory, it affects all threads
in the process.
Multithreaded applications and shared library code should avoid
calling the <b>SetCurrentDirectory</b> function due to the risk of
affecting relative path calculations being performed by other threads.
Conversely,
multithreaded applications and shared library code should avoid
using relative paths so that they are unaffected by changes to the
current directory performed by other threads.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/changing-the-current-directory">Changing the Current Directory</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="GetCurrentDirectory" />
    <seealso cref="GetFullPathName" />
  </member>
  <member name="Windows.SetCurrentDirectoryW">
    <summary>
      <para>Changes the current directory for the current process.</para>
    </summary>
    <param name="lpPathName">
      <para>The path to the new current directory. This parameter may specify a relative path or a full path. In either case, the full path of the specified directory is calculated and stored as the current directory.</para>
      <para>For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters.</para>
      <para>The final character before the null character must be a backslash ('\'). If you do not specify the backslash, it will be added for you; therefore, specify <b>MAX_PATH</b>-2 characters for the path unless you  include the trailing backslash, in which case, specify <b>MAX_PATH</b>-1 characters for the path.</para>
      <para>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>SetCurrentDirectoryW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>Each process has a single current directory made up of two parts:</para>
      <list type="bullet">
        <item>
          <description>A disk designator that is either a drive letter followed by a colon, or a server name and share name (\\<i>servername</i>\<i>sharename</i>)</description>
        </item>
        <item>
          <description>A directory on the disk designator</description>
        </item>
      </list>
      <para>The current directory is shared by all threads of the process:
If one thread changes the current directory, it affects all threads
in the process.
Multithreaded applications and shared library code should avoid
calling the <b>SetCurrentDirectory</b> function due to the risk of
affecting relative path calculations being performed by other threads.
Conversely,
multithreaded applications and shared library code should avoid
using relative paths so that they are unaffected by changes to the
current directory performed by other threads.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/changing-the-current-directory">Changing the Current Directory</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/directory-management-functions">Directory Management Functions</seealso>
    <seealso cref="GetCurrentDirectory" />
    <seealso cref="GetFullPathName" />
  </member>
  <member name="Windows.SetDefaultCommConfig">
    <summary>
      <para>Sets the default configuration for a communications device.</para>
    </summary>
    <param name="lpszName">
      <para>The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</para>
    </param>
    <param name="lpCC">
      <para>A pointer to a
<see cref="COMMCONFIG" /> structure.</para>
    </param>
    <param name="dwSize">
      <para>The size of the structure pointed to by <i>lpCC</i>, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetDefaultCommConfig as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMMCONFIG" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="GetDefaultCommConfig" />
  </member>
  <member name="Windows.SetDefaultCommConfigA">
    <summary>
      <para>Sets the default configuration for a communications device.</para>
    </summary>
    <param name="lpszName">
      <para>The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</para>
    </param>
    <param name="lpCC">
      <para>A pointer to a
<see cref="COMMCONFIG" /> structure.</para>
    </param>
    <param name="dwSize">
      <para>The size of the structure pointed to by <i>lpCC</i>, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetDefaultCommConfig as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMMCONFIG" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="GetDefaultCommConfig" />
  </member>
  <member name="Windows.SetDefaultCommConfigW">
    <summary>
      <para>Sets the default configuration for a communications device.</para>
    </summary>
    <param name="lpszName">
      <para>The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</para>
    </param>
    <param name="lpCC">
      <para>A pointer to a
<see cref="COMMCONFIG" /> structure.</para>
    </param>
    <param name="dwSize">
      <para>The size of the structure pointed to by <i>lpCC</i>, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetDefaultCommConfig as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMMCONFIG" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="GetDefaultCommConfig" />
  </member>
  <member name="Windows.SetDefaultCommConfig">
    <summary>
      <para>Sets the default configuration for a communications device.</para>
    </summary>
    <param name="lpszName">
      <para>The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</para>
    </param>
    <param name="lpCC">
      <para>A pointer to a
<see cref="COMMCONFIG" /> structure.</para>
    </param>
    <param name="dwSize">
      <para>The size of the structure pointed to by <i>lpCC</i>, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetDefaultCommConfig as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMMCONFIG" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="GetDefaultCommConfig" />
  </member>
  <member name="Windows.SetDefaultCommConfigA">
    <summary>
      <para>Sets the default configuration for a communications device.</para>
    </summary>
    <param name="lpszName">
      <para>The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</para>
    </param>
    <param name="lpCC">
      <para>A pointer to a
<see cref="COMMCONFIG" /> structure.</para>
    </param>
    <param name="dwSize">
      <para>The size of the structure pointed to by <i>lpCC</i>, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetDefaultCommConfig as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMMCONFIG" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="GetDefaultCommConfig" />
  </member>
  <member name="Windows.SetDefaultCommConfigW">
    <summary>
      <para>Sets the default configuration for a communications device.</para>
    </summary>
    <param name="lpszName">
      <para>The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</para>
    </param>
    <param name="lpCC">
      <para>A pointer to a
<see cref="COMMCONFIG" /> structure.</para>
    </param>
    <param name="dwSize">
      <para>The size of the structure pointed to by <i>lpCC</i>, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetDefaultCommConfig as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="COMMCONFIG" />
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="GetDefaultCommConfig" />
  </member>
  <member name="Windows.SetDllDirectory">
    <summary>
      <para>Adds a directory to the search path used to locate DLLs for the application.</para>
    </summary>
    <param name="lpPathName">
      <para>The directory to be added to the search path. If this parameter is an empty string (""), the call removes the current directory from the default DLL search order. If this parameter is NULL, the function restores the default search order.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>SetDllDirectory</b> function affects all subsequent calls to the
<see cref="LoadLibrary" /> and
<see cref="LoadLibraryEx" /> functions. It also effectively disables safe DLL search mode while the specified directory is in the search path.</para>
      <blockquote>
        <para>[!NOTE]
For Win32 processes that are <b>not</b> running a packaged or protected process, calling this function will also affect the DLL search order of the children processes started from the process that has called the function.</para>
      </blockquote>
      <para>After calling
<b>SetDllDirectory</b>, the standard DLL search path is:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The directory specified by the <i>lpPathName</i> parameter.</description>
        </item>
        <item>
          <description>The system directory. Use the
<see cref="GetSystemDirectory" /> function to get the path of this directory. The name of this directory is System32.</description>
        </item>
        <item>
          <description>The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</description>
        </item>
        <item>
          <description>The Windows directory. Use the
<see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable.</description>
        </item>
      </list>
      <para>Each time the <b>SetDllDirectory</b> function is called, it replaces the directory specified in the previous <b>SetDllDirectory</b> call. To specify more than one directory, use the <see cref="AddDllDirectory" /> function and call <see cref="LoadLibraryEx" /> with LOAD_LIBRARY_SEARCH_USER_DIRS.</para>
      <para>To revert to the standard search path used by
<see cref="LoadLibrary" /> and
<see cref="LoadLibraryEx" />, call
<b>SetDllDirectory</b> with NULL. This also restores safe DLL search mode  based on the <b>SafeDllSearchMode</b> registry value.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0502 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetDllDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddDllDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</seealso>
    <seealso cref="GetDllDirectory" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.SetDllDirectoryA">
    <summary>
      <para>Adds a directory to the search path used to locate DLLs for the application.</para>
    </summary>
    <param name="lpPathName">
      <para>The directory to be added to the search path. If this parameter is an empty string (""), the call removes the current directory from the default DLL search order. If this parameter is NULL, the function restores the default search order.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>SetDllDirectory</b> function affects all subsequent calls to the
<see cref="LoadLibrary" /> and
<see cref="LoadLibraryEx" /> functions. It also effectively disables safe DLL search mode while the specified directory is in the search path.</para>
      <blockquote>
        <para>[!NOTE]
For Win32 processes that are <b>not</b> running a packaged or protected process, calling this function will also affect the DLL search order of the children processes started from the process that has called the function.</para>
      </blockquote>
      <para>After calling
<b>SetDllDirectory</b>, the standard DLL search path is:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The directory specified by the <i>lpPathName</i> parameter.</description>
        </item>
        <item>
          <description>The system directory. Use the
<see cref="GetSystemDirectory" /> function to get the path of this directory. The name of this directory is System32.</description>
        </item>
        <item>
          <description>The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</description>
        </item>
        <item>
          <description>The Windows directory. Use the
<see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable.</description>
        </item>
      </list>
      <para>Each time the <b>SetDllDirectory</b> function is called, it replaces the directory specified in the previous <b>SetDllDirectory</b> call. To specify more than one directory, use the <see cref="AddDllDirectory" /> function and call <see cref="LoadLibraryEx" /> with LOAD_LIBRARY_SEARCH_USER_DIRS.</para>
      <para>To revert to the standard search path used by
<see cref="LoadLibrary" /> and
<see cref="LoadLibraryEx" />, call
<b>SetDllDirectory</b> with NULL. This also restores safe DLL search mode  based on the <b>SafeDllSearchMode</b> registry value.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0502 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetDllDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddDllDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</seealso>
    <seealso cref="GetDllDirectory" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.SetDllDirectoryW">
    <summary>
      <para>Adds a directory to the search path used to locate DLLs for the application.</para>
    </summary>
    <param name="lpPathName">
      <para>The directory to be added to the search path. If this parameter is an empty string (""), the call removes the current directory from the default DLL search order. If this parameter is NULL, the function restores the default search order.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>SetDllDirectory</b> function affects all subsequent calls to the
<see cref="LoadLibrary" /> and
<see cref="LoadLibraryEx" /> functions. It also effectively disables safe DLL search mode while the specified directory is in the search path.</para>
      <blockquote>
        <para>[!NOTE]
For Win32 processes that are <b>not</b> running a packaged or protected process, calling this function will also affect the DLL search order of the children processes started from the process that has called the function.</para>
      </blockquote>
      <para>After calling
<b>SetDllDirectory</b>, the standard DLL search path is:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The directory specified by the <i>lpPathName</i> parameter.</description>
        </item>
        <item>
          <description>The system directory. Use the
<see cref="GetSystemDirectory" /> function to get the path of this directory. The name of this directory is System32.</description>
        </item>
        <item>
          <description>The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</description>
        </item>
        <item>
          <description>The Windows directory. Use the
<see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable.</description>
        </item>
      </list>
      <para>Each time the <b>SetDllDirectory</b> function is called, it replaces the directory specified in the previous <b>SetDllDirectory</b> call. To specify more than one directory, use the <see cref="AddDllDirectory" /> function and call <see cref="LoadLibraryEx" /> with LOAD_LIBRARY_SEARCH_USER_DIRS.</para>
      <para>To revert to the standard search path used by
<see cref="LoadLibrary" /> and
<see cref="LoadLibraryEx" />, call
<b>SetDllDirectory</b> with NULL. This also restores safe DLL search mode  based on the <b>SafeDllSearchMode</b> registry value.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0502 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetDllDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddDllDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</seealso>
    <seealso cref="GetDllDirectory" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.SetDllDirectory">
    <summary>
      <para>Adds a directory to the search path used to locate DLLs for the application.</para>
    </summary>
    <param name="lpPathName">
      <para>The directory to be added to the search path. If this parameter is an empty string (""), the call removes the current directory from the default DLL search order. If this parameter is NULL, the function restores the default search order.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>SetDllDirectory</b> function affects all subsequent calls to the
<see cref="LoadLibrary" /> and
<see cref="LoadLibraryEx" /> functions. It also effectively disables safe DLL search mode while the specified directory is in the search path.</para>
      <blockquote>
        <para>[!NOTE]
For Win32 processes that are <b>not</b> running a packaged or protected process, calling this function will also affect the DLL search order of the children processes started from the process that has called the function.</para>
      </blockquote>
      <para>After calling
<b>SetDllDirectory</b>, the standard DLL search path is:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The directory specified by the <i>lpPathName</i> parameter.</description>
        </item>
        <item>
          <description>The system directory. Use the
<see cref="GetSystemDirectory" /> function to get the path of this directory. The name of this directory is System32.</description>
        </item>
        <item>
          <description>The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</description>
        </item>
        <item>
          <description>The Windows directory. Use the
<see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable.</description>
        </item>
      </list>
      <para>Each time the <b>SetDllDirectory</b> function is called, it replaces the directory specified in the previous <b>SetDllDirectory</b> call. To specify more than one directory, use the <see cref="AddDllDirectory" /> function and call <see cref="LoadLibraryEx" /> with LOAD_LIBRARY_SEARCH_USER_DIRS.</para>
      <para>To revert to the standard search path used by
<see cref="LoadLibrary" /> and
<see cref="LoadLibraryEx" />, call
<b>SetDllDirectory</b> with NULL. This also restores safe DLL search mode  based on the <b>SafeDllSearchMode</b> registry value.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0502 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetDllDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddDllDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</seealso>
    <seealso cref="GetDllDirectory" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.SetDllDirectoryA">
    <summary>
      <para>Adds a directory to the search path used to locate DLLs for the application.</para>
    </summary>
    <param name="lpPathName">
      <para>The directory to be added to the search path. If this parameter is an empty string (""), the call removes the current directory from the default DLL search order. If this parameter is NULL, the function restores the default search order.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>SetDllDirectory</b> function affects all subsequent calls to the
<see cref="LoadLibrary" /> and
<see cref="LoadLibraryEx" /> functions. It also effectively disables safe DLL search mode while the specified directory is in the search path.</para>
      <blockquote>
        <para>[!NOTE]
For Win32 processes that are <b>not</b> running a packaged or protected process, calling this function will also affect the DLL search order of the children processes started from the process that has called the function.</para>
      </blockquote>
      <para>After calling
<b>SetDllDirectory</b>, the standard DLL search path is:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The directory specified by the <i>lpPathName</i> parameter.</description>
        </item>
        <item>
          <description>The system directory. Use the
<see cref="GetSystemDirectory" /> function to get the path of this directory. The name of this directory is System32.</description>
        </item>
        <item>
          <description>The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</description>
        </item>
        <item>
          <description>The Windows directory. Use the
<see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable.</description>
        </item>
      </list>
      <para>Each time the <b>SetDllDirectory</b> function is called, it replaces the directory specified in the previous <b>SetDllDirectory</b> call. To specify more than one directory, use the <see cref="AddDllDirectory" /> function and call <see cref="LoadLibraryEx" /> with LOAD_LIBRARY_SEARCH_USER_DIRS.</para>
      <para>To revert to the standard search path used by
<see cref="LoadLibrary" /> and
<see cref="LoadLibraryEx" />, call
<b>SetDllDirectory</b> with NULL. This also restores safe DLL search mode  based on the <b>SafeDllSearchMode</b> registry value.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0502 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetDllDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddDllDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</seealso>
    <seealso cref="GetDllDirectory" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.SetDllDirectoryW">
    <summary>
      <para>Adds a directory to the search path used to locate DLLs for the application.</para>
    </summary>
    <param name="lpPathName">
      <para>The directory to be added to the search path. If this parameter is an empty string (""), the call removes the current directory from the default DLL search order. If this parameter is NULL, the function restores the default search order.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>SetDllDirectory</b> function affects all subsequent calls to the
<see cref="LoadLibrary" /> and
<see cref="LoadLibraryEx" /> functions. It also effectively disables safe DLL search mode while the specified directory is in the search path.</para>
      <blockquote>
        <para>[!NOTE]
For Win32 processes that are <b>not</b> running a packaged or protected process, calling this function will also affect the DLL search order of the children processes started from the process that has called the function.</para>
      </blockquote>
      <para>After calling
<b>SetDllDirectory</b>, the standard DLL search path is:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The directory specified by the <i>lpPathName</i> parameter.</description>
        </item>
        <item>
          <description>The system directory. Use the
<see cref="GetSystemDirectory" /> function to get the path of this directory. The name of this directory is System32.</description>
        </item>
        <item>
          <description>The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</description>
        </item>
        <item>
          <description>The Windows directory. Use the
<see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable.</description>
        </item>
      </list>
      <para>Each time the <b>SetDllDirectory</b> function is called, it replaces the directory specified in the previous <b>SetDllDirectory</b> call. To specify more than one directory, use the <see cref="AddDllDirectory" /> function and call <see cref="LoadLibraryEx" /> with LOAD_LIBRARY_SEARCH_USER_DIRS.</para>
      <para>To revert to the standard search path used by
<see cref="LoadLibrary" /> and
<see cref="LoadLibraryEx" />, call
<b>SetDllDirectory</b> with NULL. This also restores safe DLL search mode  based on the <b>SafeDllSearchMode</b> registry value.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0502 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetDllDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="AddDllDirectory" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</seealso>
    <seealso cref="GetDllDirectory" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="GetWindowsDirectory" />
    <seealso cref="LoadLibrary" />
    <seealso cref="LoadLibraryEx" />
  </member>
  <member name="Windows.SetEnvironmentVariable">
    <summary>
      <para>Sets the contents of the specified environment variable for the current process.</para>
    </summary>
    <param name="lpName">
      <para>The name of the environment variable. The operating system creates the environment variable if it does not exist and <i>lpValue</i> is not NULL.</para>
    </param>
    <param name="lpValue">
      <para>The contents of the environment variable. The maximum size of a user-defined environment variable is 32,767 characters. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/environment-variables">Environment Variables</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The total size of the environment block for a process may not exceed 32,767 characters.</para>
      <para>If this parameter is NULL, the variable is deleted from the current process's environment.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function has no effect on the system environment variables or the environment variables of other processes.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/changing-environment-variables">Changing Environment Variables</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/environment-variables">Environment Variables</seealso>
    <seealso cref="GetEnvironmentVariable" />
  </member>
  <member name="Windows.SetEnvironmentVariableA">
    <summary>
      <para>Sets the contents of the specified environment variable for the current process.</para>
    </summary>
    <param name="lpName">
      <para>The name of the environment variable. The operating system creates the environment variable if it does not exist and <i>lpValue</i> is not NULL.</para>
    </param>
    <param name="lpValue">
      <para>The contents of the environment variable. The maximum size of a user-defined environment variable is 32,767 characters. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/environment-variables">Environment Variables</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The total size of the environment block for a process may not exceed 32,767 characters.</para>
      <para>If this parameter is NULL, the variable is deleted from the current process's environment.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function has no effect on the system environment variables or the environment variables of other processes.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/changing-environment-variables">Changing Environment Variables</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/environment-variables">Environment Variables</seealso>
    <seealso cref="GetEnvironmentVariable" />
  </member>
  <member name="Windows.SetEnvironmentVariableW">
    <summary>
      <para>Sets the contents of the specified environment variable for the current process.</para>
    </summary>
    <param name="lpName">
      <para>The name of the environment variable. The operating system creates the environment variable if it does not exist and <i>lpValue</i> is not NULL.</para>
    </param>
    <param name="lpValue">
      <para>The contents of the environment variable. The maximum size of a user-defined environment variable is 32,767 characters. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/environment-variables">Environment Variables</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The total size of the environment block for a process may not exceed 32,767 characters.</para>
      <para>If this parameter is NULL, the variable is deleted from the current process's environment.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function has no effect on the system environment variables or the environment variables of other processes.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/changing-environment-variables">Changing Environment Variables</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/environment-variables">Environment Variables</seealso>
    <seealso cref="GetEnvironmentVariable" />
  </member>
  <member name="Windows.SetFileBandwidthReservation">
    <summary>
      <para>Requests that bandwidth for the specified file stream be reserved. The reservation is specified as a
number of bytes in a period of milliseconds for I/O requests on the specified  file handle.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file.</para>
    </param>
    <param name="nPeriodMilliseconds">
      <para>The period of the reservation, in milliseconds. The period is the time from which the I/O is issued to the
kernel until the time the I/O should be completed. The minimum supported value for the file
stream can be determined by looking at the value returned through the
<i>lpPeriodMilliseconds</i> parameter to the
<see cref="GetFileBandwidthReservation" /> function,
on a handle that has not had a bandwidth reservation set.</para>
    </param>
    <param name="nBytesPerPeriod">
      <para>The bandwidth to reserve, in bytes per period. The maximum supported value for the file
stream can be determined by looking at the value returned through the
<i>lpBytesPerPeriod</i> parameter to the
<see cref="GetFileBandwidthReservation" /> function,
on a handle that has not had a bandwidth reservation set.</para>
    </param>
    <param name="bDiscardable">
      <para>Indicates whether I/O should be completed with an error if a driver is unable to satisfy an I/O operation
before the period expires. If one of the drivers for the specified file stream does not support this
functionality, this function may return success and ignore the flag. To verify whether the setting will be
honored, call the
<see cref="GetFileBandwidthReservation" /> function
using the same <i>hFile</i> handle and examine the <i>*pDiscardable</i></para>
      <para>return value.</para>
    </param>
    <param name="lpTransferSize">
      <para>A pointer to a variable that receives the minimum size of any individual I/O request that may be issued by
the application. All I/O requests should be multiples of <i>TransferSize</i>.</para>
    </param>
    <param name="lpNumOutstandingRequests">
      <para>A pointer to a variable that receives the number of <i>TransferSize</i> chunks the
application should allow to be outstanding with the operating system. This allows the storage stack to keep the
device busy and allows maximum throughput.</para>
    </param>
    <returns>
      <para>Returns nonzero if successful or zero otherwise.</para>
      <para>A reservation can fail if there is not enough bandwidth available on the volume because of existing
reservations; in this case <b>ERROR_NO_SYSTEM_RESOURCES</b> is returned.</para>
      <para>To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The requested bandwidth reservation must be greater than or equal to one packet per period. The minimum period,
in milliseconds, maximum bytes per period, and minimum transfer size, in bytes, for a specific volume are
returned through the <i>lpPeriodMilliseconds</i>, <i>lpBytesPerPeriod</i>,
and  <i>lpTransferSize</i> parameters to
<see cref="GetFileBandwidthReservation" /> on a
handle that has not been used in a call to
<b>SetFileBandwidthReservation</b>. In other
words:</para>
      <para>1 ≤ (<i>nBytesPerPeriod</i>)×(<i><i>lpPeriodMilliseconds</i>)/(</i><i>lpTransferSize</i>)/(<i>nPeriodMilliseconds</i>)</para>
      <para>IIn Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetFileBandwidthReservation" />
  </member>
  <member name="Windows.SetFileCompletionNotificationModes">
    <summary>
      <para>Sets the  notification modes for a file handle, allowing you to  specify how completion notifications
work for the specified file.</para>
    </summary>
    <param name="FileHandle">
      <para>A handle to the file.</para>
    </param>
    <param name="Flags">
      <para>The modes to be set.  One or more modes can be set at the same time; however, after a mode has been set for
a file handle, it cannot be removed.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SKIP_COMPLETION_PORT_ON_SUCCESS</b>
                </description>
              </item>
              <item>
                <description>0x1</description>
              </item>
            </list>
          </description>
          <description>
            <para>If the following three conditions are true, the I/O Manager does not queue a completion entry to the port,
when it would ordinarily do so. The conditions are:</para>
            <list type="bullet">
              <item>
                <description>A completion port is associated with the file handle.</description>
              </item>
              <item>
                <description>The file is opened for asynchronous I/O.</description>
              </item>
              <item>
                <description>A request returns success immediately without returning
<b>ERROR_PENDING</b>.</description>
              </item>
            </list>
            <para>When the <i>FileHandle</i> parameter is a socket, this mode is only compatible with
Layered Service Providers (LSP) that return Installable File Systems (IFS) handles. To detect whether a
non-IFS LSP is installed, use the
<see cref="WSAEnumProtocols" /> function and examine the
<b>dwServiceFlag1</b> member in each returned
<see cref="WSAPROTOCOL_INFO" /> structure. If the
<b>XP1_IFS_HANDLES</b> (0x20000) bit is cleared then the specified LSP is not an IFS LSP.
Vendors that have non-IFS LSPs are encouraged to migrate to the
<a href="https://docs.microsoft.com//windows/desktop/FWP/windows-filtering-platform-start-page">Windows Filtering Platform</a></para>
            <para>(WFP).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>FILE_SKIP_SET_EVENT_ON_HANDLE</b>
                </description>
              </item>
              <item>
                <description>0x2</description>
              </item>
            </list>
          </description>
          <description>
            <para>The I/O Manager does not set the event for the file object if a request returns with a success code, or the
error returned is <b>ERROR_PENDING</b> and the function that is called is not a
synchronous function.</para>
            <para>If an explicit event is provided for the request, it is still signaled.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>Returns nonzero if successful or zero otherwise.</para>
      <para>To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>To compile an application that uses this function, define the <b>_WIN32_WINNT</b> macro
as 0x0600 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
  </member>
  <member name="Windows.SetFileSecurity">
    <summary>
      <para>The <b>SetFileSecurity</b> function sets the security of a file or directory object.</para>
      <para>This function is obsolete. Use the <see cref="SetNamedSecurityInfo" /> function instead.</para>
    </summary>
    <param name="lpFileName">
      <para>A pointer to a null-terminated string that specifies the file or directory for which security is set. Note that security applied to a directory is not inherited by its children.</para>
    </param>
    <param name="SecurityInformation">
      <para>Specifies a
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</a> structure that identifies the contents of the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> pointed to by the <i>pSecurityDescriptor</i> parameter.</para>
    </param>
    <param name="pSecurityDescriptor">
      <para>A pointer to a
<see cref="SECURITY_DESCRIPTOR" /> structure.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>SetFileSecurity</b> function is successful only if the following conditions are met:</para>
      <list type="bullet">
        <item>
          <description>If the owner of the object is being set, the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> must have either WRITE_OWNER permission or be the owner of the object.</description>
        </item>
        <item>
          <description>If the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/d-gly">discretionary access control list</a> (DACL) of the object is being set, the calling process must have either WRITE_DAC permission or be the owner of the object.</description>
        </item>
        <item>
          <description>If the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) of the object is being set, the SE_SECURITY_NAME privilege must be enabled for the calling process.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="GetFileSecurity" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/low-level-access-control">Low-level Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Low-level Access Control Functions</seealso>
    <seealso cref="SECURITY_DESCRIPTOR" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</seealso>
    <seealso cref="SetKernelObjectSecurity" />
    <seealso cref="SetNamedSecurityInfo" />
    <seealso cref="SetPrivateObjectSecurity" />
    <seealso cref="SetUserObjectSecurity" />
  </member>
  <member name="Windows.SetFileSecurityA">
    <summary>
      <para>The <b>SetFileSecurity</b> function sets the security of a file or directory object.</para>
      <para>This function is obsolete. Use the <see cref="SetNamedSecurityInfo" /> function instead.</para>
    </summary>
    <param name="lpFileName">
      <para>A pointer to a null-terminated string that specifies the file or directory for which security is set. Note that security applied to a directory is not inherited by its children.</para>
    </param>
    <param name="SecurityInformation">
      <para>Specifies a
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</a> structure that identifies the contents of the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> pointed to by the <i>pSecurityDescriptor</i> parameter.</para>
    </param>
    <param name="pSecurityDescriptor">
      <para>A pointer to a
<see cref="SECURITY_DESCRIPTOR" /> structure.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>SetFileSecurity</b> function is successful only if the following conditions are met:</para>
      <list type="bullet">
        <item>
          <description>If the owner of the object is being set, the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> must have either WRITE_OWNER permission or be the owner of the object.</description>
        </item>
        <item>
          <description>If the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/d-gly">discretionary access control list</a> (DACL) of the object is being set, the calling process must have either WRITE_DAC permission or be the owner of the object.</description>
        </item>
        <item>
          <description>If the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) of the object is being set, the SE_SECURITY_NAME privilege must be enabled for the calling process.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="GetFileSecurity" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/low-level-access-control">Low-level Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Low-level Access Control Functions</seealso>
    <seealso cref="SECURITY_DESCRIPTOR" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</seealso>
    <seealso cref="SetKernelObjectSecurity" />
    <seealso cref="SetNamedSecurityInfo" />
    <seealso cref="SetPrivateObjectSecurity" />
    <seealso cref="SetUserObjectSecurity" />
  </member>
  <member name="Windows.SetFileSecurityW">
    <summary>
      <para>The <b>SetFileSecurity</b> function sets the security of a file or directory object.</para>
      <para>This function is obsolete. Use the <see cref="SetNamedSecurityInfo" /> function instead.</para>
    </summary>
    <param name="lpFileName">
      <para>A pointer to a null-terminated string that specifies the file or directory for which security is set. Note that security applied to a directory is not inherited by its children.</para>
    </param>
    <param name="SecurityInformation">
      <para>Specifies a
<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</a> structure that identifies the contents of the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> pointed to by the <i>pSecurityDescriptor</i> parameter.</para>
    </param>
    <param name="pSecurityDescriptor">
      <para>A pointer to a
<see cref="SECURITY_DESCRIPTOR" /> structure.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>SetFileSecurity</b> function is successful only if the following conditions are met:</para>
      <list type="bullet">
        <item>
          <description>If the owner of the object is being set, the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> must have either WRITE_OWNER permission or be the owner of the object.</description>
        </item>
        <item>
          <description>If the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/d-gly">discretionary access control list</a> (DACL) of the object is being set, the calling process must have either WRITE_DAC permission or be the owner of the object.</description>
        </item>
        <item>
          <description>If the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) of the object is being set, the SE_SECURITY_NAME privilege must be enabled for the calling process.</description>
        </item>
      </list>
    </remarks>
    <seealso cref="GetFileSecurity" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/low-level-access-control">Low-level Access Control</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-functions">Low-level Access Control Functions</seealso>
    <seealso cref="SECURITY_DESCRIPTOR" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</seealso>
    <seealso cref="SetKernelObjectSecurity" />
    <seealso cref="SetNamedSecurityInfo" />
    <seealso cref="SetPrivateObjectSecurity" />
    <seealso cref="SetUserObjectSecurity" />
  </member>
  <member name="Windows.SetFileShortName">
    <summary>
      <para>Sets the short name for the specified file. The file must be on an NTFS file system
volume.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file. The file must be opened with either the <b>GENERIC_ALL</b> access
right or <b>GENERIC_WRITE</b>|<b>DELETE</b>, and with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> file attribute.</para>
    </param>
    <param name="lpShortName">
      <para>A pointer to a string that specifies the short name for the file.</para>
      <para>Specifying  an empty (zero-length) string will remove the short file name, if it exists for the file specified by the <i>hFile</i> parameter. If  a short file name does not exist, the function will do nothing and return success.</para>
      <para>
        <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This behavior is not supported. The parameter must contain a valid string of one or more characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.
<b>GetLastError</b> may return one of the following error
codes that are specific to this function.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified short name is not unique.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>Either the specified file has been opened in case-sensitive mode or the specified short name is invalid.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The caller of this function must have the <b>SE_RESTORE_NAME</b> privilege. For more
information, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support short names on shares with continuous availability capability . Short names are not recommended on CsvFs.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetFileShortName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetShortPathName" />
  </member>
  <member name="Windows.SetFileShortNameA">
    <summary>
      <para>Sets the short name for the specified file. The file must be on an NTFS file system
volume.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file. The file must be opened with either the <b>GENERIC_ALL</b> access
right or <b>GENERIC_WRITE</b>|<b>DELETE</b>, and with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> file attribute.</para>
    </param>
    <param name="lpShortName">
      <para>A pointer to a string that specifies the short name for the file.</para>
      <para>Specifying  an empty (zero-length) string will remove the short file name, if it exists for the file specified by the <i>hFile</i> parameter. If  a short file name does not exist, the function will do nothing and return success.</para>
      <para>
        <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This behavior is not supported. The parameter must contain a valid string of one or more characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.
<b>GetLastError</b> may return one of the following error
codes that are specific to this function.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified short name is not unique.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>Either the specified file has been opened in case-sensitive mode or the specified short name is invalid.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The caller of this function must have the <b>SE_RESTORE_NAME</b> privilege. For more
information, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support short names on shares with continuous availability capability . Short names are not recommended on CsvFs.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetFileShortName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetShortPathName" />
  </member>
  <member name="Windows.SetFileShortNameW">
    <summary>
      <para>Sets the short name for the specified file. The file must be on an NTFS file system
volume.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file. The file must be opened with either the <b>GENERIC_ALL</b> access
right or <b>GENERIC_WRITE</b>|<b>DELETE</b>, and with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> file attribute.</para>
    </param>
    <param name="lpShortName">
      <para>A pointer to a string that specifies the short name for the file.</para>
      <para>Specifying  an empty (zero-length) string will remove the short file name, if it exists for the file specified by the <i>hFile</i> parameter. If  a short file name does not exist, the function will do nothing and return success.</para>
      <para>
        <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This behavior is not supported. The parameter must contain a valid string of one or more characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.
<b>GetLastError</b> may return one of the following error
codes that are specific to this function.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified short name is not unique.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>Either the specified file has been opened in case-sensitive mode or the specified short name is invalid.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The caller of this function must have the <b>SE_RESTORE_NAME</b> privilege. For more
information, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support short names on shares with continuous availability capability . Short names are not recommended on CsvFs.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetFileShortName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetShortPathName" />
  </member>
  <member name="Windows.SetFileShortName">
    <summary>
      <para>Sets the short name for the specified file. The file must be on an NTFS file system
volume.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file. The file must be opened with either the <b>GENERIC_ALL</b> access
right or <b>GENERIC_WRITE</b>|<b>DELETE</b>, and with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> file attribute.</para>
    </param>
    <param name="lpShortName">
      <para>A pointer to a string that specifies the short name for the file.</para>
      <para>Specifying  an empty (zero-length) string will remove the short file name, if it exists for the file specified by the <i>hFile</i> parameter. If  a short file name does not exist, the function will do nothing and return success.</para>
      <para>
        <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This behavior is not supported. The parameter must contain a valid string of one or more characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.
<b>GetLastError</b> may return one of the following error
codes that are specific to this function.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified short name is not unique.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>Either the specified file has been opened in case-sensitive mode or the specified short name is invalid.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The caller of this function must have the <b>SE_RESTORE_NAME</b> privilege. For more
information, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support short names on shares with continuous availability capability . Short names are not recommended on CsvFs.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetFileShortName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetShortPathName" />
  </member>
  <member name="Windows.SetFileShortNameA">
    <summary>
      <para>Sets the short name for the specified file. The file must be on an NTFS file system
volume.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file. The file must be opened with either the <b>GENERIC_ALL</b> access
right or <b>GENERIC_WRITE</b>|<b>DELETE</b>, and with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> file attribute.</para>
    </param>
    <param name="lpShortName">
      <para>A pointer to a string that specifies the short name for the file.</para>
      <para>Specifying  an empty (zero-length) string will remove the short file name, if it exists for the file specified by the <i>hFile</i> parameter. If  a short file name does not exist, the function will do nothing and return success.</para>
      <para>
        <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This behavior is not supported. The parameter must contain a valid string of one or more characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.
<b>GetLastError</b> may return one of the following error
codes that are specific to this function.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified short name is not unique.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>Either the specified file has been opened in case-sensitive mode or the specified short name is invalid.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The caller of this function must have the <b>SE_RESTORE_NAME</b> privilege. For more
information, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support short names on shares with continuous availability capability . Short names are not recommended on CsvFs.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetFileShortName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetShortPathName" />
  </member>
  <member name="Windows.SetFileShortNameW">
    <summary>
      <para>Sets the short name for the specified file. The file must be on an NTFS file system
volume.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file. The file must be opened with either the <b>GENERIC_ALL</b> access
right or <b>GENERIC_WRITE</b>|<b>DELETE</b>, and with the
<b>FILE_FLAG_BACKUP_SEMANTICS</b> file attribute.</para>
    </param>
    <param name="lpShortName">
      <para>A pointer to a string that specifies the short name for the file.</para>
      <para>Specifying  an empty (zero-length) string will remove the short file name, if it exists for the file specified by the <i>hFile</i> parameter. If  a short file name does not exist, the function will do nothing and return success.</para>
      <para>
        <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This behavior is not supported. The parameter must contain a valid string of one or more characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.
<b>GetLastError</b> may return one of the following error
codes that are specific to this function.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_ALREADY_EXISTS</b>
            </para>
          </description>
          <description>
            <para>The specified short name is not unique.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_PARAMETER</b>
            </para>
          </description>
          <description>
            <para>Either the specified file has been opened in case-sensitive mode or the specified short name is invalid.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The caller of this function must have the <b>SE_RESTORE_NAME</b> privilege. For more
information, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support short names on shares with continuous availability capability . Short names are not recommended on CsvFs.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetFileShortName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="GetShortPathName" />
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariable">
    <summary>
      <para>Sets the value of the specified firmware environment variable.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored.</para>
    </param>
    <param name="pValue">
      <para>A pointer to the new value for the  firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pBuffer</i> buffer, in bytes. If this parameter is zero, the firmware environment variable is deleted.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write UEFI firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>Starting with Windows 10, version 1803, reading UEFI firmware variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI firmware variables from UMDF drivers is not supported.</para>
      <para>To write a firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>SetFirmwareEnvironmentVariable</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI.  To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <para>
        <b>SetFirmwareEnvironmentVariable</b> is the user-mode equivalent of the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/wdm/nf-wdm-exsetfirmwareenvironmentvariable">ExSetFirmwareEnvironmentVariable</a> kernel-mode routine.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetFirmwareEnvironmentVariable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariable" />
    <seealso cref="SetFirmwareEnvironmentVariableEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariableA">
    <summary>
      <para>Sets the value of the specified firmware environment variable.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored.</para>
    </param>
    <param name="pValue">
      <para>A pointer to the new value for the  firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pBuffer</i> buffer, in bytes. If this parameter is zero, the firmware environment variable is deleted.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write UEFI firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>Starting with Windows 10, version 1803, reading UEFI firmware variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI firmware variables from UMDF drivers is not supported.</para>
      <para>To write a firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>SetFirmwareEnvironmentVariable</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI.  To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <para>
        <b>SetFirmwareEnvironmentVariable</b> is the user-mode equivalent of the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/wdm/nf-wdm-exsetfirmwareenvironmentvariable">ExSetFirmwareEnvironmentVariable</a> kernel-mode routine.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetFirmwareEnvironmentVariable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariable" />
    <seealso cref="SetFirmwareEnvironmentVariableEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariableW">
    <summary>
      <para>Sets the value of the specified firmware environment variable.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored.</para>
    </param>
    <param name="pValue">
      <para>A pointer to the new value for the  firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pBuffer</i> buffer, in bytes. If this parameter is zero, the firmware environment variable is deleted.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write UEFI firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>Starting with Windows 10, version 1803, reading UEFI firmware variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI firmware variables from UMDF drivers is not supported.</para>
      <para>To write a firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>SetFirmwareEnvironmentVariable</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI.  To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <para>
        <b>SetFirmwareEnvironmentVariable</b> is the user-mode equivalent of the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/wdm/nf-wdm-exsetfirmwareenvironmentvariable">ExSetFirmwareEnvironmentVariable</a> kernel-mode routine.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetFirmwareEnvironmentVariable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariable" />
    <seealso cref="SetFirmwareEnvironmentVariableEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariableEx">
    <summary>
      <para>Sets the value of the specified firmware environment variable as the attributes that indicate how this variable is stored and maintained.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="pValue">
      <para>A pointer to the new value for the  firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pValue</i> buffer, in bytes. Unless the VARIABLE_ATTRIBUTE_APPEND_WRITE,
VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS, or
VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS variable attribute is set via <i>dwAttributes</i>,
setting this value to zero will result in the deletion of this variable.</para>
    </param>
    <param name="dwAttributes">
      <para>Bitmask to set UEFI variable attributes associated with the variable. See also <a href="https://www.uefi.org/specifications">UEFI Spec 2.3.1, Section 7.2</a>.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_NON_VOLATILE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The firmware environment variable is stored in non-volatile memory (e.g. NVRAM).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The firmware environment variable can be accessed during boot service.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The firmware environment variable can be accessed at runtime.</para>
            <para>
              <b>Note</b>  Variables with this attribute set, must also have
<b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b> set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_HARDWARE_ERROR_RECORD</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates hardware related errors encountered at runtime.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates an authentication requirement that must be met before writing to this firmware environment variable. For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates authentication and time stamp requirements that must be met before writing to this firmware environment variable. When this attribute is set, the buffer, represented by <i>pValue</i>, will begin with an instance of a complete (and serialized) EFI_VARIABLE_AUTHENTICATION_2 descriptor.  For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_APPEND_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>Append an existing environment variable with the value of <i>pValue</i>. If the
firmware does not support the operation, then <b>SetFirmwareEnvironmentVariableEx</b> will return
ERROR_INVALID_FUNCTION.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write UEFI firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>Starting with Windows 10, version 1803, reading UEFI firmware variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI firmware variables from UMDF drivers is not supported.</para>
      <para>To write a firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>The correct method of changing the attributes of a variable is to delete the
variable and recreate it with different attributes.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>SetFirmwareEnvironmentVariableEx</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI.  To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetFirmwareEnvironmentVariableEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariableEx" />
    <seealso cref="SetFirmwareEnvironmentVariable" />
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariableExA">
    <summary>
      <para>Sets the value of the specified firmware environment variable as the attributes that indicate how this variable is stored and maintained.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="pValue">
      <para>A pointer to the new value for the  firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pValue</i> buffer, in bytes. Unless the VARIABLE_ATTRIBUTE_APPEND_WRITE,
VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS, or
VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS variable attribute is set via <i>dwAttributes</i>,
setting this value to zero will result in the deletion of this variable.</para>
    </param>
    <param name="dwAttributes">
      <para>Bitmask to set UEFI variable attributes associated with the variable. See also <a href="https://www.uefi.org/specifications">UEFI Spec 2.3.1, Section 7.2</a>.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_NON_VOLATILE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The firmware environment variable is stored in non-volatile memory (e.g. NVRAM).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The firmware environment variable can be accessed during boot service.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The firmware environment variable can be accessed at runtime.</para>
            <para>
              <b>Note</b>  Variables with this attribute set, must also have
<b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b> set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_HARDWARE_ERROR_RECORD</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates hardware related errors encountered at runtime.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates an authentication requirement that must be met before writing to this firmware environment variable. For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates authentication and time stamp requirements that must be met before writing to this firmware environment variable. When this attribute is set, the buffer, represented by <i>pValue</i>, will begin with an instance of a complete (and serialized) EFI_VARIABLE_AUTHENTICATION_2 descriptor.  For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_APPEND_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>Append an existing environment variable with the value of <i>pValue</i>. If the
firmware does not support the operation, then <b>SetFirmwareEnvironmentVariableEx</b> will return
ERROR_INVALID_FUNCTION.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write UEFI firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>Starting with Windows 10, version 1803, reading UEFI firmware variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI firmware variables from UMDF drivers is not supported.</para>
      <para>To write a firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>The correct method of changing the attributes of a variable is to delete the
variable and recreate it with different attributes.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>SetFirmwareEnvironmentVariableEx</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI.  To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetFirmwareEnvironmentVariableEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariableEx" />
    <seealso cref="SetFirmwareEnvironmentVariable" />
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariableExW">
    <summary>
      <para>Sets the value of the specified firmware environment variable as the attributes that indicate how this variable is stored and maintained.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="pValue">
      <para>A pointer to the new value for the  firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pValue</i> buffer, in bytes. Unless the VARIABLE_ATTRIBUTE_APPEND_WRITE,
VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS, or
VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS variable attribute is set via <i>dwAttributes</i>,
setting this value to zero will result in the deletion of this variable.</para>
    </param>
    <param name="dwAttributes">
      <para>Bitmask to set UEFI variable attributes associated with the variable. See also <a href="https://www.uefi.org/specifications">UEFI Spec 2.3.1, Section 7.2</a>.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_NON_VOLATILE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The firmware environment variable is stored in non-volatile memory (e.g. NVRAM).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The firmware environment variable can be accessed during boot service.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The firmware environment variable can be accessed at runtime.</para>
            <para>
              <b>Note</b>  Variables with this attribute set, must also have
<b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b> set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_HARDWARE_ERROR_RECORD</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates hardware related errors encountered at runtime.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates an authentication requirement that must be met before writing to this firmware environment variable. For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates authentication and time stamp requirements that must be met before writing to this firmware environment variable. When this attribute is set, the buffer, represented by <i>pValue</i>, will begin with an instance of a complete (and serialized) EFI_VARIABLE_AUTHENTICATION_2 descriptor.  For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_APPEND_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>Append an existing environment variable with the value of <i>pValue</i>. If the
firmware does not support the operation, then <b>SetFirmwareEnvironmentVariableEx</b> will return
ERROR_INVALID_FUNCTION.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write UEFI firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>Starting with Windows 10, version 1803, reading UEFI firmware variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI firmware variables from UMDF drivers is not supported.</para>
      <para>To write a firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>The correct method of changing the attributes of a variable is to delete the
variable and recreate it with different attributes.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>SetFirmwareEnvironmentVariableEx</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI.  To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetFirmwareEnvironmentVariableEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariableEx" />
    <seealso cref="SetFirmwareEnvironmentVariable" />
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariableEx">
    <summary>
      <para>Sets the value of the specified firmware environment variable and the attributes that indicate how this variable is stored and maintained.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="pValue">
      <para>A pointer to the new value for the  firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pValue</i> buffer, in bytes. Unless the VARIABLE_ATTRIBUTE_APPEND_WRITE,
VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS, or
VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS variable attribute is set via <i>dwAttributes</i>,
setting this value to zero will result in the deletion of this variable.</para>
    </param>
    <param name="dwAttributes">
      <para>Bitmask to set UEFI variable attributes associated with the variable. See also <a href="https://www.uefi.org/specifications">UEFI Spec 2.3.1, Section 7.2</a>.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_NON_VOLATILE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The firmware environment variable is stored in non-volatile memory (e.g. NVRAM).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The firmware environment variable can be accessed during boot service.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The firmware environment variable can be accessed at runtime.</para>
            <para>
              <b>Note</b>  Variables with this attribute set, must also have
<b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b> set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_HARDWARE_ERROR_RECORD</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates hardware related errors encountered at runtime.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates an authentication requirement that must be met before writing to this firmware environment variable. For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates authentication and time stamp requirements that must be met before writing to this firmware environment variable. When this attribute is set, the buffer, represented by <i>pValue</i>, will begin with an instance of a complete (and serialized) EFI_VARIABLE_AUTHENTICATION_2 descriptor.  For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_APPEND_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>Append an existing environment variable with the value of <i>pValue</i>. If the
firmware does not support the operation, then <b>SetFirmwareEnvironmentVariableEx</b> will return
ERROR_INVALID_FUNCTION.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write UEFI firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>Starting with Windows 10, version 1803, reading UEFI firmware variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI firmware variables from UMDF drivers is not supported.</para>
      <para>To write a firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>The correct method of changing the attributes of a variable is to delete the
variable and recreate it with different attributes.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>SetFirmwareEnvironmentVariableEx</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI.  To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetFirmwareEnvironmentVariableEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariableEx" />
    <seealso cref="SetFirmwareEnvironmentVariable" />
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariableExA">
    <summary>
      <para>Sets the value of the specified firmware environment variable and the attributes that indicate how this variable is stored and maintained.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="pValue">
      <para>A pointer to the new value for the  firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pValue</i> buffer, in bytes. Unless the VARIABLE_ATTRIBUTE_APPEND_WRITE,
VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS, or
VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS variable attribute is set via <i>dwAttributes</i>,
setting this value to zero will result in the deletion of this variable.</para>
    </param>
    <param name="dwAttributes">
      <para>Bitmask to set UEFI variable attributes associated with the variable. See also <a href="https://www.uefi.org/specifications">UEFI Spec 2.3.1, Section 7.2</a>.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_NON_VOLATILE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The firmware environment variable is stored in non-volatile memory (e.g. NVRAM).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The firmware environment variable can be accessed during boot service.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The firmware environment variable can be accessed at runtime.</para>
            <para>
              <b>Note</b>  Variables with this attribute set, must also have
<b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b> set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_HARDWARE_ERROR_RECORD</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates hardware related errors encountered at runtime.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates an authentication requirement that must be met before writing to this firmware environment variable. For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates authentication and time stamp requirements that must be met before writing to this firmware environment variable. When this attribute is set, the buffer, represented by <i>pValue</i>, will begin with an instance of a complete (and serialized) EFI_VARIABLE_AUTHENTICATION_2 descriptor.  For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_APPEND_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>Append an existing environment variable with the value of <i>pValue</i>. If the
firmware does not support the operation, then <b>SetFirmwareEnvironmentVariableEx</b> will return
ERROR_INVALID_FUNCTION.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write UEFI firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>Starting with Windows 10, version 1803, reading UEFI firmware variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI firmware variables from UMDF drivers is not supported.</para>
      <para>To write a firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>The correct method of changing the attributes of a variable is to delete the
variable and recreate it with different attributes.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>SetFirmwareEnvironmentVariableEx</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI.  To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetFirmwareEnvironmentVariableEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariableEx" />
    <seealso cref="SetFirmwareEnvironmentVariable" />
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariableExW">
    <summary>
      <para>Sets the value of the specified firmware environment variable and the attributes that indicate how this variable is stored and maintained.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="pValue">
      <para>A pointer to the new value for the  firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pValue</i> buffer, in bytes. Unless the VARIABLE_ATTRIBUTE_APPEND_WRITE,
VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS, or
VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS variable attribute is set via <i>dwAttributes</i>,
setting this value to zero will result in the deletion of this variable.</para>
    </param>
    <param name="dwAttributes">
      <para>Bitmask to set UEFI variable attributes associated with the variable. See also <a href="https://www.uefi.org/specifications">UEFI Spec 2.3.1, Section 7.2</a>.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_NON_VOLATILE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>The firmware environment variable is stored in non-volatile memory (e.g. NVRAM).</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The firmware environment variable can be accessed during boot service.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The firmware environment variable can be accessed at runtime.</para>
            <para>
              <b>Note</b>  Variables with this attribute set, must also have
<b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b> set.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_HARDWARE_ERROR_RECORD</b>
                </description>
              </item>
              <item>
                <description>0x00000008</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates hardware related errors encountered at runtime.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000010</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates an authentication requirement that must be met before writing to this firmware environment variable. For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS</b>
                </description>
              </item>
              <item>
                <description>0x00000020</description>
              </item>
            </list>
          </description>
          <description>
            <para>Indicates authentication and time stamp requirements that must be met before writing to this firmware environment variable. When this attribute is set, the buffer, represented by <i>pValue</i>, will begin with an instance of a complete (and serialized) EFI_VARIABLE_AUTHENTICATION_2 descriptor.  For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>VARIABLE_ATTRIBUTE_APPEND_WRITE</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>Append an existing environment variable with the value of <i>pValue</i>. If the
firmware does not support the operation, then <b>SetFirmwareEnvironmentVariableEx</b> will return
ERROR_INVALID_FUNCTION.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write UEFI firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>Starting with Windows 10, version 1803, reading UEFI firmware variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI firmware variables from UMDF drivers is not supported.</para>
      <para>To write a firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>The correct method of changing the attributes of a variable is to delete the
variable and recreate it with different attributes.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>SetFirmwareEnvironmentVariableEx</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI.  To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetFirmwareEnvironmentVariableEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariableEx" />
    <seealso cref="SetFirmwareEnvironmentVariable" />
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariable">
    <summary>
      <para>Sets the value of the specified firmware environment variable.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored.</para>
    </param>
    <param name="pValue">
      <para>A pointer to the new value for the  firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pBuffer</i> buffer, in bytes. If this parameter is zero, the firmware environment variable is deleted.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write UEFI firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>Starting with Windows 10, version 1803, reading UEFI firmware variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI firmware variables from UMDF drivers is not supported.</para>
      <para>To write a firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>SetFirmwareEnvironmentVariable</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI.  To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <para>
        <b>SetFirmwareEnvironmentVariable</b> is the user-mode equivalent of the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/wdm/nf-wdm-exsetfirmwareenvironmentvariable">ExSetFirmwareEnvironmentVariable</a> kernel-mode routine.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetFirmwareEnvironmentVariable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariable" />
    <seealso cref="SetFirmwareEnvironmentVariableEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariableA">
    <summary>
      <para>Sets the value of the specified firmware environment variable.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored.</para>
    </param>
    <param name="pValue">
      <para>A pointer to the new value for the  firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pBuffer</i> buffer, in bytes. If this parameter is zero, the firmware environment variable is deleted.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write UEFI firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>Starting with Windows 10, version 1803, reading UEFI firmware variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI firmware variables from UMDF drivers is not supported.</para>
      <para>To write a firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>SetFirmwareEnvironmentVariable</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI.  To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <para>
        <b>SetFirmwareEnvironmentVariable</b> is the user-mode equivalent of the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/wdm/nf-wdm-exsetfirmwareenvironmentvariable">ExSetFirmwareEnvironmentVariable</a> kernel-mode routine.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetFirmwareEnvironmentVariable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariable" />
    <seealso cref="SetFirmwareEnvironmentVariableEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariableW">
    <summary>
      <para>Sets the value of the specified firmware environment variable.</para>
    </summary>
    <param name="lpName">
      <para>The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</para>
    </param>
    <param name="lpGuid">
      <para>The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format  "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored.</para>
    </param>
    <param name="pValue">
      <para>A pointer to the new value for the  firmware environment variable.</para>
    </param>
    <param name="nSize">
      <para>The size of the <i>pBuffer</i> buffer, in bytes. If this parameter is zero, the firmware environment variable is deleted.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
    <remarks>
      <para>Starting with Windows 10, version 1803, Universal Windows apps can read and write UEFI firmware variables. See <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a> for details.</para>
      <para>Starting with Windows 10, version 1803, reading UEFI firmware variables is also supported from User-Mode Driver Framework (UMDF) drivers. Writing UEFI firmware variables from UMDF drivers is not supported.</para>
      <para>To write a firmware environment variable, the user account that the app is running under must have the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">SE_SYSTEM_ENVIRONMENT_NAME</a> privilege. A Universal Windows app must be run from an administrator account and follow the requirements outlined in <a href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</a>.</para>
      <para>The exact set of firmware environment variables is determined by the boot firmware. The location of these environment variables is also specified by the firmware.  For example, on a UEFI-based system, NVRAM contains firmware environment variables that specify system boot settings. For information about specific variables used, see the <a href="https://www.uefi.org/specifications">UEFI specification</a>. For more information about UEFI and Windows, see <a href="https://docs.microsoft.com//windows-hardware/drivers/bringup/uefi-in-windows">UEFI and Windows</a>.</para>
      <para>Firmware variables are not supported on a legacy BIOS-based system. The <b>SetFirmwareEnvironmentVariable</b> function will always fail on a legacy BIOS-based system, or if Windows was installed using legacy BIOS on a system that supports both legacy BIOS and UEFI.  To identify these conditions, call the function with a dummy firmware environment name such as an empty string ("") for the <i>lpName</i> parameter and a dummy GUID such as "{00000000-0000-0000-0000-000000000000}" for the <i>lpGuid</i> parameter. On a legacy BIOS-based system, or on a system that supports both legacy BIOS and UEFI where Windows was installed using legacy BIOS, the function will fail with  ERROR_INVALID_FUNCTION. On a UEFI-based system, the function will  fail with an error specific to the firmware, such as ERROR_NOACCESS, to indicate that the dummy GUID namespace does not exist.</para>
      <para>
        <b>SetFirmwareEnvironmentVariable</b> is the user-mode equivalent of the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/wdm/nf-wdm-exsetfirmwareenvironmentvariable">ExSetFirmwareEnvironmentVariable</a> kernel-mode routine.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetFirmwareEnvironmentVariable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/access-uefi-firmware-variables-from-a-universal-windows-app">Access UEFI firmware variables from a Universal Windows App</seealso>
    <seealso cref="GetFirmwareEnvironmentVariable" />
    <seealso cref="SetFirmwareEnvironmentVariableEx" />
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/system-information-functions">System
Information Functions</seealso>
  </member>
  <member name="Windows.SetHandleCount">
    <summary>
      <para>Changes the number of file handles available to a process.  For DOS-based Win32, the default maximum number of file handles available to a process is 20.  For Windows Win32 systems, this API has no effect.</para>
    </summary>
    <param name="uNumber">
      <para>The requested number of available file handles.</para>
    </param>
    <returns>
      <para>The number of available file handles.</para>
    </returns>
  </member>
  <member name="Windows.SetMailslotInfo">
    <summary>
      <para>Sets the time-out value used by the specified mailslot for a read operation.</para>
    </summary>
    <param name="hMailslot">
      <para>A handle to a mailslot. The
<see cref="CreateMailslot" /> function must create this handle.</para>
    </param>
    <param name="lReadTimeout">
      <para>The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in milliseconds. The following values have special meanings.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>Returns immediately if no message is present. (The system does not treat an immediate return as an error.)</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>MAILSLOT_WAIT_FOREVER</b>
                </description>
              </item>
              <item>
                <description>((DWORD)-1)</description>
              </item>
            </list>
          </description>
          <description>
            <para>Waits forever for a message.</para>
          </description>
        </item>
      </list>
      <para>This time-out value applies to all subsequent read operations and to all inherited mailslot handles.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The initial time-out value used by a mailslot for a read operation is typically set by
<see cref="CreateMailslot" /> when the mailslot is created.</para>
    </remarks>
    <seealso cref="CreateMailslot" />
    <seealso cref="GetMailslotInfo" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/mailslot-functions">Mailslot Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/mailslots">Mailslots Overview</seealso>
  </member>
  <member name="Windows.SetProcessAffinityMask">
    <summary>
      <para>Sets a processor affinity mask for the threads of the specified process.</para>
    </summary>
    <param name="hProcess">
      <para>A handle to the process whose affinity mask is to be set. This handle must have the <b>PROCESS_SET_INFORMATION</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
    </param>
    <param name="dwProcessAffinityMask">
      <para>The affinity mask for the threads of the process.</para>
      <para>On a system with more than 64 processors, the affinity mask must specify processors in a single <a href="https://docs.microsoft.com//windows/desktop/ProcThread/processor-groups">processor group</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the process affinity mask requests a processor that is not configured in the system, the last error code is <b>ERROR_INVALID_PARAMETER</b>.</para>
      <para>On a system with more than 64 processors, if the calling process contains threads in more than one processor group, the last error code is <b>ERROR_INVALID_PARAMETER</b>.</para>
    </returns>
    <remarks>
      <para>A process affinity mask is a bit vector in which each bit represents a logical processor on which the threads of the process are allowed to run. The value of the process affinity mask must be a subset of the system affinity mask values obtained by the
<see cref="GetProcessAffinityMask" /> function. A process is only allowed to run on the processors configured into a system. Therefore, the process affinity mask cannot specify a 1 bit for a processor when the system affinity mask specifies a 0 bit for that processor.</para>
      <para>Process affinity is inherited by any child process or newly instantiated local process.</para>
      <para>Do not call <b>SetProcessAffinityMask</b> in a DLL that may be called by processes other than your own.</para>
      <para>On a system with more than 64 processors, the <b>SetProcessAffinityMask</b> function can be used to set the process affinity mask only for processes with threads in a single <a href="https://docs.microsoft.com//windows/desktop/ProcThread/processor-groups">processor group</a>. Use the <see cref="SetThreadAffinityMask" /> function to set the affinity mask for individual threads in multiple groups. This effectively changes the group assignment of the process.</para>
    </remarks>
    <seealso cref="CreateProcess" />
    <seealso cref="GetProcessAffinityMask" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-processors">Multiple Processors</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/child-processes">Processes</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/processor-groups">Processor Groups</seealso>
    <seealso cref="SetThreadAffinityMask" />
  </member>
  <member name="Windows.SetProcessDEPPolicy">
    <summary>
      <para>Changes data execution prevention (DEP) and DEP-ATL thunk emulation settings for a 32-bit process.</para>
    </summary>
    <param name="dwFlags">
      <para>A <b>DWORD</b> that can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>If the DEP system policy is OptIn or OptOut and DEP is enabled for the process, setting <i>dwFlags</i> to 0 disables DEP for the process.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PROCESS_DEP_ENABLE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables DEP permanently on the current process. After DEP has been enabled for the process by setting <b>PROCESS_DEP_ENABLE</b>, it cannot be disabled for the life of the process.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Disables DEP-ATL thunk emulation for the current process, which prevents the system from intercepting NX faults that originate from the Active Template Library (ATL) thunk layer. For more information, see the Remarks section. This flag can be specified only with  <b>PROCESS_DEP_ENABLE</b>.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>.</para>
      <para>If the function fails, it returns <b>FALSE</b>. To retrieve error values defined for this function,  call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>SetProcessDEPPolicy</b>  function overrides the system DEP policy for the current process unless its DEP policy was specified at process creation. The system DEP policy setting must be OptIn or OptOut. If the system DEP policy is AlwaysOff or AlwaysOn, <b>SetProcessDEPPolicy</b> returns an error. After DEP is enabled for a process, subsequent calls to <b>SetProcessDEPPolicy</b> are ignored.</para>
      <para>DEP policy specified at process creation with the <see cref="PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY" /> attribute cannot be changed for the life of the process. In this case, calls to <b>SetProcessDEPPolicy</b> fail with <b>ERROR_ACCESS_DENIED</b>.</para>
      <para>
        <b>SetProcessDEPPolicy</b> is supported for 32-bit processes only. If this function is called on a 64-bit process, it fails with <b>ERROR_NOT_SUPPORTED</b>.</para>
      <para>Applications written to ATL 7.1 and earlier can attempt to execute code on pages marked as non-executable, which triggers an NX fault and terminates the application. DEP-ATL thunk emulation allows an application that would otherwise trigger an NX fault to run with DEP enabled. For information about ATL versions, see <a href="https://docs.microsoft.com//previous-versions/visualstudio/visual-studio-2008/3z02ch3k(v=vs.90)">ATL and MFC Version Numbers</a>.</para>
      <para>If DEP-ATL thunk emulation is enabled, the system intercepts NX faults, emulates the instructions, and handles the exceptions so the application can continue to run. If DEP-ATL thunk emulation is disabled by setting <b>PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION</b> for the process, NX faults are not intercepted, which is useful when testing applications for compatibility with DEP.</para>
      <para>The following table summarizes the interactions between system DEP policy, DEP-ATL thunk emulation, and  <b>SetProcessDEPPolicy</b>.
To get the system DEP policy setting, use the <see cref="GetSystemDEPPolicy" /> function.</para>
      <list type="table">
        <listheader>
          <description>System DEP policy</description>
          <description>DEP behavior</description>
          <description>DEP_ATL thunk emulation behavior</description>
          <description>
            <b>SetProcessDEPPolicy</b> behavior</description>
        </listheader>
        <item>
          <description>
            <para>AlwaysOff</para>
            <para>0</para>
          </description>
          <description>
            <para>Disabled for the operating system and all processes.</para>
          </description>
          <description>
            <para>Not applicable.</para>
          </description>
          <description>
            <para>Returns an error.</para>
          </description>
        </item>
        <item>
          <description>
            <para>AlwaysOn</para>
            <para>1</para>
          </description>
          <description>
            <para>Enabled for the operating system and all processes.</para>
          </description>
          <description>
            <para>Disabled.</para>
          </description>
          <description>
            <para>Returns an error.</para>
          </description>
        </item>
        <item>
          <description>
            <para>OptIn</para>
            <para>2</para>
            <para>Default configuration for Windows client versions.</para>
          </description>
          <description>
            <para>Enabled for the operating system and disabled for nonsystem processes. Administrators can  explicitly enable DEP for selected executable files.</para>
          </description>
          <description>
            <para>Not applicable.</para>
          </description>
          <description>
            <para>DEP can be enabled for the current process.</para>
            <para>If DEP is enabled for the current process, DEP-ATL thunk emulation can be disabled for that process.</para>
          </description>
        </item>
        <item>
          <description>
            <para>OptOut</para>
            <para>3</para>
            <para>Default configuration for Windows Server versions.</para>
          </description>
          <description>
            <para>Enabled for the operating system and all processes. Administrators can explicitly disable DEP for selected executable files.</para>
          </description>
          <description>
            <para>Enabled.</para>
          </description>
          <description>
            <para>DEP can be disabled for the current process.</para>
            <para>If DEP is disabled for the current process, DEP-ATL thunk emulation is automatically disabled for that process.</para>
          </description>
        </item>
      </list>
      <para>To compile an application that calls this function, define <b>_WIN32_WINNT</b> as 0x0600 or later. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Memory/data-execution-prevention">Data Execution Prevention</seealso>
    <seealso cref="GetProcessDEPPolicy" />
    <seealso cref="GetSystemDEPPolicy" />
  </member>
  <member name="Windows.SetSearchPathMode">
    <summary>
      <para>Sets the per-process mode that the <see cref="SearchPath" /></para>
      <para>function uses when locating files.</para>
    </summary>
    <param name="Flags">
      <para>The search mode to use.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enable safe process search mode for the process.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE</b>
                </description>
              </item>
              <item>
                <description>0x00010000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Disable safe process search mode for the process.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>BASE_SEARCH_PATH_PERMANENT</b>
                </description>
              </item>
              <item>
                <description>0x00008000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Optional flag to use in combination with
<b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b> to make this mode permanent for this
process. This is done by bitwise <b>OR</b> operation:</para>
            <para>
              <code>(BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE | BASE_SEARCH_PATH_PERMANENT)</code>
            </para>
            <para>This flag cannot be combined with the <b>BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE</b></para>
            <para>flag.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the operation completes successfully, the
<b>SetSearchPathMode</b> function returns a nonzero
value.</para>
      <para>If the operation fails, the <b>SetSearchPathMode</b></para>
      <para>function returns zero. To get extended error information, call the
<see cref="GetLastError" /> function.</para>
      <para>If the <b>SetSearchPathMode</b> function fails because a
parameter value is not valid, the value returned by the
<see cref="GetLastError" /> function will be
<b>ERROR_INVALID_PARAMETER</b>.</para>
      <para>If the <b>SetSearchPathMode</b> function fails because
the combination of current state and parameter value is not valid, the value returned by the
<see cref="GetLastError" /> function will be
<b>ERROR_ACCESS_DENIED</b>. For more information, see the Remarks section.</para>
    </returns>
    <remarks>
      <para>If the <b>SetSearchPathMode</b> function has not been
successfully called for the current process, the search mode used by the
<see cref="SearchPath" /> function is obtained from the system registry. For
more information, see <see cref="SearchPath" />.</para>
      <para>After the <b>SetSearchPathMode</b> function has been
successfully called for the current process, the setting in the system registry is ignored in favor of the mode
most recently set successfully.</para>
      <para>If the <b>SetSearchPathMode</b> function has been
successfully called for the current process with <i>Flags</i> set to
<code>(BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE | BASE_SEARCH_PATH_PERMANENT)</code>,
safe mode is set permanently for the calling process. Any subsequent calls to the
<b>SetSearchPathMode</b> function from within that process
that attempt to change the search mode will fail with <b>ERROR_ACCESS_DENIED</b> from the
<see cref="GetLastError" /> function.</para>
      <para>
        <b>Note</b>  Because setting safe search mode permanently cannot be disabled for the life of the process for which is was
set, it should be used with careful consideration. This is particularly true for DLL development, where the user
of the DLL will be affected by this process-wide setting.</para>
      <para>It is not possible to permanently disable safe search mode.</para>
      <para>This function does not modify the system registry.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso cref="SearchPath" />
  </member>
  <member name="Windows.SetTapeParameters">
    <summary>
      <para>The
<b>SetTapeParameters</b> function either specifies the block size of a tape or configures the tape device.</para>
    </summary>
    <param name="hDevice">
      <para>Handle to the device for which to set configuration information. This handle is created by using the
<see cref="CreateFile" /> function.</para>
    </param>
    <param name="dwOperation">
      <para>Type of information to set. This parameter must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SET_TAPE_DRIVE_INFORMATION</b>
                </description>
              </item>
              <item>
                <description>1L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets the device-specific information specified by <i>lpTapeInformation</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>SET_TAPE_MEDIA_INFORMATION</b>
                </description>
              </item>
              <item>
                <description>0L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Sets the tape-specific information specified by the <i>lpTapeInformation</i> parameter.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpTapeInformation">
      <para>Pointer to a structure that contains the information to set. If the <i>dwOperation</i> parameter is SET_TAPE_MEDIA_INFORMATION, <i>lpTapeInformation</i> points to a
<see cref="TAPE_SET_MEDIA_PARAMETERS" /> structure.</para>
      <para>If <i>dwOperation</i> is SET_TAPE_DRIVE_INFORMATION, <i>lpTapeInformation</i> points to a
<see cref="TAPE_SET_DRIVE_PARAMETERS" /> structure.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, it can return one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_BEGINNING_OF_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1102L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to access data before the beginning-of-medium marker failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_BUS_RESET</b>
                </description>
              </item>
              <item>
                <description>1111L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A reset condition was detected on the bus.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_DEVICE_NOT_PARTITIONED</b>
                </description>
              </item>
              <item>
                <description>1107L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The partition information could not be found when a tape was being loaded.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_END_OF_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1100L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The end-of-tape marker was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_FILEMARK_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1101L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A filemark was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_INVALID_BLOCK_LENGTH</b>
                </description>
              </item>
              <item>
                <description>1106L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The block size is incorrect on a new tape in a multivolume partition.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_MEDIA_CHANGED</b>
                </description>
              </item>
              <item>
                <description>1110L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape that was in the drive has been replaced or removed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NO_DATA_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1104L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The end-of-data marker was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NO_MEDIA_IN_DRIVE</b>
                </description>
              </item>
              <item>
                <description>1112L</description>
              </item>
            </list>
          </description>
          <description>
            <para>There is no media in the drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NOT_SUPPORTED</b>
                </description>
              </item>
              <item>
                <description>50L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape driver does not support a requested function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_PARTITION_FAILURE</b>
                </description>
              </item>
              <item>
                <description>1105L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape could not be partitioned.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_SETMARK_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1103L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A setmark was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_UNABLE_TO_LOCK_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1108L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to lock the ejection mechanism failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1109L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to unload the tape failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_WRITE_PROTECT</b>
                </description>
              </item>
              <item>
                <description>19L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The media is write protected.</para>
          </description>
        </item>
      </list>
    </returns>
    <seealso cref="GetTapeParameters" />
    <seealso cref="TAPE_SET_DRIVE_PARAMETERS" />
    <seealso cref="TAPE_SET_MEDIA_PARAMETERS" />
  </member>
  <member name="Windows.SetTapePosition">
    <summary>
      <para>The
<b>SetTapePosition</b> function sets the tape position on the specified device.</para>
    </summary>
    <param name="hDevice">
      <para>Handle to the device on which to set the tape position. This handle is created by using the
<see cref="CreateFile" /> function.</para>
    </param>
    <param name="dwPositionMethod">
      <para>Type of positioning to perform. This parameter must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_ABSOLUTE_BLOCK</b>
                </description>
              </item>
              <item>
                <description>1L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Moves the tape to the device-specific block address specified by the <i>dwOffsetLow</i> and <i>dwOffsetHigh</i> parameters. The <i>dwPartition</i> parameter is ignored.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_LOGICAL_BLOCK</b>
                </description>
              </item>
              <item>
                <description>2L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Moves the tape to the block address specified by <i>dwOffsetLow</i> and <i>dwOffsetHigh</i> in the partition specified by <i>dwPartition</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_REWIND</b>
                </description>
              </item>
              <item>
                <description>0L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Moves the tape to the beginning of the current partition. The <i>dwPartition</i>, <i>dwOffsetLow</i>, and <i>dwOffsetHigh</i> parameters are ignored.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_SPACE_END_OF_DATA</b>
                </description>
              </item>
              <item>
                <description>4L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Moves the tape to the end of the data on the partition specified by <i>dwPartition</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_SPACE_FILEMARKS</b>
                </description>
              </item>
              <item>
                <description>6L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Moves the tape forward (or backward) the number of filemarks specified by <i>dwOffsetLow</i> and <i>dwOffsetHigh</i> in the current partition. The <i>dwPartition</i> parameter is ignored.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_SPACE_RELATIVE_BLOCKS</b>
                </description>
              </item>
              <item>
                <description>5L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Moves the tape forward (or backward) the number of blocks specified by <i>dwOffsetLow</i> and <i>dwOffsetHigh</i> in the current partition. The <i>dwPartition</i> parameter is ignored.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_SPACE_SEQUENTIAL_FMKS</b>
                </description>
              </item>
              <item>
                <description>7L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Moves the tape forward (or backward) to the first occurrence of n filemarks in the current partition, where n is the number specified by <i>dwOffsetLow</i> and <i>dwOffsetHigh</i>. The <i>dwPartition</i> parameter is ignored.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_SPACE_SEQUENTIAL_SMKS</b>
                </description>
              </item>
              <item>
                <description>9L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Moves the tape forward (or backward) to the first occurrence of n setmarks in the current partition, where n is the number specified by <i>dwOffsetLow</i> and <i>dwOffsetHigh</i>. The <i>dwPartition</i> parameter is ignored.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_SPACE_SETMARKS</b>
                </description>
              </item>
              <item>
                <description>8L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Moves the tape forward (or backward) the number of setmarks specified by <i>dwOffsetLow</i> and <i>dwOffsetHigh</i> in the current partition. The <i>dwPartition</i> parameter is ignored.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwPartition">
      <para>Partition to position within. If <i>dwPartition</i> is zero, the current partition is used. Partitions are numbered logically from 1 through n, where 1 is the first partition on the tape and n is the last.</para>
    </param>
    <param name="dwOffsetLow">
      <para>Low-order bits of the block address or count for the position operation specified by the <i>dwPositionMethod</i> parameter.</para>
    </param>
    <param name="dwOffsetHigh">
      <para>High-order bits of the block address or count for the position operation specified by the <i>dwPositionMethod</i> parameter. If the high-order bits are not required, this parameter should be zero.</para>
    </param>
    <param name="bImmediate">
      <para>Indicates whether to return as soon as the move operation begins. If this parameter is <b>TRUE</b>, the function returns immediately; if <b>FALSE</b>, the function does not return until the move operation has been completed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, it can return one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_BEGINNING_OF_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1102L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to access data before the beginning-of-medium marker failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_BUS_RESET</b>
                </description>
              </item>
              <item>
                <description>1111L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A reset condition was detected on the bus.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_DEVICE_NOT_PARTITIONED</b>
                </description>
              </item>
              <item>
                <description>1107L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The partition information could not be found when a tape was being loaded.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_END_OF_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1100L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The end-of-tape marker was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_FILEMARK_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1101L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A filemark was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_INVALID_BLOCK_LENGTH</b>
                </description>
              </item>
              <item>
                <description>1106L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The block size is incorrect on a new tape in a multivolume partition.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_MEDIA_CHANGED</b>
                </description>
              </item>
              <item>
                <description>1110L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape that was in the drive has been replaced or removed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NO_DATA_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1104L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The end-of-data marker was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NO_MEDIA_IN_DRIVE</b>
                </description>
              </item>
              <item>
                <description>1112L</description>
              </item>
            </list>
          </description>
          <description>
            <para>There is no media in the drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NOT_SUPPORTED</b>
                </description>
              </item>
              <item>
                <description>50L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape driver does not support a requested function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_PARTITION_FAILURE</b>
                </description>
              </item>
              <item>
                <description>1105L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape could not be partitioned.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_SETMARK_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1103L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A setmark was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_UNABLE_TO_LOCK_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1108L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to lock the ejection mechanism failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1109L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to unload the tape failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_WRITE_PROTECT</b>
                </description>
              </item>
              <item>
                <description>19L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The media is write protected.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If the offset specified by <i>dwOffsetLow</i> and <i>dwOffsetHigh</i> specifies the number of blocks, filemarks, or setmarks to move, a positive offset moves the tape forward to the end of the last block, filemark, or setmark. A negative offset moves the tape backward to the beginning of the last block, filemark, or setmark. If the offset is zero, the tape does not move.</para>
      <para>To obtain information about the status, capabilities, and capacities of tape drives and media, call the
<see cref="GetTapeParameters" /> function.</para>
    </remarks>
    <seealso cref="CreateFile" />
    <seealso cref="GetTapeParameters" />
    <seealso cref="GetTapePosition" />
  </member>
  <member name="Windows.SetThreadAffinityMask">
    <summary>
      <para>Sets a processor affinity mask for the specified thread.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread whose affinity mask is to be set.</para>
      <para>This handle must have the <b>THREAD_SET_INFORMATION</b> or <b>THREAD_SET_LIMITED_INFORMATION</b> access right and the <b>THREAD_QUERY_INFORMATION</b> or <b>THREAD_QUERY_LIMITED_INFORMATION</b> access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>THREAD_SET_INFORMATION</b> and <b>THREAD_QUERY_INFORMATION</b> access rights.</para>
    </param>
    <param name="dwThreadAffinityMask">
      <para>The affinity mask for the thread.</para>
      <para>On a system with more than 64 processors, the affinity mask must specify processors in the thread's current <a href="https://docs.microsoft.com//windows/desktop/ProcThread/processor-groups">processor group</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the thread's previous affinity mask.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the thread affinity mask requests a processor that is not selected for the process affinity mask, the last error code is <b>ERROR_INVALID_PARAMETER</b>.</para>
    </returns>
    <remarks>
      <para>A thread affinity mask is a bit vector in which each bit represents a logical processor that a thread is allowed to run on. A thread affinity mask must be a subset of the process affinity mask for the containing process of a thread. A thread can only run on the processors its process can run on. Therefore, the thread affinity mask cannot specify a 1 bit for a processor when the process affinity mask specifies a 0 bit for that processor.</para>
      <para>Setting an affinity mask for a process or thread can result in threads receiving less processor time, as the system is restricted from running the threads on certain processors. In most cases, it is better to let the system select an available processor.</para>
      <para>If the new thread affinity mask does not specify the processor that is currently running the thread, the thread is rescheduled on one of the allowable processors.</para>
    </remarks>
    <seealso cref="GetProcessAffinityMask" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-processors">Multiple Processors</seealso>
    <seealso cref="OpenThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/processor-groups">Processor Groups</seealso>
    <seealso cref="SetProcessAffinityMask" />
    <seealso cref="SetThreadIdealProcessor" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/multiple-threads">Threads</seealso>
  </member>
  <member name="Windows.SetThreadExecutionState">
    <summary>
      <para>Enables an application to inform the system that it is in use, thereby preventing the system from entering sleep or turning off the display while the application is running.</para>
    </summary>
    <param name="esFlags">
      <para>The thread's execution requirements. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ES_AWAYMODE_REQUIRED</b>
                </description>
              </item>
              <item>
                <description>0x00000040</description>
              </item>
            </list>
          </description>
          <description>
            <para>Enables away mode. This value must be specified with <b>ES_CONTINUOUS</b>.</para>
            <para>Away mode should be used only by media-recording and media-distribution applications that must perform critical background processing on desktop computers while the computer appears to be sleeping. See Remarks.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ES_CONTINUOUS</b>
                </description>
              </item>
              <item>
                <description>0x80000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>Informs the system that the state being set should remain in effect until the next call that uses <b>ES_CONTINUOUS</b> and one of the other state flags is cleared.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ES_DISPLAY_REQUIRED</b>
                </description>
              </item>
              <item>
                <description>0x00000002</description>
              </item>
            </list>
          </description>
          <description>
            <para>Forces the display to be on by resetting the display idle timer.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ES_SYSTEM_REQUIRED</b>
                </description>
              </item>
              <item>
                <description>0x00000001</description>
              </item>
            </list>
          </description>
          <description>
            <para>Forces the system to be in the working state by resetting the system idle timer.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ES_USER_PRESENT</b>
                </description>
              </item>
              <item>
                <description>0x00000004</description>
              </item>
            </list>
          </description>
          <description>
            <para>This value is not supported. If <b>ES_USER_PRESENT</b> is combined with other <i>esFlags</i> values, the call will fail and  none of the specified states will be set.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the previous thread execution state.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>The system automatically detects activities such as local keyboard or mouse input, server activity, and changing window focus. Activities that are not automatically detected include disk or CPU activity and video display.</para>
      <para>Calling
<b>SetThreadExecutionState</b> without <b>ES_CONTINUOUS</b> simply resets the idle timer; to keep the display or system in the working state, the thread must call
<b>SetThreadExecutionState</b> periodically.</para>
      <para>To run properly on a power-managed computer, applications such as fax servers, answering machines, backup agents, and network management applications must use both <b>ES_SYSTEM_REQUIRED</b> and <b>ES_CONTINUOUS</b> when they process events. Multimedia applications, such as video players and presentation applications, must use <b>ES_DISPLAY_REQUIRED</b> when they display video for long periods of time without user input. Applications such as word processors, spreadsheets, browsers, and games do not need to call
<b>SetThreadExecutionState</b>.</para>
      <para>The <b>ES_AWAYMODE_REQUIRED</b> value should be used only when absolutely necessary by media applications that require the system to perform background tasks such as recording television content or streaming media to other devices while the system appears to be sleeping. Applications that do not require critical background processing or that run on portable computers should not enable away mode because it prevents the system from conserving power by entering true sleep.</para>
      <para>To enable away mode, an application uses both <b>ES_AWAYMODE_REQUIRED</b> and <b>ES_CONTINUOUS</b>; to disable away mode, an application calls <b>SetThreadExecutionState</b> with <b>ES_CONTINUOUS</b> and clears <b>ES_AWAYMODE_REQUIRED</b>. When away mode is enabled, any operation that would put the computer to sleep puts it in away mode instead. The computer appears to be sleeping while the system continues to perform tasks that do not require user input.  Away mode does not affect the sleep idle timer; to prevent the system from entering sleep when the timer expires, an application must also set the <b>ES_SYSTEM_REQUIRED</b> value.</para>
      <para>The
<b>SetThreadExecutionState</b> function cannot be used to prevent the user from putting the computer to sleep. Applications should respect that the user expects a certain behavior when they close the lid on their laptop or press the power button.</para>
      <para>This function does not  stop the screen saver from executing.</para>
      <h4>Examples</h4>
      <code>// Television recording is beginning. Enable away mode and prevent
// the sleep idle time-out.
//
SetThreadExecutionState(ES_CONTINUOUS | ES_SYSTEM_REQUIRED | ES_AWAYMODE_REQUIRED);

//
// Wait until recording is complete...
//

//
// Clear EXECUTION_STATE flags to disable away mode and allow the system to idle to sleep normally.
//
SetThreadExecutionState(ES_CONTINUOUS);

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Power/power-management-functions">Power Management Functions</seealso>
    <seealso cref="SetSuspendState" />
    <seealso cref="SetSystemPowerState" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Power/wm-powerbroadcast">WM_POWERBROADCAST</seealso>
  </member>
  <member name="Windows.SetThreadpoolCallbackCleanupGroup">
    <summary>
      <para>Associates the specified cleanup group with the specified callback environment.</para>
    </summary>
    <param name="pcbe">
      <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="InitializeThreadpoolEnvironment" /> function returns this structure.</para>
    </param>
    <param name="ptpcg">
      <para>A <b>TP_CLEANUP_GROUP</b> structure that defines the cleanup group. The <see cref="CreateThreadpoolCleanupGroup" /> function returns this structure.</para>
    </param>
    <param name="pfng">
      <para>The cleanup callback to be called if the cleanup group is canceled before the associated object is released. The function is called when you call <see cref="CloseThreadpoolCleanupGroupMembers" />.</para>
    </param>
    <remarks>
      <para>This function is implemented as an inline function.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/using-the-thread-pool-functions">Using the Thread Pool Functions</a>.</para>
    </remarks>
    <seealso cref="DestroyThreadpoolEnvironment" />
    <seealso cref="InitializeThreadpoolEnvironment" />
    <seealso cref="SetThreadpoolCallbackLibrary" />
    <seealso cref="SetThreadpoolCallbackPool" />
    <seealso cref="SetThreadpoolCallbackPriority" />
    <seealso cref="SetThreadpoolCallbackRunsLong" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-pools">Thread Pools</seealso>
  </member>
  <member name="Windows.SetThreadpoolCallbackLibrary">
    <summary>
      <para>Ensures that the specified DLL remains loaded as long as there are outstanding callbacks.</para>
    </summary>
    <param name="pcbe">
      <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="InitializeThreadpoolEnvironment" /> function returns this structure.</para>
    </param>
    <param name="mod">
      <para>A handle to the DLL.</para>
    </param>
    <remarks>
      <para>You should call this function if a callback might acquire the loader lock. This prevents a deadlock from occurring when one thread in DllMain is waiting for the callback to end, and another thread that is executing the callback attempts to acquire the loader lock.</para>
      <para>If the DLL containing the callback might be unloaded, the cleanup code in DllMain must cancel outstanding callbacks before releasing the object.</para>
      <para>Managing callbacks created with a TP_CALLBACK_ENVIRON that specifies a callback library is somewhat processing-intensive.  You should consider other options for ensuring that the library is not unloaded while callbacks are executing, or to guarantee that callbacks which may be executing do not acquire the loader lock.</para>
      <para>The thread pool assumes ownership of the library reference supplied to this function.  The caller should not call <see cref="FreeLibrary" /> on a module handle after passing it to this function.</para>
      <para>This function is implemented as an inline function.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
    </remarks>
    <seealso cref="DestroyThreadpoolEnvironment" />
    <seealso cref="FreeLibraryWhenCallbackReturns" />
    <seealso cref="InitializeThreadpoolEnvironment" />
    <seealso cref="SetThreadpoolCallbackCleanupGroup" />
    <seealso cref="SetThreadpoolCallbackPool" />
    <seealso cref="SetThreadpoolCallbackPriority" />
    <seealso cref="SetThreadpoolCallbackRunsLong" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-pools">Thread Pools</seealso>
  </member>
  <member name="Windows.SetThreadpoolCallbackPersistent">
    <summary>
      <para>Specifies that the callback should run on a persistent thread.</para>
    </summary>
    <param name="pcbe">
      <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="InitializeThreadpoolEnvironment" /> function returns this structure.</para>
    </param>
    <remarks>
      <para>This function is implemented as an inline function.</para>
      <para>To compile an application that uses this function, set _WIN32_WINNT to _WIN32_WINNT_WIN7. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
  </member>
  <member name="Windows.SetThreadpoolCallbackPool">
    <summary>
      <para>Sets the thread pool to be used when generating callbacks.</para>
    </summary>
    <param name="pcbe">
      <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="InitializeThreadpoolEnvironment" /> function returns this structure.</para>
    </param>
    <param name="ptpp">
      <para>A <b>TP_POOL</b> structure that defines the thread pool. The <see cref="CreateThreadpool" /> function returns this structure.</para>
    </param>
    <remarks>
      <para>If you do not specify a thread pool, the global thread pool is used.</para>
      <para>This function is implemented as an inline function.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/using-the-thread-pool-functions">Using the Thread Pool Functions</a>.</para>
    </remarks>
    <seealso cref="DestroyThreadpoolEnvironment" />
    <seealso cref="InitializeThreadpoolEnvironment" />
    <seealso cref="SetThreadpoolCallbackCleanupGroup" />
    <seealso cref="SetThreadpoolCallbackLibrary" />
    <seealso cref="SetThreadpoolCallbackPriority" />
    <seealso cref="SetThreadpoolCallbackRunsLong" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-pools">Thread Pools</seealso>
  </member>
  <member name="Windows.SetThreadpoolCallbackPriority">
    <summary>
      <para>Specifies the priority of a callback function relative to other work items in the same thread pool.</para>
    </summary>
    <param name="pcbe">
      <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="InitializeThreadpoolEnvironment" /> function returns this structure.</para>
    </param>
    <param name="Priority">
      <para>The priority for the callback relative to other callbacks in the same thread pool. This parameter can be one of the following <b>TP_CALLBACK_PRIORITY</b> enumeration values:</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <b>TP_CALLBACK_PRIORITY_HIGH</b>
          </description>
          <description>
            <para>The callback should run at high priority.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TP_CALLBACK_PRIORITY_LOW</b>
          </description>
          <description>
            <para>The callback should run at low priority.</para>
          </description>
        </item>
        <item>
          <description>
            <b>TP_CALLBACK_PRIORITY_NORMAL</b>
          </description>
          <description>
            <para>The callback should run at normal priority.</para>
          </description>
        </item>
      </list>
    </param>
    <remarks>
      <para>Higher priority callbacks are guaranteed to be run first by the first available worker thread, but they are not guaranteed to finish before lower priority callbacks.</para>
      <para>This function is implemented as an inline function.</para>
      <para>To compile an application that uses this function, set _WIN32_WINNT &gt;= _WIN32_WINNT_WIN7. For more information, see <a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
  </member>
  <member name="Windows.SetThreadpoolCallbackRunsLong">
    <summary>
      <para>Indicates that callbacks associated with this callback environment may not return quickly.</para>
    </summary>
    <param name="pcbe">
      <para>A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="InitializeThreadpoolEnvironment" /> function returns this structure.</para>
    </param>
    <remarks>
      <para>The thread pool may use this information to better determine when a new thread should be created.</para>
      <para>This function is implemented as an inline function.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0600 or higher.</para>
    </remarks>
    <seealso cref="CallbackMayRunLong" />
    <seealso cref="DestroyThreadpoolEnvironment" />
    <seealso cref="InitializeThreadpoolEnvironment" />
    <seealso cref="SetThreadpoolCallbackCleanupGroup" />
    <seealso cref="SetThreadpoolCallbackLibrary" />
    <seealso cref="SetThreadpoolCallbackPool" />
    <seealso cref="SetThreadpoolCallbackPriority" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-pools">Thread Pools</seealso>
  </member>
  <member name="Windows.SetUmsThreadInformation">
    <summary>
      <para>Sets application-specific context information for the specified user-mode scheduling (UMS) worker thread.</para>
    </summary>
    <param name="UmsThread">
      <para>A pointer to a UMS thread context.</para>
    </param>
    <param name="UmsThreadInfoClass">
      <para>A <see cref="UMS_THREAD_INFO_CLASS" /> value that specifies the kind of information to set. This parameter must be <b>UmsThreadUserContext</b>.</para>
    </param>
    <param name="UmsThreadInformation">
      <para>A pointer to a buffer that contains the information to set.</para>
    </param>
    <param name="UmsThreadInformationLength">
      <para>The size of the <i>UmsThreadInformation</i> buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. Possible error values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>ERROR_INFO_LENGTH_MISMATCH</b>
            </para>
          </description>
          <description>
            <para>The buffer size does not match the  required size for the specified information class.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_INVALID_INFO_CLASS</b>
            </para>
          </description>
          <description>
            <para>The <i>UmsThreadInfoClass</i> parameter specifies an information class that is not supported.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The <b>SetUmsThreadInformation</b> function can be used to set an application-defined context for the specified UMS worker thread. The context information can consist of anything the application might find useful to track, such as per-scheduler or per-worker thread state. The underlying structures for UMS worker threads are managed by the system and should not be modified directly.</para>
      <para>The <see cref="QueryUmsThreadInformation" /> function can be used to retrieve other exposed information about the specified thread, such as its thread execution block (<see cref="TEB" />) and whether the thread is suspended or terminated. Information that is not exposed through <b>QueryUmsThreadInformation</b> should be considered reserved.</para>
    </remarks>
    <seealso cref="QueryUmsThreadInformation" />
  </member>
  <member name="Windows.SetupComm">
    <summary>
      <para>Initializes the communications parameters for a specified communications device.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the communications device. The
<see cref="CreateFile" /> function returns this handle.</para>
    </param>
    <param name="dwInQueue">
      <para>The recommended size of the device's internal input buffer, in bytes.</para>
    </param>
    <param name="dwOutQueue">
      <para>The recommended size of the device's internal output buffer, in bytes.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>After a process uses the
<see cref="CreateFile" /> function to open a handle to a communications device, but before doing any I/O with the device, it can call
<b>SetupComm</b> to set the communications parameters for the device. If it does not set them, the device uses the default parameters when the first call to another communications function occurs.</para>
      <para>The <i>dwInQueue</i> and <i>dwOutQueue</i> parameters specify the recommended sizes for the internal buffers used by the driver for the specified device. For example, YMODEM protocol packets are slightly larger than 1024 bytes. Therefore, a recommended buffer size might be 1200 bytes for YMODEM communications. For Ethernet-based communications, a recommended buffer size might be 1600 bytes, which is slightly larger than a single Ethernet frame.</para>
      <para>The device driver receives the recommended buffer sizes, but is free to use any input and output (I/O) buffering scheme, as long as it provides reasonable performance and data is not lost due to overrun (except under extreme circumstances). For example, the function can succeed even though the driver does not allocate a buffer, as long as some other portion of the system provides equivalent functionality.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="CreateFile" />
    <seealso cref="SetCommState" />
  </member>
  <member name="Windows.SetVolumeLabel">
    <summary>
      <para>Sets the label of a file system volume.</para>
    </summary>
    <param name="lpRootPathName">
      <para>A pointer to a string that contains the volume's drive letter (for example, X:) or the path
of a mounted folder that is associated with the volume (for example, Y:\MountX). The string must
end with a trailing backslash (''). If this parameter is <b>NULL</b>, the root of the
current directory is used.</para>
    </param>
    <param name="lpVolumeName">
      <para>A pointer to a string that contains the new label for the volume. If this parameter is
<b>NULL</b>, the function deletes any existing label from the specified volume and does not
assign a new label.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The maximum volume label length is 32 characters.</para>
      <para>
        <b>FAT filesystems:  </b>The maximum volume label length is 11 characters.</para>
      <para>A label is a user-friendly name that a user assigns to a volume to make it easier to recognize. A volume can
have a label, a drive letter, both, or neither. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetVolumeLabel as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetVolumeInformation" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.SetVolumeLabelA">
    <summary>
      <para>Sets the label of a file system volume.</para>
    </summary>
    <param name="lpRootPathName">
      <para>A pointer to a string that contains the volume's drive letter (for example, X:) or the path
of a mounted folder that is associated with the volume (for example, Y:\MountX). The string must
end with a trailing backslash (''). If this parameter is <b>NULL</b>, the root of the
current directory is used.</para>
    </param>
    <param name="lpVolumeName">
      <para>A pointer to a string that contains the new label for the volume. If this parameter is
<b>NULL</b>, the function deletes any existing label from the specified volume and does not
assign a new label.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The maximum volume label length is 32 characters.</para>
      <para>
        <b>FAT filesystems:  </b>The maximum volume label length is 11 characters.</para>
      <para>A label is a user-friendly name that a user assigns to a volume to make it easier to recognize. A volume can
have a label, a drive letter, both, or neither. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetVolumeLabel as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetVolumeInformation" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.SetVolumeLabelW">
    <summary>
      <para>Sets the label of a file system volume.</para>
    </summary>
    <param name="lpRootPathName">
      <para>A pointer to a string that contains the volume's drive letter (for example, X:) or the path
of a mounted folder that is associated with the volume (for example, Y:\MountX). The string must
end with a trailing backslash (''). If this parameter is <b>NULL</b>, the root of the
current directory is used.</para>
    </param>
    <param name="lpVolumeName">
      <para>A pointer to a string that contains the new label for the volume. If this parameter is
<b>NULL</b>, the function deletes any existing label from the specified volume and does not
assign a new label.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The maximum volume label length is 32 characters.</para>
      <para>
        <b>FAT filesystems:  </b>The maximum volume label length is 11 characters.</para>
      <para>A label is a user-friendly name that a user assigns to a volume to make it easier to recognize. A volume can
have a label, a drive letter, both, or neither. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetVolumeLabel as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetVolumeInformation" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.SetVolumeLabel">
    <summary>
      <para>Sets the label of a file system volume.</para>
    </summary>
    <param name="lpRootPathName">
      <para>A pointer to a string that contains the volume's drive letter (for example, X:) or the path
of a mounted folder that is associated with the volume (for example, Y:\MountX). The string must
end with a trailing backslash (''). If this parameter is <b>NULL</b>, the root of the
current directory is used.</para>
    </param>
    <param name="lpVolumeName">
      <para>A pointer to a string that contains the new label for the volume. If this parameter is
<b>NULL</b>, the function deletes any existing label from the specified volume and does not
assign a new label.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The maximum volume label length is 32 characters.</para>
      <para>
        <b>FAT filesystems:  </b>The maximum volume label length is 11 characters.</para>
      <para>A label is a user-friendly name that a user assigns to a volume to make it easier to recognize. A volume can
have a label, a drive letter, both, or neither. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetVolumeLabel as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetVolumeInformation" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.SetVolumeLabelA">
    <summary>
      <para>Sets the label of a file system volume.</para>
    </summary>
    <param name="lpRootPathName">
      <para>A pointer to a string that contains the volume's drive letter (for example, X:) or the path
of a mounted folder that is associated with the volume (for example, Y:\MountX). The string must
end with a trailing backslash (''). If this parameter is <b>NULL</b>, the root of the
current directory is used.</para>
    </param>
    <param name="lpVolumeName">
      <para>A pointer to a string that contains the new label for the volume. If this parameter is
<b>NULL</b>, the function deletes any existing label from the specified volume and does not
assign a new label.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The maximum volume label length is 32 characters.</para>
      <para>
        <b>FAT filesystems:  </b>The maximum volume label length is 11 characters.</para>
      <para>A label is a user-friendly name that a user assigns to a volume to make it easier to recognize. A volume can
have a label, a drive letter, both, or neither. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetVolumeLabel as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetVolumeInformation" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.SetVolumeLabelW">
    <summary>
      <para>Sets the label of a file system volume.</para>
    </summary>
    <param name="lpRootPathName">
      <para>A pointer to a string that contains the volume's drive letter (for example, X:) or the path
of a mounted folder that is associated with the volume (for example, Y:\MountX). The string must
end with a trailing backslash (''). If this parameter is <b>NULL</b>, the root of the
current directory is used.</para>
    </param>
    <param name="lpVolumeName">
      <para>A pointer to a string that contains the new label for the volume. If this parameter is
<b>NULL</b>, the function deletes any existing label from the specified volume and does not
assign a new label.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The maximum volume label length is 32 characters.</para>
      <para>
        <b>FAT filesystems:  </b>The maximum volume label length is 11 characters.</para>
      <para>A label is a user-friendly name that a user assigns to a volume to make it easier to recognize. A volume can
have a label, a drive letter, both, or neither. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetVolumeLabel as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="GetVolumeInformation" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.SetVolumeMountPoint">
    <summary>
      <para>Associates a volume with a drive letter or a directory on another volume.</para>
    </summary>
    <param name="lpszVolumeMountPoint">
      <para>The user-mode path to be associated with the volume. This may be a drive letter (for example, "X:") or a directory
on another volume (for example, "Y:\MountX"). The string must end with a trailing backslash ('').</para>
    </param>
    <param name="lpszVolumeName">
      <para>A volume <b>GUID</b> path for the volume. This string must be of the form
"\\?\Volume{<i>GUID</i>}" where <i>GUID</i> is a <b>GUID</b> that identifies
the volume. The "\\?" turns off path parsing and is ignored as part of the path, as discussed in
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the <i>lpszVolumeMountPoint</i> parameter contains a path to a mounted folder, <see cref="GetLastError" /> returns <b>ERROR_DIR_NOT_EMPTY</b>, even if the directory is empty.</para>
    </returns>
    <remarks>
      <para>When this function is used to associate a volume with a directory on another volume, the associated directory is called a <i>mounted folder</i>.</para>
      <para>It is an error to associate a volume with a directory that has any files or subdirectories in it. This
error occurs for system and hidden directories as well as other directories, and it occurs for system and hidden
files.</para>
      <para>When mounted folders are created on a volume on a clustered disk, they may be deleted unexpectedly under certain
circumstances. For information on how to create and configure mounted folders to ensure that this does not happen,
see <a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2003/cc757627(v=ws.10)">Cluster Disk and Drive Connection Problems</a>.</para>
      <para>IIn Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. For CsvFS a new mount point will not be replicated to the other nodes on the cluster.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/mounting-a-volume-at-a-mount-point">Creating a Mounted Folder</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="GetVolumeNameForVolumeMountPoint" />
    <seealso cref="GetVolumePathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.SetVolumeMountPointA">
    <summary>
      <para>Associates a volume with a drive letter or a directory on another volume.</para>
    </summary>
    <param name="lpszVolumeMountPoint">
      <para>The user-mode path to be associated with the volume. This may be a drive letter (for example, "X:") or a directory
on another volume (for example, "Y:\MountX"). The string must end with a trailing backslash ('').</para>
    </param>
    <param name="lpszVolumeName">
      <para>A volume <b>GUID</b> path for the volume. This string must be of the form
"\\?\Volume{<i>GUID</i>}" where <i>GUID</i> is a <b>GUID</b> that identifies
the volume. The "\\?" turns off path parsing and is ignored as part of the path, as discussed in
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the <i>lpszVolumeMountPoint</i> parameter contains a path to a mounted folder, <see cref="GetLastError" /> returns <b>ERROR_DIR_NOT_EMPTY</b>, even if the directory is empty.</para>
    </returns>
    <remarks>
      <para>When this function is used to associate a volume with a directory on another volume, the associated directory is called a <i>mounted folder</i>.</para>
      <para>It is an error to associate a volume with a directory that has any files or subdirectories in it. This
error occurs for system and hidden directories as well as other directories, and it occurs for system and hidden
files.</para>
      <para>When mounted folders are created on a volume on a clustered disk, they may be deleted unexpectedly under certain
circumstances. For information on how to create and configure mounted folders to ensure that this does not happen,
see <a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2003/cc757627(v=ws.10)">Cluster Disk and Drive Connection Problems</a>.</para>
      <para>IIn Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. For CsvFS a new mount point will not be replicated to the other nodes on the cluster.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/mounting-a-volume-at-a-mount-point">Creating a Mounted Folder</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="GetVolumeNameForVolumeMountPoint" />
    <seealso cref="GetVolumePathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.SetVolumeMountPointW">
    <summary>
      <para>Associates a volume with a drive letter or a directory on another volume.</para>
    </summary>
    <param name="lpszVolumeMountPoint">
      <para>The user-mode path to be associated with the volume. This may be a drive letter (for example, "X:") or a directory
on another volume (for example, "Y:\MountX"). The string must end with a trailing backslash ('').</para>
    </param>
    <param name="lpszVolumeName">
      <para>A volume <b>GUID</b> path for the volume. This string must be of the form
"\\?\Volume{<i>GUID</i>}" where <i>GUID</i> is a <b>GUID</b> that identifies
the volume. The "\\?" turns off path parsing and is ignored as part of the path, as discussed in
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the <i>lpszVolumeMountPoint</i> parameter contains a path to a mounted folder, <see cref="GetLastError" /> returns <b>ERROR_DIR_NOT_EMPTY</b>, even if the directory is empty.</para>
    </returns>
    <remarks>
      <para>When this function is used to associate a volume with a directory on another volume, the associated directory is called a <i>mounted folder</i>.</para>
      <para>It is an error to associate a volume with a directory that has any files or subdirectories in it. This
error occurs for system and hidden directories as well as other directories, and it occurs for system and hidden
files.</para>
      <para>When mounted folders are created on a volume on a clustered disk, they may be deleted unexpectedly under certain
circumstances. For information on how to create and configure mounted folders to ensure that this does not happen,
see <a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2003/cc757627(v=ws.10)">Cluster Disk and Drive Connection Problems</a>.</para>
      <para>IIn Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. For CsvFS a new mount point will not be replicated to the other nodes on the cluster.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/mounting-a-volume-at-a-mount-point">Creating a Mounted Folder</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="GetVolumeNameForVolumeMountPoint" />
    <seealso cref="GetVolumePathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.SetVolumeMountPoint">
    <summary>
      <para>Associates a volume with a drive letter or a directory on another volume.</para>
    </summary>
    <param name="lpszVolumeMountPoint">
      <para>The user-mode path to be associated with the volume. This may be a drive letter (for example, "X:") or a directory
on another volume (for example, "Y:\MountX"). The string must end with a trailing backslash ('').</para>
    </param>
    <param name="lpszVolumeName">
      <para>A volume <b>GUID</b> path for the volume. This string must be of the form
"\\?\Volume{<i>GUID</i>}\" where <i>GUID</i> is a <b>GUID</b> that identifies
the volume. The "\\?\" turns off path parsing and is ignored as part of the path, as discussed in
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the <i>lpszVolumeMountPoint</i> parameter contains a path to a mounted folder, <see cref="GetLastError" /> returns <b>ERROR_DIR_NOT_EMPTY</b>, even if the directory is empty.</para>
    </returns>
    <remarks>
      <para>When this function is used to associate a volume with a directory on another volume, the associated directory is called a <i>mounted folder</i>.</para>
      <para>It is an error to associate a volume with a directory that has any files or subdirectories in it. This
error occurs for system and hidden directories as well as other directories, and it occurs for system and hidden
files.</para>
      <para>When mounted folders are created on a volume on a clustered disk, they may be deleted unexpectedly under certain
circumstances. For information on how to create and configure mounted folders to ensure that this does not happen,
see <a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2003/cc757627(v=ws.10)">Cluster Disk and Drive Connection Problems</a>.</para>
      <para>IIn Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. For CsvFS a new mount point will not be replicated to the other nodes on the cluster.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/mounting-a-volume-at-a-mount-point">Creating a Mounted Folder</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="GetVolumeNameForVolumeMountPoint" />
    <seealso cref="GetVolumePathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.SetVolumeMountPointA">
    <summary>
      <para>Associates a volume with a drive letter or a directory on another volume.</para>
    </summary>
    <param name="lpszVolumeMountPoint">
      <para>The user-mode path to be associated with the volume. This may be a drive letter (for example, "X:") or a directory
on another volume (for example, "Y:\MountX"). The string must end with a trailing backslash ('').</para>
    </param>
    <param name="lpszVolumeName">
      <para>A volume <b>GUID</b> path for the volume. This string must be of the form
"\\?\Volume{<i>GUID</i>}\" where <i>GUID</i> is a <b>GUID</b> that identifies
the volume. The "\\?\" turns off path parsing and is ignored as part of the path, as discussed in
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the <i>lpszVolumeMountPoint</i> parameter contains a path to a mounted folder, <see cref="GetLastError" /> returns <b>ERROR_DIR_NOT_EMPTY</b>, even if the directory is empty.</para>
    </returns>
    <remarks>
      <para>When this function is used to associate a volume with a directory on another volume, the associated directory is called a <i>mounted folder</i>.</para>
      <para>It is an error to associate a volume with a directory that has any files or subdirectories in it. This
error occurs for system and hidden directories as well as other directories, and it occurs for system and hidden
files.</para>
      <para>When mounted folders are created on a volume on a clustered disk, they may be deleted unexpectedly under certain
circumstances. For information on how to create and configure mounted folders to ensure that this does not happen,
see <a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2003/cc757627(v=ws.10)">Cluster Disk and Drive Connection Problems</a>.</para>
      <para>IIn Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. For CsvFS a new mount point will not be replicated to the other nodes on the cluster.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/mounting-a-volume-at-a-mount-point">Creating a Mounted Folder</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="GetVolumeNameForVolumeMountPoint" />
    <seealso cref="GetVolumePathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.SetVolumeMountPointW">
    <summary>
      <para>Associates a volume with a drive letter or a directory on another volume.</para>
    </summary>
    <param name="lpszVolumeMountPoint">
      <para>The user-mode path to be associated with the volume. This may be a drive letter (for example, "X:") or a directory
on another volume (for example, "Y:\MountX"). The string must end with a trailing backslash ('').</para>
    </param>
    <param name="lpszVolumeName">
      <para>A volume <b>GUID</b> path for the volume. This string must be of the form
"\\?\Volume{<i>GUID</i>}\" where <i>GUID</i> is a <b>GUID</b> that identifies
the volume. The "\\?\" turns off path parsing and is ignored as part of the path, as discussed in
<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
      <para>If the <i>lpszVolumeMountPoint</i> parameter contains a path to a mounted folder, <see cref="GetLastError" /> returns <b>ERROR_DIR_NOT_EMPTY</b>, even if the directory is empty.</para>
    </returns>
    <remarks>
      <para>When this function is used to associate a volume with a directory on another volume, the associated directory is called a <i>mounted folder</i>.</para>
      <para>It is an error to associate a volume with a directory that has any files or subdirectories in it. This
error occurs for system and hidden directories as well as other directories, and it occurs for system and hidden
files.</para>
      <para>When mounted folders are created on a volume on a clustered disk, they may be deleted unexpectedly under certain
circumstances. For information on how to create and configure mounted folders to ensure that this does not happen,
see <a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2003/cc757627(v=ws.10)">Cluster Disk and Drive Connection Problems</a>.</para>
      <para>IIn Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB does not support volume management functions. For CsvFS a new mount point will not be replicated to the other nodes on the cluster.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/FileIO/mounting-a-volume-at-a-mount-point">Creating a Mounted Folder</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines SetVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DeleteVolumeMountPoint" />
    <seealso cref="GetVolumeNameForVolumeMountPoint" />
    <seealso cref="GetVolumePathName" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-mount-points">Mounted Folders</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/volume-management-functions">Volume Management Functions</seealso>
  </member>
  <member name="Windows.SetXStateFeaturesMask">
    <summary>
      <para>Sets the mask of XState features set within a
<see cref="CONTEXT" /> structure.</para>
    </summary>
    <param name="Context">
      <para>A pointer to a <see cref="CONTEXT" /> structure that has been
initialized with <see cref="InitializeContext" />.</para>
    </param>
    <param name="FeatureMask">
      <para>A mask of XState features to set in the specified
<see cref="CONTEXT" /> structure.</para>
    </param>
    <returns>
      <para>This function returns <b>TRUE</b> if successful, otherwise
<b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The <b>SetXStateFeaturesMask</b> function sets the
mask of valid features in the specified context. Before calling
<see cref="GetThreadContext" />,
<see cref="Wow64GetThreadContext" />,
<see cref="SetThreadContext" />, or
<see cref="Wow64SetThreadContext" /> the application must call
<b>SetXStateFeaturesMask</b> to specify which set of
features to retrieve or set.  The system silently ignores any feature specified in the
<i>FeatureMask</i> which is not enabled on the processor.</para>
      <para>
        <b>Windows 7 with SP1 and Windows Server 2008 R2 with SP1:  </b>The <a href="https://docs.microsoft.com//windows/desktop/Debug/avx-support-portal">AVX API</a> is first implemented on
Windows 7 with SP1 and Windows Server 2008 R2 with SP1 . Since there is no SDK for SP1, that means there are
no available headers and library files to work with. In this situation, a caller must declare the needed
functions from this documentation and get pointers to them using
<see cref="GetModuleHandle" /> on
"Kernel32.dll", followed by calls to
<see cref="GetProcAddress" />. See
<a href="https://docs.microsoft.com//windows/desktop/Debug/working-with-xstate-context">Working with XState Context</a> for
details.</para>
    </remarks>
    <seealso cref="CONTEXT" />
    <seealso cref="GetThreadContext" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/avx-support-portal">Intel AVX</seealso>
    <seealso cref="SetThreadContext" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/working-with-xstate-context">Working with XState Context</seealso>
    <seealso cref="Wow64GetThreadContext" />
    <seealso cref="Wow64SetThreadContext" />
  </member>
  <member name="Windows.SwitchToFiber">
    <summary>
      <para>Schedules a fiber. The function must be called on a fiber.</para>
    </summary>
    <param name="lpFiber">
      <para>The address of the fiber to be scheduled.</para>
    </param>
    <remarks>
      <para>You create fibers with the
<see cref="CreateFiber" /> function. Before you can schedule fibers associated with a thread, you must call
<see cref="ConvertThreadToFiber" /> to set up an area in which to save the fiber state information. The thread is now the currently executing fiber.</para>
      <para>The
<b>SwitchToFiber</b> function saves the state information of the current fiber and restores the state of the specified fiber. You can call
<b>SwitchToFiber</b> with the address of a fiber created by a different thread. To do this, you must have the address returned to the other thread when it called
<see cref="CreateFiber" /> and you must use proper synchronization.</para>
      <para>Avoid making the following call:</para>
      <code>SwitchToFiber( GetCurrentFiber() );
</code>
      <para>This call can cause unpredictable problems.</para>
      <para>To compile an application that uses this function, define _WIN32_WINNT as 0x0400 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="ConvertThreadToFiber" />
    <seealso cref="CreateFiber" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/fibers">Fibers</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
  </member>
  <member name="Windows.TransmitCommChar">
    <summary>
      <para>Transmits a specified character ahead of any pending data in the output buffer of the specified communications device.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the communications device. The
<see cref="CreateFile" /> function returns this handle.</para>
    </param>
    <param name="cChar">
      <para>The character to be transmitted.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>TransmitCommChar</b> function is useful for sending an interrupt character (such as a CTRL+C) to a host system.</para>
      <para>If the device is not transmitting,
<b>TransmitCommChar</b> cannot be called repeatedly. Once
<b>TransmitCommChar</b> places a character in the output buffer, the character must be transmitted before the function can be called again. If the previous character has not yet been sent,
<b>TransmitCommChar</b> returns an error.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="CreateFile" />
    <seealso cref="WaitCommEvent" />
  </member>
  <member name="Windows.UmsThreadYield">
    <summary>
      <para>Yields control to the user-mode scheduling (UMS) scheduler thread on which the calling UMS worker thread is running.</para>
    </summary>
    <param name="SchedulerParam">
      <para>A parameter to pass to the scheduler thread's <a href="https://docs.microsoft.com//windows/desktop/api/winnt/nc-winnt-rtl_ums_scheduler_entry_point">UmsSchedulerProc</a> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>A UMS worker thread calls the <b>UmsThreadYield</b> function to cooperatively yield control to the UMS scheduler thread on which the worker thread is running. If a UMS worker thread never calls <b>UmsThreadYield</b>, the worker thread runs until it either blocks or is terminated.</para>
      <para>When control switches to the UMS scheduler thread, the system calls the associated scheduler entry point function with the reason <b>UmsSchedulerThreadYield</b> and the <i>ScheduleParam</i> parameter specified by the worker thread in the <b>UmsThreadYield</b> call.</para>
      <para>The application's scheduler is responsible for rescheduling the worker thread.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winnt/nc-winnt-rtl_ums_scheduler_entry_point">UmsSchedulerProc</seealso>
  </member>
  <member name="Windows.UnregisterApplicationRecoveryCallback">
    <summary>
      <para>Removes the active instance of an application from the recovery list.</para>
    </summary>
    <returns>
      <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>E_FAIL</b>
            </para>
          </description>
          <description>
            <para>Internal error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>You do not need to call this function before exiting. You need to remove the registration only if you choose to not recover data.</para>
    </remarks>
    <seealso cref="RegisterApplicationRecoveryCallback" />
  </member>
  <member name="Windows.UnregisterApplicationRestart">
    <summary>
      <para>Removes the active instance of an application from the restart list.</para>
    </summary>
    <returns>
      <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>E_FAIL</b>
            </para>
          </description>
          <description>
            <para>Internal error.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>You do not need to call this function before exiting. You need to remove the registration only if you choose to not restart the application. For example, you could remove the registration if your application entered a corrupted state where a future restart would also fail. You must call this function before the application fails abnormally.</para>
    </remarks>
    <seealso cref="RegisterApplicationRestart" />
  </member>
  <member name="Windows.UnregisterWait">
    <summary>
      <para>Cancels a registered wait operation issued by the
<see cref="RegisterWaitForSingleObject" /> function.</para>
      <para>To use a completion event, call the
<a href="https://docs.microsoft.com//windows/desktop/Sync/unregisterwaitex">UnregisterWaitEx</a> function.</para>
    </summary>
    <param name="WaitHandle">
      <para>The wait handle. This handle is returned by the
<see cref="RegisterWaitForSingleObject" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If any callback functions associated with the timer have not completed when <b>UnregisterWait</b> is called, <b>UnregisterWait</b> unregisters the wait on the callback functions and fails with the <b>ERROR_IO_PENDING</b> error code. The error code does not indicate that the function has failed, and the function does not need to be called again. If your code requires an error code to set only when the unregister operation has failed, call <a href="https://docs.microsoft.com//windows/desktop/Sync/unregisterwaitex">UnregisterWaitEx</a> instead.</para>
      <para>To compile an application that uses this function, define <b>_WIN32_WINNT</b> as 0x0500 or later. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.</para>
    </remarks>
    <seealso cref="RegisterWaitForSingleObject" />
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-functions">Synchronization Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-pooling">Thread Pooling</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/Sync/unregisterwaitex">UnregisterWaitEx</seealso>
  </member>
  <member name="Windows.UpdateResource">
    <summary>
      <para>Adds, deletes, or replaces a resource in a portable executable (PE) file. There are some restrictions on resource updates in files that contain Resource Configuration (RC Config) data: <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral</a> (LN) files and language-specific resource (.mui) files.</para>
    </summary>
    <param name="hUpdate">
      <para>Type: <b>HANDLE</b></para>
      <para>A module handle returned by the <see cref="BeginUpdateResource" /> function, referencing the file to be updated.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The resource type to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-types">Resource Types</a>.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is a resource ID. When creating a new resource do not use a string that begins with a '#' character for this parameter.</para>
    </param>
    <param name="wLanguage">
      <para>Type: <b>WORD</b></para>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">language identifier</a> of the resource to be updated. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the <see cref="MAKELANGID" />  macro.</para>
    </param>
    <param name="lpData">
      <para>Type: <b>LPVOID</b></para>
      <para>The resource data to be inserted into the file indicated by <i>hUpdate</i>. If the resource is one of the predefined types, the data must be valid and properly aligned. Note that this is the raw binary data to be stored in the file indicated by <i>hUpdate</i>, not the data provided by <see cref="LoadIcon" />, <see cref="LoadString" />, or other resource-specific load functions. All data containing strings or text must be in Unicode format. <i>lpData</i> must not point to ANSI data.</para>
      <para>If <i>lpData</i> is <b>NULL</b> and <i>cbData</i> is 0, the specified resource is deleted from the file indicated by <i>hUpdate</i>.</para>
    </param>
    <param name="cb">
      <para>Type: <b>DWORD</b></para>
      <para>The size, in bytes, of the resource data at <i>lpData</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>It is recommended that the resource file is not loaded before this function is called. However, if that file is already loaded, it will not cause an error to be returned.</para>
      <para>An application can use <b>UpdateResource</b> repeatedly to make changes to the resource data. Each call to <b>UpdateResource</b> contributes to an internal list of additions, deletions, and replacements but does not actually write the data to the file indicated by <i>hUpdate</i>. The application must use the <see cref="EndUpdateResource" /> function to write the accumulated changes to the file.</para>
      <para>This function can update resources within modules that contain both code and resources.</para>
      <para>
        <b>Prior to Windows 7:</b> If <i>lpData</i> is <b>NULL</b> and <i>cbData</i> is nonzero, the specified resource is NOT deleted and an exception is thrown.</para>
      <para>
        <b>Starting with Windows Vista:</b> As noted above, there are restrictions on resource updates in files that contain RC Config data: LN files and .mui files. The restrictions are as follows:</para>
      <list type="table">
        <listheader>
          <description>Action</description>
          <description>LN file</description>
          <description>.mui file</description>
        </listheader>
        <item>
          <description>1. Add a new type that doesn't exist in the LN or .mui files.</description>
          <description>Add type in the LN file and treat as language-neutral (non-localizable) and add new type or item in the RC Config data</description>
          <description>The only additions allowed are the following types: file Version, RC Config data, Side-by-side Assembly XML Manifest.</description>
        </item>
        <item>
          <description>2. Add a new resource item to an existing type.</description>
          <description>Uses the RC Config data to check whether the type exists in the .mui files associated with this LN file. If the type doesn't exist in the .mui files, add the item and treat new item as un-localizable. If the type exists in the .mui files, then adding is not allowed.</description>
          <description>Only items of the following types may be added: File Version, RC Config data, Side-by-side Assembly XML Manifest.</description>
        </item>
        <item>
          <description>3. Update a resource item.</description>
          <description>Uses the RC Config data to check whether the type exists in the .mui files associated with the LN file. If the type doesn't exist in the .mui files, then this resource item update is allowed in the LN file. Otherwise, if the type exists in the .mui files associated with this LN file, then this update is not allowed.</description>
          <description>The only updates allowed are items of the following types: file Version, RC Config data, Side-by-side Assembly XML Manifest.</description>
        </item>
        <item>
          <description>4. Add a type/item for a new language.</description>
          <description>Not allowed.</description>
          <description>Not allowed.</description>
        </item>
        <item>
          <description>5. Remove an existing type/item.</description>
          <description>Works similarly to case 3. Uses the RC Config data to check whether the type exists in the .mui files associated with the LN file. If not, then the removal of the type/item from the LN file is allowed.  Otherwise, if the type/item exists in the .mui files associated with this LN file, then the removal is not allowed.</description>
          <description>The only types allowed to be removed are: file Version, RC Config data, Side-by-side Assembly XML Manifest; also, only items of these types may be removed.</description>
        </item>
        <item>
          <description>6. Add/delete/update a type not included in the RC Config data (such as Version, Side-by-side Assembly XML Manifest, or RC Config data itself). </description>
          <description>Allowed.</description>
          <description>Allowed.</description>
        </item>
        <item>
          <description>7. Other update of non-localizable data, such as TYPELIB, reginst, and so on.</description>
          <description>Update type or item in the LN file, treat as non-localizable, and add new type or item in the RC Config data.</description>
          <description>Not applicable.</description>
        </item>
        <item>
          <description>8. Add RC Config data.</description>
          <description>Can be done but the integrity of the RC Config data is not checked.</description>
          <description>Can be done but the integrity of the RC Config data is not checked.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines UpdateResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BeginUpdateResource" />
    <seealso cref="EndUpdateResource" />
    <seealso cref="LoadIcon" />
    <seealso cref="LoadString" />
    <seealso cref="LockResource" />
    <seealso cref="MAKEINTRESOURCE" />
    <seealso cref="MAKELANGID" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="SizeofResource" />
  </member>
  <member name="Windows.UpdateResourceA">
    <summary>
      <para>Adds, deletes, or replaces a resource in a portable executable (PE) file. There are some restrictions on resource updates in files that contain Resource Configuration (RC Config) data: <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral</a> (LN) files and language-specific resource (.mui) files.</para>
    </summary>
    <param name="hUpdate">
      <para>Type: <b>HANDLE</b></para>
      <para>A module handle returned by the <see cref="BeginUpdateResource" /> function, referencing the file to be updated.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The resource type to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-types">Resource Types</a>.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is a resource ID. When creating a new resource do not use a string that begins with a '#' character for this parameter.</para>
    </param>
    <param name="wLanguage">
      <para>Type: <b>WORD</b></para>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">language identifier</a> of the resource to be updated. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the <see cref="MAKELANGID" />  macro.</para>
    </param>
    <param name="lpData">
      <para>Type: <b>LPVOID</b></para>
      <para>The resource data to be inserted into the file indicated by <i>hUpdate</i>. If the resource is one of the predefined types, the data must be valid and properly aligned. Note that this is the raw binary data to be stored in the file indicated by <i>hUpdate</i>, not the data provided by <see cref="LoadIcon" />, <see cref="LoadString" />, or other resource-specific load functions. All data containing strings or text must be in Unicode format. <i>lpData</i> must not point to ANSI data.</para>
      <para>If <i>lpData</i> is <b>NULL</b> and <i>cbData</i> is 0, the specified resource is deleted from the file indicated by <i>hUpdate</i>.</para>
    </param>
    <param name="cb">
      <para>Type: <b>DWORD</b></para>
      <para>The size, in bytes, of the resource data at <i>lpData</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>It is recommended that the resource file is not loaded before this function is called. However, if that file is already loaded, it will not cause an error to be returned.</para>
      <para>An application can use <b>UpdateResource</b> repeatedly to make changes to the resource data. Each call to <b>UpdateResource</b> contributes to an internal list of additions, deletions, and replacements but does not actually write the data to the file indicated by <i>hUpdate</i>. The application must use the <see cref="EndUpdateResource" /> function to write the accumulated changes to the file.</para>
      <para>This function can update resources within modules that contain both code and resources.</para>
      <para>
        <b>Prior to Windows 7:</b> If <i>lpData</i> is <b>NULL</b> and <i>cbData</i> is nonzero, the specified resource is NOT deleted and an exception is thrown.</para>
      <para>
        <b>Starting with Windows Vista:</b> As noted above, there are restrictions on resource updates in files that contain RC Config data: LN files and .mui files. The restrictions are as follows:</para>
      <list type="table">
        <listheader>
          <description>Action</description>
          <description>LN file</description>
          <description>.mui file</description>
        </listheader>
        <item>
          <description>1. Add a new type that doesn't exist in the LN or .mui files.</description>
          <description>Add type in the LN file and treat as language-neutral (non-localizable) and add new type or item in the RC Config data</description>
          <description>The only additions allowed are the following types: file Version, RC Config data, Side-by-side Assembly XML Manifest.</description>
        </item>
        <item>
          <description>2. Add a new resource item to an existing type.</description>
          <description>Uses the RC Config data to check whether the type exists in the .mui files associated with this LN file. If the type doesn't exist in the .mui files, add the item and treat new item as un-localizable. If the type exists in the .mui files, then adding is not allowed.</description>
          <description>Only items of the following types may be added: File Version, RC Config data, Side-by-side Assembly XML Manifest.</description>
        </item>
        <item>
          <description>3. Update a resource item.</description>
          <description>Uses the RC Config data to check whether the type exists in the .mui files associated with the LN file. If the type doesn't exist in the .mui files, then this resource item update is allowed in the LN file. Otherwise, if the type exists in the .mui files associated with this LN file, then this update is not allowed.</description>
          <description>The only updates allowed are items of the following types: file Version, RC Config data, Side-by-side Assembly XML Manifest.</description>
        </item>
        <item>
          <description>4. Add a type/item for a new language.</description>
          <description>Not allowed.</description>
          <description>Not allowed.</description>
        </item>
        <item>
          <description>5. Remove an existing type/item.</description>
          <description>Works similarly to case 3. Uses the RC Config data to check whether the type exists in the .mui files associated with the LN file. If not, then the removal of the type/item from the LN file is allowed.  Otherwise, if the type/item exists in the .mui files associated with this LN file, then the removal is not allowed.</description>
          <description>The only types allowed to be removed are: file Version, RC Config data, Side-by-side Assembly XML Manifest; also, only items of these types may be removed.</description>
        </item>
        <item>
          <description>6. Add/delete/update a type not included in the RC Config data (such as Version, Side-by-side Assembly XML Manifest, or RC Config data itself). </description>
          <description>Allowed.</description>
          <description>Allowed.</description>
        </item>
        <item>
          <description>7. Other update of non-localizable data, such as TYPELIB, reginst, and so on.</description>
          <description>Update type or item in the LN file, treat as non-localizable, and add new type or item in the RC Config data.</description>
          <description>Not applicable.</description>
        </item>
        <item>
          <description>8. Add RC Config data.</description>
          <description>Can be done but the integrity of the RC Config data is not checked.</description>
          <description>Can be done but the integrity of the RC Config data is not checked.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines UpdateResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BeginUpdateResource" />
    <seealso cref="EndUpdateResource" />
    <seealso cref="LoadIcon" />
    <seealso cref="LoadString" />
    <seealso cref="LockResource" />
    <seealso cref="MAKEINTRESOURCE" />
    <seealso cref="MAKELANGID" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="SizeofResource" />
  </member>
  <member name="Windows.UpdateResourceW">
    <summary>
      <para>Adds, deletes, or replaces a resource in a portable executable (PE) file. There are some restrictions on resource updates in files that contain Resource Configuration (RC Config) data: <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral</a> (LN) files and language-specific resource (.mui) files.</para>
    </summary>
    <param name="hUpdate">
      <para>Type: <b>HANDLE</b></para>
      <para>A module handle returned by the <see cref="BeginUpdateResource" /> function, referencing the file to be updated.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The resource type to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-types">Resource Types</a>.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is a resource ID. When creating a new resource do not use a string that begins with a '#' character for this parameter.</para>
    </param>
    <param name="wLanguage">
      <para>Type: <b>WORD</b></para>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">language identifier</a> of the resource to be updated. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the <see cref="MAKELANGID" />  macro.</para>
    </param>
    <param name="lpData">
      <para>Type: <b>LPVOID</b></para>
      <para>The resource data to be inserted into the file indicated by <i>hUpdate</i>. If the resource is one of the predefined types, the data must be valid and properly aligned. Note that this is the raw binary data to be stored in the file indicated by <i>hUpdate</i>, not the data provided by <see cref="LoadIcon" />, <see cref="LoadString" />, or other resource-specific load functions. All data containing strings or text must be in Unicode format. <i>lpData</i> must not point to ANSI data.</para>
      <para>If <i>lpData</i> is <b>NULL</b> and <i>cbData</i> is 0, the specified resource is deleted from the file indicated by <i>hUpdate</i>.</para>
    </param>
    <param name="cb">
      <para>Type: <b>DWORD</b></para>
      <para>The size, in bytes, of the resource data at <i>lpData</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>It is recommended that the resource file is not loaded before this function is called. However, if that file is already loaded, it will not cause an error to be returned.</para>
      <para>An application can use <b>UpdateResource</b> repeatedly to make changes to the resource data. Each call to <b>UpdateResource</b> contributes to an internal list of additions, deletions, and replacements but does not actually write the data to the file indicated by <i>hUpdate</i>. The application must use the <see cref="EndUpdateResource" /> function to write the accumulated changes to the file.</para>
      <para>This function can update resources within modules that contain both code and resources.</para>
      <para>
        <b>Prior to Windows 7:</b> If <i>lpData</i> is <b>NULL</b> and <i>cbData</i> is nonzero, the specified resource is NOT deleted and an exception is thrown.</para>
      <para>
        <b>Starting with Windows Vista:</b> As noted above, there are restrictions on resource updates in files that contain RC Config data: LN files and .mui files. The restrictions are as follows:</para>
      <list type="table">
        <listheader>
          <description>Action</description>
          <description>LN file</description>
          <description>.mui file</description>
        </listheader>
        <item>
          <description>1. Add a new type that doesn't exist in the LN or .mui files.</description>
          <description>Add type in the LN file and treat as language-neutral (non-localizable) and add new type or item in the RC Config data</description>
          <description>The only additions allowed are the following types: file Version, RC Config data, Side-by-side Assembly XML Manifest.</description>
        </item>
        <item>
          <description>2. Add a new resource item to an existing type.</description>
          <description>Uses the RC Config data to check whether the type exists in the .mui files associated with this LN file. If the type doesn't exist in the .mui files, add the item and treat new item as un-localizable. If the type exists in the .mui files, then adding is not allowed.</description>
          <description>Only items of the following types may be added: File Version, RC Config data, Side-by-side Assembly XML Manifest.</description>
        </item>
        <item>
          <description>3. Update a resource item.</description>
          <description>Uses the RC Config data to check whether the type exists in the .mui files associated with the LN file. If the type doesn't exist in the .mui files, then this resource item update is allowed in the LN file. Otherwise, if the type exists in the .mui files associated with this LN file, then this update is not allowed.</description>
          <description>The only updates allowed are items of the following types: file Version, RC Config data, Side-by-side Assembly XML Manifest.</description>
        </item>
        <item>
          <description>4. Add a type/item for a new language.</description>
          <description>Not allowed.</description>
          <description>Not allowed.</description>
        </item>
        <item>
          <description>5. Remove an existing type/item.</description>
          <description>Works similarly to case 3. Uses the RC Config data to check whether the type exists in the .mui files associated with the LN file. If not, then the removal of the type/item from the LN file is allowed.  Otherwise, if the type/item exists in the .mui files associated with this LN file, then the removal is not allowed.</description>
          <description>The only types allowed to be removed are: file Version, RC Config data, Side-by-side Assembly XML Manifest; also, only items of these types may be removed.</description>
        </item>
        <item>
          <description>6. Add/delete/update a type not included in the RC Config data (such as Version, Side-by-side Assembly XML Manifest, or RC Config data itself). </description>
          <description>Allowed.</description>
          <description>Allowed.</description>
        </item>
        <item>
          <description>7. Other update of non-localizable data, such as TYPELIB, reginst, and so on.</description>
          <description>Update type or item in the LN file, treat as non-localizable, and add new type or item in the RC Config data.</description>
          <description>Not applicable.</description>
        </item>
        <item>
          <description>8. Add RC Config data.</description>
          <description>Can be done but the integrity of the RC Config data is not checked.</description>
          <description>Can be done but the integrity of the RC Config data is not checked.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines UpdateResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BeginUpdateResource" />
    <seealso cref="EndUpdateResource" />
    <seealso cref="LoadIcon" />
    <seealso cref="LoadString" />
    <seealso cref="LockResource" />
    <seealso cref="MAKEINTRESOURCE" />
    <seealso cref="MAKELANGID" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="SizeofResource" />
  </member>
  <member name="Windows.UpdateResource">
    <summary>
      <para>Adds, deletes, or replaces a resource in a portable executable (PE) file. There are some restrictions on resource updates in files that contain Resource Configuration (RC Config) data: <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral</a> (LN) files and language-specific resource (.mui) files.</para>
    </summary>
    <param name="hUpdate">
      <para>Type: <b>HANDLE</b></para>
      <para>A module handle returned by the <see cref="BeginUpdateResource" /> function, referencing the file to be updated.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The resource type to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-types">Resource Types</a>.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is a resource ID. When creating a new resource do not use a string that begins with a '#' character for this parameter.</para>
    </param>
    <param name="wLanguage">
      <para>Type: <b>WORD</b></para>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">language identifier</a> of the resource to be updated. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the <see cref="MAKELANGID" />  macro.</para>
    </param>
    <param name="lpData">
      <para>Type: <b>LPVOID</b></para>
      <para>The resource data to be inserted into the file indicated by <i>hUpdate</i>. If the resource is one of the predefined types, the data must be valid and properly aligned. Note that this is the raw binary data to be stored in the file indicated by <i>hUpdate</i>, not the data provided by <see cref="LoadIcon" />, <see cref="LoadString" />, or other resource-specific load functions. All data containing strings or text must be in Unicode format. <i>lpData</i> must not point to ANSI data.</para>
      <para>If <i>lpData</i> is <b>NULL</b> and <i>cbData</i> is 0, the specified resource is deleted from the file indicated by <i>hUpdate</i>.</para>
    </param>
    <param name="cb">
      <para>Type: <b>DWORD</b></para>
      <para>The size, in bytes, of the resource data at <i>lpData</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>It is recommended that the resource file is not loaded before this function is called. However, if that file is already loaded, it will not cause an error to be returned.</para>
      <para>An application can use <b>UpdateResource</b> repeatedly to make changes to the resource data. Each call to <b>UpdateResource</b> contributes to an internal list of additions, deletions, and replacements but does not actually write the data to the file indicated by <i>hUpdate</i>. The application must use the <see cref="EndUpdateResource" /> function to write the accumulated changes to the file.</para>
      <para>This function can update resources within modules that contain both code and resources.</para>
      <para>
        <b>Prior to Windows 7:</b> If <i>lpData</i> is <b>NULL</b> and <i>cbData</i> is nonzero, the specified resource is NOT deleted and an exception is thrown.</para>
      <para>
        <b>Starting with Windows Vista:</b> As noted above, there are restrictions on resource updates in files that contain RC Config data: LN files and .mui files. The restrictions are as follows:</para>
      <list type="table">
        <listheader>
          <description>Action</description>
          <description>LN file</description>
          <description>.mui file</description>
        </listheader>
        <item>
          <description>1. Add a new type that doesn't exist in the LN or .mui files.</description>
          <description>Add type in the LN file and treat as language-neutral (non-localizable) and add new type or item in the RC Config data</description>
          <description>The only additions allowed are the following types: file Version, RC Config data, Side-by-side Assembly XML Manifest.</description>
        </item>
        <item>
          <description>2. Add a new resource item to an existing type.</description>
          <description>Uses the RC Config data to check whether the type exists in the .mui files associated with this LN file. If the type doesn't exist in the .mui files, add the item and treat new item as un-localizable. If the type exists in the .mui files, then adding is not allowed.</description>
          <description>Only items of the following types may be added: File Version, RC Config data, Side-by-side Assembly XML Manifest.</description>
        </item>
        <item>
          <description>3. Update a resource item.</description>
          <description>Uses the RC Config data to check whether the type exists in the .mui files associated with the LN file. If the type doesn't exist in the .mui files, then this resource item update is allowed in the LN file. Otherwise, if the type exists in the .mui files associated with this LN file, then this update is not allowed.</description>
          <description>The only updates allowed are items of the following types: file Version, RC Config data, Side-by-side Assembly XML Manifest.</description>
        </item>
        <item>
          <description>4. Add a type/item for a new language.</description>
          <description>Not allowed.</description>
          <description>Not allowed.</description>
        </item>
        <item>
          <description>5. Remove an existing type/item.</description>
          <description>Works similarly to case 3. Uses the RC Config data to check whether the type exists in the .mui files associated with the LN file. If not, then the removal of the type/item from the LN file is allowed.  Otherwise, if the type/item exists in the .mui files associated with this LN file, then the removal is not allowed.</description>
          <description>The only types allowed to be removed are: file Version, RC Config data, Side-by-side Assembly XML Manifest; also, only items of these types may be removed.</description>
        </item>
        <item>
          <description>6. Add/delete/update a type not included in the RC Config data (such as Version, Side-by-side Assembly XML Manifest, or RC Config data itself). </description>
          <description>Allowed.</description>
          <description>Allowed.</description>
        </item>
        <item>
          <description>7. Other update of non-localizable data, such as TYPELIB, reginst, and so on.</description>
          <description>Update type or item in the LN file, treat as non-localizable, and add new type or item in the RC Config data.</description>
          <description>Not applicable.</description>
        </item>
        <item>
          <description>8. Add RC Config data.</description>
          <description>Can be done but the integrity of the RC Config data is not checked.</description>
          <description>Can be done but the integrity of the RC Config data is not checked.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines UpdateResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BeginUpdateResource" />
    <seealso cref="EndUpdateResource" />
    <seealso cref="LoadIcon" />
    <seealso cref="LoadString" />
    <seealso cref="LockResource" />
    <seealso cref="MAKEINTRESOURCE" />
    <seealso cref="MAKELANGID" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="SizeofResource" />
  </member>
  <member name="Windows.UpdateResourceA">
    <summary>
      <para>Adds, deletes, or replaces a resource in a portable executable (PE) file. There are some restrictions on resource updates in files that contain Resource Configuration (RC Config) data: <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral</a> (LN) files and language-specific resource (.mui) files.</para>
    </summary>
    <param name="hUpdate">
      <para>Type: <b>HANDLE</b></para>
      <para>A module handle returned by the <see cref="BeginUpdateResource" /> function, referencing the file to be updated.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The resource type to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-types">Resource Types</a>.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is a resource ID. When creating a new resource do not use a string that begins with a '#' character for this parameter.</para>
    </param>
    <param name="wLanguage">
      <para>Type: <b>WORD</b></para>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">language identifier</a> of the resource to be updated. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the <see cref="MAKELANGID" />  macro.</para>
    </param>
    <param name="lpData">
      <para>Type: <b>LPVOID</b></para>
      <para>The resource data to be inserted into the file indicated by <i>hUpdate</i>. If the resource is one of the predefined types, the data must be valid and properly aligned. Note that this is the raw binary data to be stored in the file indicated by <i>hUpdate</i>, not the data provided by <see cref="LoadIcon" />, <see cref="LoadString" />, or other resource-specific load functions. All data containing strings or text must be in Unicode format. <i>lpData</i> must not point to ANSI data.</para>
      <para>If <i>lpData</i> is <b>NULL</b> and <i>cbData</i> is 0, the specified resource is deleted from the file indicated by <i>hUpdate</i>.</para>
    </param>
    <param name="cb">
      <para>Type: <b>DWORD</b></para>
      <para>The size, in bytes, of the resource data at <i>lpData</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>It is recommended that the resource file is not loaded before this function is called. However, if that file is already loaded, it will not cause an error to be returned.</para>
      <para>An application can use <b>UpdateResource</b> repeatedly to make changes to the resource data. Each call to <b>UpdateResource</b> contributes to an internal list of additions, deletions, and replacements but does not actually write the data to the file indicated by <i>hUpdate</i>. The application must use the <see cref="EndUpdateResource" /> function to write the accumulated changes to the file.</para>
      <para>This function can update resources within modules that contain both code and resources.</para>
      <para>
        <b>Prior to Windows 7:</b> If <i>lpData</i> is <b>NULL</b> and <i>cbData</i> is nonzero, the specified resource is NOT deleted and an exception is thrown.</para>
      <para>
        <b>Starting with Windows Vista:</b> As noted above, there are restrictions on resource updates in files that contain RC Config data: LN files and .mui files. The restrictions are as follows:</para>
      <list type="table">
        <listheader>
          <description>Action</description>
          <description>LN file</description>
          <description>.mui file</description>
        </listheader>
        <item>
          <description>1. Add a new type that doesn't exist in the LN or .mui files.</description>
          <description>Add type in the LN file and treat as language-neutral (non-localizable) and add new type or item in the RC Config data</description>
          <description>The only additions allowed are the following types: file Version, RC Config data, Side-by-side Assembly XML Manifest.</description>
        </item>
        <item>
          <description>2. Add a new resource item to an existing type.</description>
          <description>Uses the RC Config data to check whether the type exists in the .mui files associated with this LN file. If the type doesn't exist in the .mui files, add the item and treat new item as un-localizable. If the type exists in the .mui files, then adding is not allowed.</description>
          <description>Only items of the following types may be added: File Version, RC Config data, Side-by-side Assembly XML Manifest.</description>
        </item>
        <item>
          <description>3. Update a resource item.</description>
          <description>Uses the RC Config data to check whether the type exists in the .mui files associated with the LN file. If the type doesn't exist in the .mui files, then this resource item update is allowed in the LN file. Otherwise, if the type exists in the .mui files associated with this LN file, then this update is not allowed.</description>
          <description>The only updates allowed are items of the following types: file Version, RC Config data, Side-by-side Assembly XML Manifest.</description>
        </item>
        <item>
          <description>4. Add a type/item for a new language.</description>
          <description>Not allowed.</description>
          <description>Not allowed.</description>
        </item>
        <item>
          <description>5. Remove an existing type/item.</description>
          <description>Works similarly to case 3. Uses the RC Config data to check whether the type exists in the .mui files associated with the LN file. If not, then the removal of the type/item from the LN file is allowed.  Otherwise, if the type/item exists in the .mui files associated with this LN file, then the removal is not allowed.</description>
          <description>The only types allowed to be removed are: file Version, RC Config data, Side-by-side Assembly XML Manifest; also, only items of these types may be removed.</description>
        </item>
        <item>
          <description>6. Add/delete/update a type not included in the RC Config data (such as Version, Side-by-side Assembly XML Manifest, or RC Config data itself). </description>
          <description>Allowed.</description>
          <description>Allowed.</description>
        </item>
        <item>
          <description>7. Other update of non-localizable data, such as TYPELIB, reginst, and so on.</description>
          <description>Update type or item in the LN file, treat as non-localizable, and add new type or item in the RC Config data.</description>
          <description>Not applicable.</description>
        </item>
        <item>
          <description>8. Add RC Config data.</description>
          <description>Can be done but the integrity of the RC Config data is not checked.</description>
          <description>Can be done but the integrity of the RC Config data is not checked.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines UpdateResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BeginUpdateResource" />
    <seealso cref="EndUpdateResource" />
    <seealso cref="LoadIcon" />
    <seealso cref="LoadString" />
    <seealso cref="LockResource" />
    <seealso cref="MAKEINTRESOURCE" />
    <seealso cref="MAKELANGID" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="SizeofResource" />
  </member>
  <member name="Windows.UpdateResourceW">
    <summary>
      <para>Adds, deletes, or replaces a resource in a portable executable (PE) file. There are some restrictions on resource updates in files that contain Resource Configuration (RC Config) data: <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral</a> (LN) files and language-specific resource (.mui) files.</para>
    </summary>
    <param name="hUpdate">
      <para>Type: <b>HANDLE</b></para>
      <para>A module handle returned by the <see cref="BeginUpdateResource" /> function, referencing the file to be updated.</para>
    </param>
    <param name="lpType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The resource type to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-types">Resource Types</a>.</para>
    </param>
    <param name="lpName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The name of the resource to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is a resource ID. When creating a new resource do not use a string that begins with a '#' character for this parameter.</para>
    </param>
    <param name="wLanguage">
      <para>Type: <b>WORD</b></para>
      <para>The <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">language identifier</a> of the resource to be updated. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the <see cref="MAKELANGID" />  macro.</para>
    </param>
    <param name="lpData">
      <para>Type: <b>LPVOID</b></para>
      <para>The resource data to be inserted into the file indicated by <i>hUpdate</i>. If the resource is one of the predefined types, the data must be valid and properly aligned. Note that this is the raw binary data to be stored in the file indicated by <i>hUpdate</i>, not the data provided by <see cref="LoadIcon" />, <see cref="LoadString" />, or other resource-specific load functions. All data containing strings or text must be in Unicode format. <i>lpData</i> must not point to ANSI data.</para>
      <para>If <i>lpData</i> is <b>NULL</b> and <i>cbData</i> is 0, the specified resource is deleted from the file indicated by <i>hUpdate</i>.</para>
    </param>
    <param name="cb">
      <para>Type: <b>DWORD</b></para>
      <para>The size, in bytes, of the resource data at <i>lpData</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>It is recommended that the resource file is not loaded before this function is called. However, if that file is already loaded, it will not cause an error to be returned.</para>
      <para>An application can use <b>UpdateResource</b> repeatedly to make changes to the resource data. Each call to <b>UpdateResource</b> contributes to an internal list of additions, deletions, and replacements but does not actually write the data to the file indicated by <i>hUpdate</i>. The application must use the <see cref="EndUpdateResource" /> function to write the accumulated changes to the file.</para>
      <para>This function can update resources within modules that contain both code and resources.</para>
      <para>
        <b>Prior to Windows 7:</b> If <i>lpData</i> is <b>NULL</b> and <i>cbData</i> is nonzero, the specified resource is NOT deleted and an exception is thrown.</para>
      <para>
        <b>Starting with Windows Vista:</b> As noted above, there are restrictions on resource updates in files that contain RC Config data: LN files and .mui files. The restrictions are as follows:</para>
      <list type="table">
        <listheader>
          <description>Action</description>
          <description>LN file</description>
          <description>.mui file</description>
        </listheader>
        <item>
          <description>1. Add a new type that doesn't exist in the LN or .mui files.</description>
          <description>Add type in the LN file and treat as language-neutral (non-localizable) and add new type or item in the RC Config data</description>
          <description>The only additions allowed are the following types: file Version, RC Config data, Side-by-side Assembly XML Manifest.</description>
        </item>
        <item>
          <description>2. Add a new resource item to an existing type.</description>
          <description>Uses the RC Config data to check whether the type exists in the .mui files associated with this LN file. If the type doesn't exist in the .mui files, add the item and treat new item as un-localizable. If the type exists in the .mui files, then adding is not allowed.</description>
          <description>Only items of the following types may be added: File Version, RC Config data, Side-by-side Assembly XML Manifest.</description>
        </item>
        <item>
          <description>3. Update a resource item.</description>
          <description>Uses the RC Config data to check whether the type exists in the .mui files associated with the LN file. If the type doesn't exist in the .mui files, then this resource item update is allowed in the LN file. Otherwise, if the type exists in the .mui files associated with this LN file, then this update is not allowed.</description>
          <description>The only updates allowed are items of the following types: file Version, RC Config data, Side-by-side Assembly XML Manifest.</description>
        </item>
        <item>
          <description>4. Add a type/item for a new language.</description>
          <description>Not allowed.</description>
          <description>Not allowed.</description>
        </item>
        <item>
          <description>5. Remove an existing type/item.</description>
          <description>Works similarly to case 3. Uses the RC Config data to check whether the type exists in the .mui files associated with the LN file. If not, then the removal of the type/item from the LN file is allowed.  Otherwise, if the type/item exists in the .mui files associated with this LN file, then the removal is not allowed.</description>
          <description>The only types allowed to be removed are: file Version, RC Config data, Side-by-side Assembly XML Manifest; also, only items of these types may be removed.</description>
        </item>
        <item>
          <description>6. Add/delete/update a type not included in the RC Config data (such as Version, Side-by-side Assembly XML Manifest, or RC Config data itself). </description>
          <description>Allowed.</description>
          <description>Allowed.</description>
        </item>
        <item>
          <description>7. Other update of non-localizable data, such as TYPELIB, reginst, and so on.</description>
          <description>Update type or item in the LN file, treat as non-localizable, and add new type or item in the RC Config data.</description>
          <description>Not applicable.</description>
        </item>
        <item>
          <description>8. Add RC Config data.</description>
          <description>Can be done but the integrity of the RC Config data is not checked.</description>
          <description>Can be done but the integrity of the RC Config data is not checked.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <para>For an example, see <a href="https://docs.microsoft.com//windows/desktop/menurc/using-resources">Updating Resources</a>.</para>
      <blockquote>
        <para>[!NOTE]
The winbase.h header defines UpdateResource as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="BeginUpdateResource" />
    <seealso cref="EndUpdateResource" />
    <seealso cref="LoadIcon" />
    <seealso cref="LoadString" />
    <seealso cref="LockResource" />
    <seealso cref="MAKEINTRESOURCE" />
    <seealso cref="MAKELANGID" />
    <seealso href="https://docs.microsoft.com//windows/desktop/menurc/resources">Resources</seealso>
    <seealso cref="SizeofResource" />
  </member>
  <member name="Windows.WaitCommEvent">
    <summary>
      <para>Waits for an event to occur for a specified communications device. The set of events that are monitored by this function is contained in the event mask associated with the device handle.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the communications device. The
<see cref="CreateFile" /> function returns this handle.</para>
    </param>
    <param name="lpEvtMask">
      <para>A pointer to a variable that receives a mask indicating the type of event that occurred. If an error occurs, the value is zero; otherwise, it is one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_BREAK</b>
                </description>
              </item>
              <item>
                <description>0x0040</description>
              </item>
            </list>
          </description>
          <description>
            <para>A break was detected on input.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_CTS</b>
                </description>
              </item>
              <item>
                <description>0x0008</description>
              </item>
            </list>
          </description>
          <description>
            <para>The CTS (clear-to-send) signal changed state.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_DSR</b>
                </description>
              </item>
              <item>
                <description>0x0010</description>
              </item>
            </list>
          </description>
          <description>
            <para>The DSR (data-set-ready) signal changed state.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_ERR</b>
                </description>
              </item>
              <item>
                <description>0x0080</description>
              </item>
            </list>
          </description>
          <description>
            <para>A line-status error occurred. Line-status errors are <b>CE_FRAME</b>, <b>CE_OVERRUN</b>, and <b>CE_RXPARITY</b>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_RING</b>
                </description>
              </item>
              <item>
                <description>0x0100</description>
              </item>
            </list>
          </description>
          <description>
            <para>A ring indicator was detected.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_RLSD</b>
                </description>
              </item>
              <item>
                <description>0x0020</description>
              </item>
            </list>
          </description>
          <description>
            <para>The RLSD (receive-line-signal-detect) signal changed state.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_RXCHAR</b>
                </description>
              </item>
              <item>
                <description>0x0001</description>
              </item>
            </list>
          </description>
          <description>
            <para>A character was received and placed in the input buffer.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_RXFLAG</b>
                </description>
              </item>
              <item>
                <description>0x0002</description>
              </item>
            </list>
          </description>
          <description>
            <para>The event character was received and placed in the input buffer. The event character is specified in the device's
<see cref="DCB" /> structure, which is applied to a serial port by using the
<see cref="SetCommState" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>EV_TXEMPTY</b>
                </description>
              </item>
              <item>
                <description>0x0004</description>
              </item>
            </list>
          </description>
          <description>
            <para>The last character in the output buffer was sent.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="lpOverlapped">
      <para>A pointer to an
<see cref="OVERLAPPED" /> structure. This structure is required if <i>hFile</i> was opened with <b>FILE_FLAG_OVERLAPPED</b>.</para>
      <para>If <i>hFile</i> was opened with <b>FILE_FLAG_OVERLAPPED</b>, the <i>lpOverlapped</i> parameter must not be <b>NULL</b>. It must point to a valid <see cref="OVERLAPPED" /> structure. If <i>hFile</i> was opened with <b>FILE_FLAG_OVERLAPPED</b> and <i>lpOverlapped</i> is <b>NULL</b>, the function can incorrectly report that the operation is complete.</para>
      <para>If <i>hFile</i> was opened with <b>FILE_FLAG_OVERLAPPED</b> and <i>lpOverlapped</i> is not <b>NULL</b>,
<b>WaitCommEvent</b> is performed as an overlapped operation. In this case, the <see cref="OVERLAPPED" /> structure must contain a handle to a manual-reset event object (created by using the
<see cref="CreateEvent" /> function).</para>
      <para>If <i>hFile</i> was not opened with <b>FILE_FLAG_OVERLAPPED</b>,
<b>WaitCommEvent</b> does not return until one of the specified events or an error occurs.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The
<b>WaitCommEvent</b> function monitors a set of events for a specified communications resource. To set and query the current event mask of a communications resource, use the
<see cref="SetCommMask" /> and
<see cref="GetCommMask" /> functions.</para>
      <para>If the overlapped operation cannot be completed immediately, the function returns <b>FALSE</b> and the <see cref="GetLastError" /> function returns <b>ERROR_IO_PENDING</b>, indicating that the operation is executing in the background. When this happens, the system sets the <b>hEvent</b> member of the <see cref="OVERLAPPED" /> structure to the not-signaled state before
<b>WaitCommEvent</b> returns, and then it sets it to the signaled state when one of the specified events or an error occurs. The calling process can use one of the
<a href="https://docs.microsoft.com//windows/desktop/Sync/wait-functions">wait functions</a> to determine the event object's state and then use the <see cref="GetOverlappedResult" /> function to determine the results of the
<b>WaitCommEvent</b> operation.
<b>GetOverlappedResult</b> reports the success or failure of the operation, and the variable pointed to by the <i>lpEvtMask</i> parameter is set to indicate the event that occurred.</para>
      <para>If a process attempts to change the device handle's event mask by using the
<see cref="SetCommMask" /> function while an overlapped
<b>WaitCommEvent</b> operation is in progress,
<b>WaitCommEvent</b> returns immediately. The variable pointed to by the <i>lpEvtMask</i> parameter is set to zero.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/DevIO/monitoring-communications-events">Monitoring Communications Events</a>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-functions">Communications Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/DevIO/communications-resources">Communications Resources</seealso>
    <seealso cref="CreateFile" />
    <seealso cref="DCB" />
    <seealso cref="GetCommMask" />
    <seealso cref="GetOverlappedResult" />
    <seealso cref="OVERLAPPED" />
    <seealso cref="SetCommMask" />
    <seealso cref="SetCommState" />
  </member>
  <member name="Windows.WaitNamedPipe">
    <summary>
      <para>Waits until either a time-out interval elapses or an instance of the specified named pipe is available for connection (that is, the pipe's server process has a pending
<see cref="ConnectNamedPipe" /> operation on the pipe).</para>
    </summary>
    <param name="lpNamedPipeName">
      <para>The name of the named pipe. The string must include the name of the computer on which the server process is executing. A period may be used for the <i>servername</i> if the pipe is local. The following pipe name format is used:</para>
      <para>\\<i>servername</i>\pipe\<i>pipename</i></para>
    </param>
    <param name="nTimeOut">
      <para>The number of milliseconds that the function will wait for an instance of the named pipe to be available. You can used one of the following values instead of specifying a number of milliseconds.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NMPWAIT_USE_DEFAULT_WAIT</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The time-out interval is the default value specified by the server process in the
<see cref="CreateNamedPipe" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NMPWAIT_WAIT_FOREVER</b>
                </description>
              </item>
              <item>
                <description>0xffffffff</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function does not return until an instance of the named pipe is available.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If an instance of the pipe is available before the time-out interval elapses, the return value is nonzero.</para>
      <para>If an instance of the pipe is not available before the time-out interval elapses, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If no instances of the specified named pipe exist, the
<b>WaitNamedPipe</b> function returns immediately, regardless of the time-out value.</para>
      <para>If the time-out interval expires, the <b>WaitNamedPipe</b> function will fail with the error <b>ERROR_SEM_TIMEOUT</b>.</para>
      <para>If the function succeeds, the process should use the <see cref="CreateFile" /> function to open a handle to the named pipe. A return value of <b>TRUE</b> indicates that there is at least one instance of the pipe available. A subsequent <b>CreateFile</b> call to the pipe can fail, because the instance was closed by the server or opened by another client.</para>
      <para>
        <b>Windows 10, version 1709:  </b>Pipes are only supported within an app-container; ie, from one UWP process to another UWP process that's part of the same app. Also, named pipes must use the syntax "\.\pipe\LOCAL" for the pipe name.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/named-pipe-client">Named Pipe Client</a>.</para>
    </remarks>
    <seealso cref="CallNamedPipe" />
    <seealso cref="ConnectNamedPipe" />
    <seealso cref="CreateFile" />
    <seealso cref="CreateNamedPipe" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipe-functions">Pipe Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipes">Pipes Overview</seealso>
  </member>
  <member name="Windows.WaitNamedPipeA">
    <summary>
      <para>Waits until either a time-out interval elapses or an instance of the specified named pipe is available for connection (that is, the pipe's server process has a pending
<see cref="ConnectNamedPipe" /> operation on the pipe).</para>
    </summary>
    <param name="lpNamedPipeName">
      <para>The name of the named pipe. The string must include the name of the computer on which the server process is executing. A period may be used for the <i>servername</i> if the pipe is local. The following pipe name format is used:</para>
      <para>\\<i>servername</i>\pipe\<i>pipename</i></para>
    </param>
    <param name="nTimeOut">
      <para>The number of milliseconds that the function will wait for an instance of the named pipe to be available. You can used one of the following values instead of specifying a number of milliseconds.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NMPWAIT_USE_DEFAULT_WAIT</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The time-out interval is the default value specified by the server process in the
<see cref="CreateNamedPipe" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NMPWAIT_WAIT_FOREVER</b>
                </description>
              </item>
              <item>
                <description>0xffffffff</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function does not return until an instance of the named pipe is available.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If an instance of the pipe is available before the time-out interval elapses, the return value is nonzero.</para>
      <para>If an instance of the pipe is not available before the time-out interval elapses, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If no instances of the specified named pipe exist, the
<b>WaitNamedPipe</b> function returns immediately, regardless of the time-out value.</para>
      <para>If the time-out interval expires, the <b>WaitNamedPipe</b> function will fail with the error <b>ERROR_SEM_TIMEOUT</b>.</para>
      <para>If the function succeeds, the process should use the <see cref="CreateFile" /> function to open a handle to the named pipe. A return value of <b>TRUE</b> indicates that there is at least one instance of the pipe available. A subsequent <b>CreateFile</b> call to the pipe can fail, because the instance was closed by the server or opened by another client.</para>
      <para>
        <b>Windows 10, version 1709:  </b>Pipes are only supported within an app-container; ie, from one UWP process to another UWP process that's part of the same app. Also, named pipes must use the syntax "\.\pipe\LOCAL" for the pipe name.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/named-pipe-client">Named Pipe Client</a>.</para>
    </remarks>
    <seealso cref="CallNamedPipe" />
    <seealso cref="ConnectNamedPipe" />
    <seealso cref="CreateFile" />
    <seealso cref="CreateNamedPipe" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipe-functions">Pipe Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipes">Pipes Overview</seealso>
  </member>
  <member name="Windows.WaitNamedPipeW">
    <summary>
      <para>Waits until either a time-out interval elapses or an instance of the specified named pipe is available for connection (that is, the pipe's server process has a pending
<see cref="ConnectNamedPipe" /> operation on the pipe).</para>
    </summary>
    <param name="lpNamedPipeName">
      <para>The name of the named pipe. The string must include the name of the computer on which the server process is executing. A period may be used for the <i>servername</i> if the pipe is local. The following pipe name format is used:</para>
      <para>\\<i>servername</i>\pipe\<i>pipename</i></para>
    </param>
    <param name="nTimeOut">
      <para>The number of milliseconds that the function will wait for an instance of the named pipe to be available. You can used one of the following values instead of specifying a number of milliseconds.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NMPWAIT_USE_DEFAULT_WAIT</b>
                </description>
              </item>
              <item>
                <description>0x00000000</description>
              </item>
            </list>
          </description>
          <description>
            <para>The time-out interval is the default value specified by the server process in the
<see cref="CreateNamedPipe" /> function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>NMPWAIT_WAIT_FOREVER</b>
                </description>
              </item>
              <item>
                <description>0xffffffff</description>
              </item>
            </list>
          </description>
          <description>
            <para>The function does not return until an instance of the named pipe is available.</para>
          </description>
        </item>
      </list>
    </param>
    <returns>
      <para>If an instance of the pipe is available before the time-out interval elapses, the return value is nonzero.</para>
      <para>If an instance of the pipe is not available before the time-out interval elapses, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>If no instances of the specified named pipe exist, the
<b>WaitNamedPipe</b> function returns immediately, regardless of the time-out value.</para>
      <para>If the time-out interval expires, the <b>WaitNamedPipe</b> function will fail with the error <b>ERROR_SEM_TIMEOUT</b>.</para>
      <para>If the function succeeds, the process should use the <see cref="CreateFile" /> function to open a handle to the named pipe. A return value of <b>TRUE</b> indicates that there is at least one instance of the pipe available. A subsequent <b>CreateFile</b> call to the pipe can fail, because the instance was closed by the server or opened by another client.</para>
      <para>
        <b>Windows 10, version 1709:  </b>Pipes are only supported within an app-container; ie, from one UWP process to another UWP process that's part of the same app. Also, named pipes must use the syntax "\.\pipe\LOCAL" for the pipe name.</para>
      <h4>Examples</h4>
      <para>For an example, see
<a href="https://docs.microsoft.com//windows/desktop/ipc/named-pipe-client">Named Pipe Client</a>.</para>
    </remarks>
    <seealso cref="CallNamedPipe" />
    <seealso cref="ConnectNamedPipe" />
    <seealso cref="CreateFile" />
    <seealso cref="CreateNamedPipe" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipe-functions">Pipe Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/ipc/pipes">Pipes Overview</seealso>
  </member>
  <member name="Windows.WinExec">
    <summary>
      <para>Runs the specified application.
<b>Note</b>  This function is provided only for compatibility with 16-bit Windows. Applications should use the
<see cref="CreateProcess" /> function.</para>
    </summary>
    <param name="lpCmdLine">
      <para>The command line (file name plus optional parameters) for the application to be executed. If the name of the executable file in the <i>lpCmdLine</i> parameter does not contain a directory path, the system searches for the executable file in this sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory.</description>
        </item>
        <item>
          <description>The Windows system directory. The
<see cref="GetSystemDirectory" /> function retrieves the path of this directory.</description>
        </item>
        <item>
          <description>The Windows directory. The
<see cref="GetWindowsDirectory" /> function retrieves the path of this directory.</description>
        </item>
        <item>
          <description>The directories listed in the PATH environment variable.</description>
        </item>
      </list>
    </param>
    <param name="uCmdShow">
      <para>The display options. For a list of the acceptable values, see the description of the <i>nCmdShow</i> parameter of the
<see cref="ShowWindow" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is greater than 31.</para>
      <para>If the function fails, the return value is one of the following error values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>0</para>
          </description>
          <description>
            <para>The system is out of memory or resources.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_BAD_FORMAT</b>
            </para>
          </description>
          <description>
            <para>The .exe file is invalid.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_FILE_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The specified file was not found.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>ERROR_PATH_NOT_FOUND</b>
            </para>
          </description>
          <description>
            <para>The specified path was not found.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>The
<b>WinExec</b> function returns when the started process calls the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/fax/-mfax-faxaccountincomingarchive-getmessage-vb">GetMessage</a> function or a time-out limit is reached. To avoid waiting for the time out delay, call the <b>GetMessage</b> function as soon as possible in any process started by a call to
<b>WinExec</b>.</para>
      <h3>Security Remarks</h3>
      <para>The executable name is treated as the first white space-delimited string in <i>lpCmdLine</i>. If the executable or path name has a space in it, there is a risk that a different executable could be run because of the way the function parses spaces. The following example is dangerous because the function will attempt to run "Program.exe", if it exists, instead of "MyApp.exe".</para>
      <code>WinExec("C:\\Program Files\\MyApp", ...)
</code>
      <para>If a malicious user were to create an application called "Program.exe" on a system, any program that incorrectly calls
<b>WinExec</b> using the Program Files directory will run this application instead of the intended application.</para>
      <para>To avoid this problem, use
<see cref="CreateProcess" /> rather than
<b>WinExec</b>. However, if you must use
<b>WinExec</b> for legacy reasons, make sure the application name is enclosed in quotation marks as shown in the example below.</para>
      <code>WinExec("\"C:\\Program Files\\MyApp.exe\" -L -S", ...)
</code>
    </remarks>
    <seealso cref="CreateProcess" />
  </member>
  <member name="Windows.WinMain">
    <summary>
      <para>The user-provided entry point for a graphical Windows-based application.</para>
      <para>
        <b>WinMain</b> is the conventional name used for the application entry point. For more information, see Remarks.</para>
    </summary>
    <param name="hInstance">
      <para>Type: <b>HINSTANCE</b></para>
      <para>A handle to the current instance of the application.</para>
    </param>
    <param name="hPrevInstance">
      <para>Type: <b>HINSTANCE</b></para>
      <para>A handle to the previous instance of the application. This parameter is always <b>NULL</b>. If you need to detect whether another instance already exists, create a uniquely named mutex using the <see cref="CreateMutex" /> function. <b>CreateMutex</b> will succeed even if the mutex already exists, but the  function will return <b>ERROR_ALREADY_EXISTS</b>. This indicates that another instance of your application exists, because it created the mutex first. However, a malicious user can create this mutex before you do and prevent your application from starting. To prevent this situation, create a randomly named mutex and store the name so that it can only be obtained by an authorized user. Alternatively, you can use a file for this purpose. To limit your application to one instance per user, create a locked file in the user's profile directory.</para>
    </param>
    <param name="lpCmdLine">
      <para>Type: <b>LPSTR</b></para>
      <para>The command line for the application, excluding the program name. To retrieve the entire command line, use the <see cref="GetCommandLine" /> function.</para>
    </param>
    <param name="nShowCmd">
      <para>Type: <b>int</b></para>
      <para>Controls how the window is to be shown. This parameter can be any of the values that can be specified in the <i>nCmdShow</i> parameter for the <see cref="ShowWindow" /> function.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>If the function succeeds, terminating when it receives a <a href="https://docs.microsoft.com//windows/desktop/winmsg/wm-quit">WM_QUIT</a> message, it should return the exit value contained in that message's <i>wParam</i> parameter. If the function terminates before entering the message loop, it should return zero.</para>
    </returns>
    <remarks>
      <para>The name <b>WinMain</b> is used by convention by many programming frameworks. Depending on the programming framework, the call to the <b>WinMain</b> function can be preceded and followed by additional activities specific to that framework.</para>
      <para>Your <b>WinMain</b> should initialize the application, display its main window, and enter a message retrieval-and-dispatch loop that is the top-level control structure for the remainder of the application's execution. Terminate the message loop when it receives a <a href="https://docs.microsoft.com//windows/desktop/winmsg/wm-quit">WM_QUIT</a> message. At that point, your <b>WinMain</b> should exit the application, returning the value passed in the <b>WM_QUIT</b> message's <i>wParam</i> parameter. If <b>WM_QUIT</b> was received as a result of calling <see cref="PostQuitMessage" />, the value of <i>wParam</i> is the value of the <b>PostQuitMessage</b> function's <i>nExitCode</i> parameter. For more information, see <a href="https://docs.microsoft.com//windows/desktop/winmsg/using-messages-and-message-queues">Creating a Message Loop</a>.</para>
      <para>ANSI applications can use the <i>lpCmdLine</i> parameter of the <b>WinMain</b> function to access the command-line string, excluding the program name. Note that <i>lpCmdLine</i> uses the <b>LPSTR</b> data type instead of the <b>LPTSTR</b> data type. This means that <b>WinMain</b> cannot be used by Unicode programs. The <see cref="GetCommandLineW" /> function can be used to obtain the command line as a Unicode string. Some programming frameworks might provide an alternative entry point that provides a Unicode command line. For example, the Microsoft Visual Studio C++ complier uses the name <b>wWinMain</b> for the Unicode entry point.</para>
    </remarks>
    <seealso cref="CreateMutex" />
    <seealso cref="DispatchMessage" />
    <seealso cref="GetCommandLine" />
    <seealso cref="GetMessage" />
    <seealso cref="PostQuitMessage" />
    <seealso cref="TranslateMessage" />
    <seealso href="https://docs.microsoft.com//windows/desktop/winmsg/windows">Windows</seealso>
  </member>
  <member name="Windows.Wow64EnableWow64FsRedirection">
    <summary>
      <para>Enables or disables file system redirection for the calling thread.</para>
      <para>This function may not work reliably when there are nested calls. Therefore, this function has been replaced by
the <see cref="Wow64DisableWow64FsRedirection" /> and
<see cref="Wow64RevertWow64FsRedirection" /></para>
      <para>functions.
<b>Note</b>  These two methods of controlling file system redirection cannot be combined in any way. Do not use the
<b>Wow64EnableWow64FsRedirection</b></para>
      <para>function with either the
<see cref="Wow64DisableWow64FsRedirection" /> or the
<see cref="Wow64RevertWow64FsRedirection" /></para>
      <para>function.</para>
    </summary>
    <param name="Wow64FsEnableRedirection">
      <para>Indicates the type of request for WOW64 system folder redirection. If
<b>TRUE</b>, requests redirection be enabled; if <b>FALSE</b>, requests
redirection be disabled.</para>
    </param>
    <returns>
      <para>Boolean value indicating whether the function succeeded. If <b>TRUE</b>, the function
succeeded; if <b>FALSE</b>, the function failed.</para>
    </returns>
    <remarks>
      <para>This function is useful for 32-bit applications that want to gain access to the native system32 directory. By
default, WOW64 file system redirection is enabled.</para>
      <para>
        <b>Note</b>  The
<b>Wow64EnableWow64FsRedirection</b></para>
      <para>function affects all file operations performed by the current thread, which can have unintended consequences if
file system redirection is disabled for any length of time. For example, DLL loading depends on file system
redirection, so disabling file system redirection will cause DLL loading to fail. Also, many feature
implementations use delayed loading and will fail while redirection is disabled. The failure state of the initial
delay-load operation is persisted, so any subsequent use of the delay-load function will fail even after file
system redirection is re-enabled. To avoid these problems, disable file system redirection immediately before
calls to specific file I/O functions (such as <see cref="CreateFile" />)
that must not be redirected, and re-enable file system redirection immediately afterward using
<code>Wow64EnableWow64FsRedirection(TRUE)</code>.</para>
      <para>File redirection is enabled or disabled only for the thread calling this function. This affects only
operations made by the current thread. Some functions, such as
<see cref="CreateProcessAsUser" />, do their work on another
thread, which is not affected by the state of file system redirection in the calling thread.</para>
      <para>In Windows 8 and Windows Server 2012, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <h4>Examples</h4>
      <code>#ifdef _WIN32_WINNT
#undef _WIN32_WINNT
#endif
#define _WIN32_WINNT 0x0501

#ifdef NTDDI_VERSION
#undef NTDDI_VERSION
#endif
#define NTDDI_VERSION 0x05010000

#include &lt;Windows.h&gt;

void main()
 {
  HANDLE hFile = INVALID_HANDLE_VALUE;

  //  Disable redirection immediately prior to the native API
  //  function call.
  if( Wow64EnableWow64FsRedirection(FALSE) )
   {
    //  Any function calls in this block of code should be as concise
    //  and as simple as possible to avoid unintended results.
    hFile = CreateFile(TEXT("C:\\Windows\\System32\\Notepad.exe"),
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    //  Immediately re-enable redirection. Note that any resources
    //  associated with OldValue are cleaned up by this call.
    if ( FALSE == Wow64EnableWow64FsRedirection(TRUE) )
     {
      //  Failure to re-enable redirection should be considered
      //  a critical failure and execution aborted.
      return;
     }
   }

  // The handle, if valid, can be used as usual without
  // leaving redirection disabled.

  if( INVALID_HANDLE_VALUE != hFile )
   {
    // Use the file handle
   }
 }

</code>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinProg64/file-system-redirector">File System Redirector</seealso>
    <seealso cref="GetSystemWow64Directory" />
    <seealso cref="Wow64DisableWow64FsRedirection" />
    <seealso cref="Wow64RevertWow64FsRedirection" />
  </member>
  <member name="Windows.Wow64GetThreadContext">
    <summary>
      <para>Retrieves the context of the specified WOW64 thread.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread whose context is to be retrieved. The handle must have
<b>THREAD_GET_CONTEXT</b> access to the thread. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
    </param>
    <param name="lpContext">
      <para>A <see cref="WOW64_CONTEXT" /> structure. The caller must
initialize the <b>ContextFlags</b> member of this structure.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function is used to retrieve the thread context of the specified thread. The function retrieves a
selective context based on the value of the <b>ContextFlags</b> member of the context
structure. The thread identified by the <i>hThread</i> parameter is typically being debugged,
but the function can also operate when the thread is not being debugged.</para>
      <para>You cannot get a valid context for a running thread. Use the
<see cref="Wow64SuspendThread" /> function to suspend the thread
before calling <b>Wow64GetThreadContext</b>.</para>
      <para>If you call <b>Wow64GetThreadContext</b> for the
current thread, the function returns successfully; however, the context returned is not valid.</para>
      <para>This function is intended for 64-bit applications. It is not supported on 32-bit Windows; such calls fail and
set the last error code to <b>ERROR_INVALID_FUNCTION</b>. A 32-bit application can call this
function on a WOW64 thread; the result is the same as calling the
<see cref="GetThreadContext" /> function.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/debugging-functions">Debugging Functions</seealso>
    <seealso cref="GetThreadContext" />
    <seealso cref="GetXStateFeaturesMask" />
    <seealso cref="WOW64_CONTEXT" />
    <seealso cref="Wow64SetThreadContext" />
  </member>
  <member name="Windows.Wow64GetThreadSelectorEntry">
    <summary>
      <para>Retrieves a descriptor table entry for the specified selector and WOW64 thread.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread containing the
specified selector.  The handle must have been created with
THREAD_QUERY_INFORMATION access to the thread. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
    </param>
    <param name="dwSelector">
      <para>The global or local selector value to look up in the thread's descriptor tables.</para>
    </param>
    <param name="lpSelectorEntry">
      <para>A pointer to a
<see cref="WOW64_LDT_ENTRY" /> structure that receives a copy of the descriptor table entry if the specified selector has an entry in the specified thread's descriptor table. This information can be used to convert a segment-relative address to a linear virtual address.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero. In that case, the structure pointed to by the <i>lpSelectorEntry</i> parameter receives a copy of the specified descriptor table entry.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>The <b>Wow64GetThreadSelectorEntry</b> function is functional only on 64-bit systems and can be called only by 64-bit processes. If this function is called by a 32-bit process, the function fails with ERROR_NOT_SUPPORTED. A 32-bit process should use the <see cref="GetThreadSelectorEntry" /> function instead.</para>
      <para>Debuggers use this function to convert segment-relative addresses to linear virtual addresses. The
<see cref="ReadProcessMemory" /> and
<see cref="WriteProcessMemory" /> functions use linear virtual addresses.</para>
    </remarks>
  </member>
  <member name="Windows.Wow64SetThreadContext">
    <summary>
      <para>Sets the context of the specified WOW64 thread.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread whose context is to be set.</para>
    </param>
    <param name="lpContext">
      <para>A <see cref="WOW64_CONTEXT" /> structure. The caller must
initialize the <b>ContextFlags</b> member of this structure.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call
<see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function allows the selective context to be set based on the value of the
<b>ContextFlags</b> member of the context structure. The thread handle identified by the
<i>hThread</i> parameter is typically being debugged, but the function can also operate even
when it is not being debugged.</para>
      <para>This function is intended for 64-bit applications. It is not supported on 32-bit Windows; such calls fail and
set the last error code to <b>ERROR_INVALID_FUNCTION</b>. A 32-bit application can call this
function on a WOW64 thread; the result is the same as calling the
<see cref="SetThreadContext" /> function.</para>
      <para>Do not try to set the context for a running thread; the results are unpredictable. Use the
<see cref="Wow64SuspendThread" /> function to suspend the thread
before calling <b>Wow64SetThreadContext</b>.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/Debug/debugging-functions">Debugging Functions</seealso>
    <seealso cref="GetXStateFeaturesMask" />
    <seealso cref="SetThreadContext" />
    <seealso cref="SetXStateFeaturesMask" />
    <seealso cref="WOW64_CONTEXT" />
    <seealso cref="Wow64GetThreadContext" />
  </member>
  <member name="Windows.Wow64SuspendThread">
    <summary>
      <para>Suspends the specified WOW64 thread.</para>
    </summary>
    <param name="hThread">
      <para>A handle to the thread that is to be suspended.</para>
      <para>The handle must have the THREAD_SUSPEND_RESUME access right. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the thread's previous suspend count; otherwise, it is (DWORD) -1. To get extended error information, use the
<see cref="GetLastError" /> function.</para>
    </returns>
    <remarks>
      <para>If the function succeeds, execution of the specified thread is suspended and the thread's suspend count is incremented. Suspending a thread causes the thread to stop executing user-mode (application) code.</para>
      <para>This function is primarily designed for use by debuggers. It is not intended to be used for thread synchronization. Calling
<b>Wow64SuspendThread</b> on a thread that owns a synchronization object, such as a mutex or critical section, can lead to a deadlock if the calling thread tries to obtain a synchronization object owned by a suspended thread. To avoid this situation, a thread within an application that is not a debugger should signal the other thread to suspend itself. The target thread must be designed to watch for this signal and respond appropriately.</para>
      <para>Each thread has a suspend count (with a maximum value of MAXIMUM_SUSPEND_COUNT). If the suspend count is greater than zero, the thread is suspended; otherwise, the thread is not suspended and is eligible for execution. Calling
<b>Wow64SuspendThread</b> causes the target thread's suspend count to be incremented. Attempting to increment past the maximum suspend count causes an error without incrementing the count.</para>
      <para>The
<see cref="ResumeThread" /> function decrements the suspend count of a suspended thread.</para>
      <para>This function is intended for 64-bit applications. It is not supported on 32-bit Windows; such calls fail and set the last error code to ERROR_INVALID_FUNCTION. A 32-bit application can call this function on a WOW64 thread; the result is the same as calling the <see cref="SuspendThread" /> function.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/process-and-thread-functions">Process and Thread Functions</seealso>
    <seealso cref="ResumeThread" />
    <seealso href="https://docs.microsoft.com//windows/desktop/ProcThread/suspending-thread-execution">Suspending Thread Execution</seealso>
  </member>
  <member name="Windows.WriteEncryptedFileRaw">
    <summary>
      <para>Restores (import) encrypted files. This is one of a group of Encrypted File System (EFS)
functions that is intended  to implement backup and restore functionality, while maintaining files in their
encrypted state.</para>
    </summary>
    <param name="pfImportCallback">
      <para>A pointer to the import callback function. The system calls the callback function multiple times, each time
passing a buffer that will be filled by the callback function with a portion of backed-up file's data. When the
callback function signals that the entire file has been processed, it tells the system that the restore
operation is finished. For more information, see
<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-pfe_import_func">ImportCallback</a>.</para>
    </param>
    <param name="pvCallbackContext">
      <para>A pointer to an application-defined and allocated context block. The system passes this pointer to the
callback function as a parameter so that the callback function can have access to application-specific data.
This can be a structure and can contain any data the application needs, such as the handle to the file that will
contain the backup copy of the encrypted file.</para>
    </param>
    <param name="pvContext">
      <para>A pointer to a system-defined context block. The context block is returned by the
<see cref="OpenEncryptedFileRaw" /> function. Do not modify
it.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, it returns a nonzero error code defined in WinError.h. You can use
<see cref="FormatMessage" /> with the
<b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of the error.</para>
    </returns>
    <remarks>
      <para>The file being restored is not decrypted;  it is restored in its encrypted state.</para>
      <para>To back up an encrypted file, call
<see cref="OpenEncryptedFileRaw" /> to open the file. Then call
<see cref="ReadEncryptedFileRaw" />, passing it the address of an
application-defined export callback function. The system calls this callback function multiple times until the
entire file's contents have been read and backed up.  When the backup is complete, call
<see cref="CloseEncryptedFileRaw" /> to free resources and close
the file. See <a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-pfe_export_func">ExportCallback</a> for details about how to
declare the export callback function.</para>
      <para>To restore an encrypted file, call
<see cref="OpenEncryptedFileRaw" />, specifying
<b>CREATE_FOR_IMPORT</b> in the <i>ulFlags</i> parameter. Then call
<b>WriteEncryptedFileRaw</b>, passing it the address of
an application-defined import callback function. The system calls this callback function multiple times until the
entire file's contents have been read and restored. When the restore is complete, call
<see cref="CloseEncryptedFileRaw" /> to free resources and close
the file. See <a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-pfe_import_func">ImportCallback</a> for details about how to
declare the export callback function.</para>
      <para>If the file is a sparse file that was backed up from a volume with a smaller sparse allocation unit size than
the volume it is being restored to, the sparse blocks in the middle of the file may not properly align with the
larger blocks and the function call would fail and set an <b>ERROR_INVALID_PARAMETER</b> last
error code. The sparse allocation unit size is either 16 clusters or 64 KB, whichever is smaller.</para>
      <para>This function is intended for restoring only encrypted files; see
<see cref="BackupWrite" /> for restoring unencrypted files.</para>
      <para>In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.</para>
      <list type="table">
        <listheader>
          <description>Technology</description>
          <description>Supported</description>
        </listheader>
        <item>
          <description>
            <para>Server Message Block (SMB) 3.0 protocol</para>
          </description>
          <description>
            <para>Yes</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 Transparent Failover (TFO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>SMB 3.0 with Scale-out File Shares (SO)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Cluster Shared Volume File System (CsvFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
        <item>
          <description>
            <para>Resilient File System (ReFS)</para>
          </description>
          <description>
            <para>No</para>
          </description>
        </item>
      </list>
      <para>SMB 3.0 does not support EFS on shares with continuous availability capability.</para>
    </remarks>
    <seealso cref="BackupWrite" />
    <seealso cref="CloseEncryptedFileRaw" />
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-encryption">File Encryption</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/FileIO/file-management-functions">File Management Functions</seealso>
    <seealso href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-pfe_import_func">ImportCallback</seealso>
    <seealso cref="OpenEncryptedFileRaw" />
    <seealso cref="ReadEncryptedFileRaw" />
  </member>
  <member name="Windows.WriteTapemark">
    <summary>
      <para>The
<b>WriteTapemark</b> function writes a specified number of filemarks, setmarks, short filemarks, or long filemarks to a tape device. These tapemarks divide a tape partition into smaller areas.</para>
    </summary>
    <param name="hDevice">
      <para>Handle to the device on which to write tapemarks. This handle is created by using the
<see cref="CreateFile" /> function.</para>
    </param>
    <param name="dwTapemarkType">
      <para>Type of tapemarks to write. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_FILEMARKS</b>
                </description>
              </item>
              <item>
                <description>1L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Writes the number of filemarks specified by the <i>dwTapemarkCount</i> parameter.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_LONG_FILEMARKS</b>
                </description>
              </item>
              <item>
                <description>3L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Writes the number of long filemarks specified by <i>dwTapemarkCount</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_SETMARKS</b>
                </description>
              </item>
              <item>
                <description>0L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Writes the number of setmarks specified by <i>dwTapemarkCount</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>TAPE_SHORT_FILEMARKS</b>
                </description>
              </item>
              <item>
                <description>2L</description>
              </item>
            </list>
          </description>
          <description>
            <para>Writes the number of short filemarks specified by <i>dwTapemarkCount</i>.</para>
          </description>
        </item>
      </list>
    </param>
    <param name="dwTapemarkCount">
      <para>Number of tapemarks to write.</para>
    </param>
    <param name="bImmediate">
      <para>If this parameter is <b>TRUE</b>, the function returns immediately; if it is <b>FALSE</b>, the function does not return until the operation has been completed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, it can return one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_BEGINNING_OF_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1102L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to access data before the beginning-of-medium marker failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_BUS_RESET</b>
                </description>
              </item>
              <item>
                <description>1111L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A reset condition was detected on the bus.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_DEVICE_NOT_PARTITIONED</b>
                </description>
              </item>
              <item>
                <description>1107L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The partition information could not be found when a tape was being loaded.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_END_OF_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1100L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The end-of-tape marker was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_FILEMARK_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1101L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A filemark was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_INVALID_BLOCK_LENGTH</b>
                </description>
              </item>
              <item>
                <description>1106L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The block size is incorrect on a new tape in a multivolume partition.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_MEDIA_CHANGED</b>
                </description>
              </item>
              <item>
                <description>1110L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape that was in the drive has been replaced or removed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NO_DATA_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1104L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The end-of-data marker was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NO_MEDIA_IN_DRIVE</b>
                </description>
              </item>
              <item>
                <description>1112L</description>
              </item>
            </list>
          </description>
          <description>
            <para>There is no media in the drive.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_NOT_SUPPORTED</b>
                </description>
              </item>
              <item>
                <description>50L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape driver does not support a requested function.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_PARTITION_FAILURE</b>
                </description>
              </item>
              <item>
                <description>1105L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The tape could not be partitioned.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_SETMARK_DETECTED</b>
                </description>
              </item>
              <item>
                <description>1103L</description>
              </item>
            </list>
          </description>
          <description>
            <para>A setmark was reached during an operation.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_UNABLE_TO_LOCK_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1108L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to lock the ejection mechanism failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b>
                </description>
              </item>
              <item>
                <description>1109L</description>
              </item>
            </list>
          </description>
          <description>
            <para>An attempt to unload the tape failed.</para>
          </description>
        </item>
        <item>
          <description>
            <list type="bullet">
              <item>
                <description>
                  <b>ERROR_WRITE_PROTECT</b>
                </description>
              </item>
              <item>
                <description>19L</description>
              </item>
            </list>
          </description>
          <description>
            <para>The media is write protected.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Filemarks, setmarks, short filemarks, and long filemarks are special recorded elements that denote the linear organization of the tape. None of these marks contain user data. Filemarks are the most general marks; setmarks provide a hierarchy not available with filemarks.</para>
      <para>A short filemark contains a short erase gap that cannot be overwritten unless the write operation is performed from the beginning of the partition or from an earlier long filemark.</para>
      <para>A long filemark contains a long erase gap that allows an application to position the tape at the beginning of the filemark and to overwrite the filemark and the erase gap.</para>
    </remarks>
    <seealso cref="CreateFile" />
  </member>
  <member name="Windows.WTSGetActiveConsoleSessionId">
    <summary>
      <para>Retrieves the session identifier of the console session. The console session is the session that is currently attached to the physical console. Note that it is not necessary that Remote Desktop Services be running for this
function to succeed.</para>
    </summary>
    <returns>
      <para>The session identifier of the session that is attached to the physical console. If there is no session attached to the
physical console, (for example, if the physical console session is in the process of being attached or detached), this function
returns 0xFFFFFFFF.</para>
    </returns>
    <remarks>
      <para>The session identifier returned by this function is the identifier of the current physical console session. To monitor
the state of the current physical console session, use the
<see cref="WTSRegisterSessionNotification" /></para>
      <para>function.</para>
    </remarks>
    <seealso cref="ProcessIdToSessionId" />
    <seealso href="https://docs.microsoft.com//windows/desktop/TermServ/wm-wtssession-change">WM_WTSSESSION_CHANGE</seealso>
    <seealso cref="WTSQuerySessionInformation" />
    <seealso cref="WTSRegisterSessionNotification" />
  </member>
  <member name="Windows.ZombifyActCtx">
    <summary>
      <para>The
<b>ZombifyActCtx</b> function deactivates the specified activation context, but does not deallocate it.</para>
    </summary>
    <param name="hActCtx">
      <para>Handle to the activation context that is to be deactivated.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. If a <b>null</b> handle is passed in the <i>hActCtx</i> parameter, NULL_INVALID_PARAMETER will be returned. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling
<see cref="GetLastError" />. For an example, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see
<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
    <remarks>
      <para>This function is intended for use in debugging threads using activation contexts. If the activation context deactivated by this function is subsequently accessed, the access  fails and an assertion failure is shown in the debugger.</para>
    </remarks>
    <seealso cref="ACTCTX" />
  </member>
  <member name="Windows._lclose">
    <summary>
      <para>The _lclose function closes the specified file so that it is no longer available for reading or writing. This function is provided for compatibility with 16-bit versions of Windows. Win32-based applications should use the CloseHandle function.</para>
    </summary>
    <param name="hFile">
      <para>Identifies the file to be closed. This handle is returned by the function that created or last opened the file.</para>
    </param>
    <returns>
      <para>Handle to file to close.</para>
    </returns>
  </member>
  <member name="Windows._lopen">
    <summary>
      <para>The _lopen function opens an existing file and sets the file pointer to the beginning of the file. This function is provided for compatibility with 16-bit versions of Windows. Win32-based applications should use the CreateFile function.</para>
    </summary>
    <param name="lpPathName">
      <para>Pointer to a null-terminated string that names the file to open. The string must consist of characters from the Windows ANSI character set.</para>
    </param>
    <param name="iReadWrite">
      <para>Specifies the modes in which to open the file. This parameter consists of one access mode and an optional share mode. The access mode must be one of the following values: OF_READ,  OF_READWRITE, OF_WRITE</para>
      <para>The share mode can be one of the following values: OF_SHARE_COMPAT,  OF_SHARE_DENY_NONE, OF_SHARE_DENY_READ, OF_SHARE_DENY_WRITE, OF_SHARE_EXCLUSIVE</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a file handle.</para>
    </returns>
  </member>
  <member name="Windows._lread">
    <summary>
      <para>The _lread function reads data from the specified file. This function is provided for compatibility with 16-bit versions of Windows. Win32-based applications should use the ReadFile function.</para>
    </summary>
    <param name="hFile">
      <para>Identifies the specified file.</para>
    </param>
    <param name="lpBuffer">
      <para>Pointer to a buffer that contains the data read from the file.</para>
    </param>
    <param name="uBytes">
      <para>Specifies the number of bytes to be read from the file.</para>
    </param>
    <returns>
      <para>The return value indicates the number of bytes actually read from the file. If the number of bytes read is less than uBytes, the function has reached the end of file (EOF) before reading the specified number of bytes.</para>
    </returns>
  </member>
</doc>