<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.AccessCheckAndAuditAlarm">
    <summary>
      <para>The <b>AccessCheckAndAuditAlarm</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client being impersonated by the calling thread. If the security descriptor has a SACL with ACEs that apply to the client, the function generates any necessary audit messages in the security event log.</para>
      <para>Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">A pointer to a unique value representing the client's handle to the object. If the access is denied, the system ignores this value.</param>
    <param name="ObjectTypeName">A pointer to a null-terminated string specifying the type of object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="ObjectName">A pointer to a null-terminated string specifying the name of the object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="SecurityDescriptor">A pointer to the<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</param>
    <param name="DesiredAccess">
      <para>
        <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">Access mask</a> that specifies the access rights to check. This mask must have been mapped by the<see cref="MapGenericMask" /> function to contain no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the <i>GrantedAccess</i> access mask to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="GenericMapping">A pointer to the<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</param>
    <param name="ObjectCreation">Specifies a flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</param>
    <param name="GrantedAccess">A pointer to an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that receives the granted access rights. If <i>AccessStatus</i> is set to <b>FALSE</b>, the function sets the access mask to zero. If the function fails, it does not set the access mask.</param>
    <param name="AccessStatus">A pointer to a variable that receives the results of the access check. If the security descriptor allows the requested access rights to the client, <i>AccessStatus</i> is set to <b>TRUE</b>. Otherwise, <i>AccessStatus</i> is set to <b>FALSE</b>.</param>
    <param name="pfGenerateOnClose">A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.AccessCheckAndAuditAlarmA">
    <summary>
      <para>The <b>AccessCheckAndAuditAlarm</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client being impersonated by the calling thread. If the security descriptor has a SACL with ACEs that apply to the client, the function generates any necessary audit messages in the security event log.</para>
      <para>Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">A pointer to a unique value representing the client's handle to the object. If the access is denied, the system ignores this value.</param>
    <param name="ObjectTypeName">A pointer to a null-terminated string specifying the type of object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="ObjectName">A pointer to a null-terminated string specifying the name of the object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="SecurityDescriptor">A pointer to the<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</param>
    <param name="DesiredAccess">
      <para>
        <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">Access mask</a> that specifies the access rights to check. This mask must have been mapped by the<see cref="MapGenericMask" /> function to contain no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the <i>GrantedAccess</i> access mask to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="GenericMapping">A pointer to the<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</param>
    <param name="ObjectCreation">Specifies a flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</param>
    <param name="GrantedAccess">A pointer to an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that receives the granted access rights. If <i>AccessStatus</i> is set to <b>FALSE</b>, the function sets the access mask to zero. If the function fails, it does not set the access mask.</param>
    <param name="AccessStatus">A pointer to a variable that receives the results of the access check. If the security descriptor allows the requested access rights to the client, <i>AccessStatus</i> is set to <b>TRUE</b>. Otherwise, <i>AccessStatus</i> is set to <b>FALSE</b>.</param>
    <param name="pfGenerateOnClose">A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.AccessCheckAndAuditAlarmW">
    <summary>
      <para>The <b>AccessCheckAndAuditAlarm</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client being impersonated by the calling thread. If the security descriptor has a SACL with ACEs that apply to the client, the function generates any necessary audit messages in the security event log.</para>
      <para>Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">A pointer to a unique value representing the client's handle to the object. If the access is denied, the system ignores this value.</param>
    <param name="ObjectTypeName">A pointer to a null-terminated string specifying the type of object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="ObjectName">A pointer to a null-terminated string specifying the name of the object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="SecurityDescriptor">A pointer to the<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</param>
    <param name="DesiredAccess">
      <para>
        <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">Access mask</a> that specifies the access rights to check. This mask must have been mapped by the<see cref="MapGenericMask" /> function to contain no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the <i>GrantedAccess</i> access mask to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="GenericMapping">A pointer to the<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</param>
    <param name="ObjectCreation">Specifies a flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</param>
    <param name="GrantedAccess">A pointer to an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that receives the granted access rights. If <i>AccessStatus</i> is set to <b>FALSE</b>, the function sets the access mask to zero. If the function fails, it does not set the access mask.</param>
    <param name="AccessStatus">A pointer to a variable that receives the results of the access check. If the security descriptor allows the requested access rights to the client, <i>AccessStatus</i> is set to <b>TRUE</b>. Otherwise, <i>AccessStatus</i> is set to <b>FALSE</b>.</param>
    <param name="pfGenerateOnClose">A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.AccessCheckByTypeAndAuditAlarm">
    <summary>
      <para>The <b>AccessCheckByTypeAndAuditAlarm</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client being impersonated by the calling thread. The function can check the client's access to a hierarchy of objects, such as an object, its property sets, and properties. The function grants or denies access to the hierarchy as a whole. If the security descriptor has a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) with <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control entries</a> (ACEs) that apply to the client, the function generates any necessary audit messages in the security event log.</para>
      <para>Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.</param>
    <param name="ObjectTypeName">A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="ObjectName">A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="SecurityDescriptor">A pointer to a<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</param>
    <param name="PrincipalSelfSid">
      <para>A pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID). If the security descriptor is associated with an object that represents a principal (for example, a user object), the <i>PrincipalSelfSid</i> parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE containing the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-known SIDs</a>.</para>
      <para>If the protected object does not represent a principal, set this parameter to <b>NULL</b>.</para>
    </param>
    <param name="DesiredAccess">
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the access rights to check. This mask must have been mapped by the<see cref="MapGenericMask" /> function to contain no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the <i>GrantedAccess</i> access mask to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="AuditType">The type of audit to be generated. This can be one of the values from the<see cref="AUDIT_EVENT_TYPE" /> enumeration type.</param>
    <param name="Flags">A flag that controls the function's behavior if the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.</param>
    <param name="ObjectTypeList">
      <para>A pointer to an array of<see cref="OBJECT_TYPE_LIST" /> structures that identify the hierarchy of object types for which to check access. Each element in the array specifies a GUID that identifies the object type and a value that indicates the level of the object type in the hierarchy of object types. The array should not have two elements with the same GUID.</para>
      <para>The array must have at least one element. The first element in the array must be at level zero and identify the object itself. The array can have only one level zero element. The second element is a subobject, such as a property set, at level 1. Following each level 1 entry are subordinate entries for the level 2 through 4 subobjects. Thus, the levels for the elements in the array might be {0, 1, 2, 2, 1, 2, 3}. If the object type list is out of order, <b>AccessCheckByTypeAndAuditAlarm</b> fails and<see cref="GetLastError" /> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <param name="ObjectTypeListLength">The number of elements in the <i>ObjectTypeList</i> array.</param>
    <param name="GenericMapping">A pointer to the<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</param>
    <param name="ObjectCreation">A flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</param>
    <param name="GrantedAccess">A pointer to an access mask that receives the granted access rights. If <i>AccessStatus</i> is set to <b>FALSE</b>, the function sets the access mask to zero. If the function fails, it does not set the access mask.</param>
    <param name="AccessStatus">A pointer to a variable that receives the results of the access check. If the security descriptor allows the requested access rights to the client, <i>AccessStatus</i> is set to <b>TRUE</b>. Otherwise, <i>AccessStatus</i> is set to <b>FALSE</b> and you can call<see cref="GetLastError" /> to get extended error information.</param>
    <param name="pfGenerateOnClose">A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.AccessCheckByTypeAndAuditAlarmA">
    <summary>
      <para>The <b>AccessCheckByTypeAndAuditAlarm</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client being impersonated by the calling thread. The function can check the client's access to a hierarchy of objects, such as an object, its property sets, and properties. The function grants or denies access to the hierarchy as a whole. If the security descriptor has a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) with <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control entries</a> (ACEs) that apply to the client, the function generates any necessary audit messages in the security event log.</para>
      <para>Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.</param>
    <param name="ObjectTypeName">A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="ObjectName">A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="SecurityDescriptor">A pointer to a<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</param>
    <param name="PrincipalSelfSid">
      <para>A pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID). If the security descriptor is associated with an object that represents a principal (for example, a user object), the <i>PrincipalSelfSid</i> parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE containing the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-known SIDs</a>.</para>
      <para>If the protected object does not represent a principal, set this parameter to <b>NULL</b>.</para>
    </param>
    <param name="DesiredAccess">
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the access rights to check. This mask must have been mapped by the<see cref="MapGenericMask" /> function to contain no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the <i>GrantedAccess</i> access mask to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="AuditType">The type of audit to be generated. This can be one of the values from the<see cref="AUDIT_EVENT_TYPE" /> enumeration type.</param>
    <param name="Flags">A flag that controls the function's behavior if the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.</param>
    <param name="ObjectTypeList">
      <para>A pointer to an array of<see cref="OBJECT_TYPE_LIST" /> structures that identify the hierarchy of object types for which to check access. Each element in the array specifies a GUID that identifies the object type and a value that indicates the level of the object type in the hierarchy of object types. The array should not have two elements with the same GUID.</para>
      <para>The array must have at least one element. The first element in the array must be at level zero and identify the object itself. The array can have only one level zero element. The second element is a subobject, such as a property set, at level 1. Following each level 1 entry are subordinate entries for the level 2 through 4 subobjects. Thus, the levels for the elements in the array might be {0, 1, 2, 2, 1, 2, 3}. If the object type list is out of order, <b>AccessCheckByTypeAndAuditAlarm</b> fails and<see cref="GetLastError" /> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <param name="ObjectTypeListLength">The number of elements in the <i>ObjectTypeList</i> array.</param>
    <param name="GenericMapping">A pointer to the<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</param>
    <param name="ObjectCreation">A flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</param>
    <param name="GrantedAccess">A pointer to an access mask that receives the granted access rights. If <i>AccessStatus</i> is set to <b>FALSE</b>, the function sets the access mask to zero. If the function fails, it does not set the access mask.</param>
    <param name="AccessStatus">A pointer to a variable that receives the results of the access check. If the security descriptor allows the requested access rights to the client, <i>AccessStatus</i> is set to <b>TRUE</b>. Otherwise, <i>AccessStatus</i> is set to <b>FALSE</b> and you can call<see cref="GetLastError" /> to get extended error information.</param>
    <param name="pfGenerateOnClose">A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.AccessCheckByTypeAndAuditAlarmW">
    <summary>
      <para>The <b>AccessCheckByTypeAndAuditAlarm</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client being impersonated by the calling thread. The function can check the client's access to a hierarchy of objects, such as an object, its property sets, and properties. The function grants or denies access to the hierarchy as a whole. If the security descriptor has a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) with <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control entries</a> (ACEs) that apply to the client, the function generates any necessary audit messages in the security event log.</para>
      <para>Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.</param>
    <param name="ObjectTypeName">A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="ObjectName">A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="SecurityDescriptor">A pointer to a<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</param>
    <param name="PrincipalSelfSid">
      <para>A pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID). If the security descriptor is associated with an object that represents a principal (for example, a user object), the <i>PrincipalSelfSid</i> parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE containing the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-known SIDs</a>.</para>
      <para>If the protected object does not represent a principal, set this parameter to <b>NULL</b>.</para>
    </param>
    <param name="DesiredAccess">
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the access rights to check. This mask must have been mapped by the<see cref="MapGenericMask" /> function to contain no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the <i>GrantedAccess</i> access mask to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="AuditType">The type of audit to be generated. This can be one of the values from the<see cref="AUDIT_EVENT_TYPE" /> enumeration type.</param>
    <param name="Flags">A flag that controls the function's behavior if the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.</param>
    <param name="ObjectTypeList">
      <para>A pointer to an array of<see cref="OBJECT_TYPE_LIST" /> structures that identify the hierarchy of object types for which to check access. Each element in the array specifies a GUID that identifies the object type and a value that indicates the level of the object type in the hierarchy of object types. The array should not have two elements with the same GUID.</para>
      <para>The array must have at least one element. The first element in the array must be at level zero and identify the object itself. The array can have only one level zero element. The second element is a subobject, such as a property set, at level 1. Following each level 1 entry are subordinate entries for the level 2 through 4 subobjects. Thus, the levels for the elements in the array might be {0, 1, 2, 2, 1, 2, 3}. If the object type list is out of order, <b>AccessCheckByTypeAndAuditAlarm</b> fails and<see cref="GetLastError" /> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <param name="ObjectTypeListLength">The number of elements in the <i>ObjectTypeList</i> array.</param>
    <param name="GenericMapping">A pointer to the<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</param>
    <param name="ObjectCreation">A flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</param>
    <param name="GrantedAccess">A pointer to an access mask that receives the granted access rights. If <i>AccessStatus</i> is set to <b>FALSE</b>, the function sets the access mask to zero. If the function fails, it does not set the access mask.</param>
    <param name="AccessStatus">A pointer to a variable that receives the results of the access check. If the security descriptor allows the requested access rights to the client, <i>AccessStatus</i> is set to <b>TRUE</b>. Otherwise, <i>AccessStatus</i> is set to <b>FALSE</b> and you can call<see cref="GetLastError" /> to get extended error information.</param>
    <param name="pfGenerateOnClose">A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.AccessCheckByTypeResultListAndAuditAlarm">
    <summary>The <b>AccessCheckByTypeResultListAndAuditAlarm</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client being impersonated by the calling thread. The function can check access to a hierarchy of objects, such as an object, its property sets, and properties. The function reports the access rights granted or denied to each object type in the hierarchy. If the security descriptor has a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) with <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control entries</a> (ACEs) that apply to the client, the function generates any necessary audit messages in the security event log. Alarms are not currently supported.</summary>
    <param name="SubsystemName">A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.</param>
    <param name="ObjectTypeName">A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="ObjectName">A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="SecurityDescriptor">A pointer to a<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</param>
    <param name="PrincipalSelfSid">
      <para>A pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID). If the security descriptor is associated with an object that represents a principal (for example, a user object), the <i>PrincipalSelfSid</i> parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE that contains the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-known SIDs</a>.</para>
      <para>Set this parameter to <b>NULL</b> if the protected object does not represent a principal.</para>
    </param>
    <param name="DesiredAccess">
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the access rights to check. This mask must have been mapped by the<see cref="MapGenericMask" /> function so that it contains no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the access mask in <i>GrantedAccess</i> to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="AuditType">The type of audit to be generated. This can be one of the values from the<see cref="AUDIT_EVENT_TYPE" /> enumeration type.</param>
    <param name="Flags">A flag that controls the function's behavior if the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.</param>
    <param name="ObjectTypeList">
      <para>A pointer to an array of<see cref="OBJECT_TYPE_LIST" /> structures that identify the hierarchy of object types for which to check access. Each element in the array specifies a GUID that identifies the object type and a value that indicates the level of the object type in the hierarchy of object types. The array should not have two elements with the same GUID.</para>
      <para>The array must have at least one element. The first element in the array must be at level zero and identify the object itself. The array can have only one level zero element. The second element is a subobject, such as a property set, at level 1. Following each level 1 entry are subordinate entries for the level 2 through 4 subobjects. Thus, the levels for the elements in the array might be {0, 1, 2, 2, 1, 2, 3}. If the object type list is out of order, <b>AccessCheckByTypeResultListAndAuditAlarm</b> fails, and<see cref="GetLastError" /> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <param name="ObjectTypeListLength">The number of elements in the <i>ObjectTypeList</i> array.</param>
    <param name="GenericMapping">A pointer to the<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</param>
    <param name="ObjectCreation">A flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</param>
    <param name="GrantedAccess">A pointer to an array of access masks. The function sets each access mask to indicate the access rights granted to the corresponding element in the object type list. If the function fails, it does not set the access masks.</param>
    <param name="AccessStatusList">A pointer to an array of status codes for the corresponding elements in the object type list. The function sets an element to zero to indicate success or to a nonzero value to indicate the specific error during the access check. If the function fails, it does not set any of the elements in the array.</param>
    <param name="pfGenerateOnClose">A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.AccessCheckByTypeResultListAndAuditAlarmA">
    <summary>The <b>AccessCheckByTypeResultListAndAuditAlarm</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client being impersonated by the calling thread. The function can check access to a hierarchy of objects, such as an object, its property sets, and properties. The function reports the access rights granted or denied to each object type in the hierarchy. If the security descriptor has a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) with <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control entries</a> (ACEs) that apply to the client, the function generates any necessary audit messages in the security event log. Alarms are not currently supported.</summary>
    <param name="SubsystemName">A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.</param>
    <param name="ObjectTypeName">A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="ObjectName">A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="SecurityDescriptor">A pointer to a<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</param>
    <param name="PrincipalSelfSid">
      <para>A pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID). If the security descriptor is associated with an object that represents a principal (for example, a user object), the <i>PrincipalSelfSid</i> parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE that contains the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-known SIDs</a>.</para>
      <para>Set this parameter to <b>NULL</b> if the protected object does not represent a principal.</para>
    </param>
    <param name="DesiredAccess">
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the access rights to check. This mask must have been mapped by the<see cref="MapGenericMask" /> function so that it contains no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the access mask in <i>GrantedAccess</i> to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="AuditType">The type of audit to be generated. This can be one of the values from the<see cref="AUDIT_EVENT_TYPE" /> enumeration type.</param>
    <param name="Flags">A flag that controls the function's behavior if the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.</param>
    <param name="ObjectTypeList">
      <para>A pointer to an array of<see cref="OBJECT_TYPE_LIST" /> structures that identify the hierarchy of object types for which to check access. Each element in the array specifies a GUID that identifies the object type and a value that indicates the level of the object type in the hierarchy of object types. The array should not have two elements with the same GUID.</para>
      <para>The array must have at least one element. The first element in the array must be at level zero and identify the object itself. The array can have only one level zero element. The second element is a subobject, such as a property set, at level 1. Following each level 1 entry are subordinate entries for the level 2 through 4 subobjects. Thus, the levels for the elements in the array might be {0, 1, 2, 2, 1, 2, 3}. If the object type list is out of order, <b>AccessCheckByTypeResultListAndAuditAlarm</b> fails, and<see cref="GetLastError" /> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <param name="ObjectTypeListLength">The number of elements in the <i>ObjectTypeList</i> array.</param>
    <param name="GenericMapping">A pointer to the<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</param>
    <param name="ObjectCreation">A flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</param>
    <param name="GrantedAccess">A pointer to an array of access masks. The function sets each access mask to indicate the access rights granted to the corresponding element in the object type list. If the function fails, it does not set the access masks.</param>
    <param name="AccessStatusList">A pointer to an array of status codes for the corresponding elements in the object type list. The function sets an element to zero to indicate success or to a nonzero value to indicate the specific error during the access check. If the function fails, it does not set any of the elements in the array.</param>
    <param name="pfGenerateOnClose">A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.AccessCheckByTypeResultListAndAuditAlarmW">
    <summary>The <b>AccessCheckByTypeResultListAndAuditAlarm</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client being impersonated by the calling thread. The function can check access to a hierarchy of objects, such as an object, its property sets, and properties. The function reports the access rights granted or denied to each object type in the hierarchy. If the security descriptor has a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) with <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control entries</a> (ACEs) that apply to the client, the function generates any necessary audit messages in the security event log. Alarms are not currently supported.</summary>
    <param name="SubsystemName">A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.</param>
    <param name="ObjectTypeName">A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="ObjectName">A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="SecurityDescriptor">A pointer to a<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</param>
    <param name="PrincipalSelfSid">
      <para>A pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID). If the security descriptor is associated with an object that represents a principal (for example, a user object), the <i>PrincipalSelfSid</i> parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE that contains the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-known SIDs</a>.</para>
      <para>Set this parameter to <b>NULL</b> if the protected object does not represent a principal.</para>
    </param>
    <param name="DesiredAccess">
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the access rights to check. This mask must have been mapped by the<see cref="MapGenericMask" /> function so that it contains no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the access mask in <i>GrantedAccess</i> to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="AuditType">The type of audit to be generated. This can be one of the values from the<see cref="AUDIT_EVENT_TYPE" /> enumeration type.</param>
    <param name="Flags">A flag that controls the function's behavior if the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.</param>
    <param name="ObjectTypeList">
      <para>A pointer to an array of<see cref="OBJECT_TYPE_LIST" /> structures that identify the hierarchy of object types for which to check access. Each element in the array specifies a GUID that identifies the object type and a value that indicates the level of the object type in the hierarchy of object types. The array should not have two elements with the same GUID.</para>
      <para>The array must have at least one element. The first element in the array must be at level zero and identify the object itself. The array can have only one level zero element. The second element is a subobject, such as a property set, at level 1. Following each level 1 entry are subordinate entries for the level 2 through 4 subobjects. Thus, the levels for the elements in the array might be {0, 1, 2, 2, 1, 2, 3}. If the object type list is out of order, <b>AccessCheckByTypeResultListAndAuditAlarm</b> fails, and<see cref="GetLastError" /> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <param name="ObjectTypeListLength">The number of elements in the <i>ObjectTypeList</i> array.</param>
    <param name="GenericMapping">A pointer to the<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</param>
    <param name="ObjectCreation">A flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</param>
    <param name="GrantedAccess">A pointer to an array of access masks. The function sets each access mask to indicate the access rights granted to the corresponding element in the object type list. If the function fails, it does not set the access masks.</param>
    <param name="AccessStatusList">A pointer to an array of status codes for the corresponding elements in the object type list. The function sets an element to zero to indicate success or to a nonzero value to indicate the specific error during the access check. If the function fails, it does not set any of the elements in the array.</param>
    <param name="pfGenerateOnClose">A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.AccessCheckByTypeResultListAndAuditAlarmByHandle">
    <summary>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client that the calling thread is impersonating. The difference between this function and<see cref="AccessCheckByTypeResultListAndAuditAlarm" /> is that this function allows the calling thread to perform the access check before impersonating the client.</para>
      <para>The function can check access to a hierarchy of objects, such as an object, its property sets, and properties. The function reports the access rights granted or denied to each object type in the hierarchy. If the security descriptor has a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) with <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control entries</a> (ACEs) that apply to the client, the function generates any necessary audit messages in the security event log. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.</param>
    <param name="ClientToken">A handle to a token object that represents the client that requested the operation. This handle must be obtained through a communication session layer, such as a local named pipe, to prevent possible security policy violations. The caller must have TOKEN_QUERY access for the specified token.</param>
    <param name="ObjectTypeName">A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="ObjectName">A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="SecurityDescriptor">A pointer to a<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</param>
    <param name="PrincipalSelfSid">
      <para>A pointer to a SID. If the security descriptor is associated with an object that represents a principal (for example, a user object), the <i>PrincipalSelfSid</i> parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE containing the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-known SIDs</a>.</para>
      <para>Set this parameter to <b>NULL</b> if the protected object does not represent a principal.</para>
    </param>
    <param name="DesiredAccess">
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the access rights to check. This mask must have been mapped by the<see cref="MapGenericMask" /> function so that it contains no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the access mask in <i>GrantedAccess</i> to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="AuditType">The type of audit to be generated. This can be one of the values from the<see cref="AUDIT_EVENT_TYPE" /> enumeration type.</param>
    <param name="Flags">A flag that controls the function's behavior if the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.</param>
    <param name="ObjectTypeList">
      <para>A pointer to an array of<see cref="OBJECT_TYPE_LIST" /> structures that identify the hierarchy of object types for which to check access. Each element in the array specifies a GUID that identifies the object type and a value that indicates the level of the object type in the hierarchy of object types. The array should not have two elements with the same GUID.</para>
      <para>The array must have at least one element. The first element in the array must be at level zero and identify the object itself. The array can have only one level zero element. The second element is a subobject, such as a property set, at level 1. Following each level 1 entry are subordinate entries for the level 2 through 4 subobjects. Thus, the levels for the elements in the array might be {0, 1, 2, 2, 1, 2, 3}. If the object type list is out of order, <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> fails, and<see cref="GetLastError" /> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <param name="ObjectTypeListLength">The number of elements in the <i>ObjectTypeList</i> array.</param>
    <param name="GenericMapping">A pointer to the<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</param>
    <param name="ObjectCreation">A flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</param>
    <param name="GrantedAccess">A pointer to an array of access masks. The function sets each access mask to indicate the access rights granted to the corresponding element in the object type list. If the function fails, it does not set the access masks.</param>
    <param name="AccessStatusList">A pointer to an array of status codes for the corresponding elements in the object type list. The function sets an element to zero to indicate success or to a nonzero value to indicate the specific error during the access check. If the function fails, it does not set any of the elements in the array.</param>
    <param name="pfGenerateOnClose">A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.AccessCheckByTypeResultListAndAuditAlarmByHandleA">
    <summary>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client that the calling thread is impersonating. The difference between this function and<see cref="AccessCheckByTypeResultListAndAuditAlarm" /> is that this function allows the calling thread to perform the access check before impersonating the client.</para>
      <para>The function can check access to a hierarchy of objects, such as an object, its property sets, and properties. The function reports the access rights granted or denied to each object type in the hierarchy. If the security descriptor has a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) with <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control entries</a> (ACEs) that apply to the client, the function generates any necessary audit messages in the security event log. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.</param>
    <param name="ClientToken">A handle to a token object that represents the client that requested the operation. This handle must be obtained through a communication session layer, such as a local named pipe, to prevent possible security policy violations. The caller must have TOKEN_QUERY access for the specified token.</param>
    <param name="ObjectTypeName">A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="ObjectName">A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="SecurityDescriptor">A pointer to a<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</param>
    <param name="PrincipalSelfSid">
      <para>A pointer to a SID. If the security descriptor is associated with an object that represents a principal (for example, a user object), the <i>PrincipalSelfSid</i> parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE containing the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-known SIDs</a>.</para>
      <para>Set this parameter to <b>NULL</b> if the protected object does not represent a principal.</para>
    </param>
    <param name="DesiredAccess">
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the access rights to check. This mask must have been mapped by the<see cref="MapGenericMask" /> function so that it contains no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the access mask in <i>GrantedAccess</i> to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="AuditType">The type of audit to be generated. This can be one of the values from the<see cref="AUDIT_EVENT_TYPE" /> enumeration type.</param>
    <param name="Flags">A flag that controls the function's behavior if the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.</param>
    <param name="ObjectTypeList">
      <para>A pointer to an array of<see cref="OBJECT_TYPE_LIST" /> structures that identify the hierarchy of object types for which to check access. Each element in the array specifies a GUID that identifies the object type and a value that indicates the level of the object type in the hierarchy of object types. The array should not have two elements with the same GUID.</para>
      <para>The array must have at least one element. The first element in the array must be at level zero and identify the object itself. The array can have only one level zero element. The second element is a subobject, such as a property set, at level 1. Following each level 1 entry are subordinate entries for the level 2 through 4 subobjects. Thus, the levels for the elements in the array might be {0, 1, 2, 2, 1, 2, 3}. If the object type list is out of order, <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> fails, and<see cref="GetLastError" /> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <param name="ObjectTypeListLength">The number of elements in the <i>ObjectTypeList</i> array.</param>
    <param name="GenericMapping">A pointer to the<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</param>
    <param name="ObjectCreation">A flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</param>
    <param name="GrantedAccess">A pointer to an array of access masks. The function sets each access mask to indicate the access rights granted to the corresponding element in the object type list. If the function fails, it does not set the access masks.</param>
    <param name="AccessStatusList">A pointer to an array of status codes for the corresponding elements in the object type list. The function sets an element to zero to indicate success or to a nonzero value to indicate the specific error during the access check. If the function fails, it does not set any of the elements in the array.</param>
    <param name="pfGenerateOnClose">A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.AccessCheckByTypeResultListAndAuditAlarmByHandleW">
    <summary>
      <para>The <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> function determines whether a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> grants a specified set of access rights to the client that the calling thread is impersonating. The difference between this function and<see cref="AccessCheckByTypeResultListAndAuditAlarm" /> is that this function allows the calling thread to perform the access check before impersonating the client.</para>
      <para>The function can check access to a hierarchy of objects, such as an object, its property sets, and properties. The function reports the access rights granted or denied to each object type in the hierarchy. If the security descriptor has a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) with <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control entries</a> (ACEs) that apply to the client, the function generates any necessary audit messages in the security event log. Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">A pointer to a null-terminated string that specifies the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">A pointer to a unique value that represents the client's handle to the object. If the access is denied, the system ignores this value.</param>
    <param name="ClientToken">A handle to a token object that represents the client that requested the operation. This handle must be obtained through a communication session layer, such as a local named pipe, to prevent possible security policy violations. The caller must have TOKEN_QUERY access for the specified token.</param>
    <param name="ObjectTypeName">A pointer to a null-terminated string that specifies the type of object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="ObjectName">A pointer to a null-terminated string that specifies the name of the object being created or accessed. This string appears in any audit message that the function generates.</param>
    <param name="SecurityDescriptor">A pointer to a<see cref="SECURITY_DESCRIPTOR" /> structure against which access is checked.</param>
    <param name="PrincipalSelfSid">
      <para>A pointer to a SID. If the security descriptor is associated with an object that represents a principal (for example, a user object), the <i>PrincipalSelfSid</i> parameter should be the SID of the object. When evaluating access, this SID logically replaces the SID in any ACE containing the well-known PRINCIPAL_SELF SID (S-1-5-10). For information about well-known SIDs, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-known SIDs</a>.</para>
      <para>Set this parameter to <b>NULL</b> if the protected object does not represent a principal.</para>
    </param>
    <param name="DesiredAccess">
      <para>An <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> that specifies the access rights to check. This mask must have been mapped by the<see cref="MapGenericMask" /> function so that it contains no generic access rights.</para>
      <para>If this parameter is MAXIMUM_ALLOWED, the function sets the access mask in <i>GrantedAccess</i> to indicate the maximum access rights the security descriptor allows the client.</para>
    </param>
    <param name="AuditType">The type of audit to be generated. This can be one of the values from the<see cref="AUDIT_EVENT_TYPE" /> enumeration type.</param>
    <param name="Flags">A flag that controls the function's behavior if the calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> does not have the SE_AUDIT_NAME privilege enabled. If the AUDIT_ALLOW_NO_PRIVILEGE flag is set, the function performs the access check without generating audit messages when the privilege is not enabled. If this parameter is zero, the function fails if the privilege is not enabled.</param>
    <param name="ObjectTypeList">
      <para>A pointer to an array of<see cref="OBJECT_TYPE_LIST" /> structures that identify the hierarchy of object types for which to check access. Each element in the array specifies a GUID that identifies the object type and a value that indicates the level of the object type in the hierarchy of object types. The array should not have two elements with the same GUID.</para>
      <para>The array must have at least one element. The first element in the array must be at level zero and identify the object itself. The array can have only one level zero element. The second element is a subobject, such as a property set, at level 1. Following each level 1 entry are subordinate entries for the level 2 through 4 subobjects. Thus, the levels for the elements in the array might be {0, 1, 2, 2, 1, 2, 3}. If the object type list is out of order, <b>AccessCheckByTypeResultListAndAuditAlarmByHandle</b> fails, and<see cref="GetLastError" /> returns ERROR_INVALID_PARAMETER.</para>
    </param>
    <param name="ObjectTypeListLength">The number of elements in the <i>ObjectTypeList</i> array.</param>
    <param name="GenericMapping">A pointer to the<see cref="GENERIC_MAPPING" /> structure associated with the object for which access is being checked.</param>
    <param name="ObjectCreation">A flag that determines whether the calling application will create a new object when access is granted. A value of <b>TRUE</b> indicates the application will create a new object. A value of <b>FALSE</b> indicates the application will open an existing object.</param>
    <param name="GrantedAccess">A pointer to an array of access masks. The function sets each access mask to indicate the access rights granted to the corresponding element in the object type list. If the function fails, it does not set the access masks.</param>
    <param name="AccessStatusList">A pointer to an array of status codes for the corresponding elements in the object type list. The function sets an element to zero to indicate success or to a nonzero value to indicate the specific error during the access check. If the function fails, it does not set any of the elements in the array.</param>
    <param name="pfGenerateOnClose">A pointer to a flag set by the audit-generation routine when the function returns. Pass this flag to the<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ActivateActCtx">
    <summary>The<b>ActivateActCtx</b> function activates the specified activation context. It does this by pushing the specified activation context to the top of the activation stack. The specified activation context is thus associated with the current thread and any appropriate side-by-side API functions.</summary>
    <param name="hActCtx">Handle to an<see cref="ACTCTX" /> structure that contains information on the activation context that is to be made active.</param>
    <param name="lpCookie">Pointer to a <b>ULONG_PTR</b> that functions as a cookie, uniquely identifying a specific, activated activation context.</param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling<see cref="GetLastError" />. For an example, see<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
  </member>
  <member name="Windows.AddAtom">
    <summary>Adds a character string to the local atom table and returns a unique value (an atom) identifying the string.</summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings differing only in case are considered identical. The case of the first string added is preserved and returned by the <see cref="GetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.AddAtomA">
    <summary>Adds a character string to the local atom table and returns a unique value (an atom) identifying the string.</summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings differing only in case are considered identical. The case of the first string added is preserved and returned by the <see cref="GetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.AddAtomW">
    <summary>Adds a character string to the local atom table and returns a unique value (an atom) identifying the string.</summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings differing only in case are considered identical. The case of the first string added is preserved and returned by the <see cref="GetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.AddAtom">
    <summary>Adds a character string to the local atom table and returns a unique value (an atom) identifying the string.</summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings differing only in case are considered identical. The case of the first string added is preserved and returned by the <see cref="GetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.AddAtomA">
    <summary>Adds a character string to the local atom table and returns a unique value (an atom) identifying the string.</summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings differing only in case are considered identical. The case of the first string added is preserved and returned by the <see cref="GetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.AddAtomW">
    <summary>Adds a character string to the local atom table and returns a unique value (an atom) identifying the string.</summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings differing only in case are considered identical. The case of the first string added is preserved and returned by the <see cref="GetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.AddConditionalAce">
    <summary>The <b>AddConditionalAce</b> function adds a conditional <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control entry</a> (ACE) to the specified <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access control list</a> (ACL). A conditional ACE specifies a logical condition that is evaluated during access checks.</summary>
    <param name="pAcl">
      <para>A pointer to an ACL. This function adds an ACE to this ACL.</para>
      <para>The value of this parameter cannot be <b>NULL</b>.</para>
    </param>
    <param name="dwAceRevision">Specifies the revision level of the ACL being modified. This value can be ACL_REVISION or ACL_REVISION_DS. Use ACL_REVISION_DS if the ACL contains object-specific ACEs.</param>
    <param name="AceFlags">
      <para>A set of bit flags that control ACE inheritance. The function sets these flags in the <b>AceFlags</b> member of the<see cref="ACE_HEADER" /> structure of the new ACE. This parameter can be a combination of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CONTAINER_INHERIT_ACE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The ACE is inherited by container objects.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>INHERIT_ONLY_ACE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The ACE does not apply to the object to which the ACL is assigned, but it can be inherited by child objects.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>INHERITED_ACE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Indicates an inherited ACE. This flag allows operations that change the security on a tree of objects to modify inherited ACEs while not changing ACEs that were directly applied to the object.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NO_PROPAGATE_INHERIT_ACE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The OBJECT_INHERIT_ACE and CONTAINER_INHERIT_ACE bits are not propagated to an inherited ACE.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OBJECT_INHERIT_ACE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The ACE is inherited by noncontainer objects.</description>
        </listheader>
      </list>
    </param>
    <param name="AceType">
      <para>The type of the ACE.</para>
      <para>This can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ACCESS_ALLOWED_CALLBACK_ACE_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x9</term>
              </listheader>
            </list>
          </description>
          <description>Access-allowed callback ACE that uses the <see cref="ACCESS_ALLOWED_CALLBACK_ACE" /> structure.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ACCESS_DENIED_CALLBACK_ACE_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0xA</term>
              </listheader>
            </list>
          </description>
          <description>Access-denied callback ACE that uses the <see cref="ACCESS_DENIED_CALLBACK_ACE" /> structure.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SYSTEM_AUDIT_CALLBACK_ACE_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0xD</term>
              </listheader>
            </list>
          </description>
          <description>System audit callback ACE that uses the <see cref="SYSTEM_AUDIT_CALLBACK_ACE" /> structure.</description>
        </listheader>
      </list>
    </param>
    <param name="AccessMask">Specifies the mask of access rights to be granted to the specified SID.</param>
    <param name="pSid">A pointer to the SID that represents a user, group, or logon account being granted access.</param>
    <param name="ConditionStr">A string that specifies the conditional statement to be evaluated for the ACE.</param>
    <param name="ReturnLength">The size, in bytes, of the ACL. If the buffer specified by the <i>pACL</i> parameter is not of sufficient size, the value of this parameter is the required size.</param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>.</para>
      <para>If the function fails, it returns <b>FALSE</b>. For extended error information, call<see cref="GetLastError" />. The following are possible error values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INSUFFICIENT_BUFFER</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The new ACE does not fit into the <i>pAcl</i> buffer.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.AddIntegrityLabelToBoundaryDescriptor">
    <summary>Adds a new required security identifier (SID) to the specified boundary descriptor.</summary>
    <param name="BoundaryDescriptor">A handle to the boundary descriptor. The <see cref="CreateBoundaryDescriptor" /> function returns this handle.</param>
    <param name="IntegrityLabel">
      <para>A pointer to a <see cref="SID" /> structure that represents the mandatory integrity level for the namespace. Use one of the following RID values to create the SID:</para>
      <para>
        <b>SECURITY_MANDATORY_UNTRUSTED_RID</b>
        <b>SECURITY_MANDATORY_LOW_RID</b>
        <b>SECURITY_MANDATORY_MEDIUM_RID</b>
        <b>SECURITY_MANDATORY_SYSTEM_RID</b>
        <b>SECURITY_MANDATORY_PROTECTED_PROCESS_RID</b>For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/well-known-sids">Well-Known SIDs</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.AddRefActCtx">
    <summary>The<b>AddRefActCtx</b> function increments the reference count of the specified activation context.</summary>
    <param name="hActCtx">Handle to an<see cref="ACTCTX" /> structure that contains information on the activation context for which the reference count is to be incremented.</param>
  </member>
  <member name="Windows.AddSecureMemoryCacheCallback">
    <summary>Registers a callback function to be called when a secured memory range is freed or its protections are changed.</summary>
    <param name="pfnCallBack">A pointer to the application-defined<a href="https://docs.microsoft.com//windows/desktop/api/winnt/nc-winnt-psecure_memory_cache_callback">SecureMemoryCacheCallback</a> function to register.</param>
    <returns>
      <para>If the function succeeds, it registers the callback function and returns<b>TRUE</b>.</para>
      <para>If the function fails, it returns <b>FALSE</b>. To get extended error information, call the <see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.ApplicationRecoveryFinished">
    <summary>Indicates that the calling application has completed its data recovery.</summary>
    <param name="bSuccess">Specify <b>TRUE</b> to indicate that the data was successfully recovered; otherwise, <b>FALSE</b>.</param>
  </member>
  <member name="Windows.ApplicationRecoveryInProgress">
    <summary>Indicates that the calling application is continuing to recover data.</summary>
    <param name="pbCancelled">Indicates whether the user has canceled the recovery process. Set by WER if the user clicks the Cancel button.</param>
    <returns>
      <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>E_FAIL</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>You can call this function only after Windows Error Reporting has called your recovery callback function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>E_INVALIDARG</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The <i>pbCancelled</i> cannot be <b>NULL</b>.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.BackupEventLog">
    <summary>Saves the specified event log to a backup file. The function does not clear the event log.</summary>
    <param name="hEventLog">A handle to the open event log. The <see cref="OpenEventLog" /> function returns this handle.</param>
    <param name="lpBackupFileName">The absolute or relative path of the backup file.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.BackupEventLogA">
    <summary>Saves the specified event log to a backup file. The function does not clear the event log.</summary>
    <param name="hEventLog">A handle to the open event log. The <see cref="OpenEventLog" /> function returns this handle.</param>
    <param name="lpBackupFileName">The absolute or relative path of the backup file.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.BackupEventLogW">
    <summary>Saves the specified event log to a backup file. The function does not clear the event log.</summary>
    <param name="hEventLog">A handle to the open event log. The <see cref="OpenEventLog" /> function returns this handle.</param>
    <param name="lpBackupFileName">The absolute or relative path of the backup file.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.BackupEventLog">
    <summary>Saves the specified event log to a backup file. The function does not clear the event log.</summary>
    <param name="hEventLog">A handle to the open event log. The <see cref="OpenEventLog" /> function returns this handle.</param>
    <param name="lpBackupFileName">The absolute or relative path of the backup file.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.BackupEventLogA">
    <summary>Saves the specified event log to a backup file. The function does not clear the event log.</summary>
    <param name="hEventLog">A handle to the open event log. The <see cref="OpenEventLog" /> function returns this handle.</param>
    <param name="lpBackupFileName">The absolute or relative path of the backup file.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.BackupEventLogW">
    <summary>Saves the specified event log to a backup file. The function does not clear the event log.</summary>
    <param name="hEventLog">A handle to the open event log. The <see cref="OpenEventLog" /> function returns this handle.</param>
    <param name="lpBackupFileName">The absolute or relative path of the backup file.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.BackupRead">
    <summary>The <b>BackupRead</b> function can be used to back up a file or directory, including the security information. The function reads data associated with a specified file or directory into a buffer, which can then be written to the backup medium using the<see cref="WriteFile" /> function.</summary>
    <param name="hFile">
      <para>Handle to the file or directory to be backed up. To obtain the handle, call the <see cref="CreateFile" /> function. The SACLs are not read unless the file handle was created with the <b>ACCESS_SYSTEM_SECURITY</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/file-security-and-access-rights">File security and access rights</a>.</para>
      <para>The handle must be synchronous (nonoverlapped). This means that the <b>FILE_FLAG_OVERLAPPED</b> flag must not be set when <see cref="CreateFile" /> is called. This function does not validate that the handle it receives is synchronous, so it does not return an error code for a synchronous handle, but calling it with an asynchronous (overlapped) handle can result in subtle errors that are very difficult to debug.</para>
      <para>The <b>BackupRead</b> function may fail if<b>CreateFile</b> was called with the flag<b>FILE_FLAG_NO_BUFFERING</b>. In this case, the<see cref="GetLastError" /> function returns the value<b>ERROR_INVALID_PARAMETER</b>.</para>
    </param>
    <param name="lpBuffer">Pointer to a buffer that receives the data.</param>
    <param name="nNumberOfBytesToRead">Length of the buffer, in bytes. The buffer size must be greater than the size of a<see cref="WIN32_STREAM_ID" /> structure.</param>
    <param name="lpNumberOfBytesRead">
      <para>Pointer to a variable that receives the number of bytes read.</para>
      <para>If the function returns a nonzero value, and the variable pointed to by<i>lpNumberOfBytesRead</i> is zero, then all the data associated with the file handle has been read.</para>
    </param>
    <param name="bAbort">Indicates whether you have finished using <b>BackupRead</b>on the handle. While you are backing up the file, specify this parameter as <b>FALSE</b>. Once you are done using <b>BackupRead</b>, you must call<b>BackupRead</b> one more time specifying<b>TRUE</b> for this parameter and passing the appropriate<i>lpContext</i>. <i>lpContext</i> must be passed when<i>bAbort</i> is <b>TRUE</b>; all other parameters are ignored.</param>
    <param name="bProcessSecurity">
      <para>Indicates whether the function will restore the access-control list (ACL) data for the file or directory.</para>
      <para>If <i>bProcessSecurity</i> is <b>TRUE</b>, the ACL data will be backed up.</para>
    </param>
    <param name="lpContext">
      <para>Pointer to a variable that receives a pointer to an internal data structure used by<b>BackupRead</b> to maintain context information during a backup operation.</para>
      <para>You must set the variable pointed to by <i>lpContext</i> to <b>NULL</b>before the first call to <b>BackupRead</b> for the specified file or directory. The function allocates memory for the data structure, and then sets the variable to point to that structure. You must not change <i>lpContext</i> or the variable that it points to between calls to <b>BackupRead</b>.</para>
      <para>To release the memory used by the data structure, call<b>BackupRead</b> with the<i>bAbort</i> parameter set to <b>TRUE</b> when the backup operation is complete.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero, indicating that an I/O error occurred. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.BackupSeek">
    <summary>The<b>BackupSeek</b> function seeks forward in a data stream initially accessed by using the<see cref="BackupRead" /> or<see cref="BackupWrite" /> function.</summary>
    <param name="hFile">
      <para>Handle to the file or directory. This handle is created by using the<see cref="CreateFile" /> function.</para>
      <para>The handle must be synchronous (nonoverlapped). This means that the FILE_FLAG_OVERLAPPED flag must not be set when <see cref="CreateFile" /> is called. This function does not validate that the handle it receives is synchronous, so it does not return an error code for a synchronous handle, but calling it with an asynchronous (overlapped) handle can result in subtle errors that are very difficult to debug.</para>
    </param>
    <param name="dwLowBytesToSeek">Low-order part of the number of bytes to seek.</param>
    <param name="dwHighBytesToSeek">High-order part of the number of bytes to seek.</param>
    <param name="lpdwLowByteSeeked">Pointer to a variable that receives the low-order bits of the number of bytes the function actually seeks.</param>
    <param name="lpdwHighByteSeeked">Pointer to a variable that receives the high-order bits of the number of bytes the function actually seeks.</param>
    <param name="lpContext">Pointer to an internal data structure used by the function. This structure must be the same structure that was initialized by the<see cref="BackupRead" /> or <see cref="BackupWrite" /> function. An application must not touch the contents of this structure.</param>
    <returns>
      <para>If the function could seek the requested amount, the function returns a nonzero value.</para>
      <para>If the function could not seek the requested amount, the function returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.BackupWrite">
    <summary>The <b>BackupWrite</b> function can be used to restore a file or directory that was backed up using<see cref="BackupRead" />. Use the<see cref="ReadFile" /> function to get a stream of data from the backup medium, then use <b>BackupWrite</b> to write the data to the specified file or directory.</summary>
    <param name="hFile">
      <para>Handle to the file or directory to be restored. To obtain the handle, call the <see cref="CreateFile" /> function. The SACLs are not restored unless the file handle was created with the <b>ACCESS_SYSTEM_SECURITY</b> access right. To ensure that the integrity ACEs are restored correctly, the file handle must also have been created with the <b>WRITE_OWNER</b> access right. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/file-security-and-access-rights">File security and access rights</a>.</para>
      <para>The handle must be synchronous (nonoverlapped). This means that the <b>FILE_FLAG_OVERLAPPED</b> flag must not be set when <see cref="CreateFile" /> is called. This function does not validate that the handle it receives is synchronous, so it does not return an error code for a synchronous handle, but calling it with an asynchronous (overlapped) handle can result in subtle errors that are very difficult to debug.</para>
      <para>The <b>BackupWrite</b> function may fail if<see cref="CreateFile" /> was called with the flag<b>FILE_FLAG_NO_BUFFERING</b>. In this case, the<see cref="GetLastError" /> function returns the value<b>ERROR_INVALID_PARAMETER</b>.</para>
    </param>
    <param name="lpBuffer">Pointer to a buffer that the function writes data from.</param>
    <param name="nNumberOfBytesToWrite">Size of the buffer, in bytes. The buffer size must be greater than the size of a<see cref="WIN32_STREAM_ID" /> structure.</param>
    <param name="lpNumberOfBytesWritten">Pointer to a variable that receives the number of bytes written.</param>
    <param name="bAbort">Indicates whether you have finished using <b>BackupWrite</b> on the handle. While you are restoring the file, specify this parameter as <b>FALSE</b>. After you are done using <b>BackupWrite</b>, you must call <b>BackupWrite</b>one more time specifying <b>TRUE</b> for this parameter and passing the appropriate<i>lpContext</i>. <i>lpContext</i> must be passed when<i>bAbort</i> is <b>TRUE</b>; all other parameters are ignored.</param>
    <param name="bProcessSecurity">
      <para>Specifies whether the function will restore the access-control list (ACL) data for the file or directory.</para>
      <para>If <i>bProcessSecurity</i> is <b>TRUE</b>, you need to specify<b>WRITE_OWNER</b> and <b>WRITE_DAC</b> access when opening the file or directory handle. If the handle does not have those access rights, the operating system denies access to the ACL data, and ACL data restoration will not occur.</para>
    </param>
    <param name="lpContext">
      <para>Pointer to a variable that receives a pointer to an internal data structure used by<b>BackupWrite</b> to maintain context information during a restore operation.</para>
      <para>You must set the variable pointed to by <i>lpContext</i> to <b>NULL</b>before the first call to <b>BackupWrite</b> for the specified file or directory. The function allocates memory for the data structure, and then sets the variable to point to that structure. You must not change <i>lpContext</i> or the variable that it points to between calls to<b>BackupWrite</b>.</para>
      <para>To release the memory used by the data structure, call <b>BackupWrite</b> with the<i>bAbort</i> parameter set to <b>TRUE</b> when the restore operation is complete.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero, indicating that an I/O error occurred. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.BeginUpdateResource">
    <summary>Retrieves a handle that can be used by the <see cref="UpdateResource" /> function to add, delete, or replace resources in a binary module.</summary>
    <param name="pFileName">The binary file in which to update resources. An application must be able to obtain write-access to this file; the file referenced by <i>pFileName</i> cannot be currently executing. If <i>pFileName</i> does not specify a full path, the system searches for the file in the current directory.</param>
    <param name="bDeleteExistingResources">Indicates whether to delete the <i>pFileName</i> parameter's existing resources. If this parameter is <b>TRUE</b>, existing resources are deleted and the updated file includes only resources added with the <see cref="UpdateResource" /> function. If this parameter is <b>FALSE</b>, the updated file includes existing resources unless they are explicitly deleted or replaced by using <b>UpdateResource</b>.</param>
    <returns>If the function succeeds, the return value is a handle that can be used by the <see cref="UpdateResource" /> and <see cref="EndUpdateResource" /> functions. The return value is <b>NULL</b> if the specified file is not a PE, the file does not exist, or the file cannot be opened for writing. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.BeginUpdateResourceA">
    <summary>Retrieves a handle that can be used by the <see cref="UpdateResource" /> function to add, delete, or replace resources in a binary module.</summary>
    <param name="pFileName">The binary file in which to update resources. An application must be able to obtain write-access to this file; the file referenced by <i>pFileName</i> cannot be currently executing. If <i>pFileName</i> does not specify a full path, the system searches for the file in the current directory.</param>
    <param name="bDeleteExistingResources">Indicates whether to delete the <i>pFileName</i> parameter's existing resources. If this parameter is <b>TRUE</b>, existing resources are deleted and the updated file includes only resources added with the <see cref="UpdateResource" /> function. If this parameter is <b>FALSE</b>, the updated file includes existing resources unless they are explicitly deleted or replaced by using <b>UpdateResource</b>.</param>
    <returns>If the function succeeds, the return value is a handle that can be used by the <see cref="UpdateResource" /> and <see cref="EndUpdateResource" /> functions. The return value is <b>NULL</b> if the specified file is not a PE, the file does not exist, or the file cannot be opened for writing. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.BeginUpdateResourceW">
    <summary>Retrieves a handle that can be used by the <see cref="UpdateResource" /> function to add, delete, or replace resources in a binary module.</summary>
    <param name="pFileName">The binary file in which to update resources. An application must be able to obtain write-access to this file; the file referenced by <i>pFileName</i> cannot be currently executing. If <i>pFileName</i> does not specify a full path, the system searches for the file in the current directory.</param>
    <param name="bDeleteExistingResources">Indicates whether to delete the <i>pFileName</i> parameter's existing resources. If this parameter is <b>TRUE</b>, existing resources are deleted and the updated file includes only resources added with the <see cref="UpdateResource" /> function. If this parameter is <b>FALSE</b>, the updated file includes existing resources unless they are explicitly deleted or replaced by using <b>UpdateResource</b>.</param>
    <returns>If the function succeeds, the return value is a handle that can be used by the <see cref="UpdateResource" /> and <see cref="EndUpdateResource" /> functions. The return value is <b>NULL</b> if the specified file is not a PE, the file does not exist, or the file cannot be opened for writing. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.BeginUpdateResource">
    <summary>Retrieves a handle that can be used by the <see cref="UpdateResource" /> function to add, delete, or replace resources in a binary module.</summary>
    <param name="pFileName">The binary file in which to update resources. An application must be able to obtain write-access to this file; the file referenced by <i>pFileName</i> cannot be currently executing. If <i>pFileName</i> does not specify a full path, the system searches for the file in the current directory.</param>
    <param name="bDeleteExistingResources">Indicates whether to delete the <i>pFileName</i> parameter's existing resources. If this parameter is <b>TRUE</b>, existing resources are deleted and the updated file includes only resources added with the <see cref="UpdateResource" /> function. If this parameter is <b>FALSE</b>, the updated file includes existing resources unless they are explicitly deleted or replaced by using <b>UpdateResource</b>.</param>
    <returns>If the function succeeds, the return value is a handle that can be used by the <see cref="UpdateResource" /> and <see cref="EndUpdateResource" /> functions. The return value is <b>NULL</b> if the specified file is not a PE, the file does not exist, or the file cannot be opened for writing. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.BeginUpdateResourceA">
    <summary>Retrieves a handle that can be used by the <see cref="UpdateResource" /> function to add, delete, or replace resources in a binary module.</summary>
    <param name="pFileName">The binary file in which to update resources. An application must be able to obtain write-access to this file; the file referenced by <i>pFileName</i> cannot be currently executing. If <i>pFileName</i> does not specify a full path, the system searches for the file in the current directory.</param>
    <param name="bDeleteExistingResources">Indicates whether to delete the <i>pFileName</i> parameter's existing resources. If this parameter is <b>TRUE</b>, existing resources are deleted and the updated file includes only resources added with the <see cref="UpdateResource" /> function. If this parameter is <b>FALSE</b>, the updated file includes existing resources unless they are explicitly deleted or replaced by using <b>UpdateResource</b>.</param>
    <returns>If the function succeeds, the return value is a handle that can be used by the <see cref="UpdateResource" /> and <see cref="EndUpdateResource" /> functions. The return value is <b>NULL</b> if the specified file is not a PE, the file does not exist, or the file cannot be opened for writing. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.BeginUpdateResourceW">
    <summary>Retrieves a handle that can be used by the <see cref="UpdateResource" /> function to add, delete, or replace resources in a binary module.</summary>
    <param name="pFileName">The binary file in which to update resources. An application must be able to obtain write-access to this file; the file referenced by <i>pFileName</i> cannot be currently executing. If <i>pFileName</i> does not specify a full path, the system searches for the file in the current directory.</param>
    <param name="bDeleteExistingResources">Indicates whether to delete the <i>pFileName</i> parameter's existing resources. If this parameter is <b>TRUE</b>, existing resources are deleted and the updated file includes only resources added with the <see cref="UpdateResource" /> function. If this parameter is <b>FALSE</b>, the updated file includes existing resources unless they are explicitly deleted or replaced by using <b>UpdateResource</b>.</param>
    <returns>If the function succeeds, the return value is a handle that can be used by the <see cref="UpdateResource" /> and <see cref="EndUpdateResource" /> functions. The return value is <b>NULL</b> if the specified file is not a PE, the file does not exist, or the file cannot be opened for writing. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.BindIoCompletionCallback">
    <summary>Associates the I/O completion port owned by the <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-pooling">thread pool</a> with the specified file handle. On completion of an I/O request involving this file, a non-I/O worker thread will execute the specified callback function.</summary>
    <param name="FileHandle">A handle to the file opened for overlapped I/O completion. This handle is returned by the<see cref="CreateFile" /> function, with the <b>FILE_FLAG_OVERLAPPED</b> flag.</param>
    <param name="Function">
      <para>A pointer to the callback function to be executed in a non-I/O worker thread when the I/O operation is complete. This callback function must not call the<see cref="TerminateThread" /> function.</para>
      <para>For more information about the completion routine, see<a href="https://docs.microsoft.com//windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</a>.</para>
    </param>
    <param name="Flags">This parameter must be zero.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call the <see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.BuildCommDCB">
    <summary>Fills a specified<see cref="DCB" /> structure with values specified in a device-control string. The device-control string uses the syntax of the <b>mode</b> command.</summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the<see cref="DCB" /> structure pointed to by <i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>COM<i>x</i>[:][baud=<i>b</i>][parity=<i>p</i>][data=<i>d</i>][stop=<i>s</i>][to={on|off}][xon={on|off}][odsr={on|off}][octs={on|off}][dtr={on|off|hs}][rts={on|off|hs|tg}][idsr={on|off}]</para>
      <para>The device name is optional, but it must specify a valid device if used.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">A pointer to a<see cref="DCB" /> structure that receives the information.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.BuildCommDCBA">
    <summary>Fills a specified<see cref="DCB" /> structure with values specified in a device-control string. The device-control string uses the syntax of the <b>mode</b> command.</summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the<see cref="DCB" /> structure pointed to by <i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>COM<i>x</i>[:][baud=<i>b</i>][parity=<i>p</i>][data=<i>d</i>][stop=<i>s</i>][to={on|off}][xon={on|off}][odsr={on|off}][octs={on|off}][dtr={on|off|hs}][rts={on|off|hs|tg}][idsr={on|off}]</para>
      <para>The device name is optional, but it must specify a valid device if used.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">A pointer to a<see cref="DCB" /> structure that receives the information.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.BuildCommDCBW">
    <summary>Fills a specified<see cref="DCB" /> structure with values specified in a device-control string. The device-control string uses the syntax of the <b>mode</b> command.</summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the<see cref="DCB" /> structure pointed to by <i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>COM<i>x</i>[:][baud=<i>b</i>][parity=<i>p</i>][data=<i>d</i>][stop=<i>s</i>][to={on|off}][xon={on|off}][odsr={on|off}][octs={on|off}][dtr={on|off|hs}][rts={on|off|hs|tg}][idsr={on|off}]</para>
      <para>The device name is optional, but it must specify a valid device if used.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">A pointer to a<see cref="DCB" /> structure that receives the information.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.BuildCommDCBAndTimeouts">
    <summary>Translates a device-definition string into appropriate device-control block codes and places them into a device control block. The function can also set up time-out values, including the possibility of no time-outs, for a device; the function's behavior in this regard depends on the contents of the device-definition string.</summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the <see cref="DCB" /> structure pointed to by<i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>
        <b>COM</b>
        <i>x</i>[<b>:</b>][<b>baud=</b>{<b>11</b>|<b>110</b>|<b>15</b>|<b>150</b>|<b>30</b>|<b>300</b>|<b>60</b>|<b>600</b>|<b>12</b>|<b>1200</b>|<b>24</b>|<b>2400</b>|<b>48</b>|<b>4800</b>|<b>96</b>|<b>9600</b>|<b>19</b>|<b>19200</b>}][<b>parity=</b>{<b>n</b>|<b>e</b>|<b>o</b>|<b>m</b>|<b>s</b>}][<b>data=</b>{<b>5</b>|<b>6</b>|<b>7</b>|<b>8</b>}][<b>stop=</b>{<b>1</b>|<b>1.5</b>|<b>2</b>}][<b>to=</b>{<b>on</b>|<b>off</b>}][<b>xon=</b>{<b>on</b>|<b>off</b>}][<b>odsr=</b>{<b>on</b>|<b>off</b>}][<b>octs=</b>{<b>on</b>|<b>off</b>}][<b>dtr=</b>{<b>on</b>|<b>off</b>|<b>hs</b>}][<b>rts=</b>{<b>on</b>|<b>off</b>|<b>hs</b>|<b>tg</b>}][<b>idsr=</b>{<b>on</b>|<b>off</b>}]</para>
      <para>The "baud" substring can be any of the values listed, which are in pairs. The two-digit values are the first two digits of the associated values that they represent. For example, 11 represents 110 baud, 19 represents 19,200 baud.</para>
      <para>The "parity" substring indicates how the parity bit is used to detect transmission errors. The values represent "none", "even", "odd",<br />"mark", and "space".</para>
      <para>For more information, see the <a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732236(v=ws.11)">Mode</a> command reference in TechNet.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">A pointer to a <see cref="DCB" /> structure that receives information from the device-control information string pointed to by <i>lpDef</i>. This<b>DCB</b> structure defines the control settings for a communications device.</param>
    <param name="lpCommTimeouts">A pointer to a <see cref="COMMTIMEOUTS" /> structure that receives time-out information.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.BuildCommDCBAndTimeoutsA">
    <summary>Translates a device-definition string into appropriate device-control block codes and places them into a device control block. The function can also set up time-out values, including the possibility of no time-outs, for a device; the function's behavior in this regard depends on the contents of the device-definition string.</summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the <see cref="DCB" /> structure pointed to by<i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>
        <b>COM</b>
        <i>x</i>[<b>:</b>][<b>baud=</b>{<b>11</b>|<b>110</b>|<b>15</b>|<b>150</b>|<b>30</b>|<b>300</b>|<b>60</b>|<b>600</b>|<b>12</b>|<b>1200</b>|<b>24</b>|<b>2400</b>|<b>48</b>|<b>4800</b>|<b>96</b>|<b>9600</b>|<b>19</b>|<b>19200</b>}][<b>parity=</b>{<b>n</b>|<b>e</b>|<b>o</b>|<b>m</b>|<b>s</b>}][<b>data=</b>{<b>5</b>|<b>6</b>|<b>7</b>|<b>8</b>}][<b>stop=</b>{<b>1</b>|<b>1.5</b>|<b>2</b>}][<b>to=</b>{<b>on</b>|<b>off</b>}][<b>xon=</b>{<b>on</b>|<b>off</b>}][<b>odsr=</b>{<b>on</b>|<b>off</b>}][<b>octs=</b>{<b>on</b>|<b>off</b>}][<b>dtr=</b>{<b>on</b>|<b>off</b>|<b>hs</b>}][<b>rts=</b>{<b>on</b>|<b>off</b>|<b>hs</b>|<b>tg</b>}][<b>idsr=</b>{<b>on</b>|<b>off</b>}]</para>
      <para>The "baud" substring can be any of the values listed, which are in pairs. The two-digit values are the first two digits of the associated values that they represent. For example, 11 represents 110 baud, 19 represents 19,200 baud.</para>
      <para>The "parity" substring indicates how the parity bit is used to detect transmission errors. The values represent "none", "even", "odd",<br />"mark", and "space".</para>
      <para>For more information, see the <a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732236(v=ws.11)">Mode</a> command reference in TechNet.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">A pointer to a <see cref="DCB" /> structure that receives information from the device-control information string pointed to by <i>lpDef</i>. This<b>DCB</b> structure defines the control settings for a communications device.</param>
    <param name="lpCommTimeouts">A pointer to a <see cref="COMMTIMEOUTS" /> structure that receives time-out information.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.BuildCommDCBAndTimeoutsW">
    <summary>Translates a device-definition string into appropriate device-control block codes and places them into a device control block. The function can also set up time-out values, including the possibility of no time-outs, for a device; the function's behavior in this regard depends on the contents of the device-definition string.</summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the <see cref="DCB" /> structure pointed to by<i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>
        <b>COM</b>
        <i>x</i>[<b>:</b>][<b>baud=</b>{<b>11</b>|<b>110</b>|<b>15</b>|<b>150</b>|<b>30</b>|<b>300</b>|<b>60</b>|<b>600</b>|<b>12</b>|<b>1200</b>|<b>24</b>|<b>2400</b>|<b>48</b>|<b>4800</b>|<b>96</b>|<b>9600</b>|<b>19</b>|<b>19200</b>}][<b>parity=</b>{<b>n</b>|<b>e</b>|<b>o</b>|<b>m</b>|<b>s</b>}][<b>data=</b>{<b>5</b>|<b>6</b>|<b>7</b>|<b>8</b>}][<b>stop=</b>{<b>1</b>|<b>1.5</b>|<b>2</b>}][<b>to=</b>{<b>on</b>|<b>off</b>}][<b>xon=</b>{<b>on</b>|<b>off</b>}][<b>odsr=</b>{<b>on</b>|<b>off</b>}][<b>octs=</b>{<b>on</b>|<b>off</b>}][<b>dtr=</b>{<b>on</b>|<b>off</b>|<b>hs</b>}][<b>rts=</b>{<b>on</b>|<b>off</b>|<b>hs</b>|<b>tg</b>}][<b>idsr=</b>{<b>on</b>|<b>off</b>}]</para>
      <para>The "baud" substring can be any of the values listed, which are in pairs. The two-digit values are the first two digits of the associated values that they represent. For example, 11 represents 110 baud, 19 represents 19,200 baud.</para>
      <para>The "parity" substring indicates how the parity bit is used to detect transmission errors. The values represent "none", "even", "odd",<br />"mark", and "space".</para>
      <para>For more information, see the <a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732236(v=ws.11)">Mode</a> command reference in TechNet.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">A pointer to a <see cref="DCB" /> structure that receives information from the device-control information string pointed to by <i>lpDef</i>. This<b>DCB</b> structure defines the control settings for a communications device.</param>
    <param name="lpCommTimeouts">A pointer to a <see cref="COMMTIMEOUTS" /> structure that receives time-out information.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.BuildCommDCBAndTimeouts">
    <summary>Translates a device-definition string into appropriate device-control block codes and places them into a device control block. The function can also set up time-out values, including the possibility of no time-outs, for a device; the function's behavior in this regard depends on the contents of the device-definition string.</summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the <see cref="DCB" /> structure pointed to by<i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>
        <b>COM</b>
        <i>x</i>[<b>:</b>][<b>baud=</b>{<b>11</b>|<b>110</b>|<b>15</b>|<b>150</b>|<b>30</b>|<b>300</b>|<b>60</b>|<b>600</b>|<b>12</b>|<b>1200</b>|<b>24</b>|<b>2400</b>|<b>48</b>|<b>4800</b>|<b>96</b>|<b>9600</b>|<b>19</b>|<b>19200</b>}][<b>parity=</b>{<b>n</b>|<b>e</b>|<b>o</b>|<b>m</b>|<b>s</b>}][<b>data=</b>{<b>5</b>|<b>6</b>|<b>7</b>|<b>8</b>}][<b>stop=</b>{<b>1</b>|<b>1.5</b>|<b>2</b>}][<b>to=</b>{<b>on</b>|<b>off</b>}][<b>xon=</b>{<b>on</b>|<b>off</b>}][<b>odsr=</b>{<b>on</b>|<b>off</b>}][<b>octs=</b>{<b>on</b>|<b>off</b>}][<b>dtr=</b>{<b>on</b>|<b>off</b>|<b>hs</b>}][<b>rts=</b>{<b>on</b>|<b>off</b>|<b>hs</b>|<b>tg</b>}][<b>idsr=</b>{<b>on</b>|<b>off</b>}]</para>
      <para>The "baud" substring can be any of the values listed, which are in pairs. The two-digit values are the first two digits of the associated values that they represent. For example, 11 represents 110 baud, 19 represents 19,200 baud.</para>
      <para>The "parity" substring indicates how the parity bit is used to detect transmission errors. The values represent "none", "even", "odd",<br />"mark", and "space".</para>
      <para>For more information, see the <a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732236(v=ws.11)">Mode</a> command reference in TechNet.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">A pointer to a <see cref="DCB" /> structure that receives information from the device-control information string pointed to by <i>lpDef</i>. This<b>DCB</b> structure defines the control settings for a communications device.</param>
    <param name="lpCommTimeouts">A pointer to a <see cref="COMMTIMEOUTS" /> structure that receives time-out information.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.BuildCommDCBAndTimeoutsA">
    <summary>Translates a device-definition string into appropriate device-control block codes and places them into a device control block. The function can also set up time-out values, including the possibility of no time-outs, for a device; the function's behavior in this regard depends on the contents of the device-definition string.</summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the <see cref="DCB" /> structure pointed to by<i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>
        <b>COM</b>
        <i>x</i>[<b>:</b>][<b>baud=</b>{<b>11</b>|<b>110</b>|<b>15</b>|<b>150</b>|<b>30</b>|<b>300</b>|<b>60</b>|<b>600</b>|<b>12</b>|<b>1200</b>|<b>24</b>|<b>2400</b>|<b>48</b>|<b>4800</b>|<b>96</b>|<b>9600</b>|<b>19</b>|<b>19200</b>}][<b>parity=</b>{<b>n</b>|<b>e</b>|<b>o</b>|<b>m</b>|<b>s</b>}][<b>data=</b>{<b>5</b>|<b>6</b>|<b>7</b>|<b>8</b>}][<b>stop=</b>{<b>1</b>|<b>1.5</b>|<b>2</b>}][<b>to=</b>{<b>on</b>|<b>off</b>}][<b>xon=</b>{<b>on</b>|<b>off</b>}][<b>odsr=</b>{<b>on</b>|<b>off</b>}][<b>octs=</b>{<b>on</b>|<b>off</b>}][<b>dtr=</b>{<b>on</b>|<b>off</b>|<b>hs</b>}][<b>rts=</b>{<b>on</b>|<b>off</b>|<b>hs</b>|<b>tg</b>}][<b>idsr=</b>{<b>on</b>|<b>off</b>}]</para>
      <para>The "baud" substring can be any of the values listed, which are in pairs. The two-digit values are the first two digits of the associated values that they represent. For example, 11 represents 110 baud, 19 represents 19,200 baud.</para>
      <para>The "parity" substring indicates how the parity bit is used to detect transmission errors. The values represent "none", "even", "odd",<br />"mark", and "space".</para>
      <para>For more information, see the <a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732236(v=ws.11)">Mode</a> command reference in TechNet.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">A pointer to a <see cref="DCB" /> structure that receives information from the device-control information string pointed to by <i>lpDef</i>. This<b>DCB</b> structure defines the control settings for a communications device.</param>
    <param name="lpCommTimeouts">A pointer to a <see cref="COMMTIMEOUTS" /> structure that receives time-out information.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.BuildCommDCBAndTimeoutsW">
    <summary>Translates a device-definition string into appropriate device-control block codes and places them into a device control block. The function can also set up time-out values, including the possibility of no time-outs, for a device; the function's behavior in this regard depends on the contents of the device-definition string.</summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the <see cref="DCB" /> structure pointed to by<i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>
        <b>COM</b>
        <i>x</i>[<b>:</b>][<b>baud=</b>{<b>11</b>|<b>110</b>|<b>15</b>|<b>150</b>|<b>30</b>|<b>300</b>|<b>60</b>|<b>600</b>|<b>12</b>|<b>1200</b>|<b>24</b>|<b>2400</b>|<b>48</b>|<b>4800</b>|<b>96</b>|<b>9600</b>|<b>19</b>|<b>19200</b>}][<b>parity=</b>{<b>n</b>|<b>e</b>|<b>o</b>|<b>m</b>|<b>s</b>}][<b>data=</b>{<b>5</b>|<b>6</b>|<b>7</b>|<b>8</b>}][<b>stop=</b>{<b>1</b>|<b>1.5</b>|<b>2</b>}][<b>to=</b>{<b>on</b>|<b>off</b>}][<b>xon=</b>{<b>on</b>|<b>off</b>}][<b>odsr=</b>{<b>on</b>|<b>off</b>}][<b>octs=</b>{<b>on</b>|<b>off</b>}][<b>dtr=</b>{<b>on</b>|<b>off</b>|<b>hs</b>}][<b>rts=</b>{<b>on</b>|<b>off</b>|<b>hs</b>|<b>tg</b>}][<b>idsr=</b>{<b>on</b>|<b>off</b>}]</para>
      <para>The "baud" substring can be any of the values listed, which are in pairs. The two-digit values are the first two digits of the associated values that they represent. For example, 11 represents 110 baud, 19 represents 19,200 baud.</para>
      <para>The "parity" substring indicates how the parity bit is used to detect transmission errors. The values represent "none", "even", "odd",<br />"mark", and "space".</para>
      <para>For more information, see the <a href="https://docs.microsoft.com//previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732236(v=ws.11)">Mode</a> command reference in TechNet.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">A pointer to a <see cref="DCB" /> structure that receives information from the device-control information string pointed to by <i>lpDef</i>. This<b>DCB</b> structure defines the control settings for a communications device.</param>
    <param name="lpCommTimeouts">A pointer to a <see cref="COMMTIMEOUTS" /> structure that receives time-out information.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.BuildCommDCB">
    <summary>Fills a specified<see cref="DCB" /> structure with values specified in a device-control string. The device-control string uses the syntax of the <b>mode</b> command.</summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the<see cref="DCB" /> structure pointed to by <i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>COM<i>x</i>[:][baud=<i>b</i>][parity=<i>p</i>][data=<i>d</i>][stop=<i>s</i>][to={on|off}][xon={on|off}][odsr={on|off}][octs={on|off}][dtr={on|off|hs}][rts={on|off|hs|tg}][idsr={on|off}]</para>
      <para>The device name is optional, but it must specify a valid device if used.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">A pointer to a<see cref="DCB" /> structure that receives the information.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.BuildCommDCBA">
    <summary>Fills a specified<see cref="DCB" /> structure with values specified in a device-control string. The device-control string uses the syntax of the <b>mode</b> command.</summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the<see cref="DCB" /> structure pointed to by <i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>COM<i>x</i>[:][baud=<i>b</i>][parity=<i>p</i>][data=<i>d</i>][stop=<i>s</i>][to={on|off}][xon={on|off}][odsr={on|off}][octs={on|off}][dtr={on|off|hs}][rts={on|off|hs|tg}][idsr={on|off}]</para>
      <para>The device name is optional, but it must specify a valid device if used.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">A pointer to a<see cref="DCB" /> structure that receives the information.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.BuildCommDCBW">
    <summary>Fills a specified<see cref="DCB" /> structure with values specified in a device-control string. The device-control string uses the syntax of the <b>mode</b> command.</summary>
    <param name="lpDef">
      <para>The device-control information. The function takes this string, parses it, and then sets appropriate values in the<see cref="DCB" /> structure pointed to by <i>lpDCB</i>.</para>
      <para>The string must have the same form as the <b>mode</b> command's command-line arguments:</para>
      <para>COM<i>x</i>[:][baud=<i>b</i>][parity=<i>p</i>][data=<i>d</i>][stop=<i>s</i>][to={on|off}][xon={on|off}][odsr={on|off}][octs={on|off}][dtr={on|off|hs}][rts={on|off|hs|tg}][idsr={on|off}]</para>
      <para>The device name is optional, but it must specify a valid device if used.</para>
      <para>For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:</para>
      <para>
        <code>baud=1200 parity=N data=8 stop=1</code>
      </para>
    </param>
    <param name="lpDCB">A pointer to a<see cref="DCB" /> structure that receives the information.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CallNamedPipe">
    <summary>Connects to a message-type pipe (and waits if an instance of the pipe is not available), writes to and reads from the pipe, and then closes the pipe.</summary>
    <param name="lpNamedPipeName">The pipe name.</param>
    <param name="lpInBuffer">The data to be written to the pipe.</param>
    <param name="nInBufferSize">The size of the write buffer, in bytes.</param>
    <param name="lpOutBuffer">A pointer to the buffer that receives the data read from the pipe.</param>
    <param name="nOutBufferSize">The size of the read buffer, in bytes.</param>
    <param name="lpBytesRead">A pointer to a variable that receives the number of bytes read from the pipe.</param>
    <param name="nTimeOut">
      <para>The number of milliseconds to wait for the named pipe to be available. In addition to numeric values, the following special values can be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NMPWAIT_NOWAIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Does not wait for the named pipe. If the named pipe is not available, the function returns an error.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NMPWAIT_WAIT_FOREVER</b>
                </term>
              </listheader>
              <listheader>
                <term>0xffffffff</term>
              </listheader>
            </list>
          </description>
          <description>Waits indefinitely.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NMPWAIT_USE_DEFAULT_WAIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000000</term>
              </listheader>
            </list>
          </description>
          <description>Uses the default time-out specified in a call to the <see cref="CreateNamedPipe" /> function.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the message written to the pipe by the server process is longer than <i>nOutBufferSize</i>,<b>CallNamedPipe</b> returns <b>FALSE</b>, and <see cref="GetLastError" /> returns ERROR_MORE_DATA. The remainder of the message is discarded, because<b>CallNamedPipe</b> closes the handle to the pipe before returning.</para>
    </returns>
  </member>
  <member name="Windows.CallNamedPipeA">
    <summary>Connects to a message-type pipe (and waits if an instance of the pipe is not available), writes to and reads from the pipe, and then closes the pipe.</summary>
    <param name="lpNamedPipeName">The pipe name.</param>
    <param name="lpInBuffer">The data to be written to the pipe.</param>
    <param name="nInBufferSize">The size of the write buffer, in bytes.</param>
    <param name="lpOutBuffer">A pointer to the buffer that receives the data read from the pipe.</param>
    <param name="nOutBufferSize">The size of the read buffer, in bytes.</param>
    <param name="lpBytesRead">A pointer to a variable that receives the number of bytes read from the pipe.</param>
    <param name="nTimeOut">
      <para>The number of milliseconds to wait for the named pipe to be available. In addition to numeric values, the following special values can be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NMPWAIT_NOWAIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Does not wait for the named pipe. If the named pipe is not available, the function returns an error.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NMPWAIT_WAIT_FOREVER</b>
                </term>
              </listheader>
              <listheader>
                <term>0xffffffff</term>
              </listheader>
            </list>
          </description>
          <description>Waits indefinitely.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NMPWAIT_USE_DEFAULT_WAIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000000</term>
              </listheader>
            </list>
          </description>
          <description>Uses the default time-out specified in a call to the <see cref="CreateNamedPipe" /> function.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the message written to the pipe by the server process is longer than <i>nOutBufferSize</i>,<b>CallNamedPipe</b> returns <b>FALSE</b>, and <see cref="GetLastError" /> returns ERROR_MORE_DATA. The remainder of the message is discarded, because<b>CallNamedPipe</b> closes the handle to the pipe before returning.</para>
    </returns>
  </member>
  <member name="Windows.CallNamedPipeW">
    <summary>Connects to a message-type pipe (and waits if an instance of the pipe is not available), writes to and reads from the pipe, and then closes the pipe.</summary>
    <param name="lpNamedPipeName">The pipe name.</param>
    <param name="lpInBuffer">The data to be written to the pipe.</param>
    <param name="nInBufferSize">The size of the write buffer, in bytes.</param>
    <param name="lpOutBuffer">A pointer to the buffer that receives the data read from the pipe.</param>
    <param name="nOutBufferSize">The size of the read buffer, in bytes.</param>
    <param name="lpBytesRead">A pointer to a variable that receives the number of bytes read from the pipe.</param>
    <param name="nTimeOut">
      <para>The number of milliseconds to wait for the named pipe to be available. In addition to numeric values, the following special values can be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NMPWAIT_NOWAIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Does not wait for the named pipe. If the named pipe is not available, the function returns an error.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NMPWAIT_WAIT_FOREVER</b>
                </term>
              </listheader>
              <listheader>
                <term>0xffffffff</term>
              </listheader>
            </list>
          </description>
          <description>Waits indefinitely.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NMPWAIT_USE_DEFAULT_WAIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000000</term>
              </listheader>
            </list>
          </description>
          <description>Uses the default time-out specified in a call to the <see cref="CreateNamedPipe" /> function.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the message written to the pipe by the server process is longer than <i>nOutBufferSize</i>,<b>CallNamedPipe</b> returns <b>FALSE</b>, and <see cref="GetLastError" /> returns ERROR_MORE_DATA. The remainder of the message is discarded, because<b>CallNamedPipe</b> closes the handle to the pipe before returning.</para>
    </returns>
  </member>
  <member name="Windows.CheckNameLegalDOS8Dot3">
    <summary>Determines whether the specified name can be used to create a file on a FAT file system.</summary>
    <param name="lpName">The file name, in 8.3 format.</param>
    <param name="lpOemName">A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This parameter can be <b>NULL</b>.</param>
    <param name="OemNameSize">The size of the <i>lpOemName</i> buffer, in characters. If<i>lpOemName</i> is <b>NULL</b>, this parameter must be 0 (zero).</param>
    <param name="pbNameContainsSpaces">Indicates whether or not a name contains spaces. This parameter can be <b>NULL</b>. If the name is not a valid 8.3 FAT file system name, this parameter is undefined.</param>
    <param name="pbNameLegal">If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when the current OEM code page is applied to the file name.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CheckNameLegalDOS8Dot3A">
    <summary>Determines whether the specified name can be used to create a file on a FAT file system.</summary>
    <param name="lpName">The file name, in 8.3 format.</param>
    <param name="lpOemName">A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This parameter can be <b>NULL</b>.</param>
    <param name="OemNameSize">The size of the <i>lpOemName</i> buffer, in characters. If<i>lpOemName</i> is <b>NULL</b>, this parameter must be 0 (zero).</param>
    <param name="pbNameContainsSpaces">Indicates whether or not a name contains spaces. This parameter can be <b>NULL</b>. If the name is not a valid 8.3 FAT file system name, this parameter is undefined.</param>
    <param name="pbNameLegal">If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when the current OEM code page is applied to the file name.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CheckNameLegalDOS8Dot3W">
    <summary>Determines whether the specified name can be used to create a file on a FAT file system.</summary>
    <param name="lpName">The file name, in 8.3 format.</param>
    <param name="lpOemName">A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This parameter can be <b>NULL</b>.</param>
    <param name="OemNameSize">The size of the <i>lpOemName</i> buffer, in characters. If<i>lpOemName</i> is <b>NULL</b>, this parameter must be 0 (zero).</param>
    <param name="pbNameContainsSpaces">Indicates whether or not a name contains spaces. This parameter can be <b>NULL</b>. If the name is not a valid 8.3 FAT file system name, this parameter is undefined.</param>
    <param name="pbNameLegal">If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when the current OEM code page is applied to the file name.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CheckNameLegalDOS8Dot3">
    <summary>Determines whether the specified name can be used to create a file on a FAT file system.</summary>
    <param name="lpName">The file name, in 8.3 format.</param>
    <param name="lpOemName">A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This parameter can be <b>NULL</b>.</param>
    <param name="OemNameSize">The size of the <i>lpOemName</i> buffer, in characters. If<i>lpOemName</i> is <b>NULL</b>, this parameter must be 0 (zero).</param>
    <param name="pbNameContainsSpaces">Indicates whether or not a name contains spaces. This parameter can be <b>NULL</b>. If the name is not a valid 8.3 FAT file system name, this parameter is undefined.</param>
    <param name="pbNameLegal">If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when the current OEM code page is applied to the file name.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CheckNameLegalDOS8Dot3A">
    <summary>Determines whether the specified name can be used to create a file on a FAT file system.</summary>
    <param name="lpName">The file name, in 8.3 format.</param>
    <param name="lpOemName">A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This parameter can be <b>NULL</b>.</param>
    <param name="OemNameSize">The size of the <i>lpOemName</i> buffer, in characters. If<i>lpOemName</i> is <b>NULL</b>, this parameter must be 0 (zero).</param>
    <param name="pbNameContainsSpaces">Indicates whether or not a name contains spaces. This parameter can be <b>NULL</b>. If the name is not a valid 8.3 FAT file system name, this parameter is undefined.</param>
    <param name="pbNameLegal">If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when the current OEM code page is applied to the file name.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CheckNameLegalDOS8Dot3W">
    <summary>Determines whether the specified name can be used to create a file on a FAT file system.</summary>
    <param name="lpName">The file name, in 8.3 format.</param>
    <param name="lpOemName">A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This parameter can be <b>NULL</b>.</param>
    <param name="OemNameSize">The size of the <i>lpOemName</i> buffer, in characters. If<i>lpOemName</i> is <b>NULL</b>, this parameter must be 0 (zero).</param>
    <param name="pbNameContainsSpaces">Indicates whether or not a name contains spaces. This parameter can be <b>NULL</b>. If the name is not a valid 8.3 FAT file system name, this parameter is undefined.</param>
    <param name="pbNameLegal">If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when the current OEM code page is applied to the file name.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is 0 (zero). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ClearCommBreak">
    <summary>Restores character transmission for a specified communications device and places the transmission line in a nonbreak state.</summary>
    <param name="hFile">A handle to the communications device. The<see cref="CreateFile" /> function returns this handle.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ClearCommError">
    <summary>Retrieves information about a communications error and reports the current status of a communications device. The function is called when a communications error occurs, and it clears the device's error flag to enable additional input and output (I/O) operations.</summary>
    <param name="hFile">A handle to the communications device. The<see cref="CreateFile" /> function returns this handle.</param>
    <param name="lpErrors">
      <para>A pointer to a variable that receives a mask indicating the type of error. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CE_BREAK</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0010</term>
              </listheader>
            </list>
          </description>
          <description>The hardware detected a break condition.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CE_FRAME</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0008</term>
              </listheader>
            </list>
          </description>
          <description>The hardware detected a framing error.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CE_OVERRUN</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0002</term>
              </listheader>
            </list>
          </description>
          <description>A character-buffer overrun has occurred. The next character is lost.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CE_RXOVER</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0001</term>
              </listheader>
            </list>
          </description>
          <description>An input buffer overflow has occurred. There is either no room in the input buffer, or a character was received after the end-of-file (EOF) character.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CE_RXPARITY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0004</term>
              </listheader>
            </list>
          </description>
          <description>The hardware detected a parity error.</description>
        </listheader>
      </list> <para>The following values are not supported:</para></param>
    <param name="lpStat">A pointer to a<see cref="COMSTAT" /> structure in which the device's status information is returned. If this parameter is <b>NULL</b>, no status information is returned.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ClearEventLog">
    <summary>Clears the specified event log, and optionally saves the current copy of the log to a backup file.</summary>
    <param name="hEventLog">A handle to the event log to be cleared. The <see cref="OpenEventLog" /> function returns this handle.</param>
    <param name="lpBackupFileName">
      <para>The absolute or relative path of the backup file. If this file already exists, the function fails.</para>
      <para>If the <i>lpBackupFileName</i> parameter is <b>NULL</b>, the event log is not backed up.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. The<b>ClearEventLog</b> function can fail if the event log is empty or the backup file already exists.</para>
    </returns>
  </member>
  <member name="Windows.ClearEventLogA">
    <summary>Clears the specified event log, and optionally saves the current copy of the log to a backup file.</summary>
    <param name="hEventLog">A handle to the event log to be cleared. The <see cref="OpenEventLog" /> function returns this handle.</param>
    <param name="lpBackupFileName">
      <para>The absolute or relative path of the backup file. If this file already exists, the function fails.</para>
      <para>If the <i>lpBackupFileName</i> parameter is <b>NULL</b>, the event log is not backed up.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. The<b>ClearEventLog</b> function can fail if the event log is empty or the backup file already exists.</para>
    </returns>
  </member>
  <member name="Windows.ClearEventLogW">
    <summary>Clears the specified event log, and optionally saves the current copy of the log to a backup file.</summary>
    <param name="hEventLog">A handle to the event log to be cleared. The <see cref="OpenEventLog" /> function returns this handle.</param>
    <param name="lpBackupFileName">
      <para>The absolute or relative path of the backup file. If this file already exists, the function fails.</para>
      <para>If the <i>lpBackupFileName</i> parameter is <b>NULL</b>, the event log is not backed up.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. The<b>ClearEventLog</b> function can fail if the event log is empty or the backup file already exists.</para>
    </returns>
  </member>
  <member name="Windows.ClearEventLog">
    <summary>Clears the specified event log, and optionally saves the current copy of the log to a backup file.</summary>
    <param name="hEventLog">A handle to the event log to be cleared. The <see cref="OpenEventLog" /> function returns this handle.</param>
    <param name="lpBackupFileName">
      <para>The absolute or relative path of the backup file. If this file already exists, the function fails.</para>
      <para>If the <i>lpBackupFileName</i> parameter is <b>NULL</b>, the event log is not backed up.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. The<b>ClearEventLog</b> function can fail if the event log is empty or the backup file already exists.</para>
    </returns>
  </member>
  <member name="Windows.ClearEventLogA">
    <summary>Clears the specified event log, and optionally saves the current copy of the log to a backup file.</summary>
    <param name="hEventLog">A handle to the event log to be cleared. The <see cref="OpenEventLog" /> function returns this handle.</param>
    <param name="lpBackupFileName">
      <para>The absolute or relative path of the backup file. If this file already exists, the function fails.</para>
      <para>If the <i>lpBackupFileName</i> parameter is <b>NULL</b>, the event log is not backed up.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. The<b>ClearEventLog</b> function can fail if the event log is empty or the backup file already exists.</para>
    </returns>
  </member>
  <member name="Windows.ClearEventLogW">
    <summary>Clears the specified event log, and optionally saves the current copy of the log to a backup file.</summary>
    <param name="hEventLog">A handle to the event log to be cleared. The <see cref="OpenEventLog" /> function returns this handle.</param>
    <param name="lpBackupFileName">
      <para>The absolute or relative path of the backup file. If this file already exists, the function fails.</para>
      <para>If the <i>lpBackupFileName</i> parameter is <b>NULL</b>, the event log is not backed up.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. The<b>ClearEventLog</b> function can fail if the event log is empty or the backup file already exists.</para>
    </returns>
  </member>
  <member name="Windows.CloseEncryptedFileRaw">
    <summary>Closes an encrypted file after a backup or restore operation, and frees associated system resources. This is one of a group of Encrypted File System (EFS) functions that is intended to implement backup and restore functionality, while maintaining files in their encrypted state.</summary>
    <param name="pvContext">A pointer to a system-defined context block. The<see cref="OpenEncryptedFileRaw" /> function returns the context block.</param>
  </member>
  <member name="Windows.CloseEventLog">
    <summary>Closes the specified event log.</summary>
    <param name="hEventLog">A handle to the event log to be closed. The<see cref="OpenEventLog" /> or<see cref="OpenBackupEventLog" /> function returns this handle.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CommConfigDialog">
    <summary>Displays a driver-supplied configuration dialog box.</summary>
    <param name="lpszName">The name of the device for which a dialog box should be displayed. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
    <param name="hWnd">A handle to the window that owns the dialog box. This parameter can be any valid window handle, or it should be <b>NULL</b> if the dialog box is to have no owner.</param>
    <param name="lpCC">A pointer to a<see cref="COMMCONFIG" /> structure. This structure contains initial settings for the dialog box before the call, and changed values after the call.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CommConfigDialogA">
    <summary>Displays a driver-supplied configuration dialog box.</summary>
    <param name="lpszName">The name of the device for which a dialog box should be displayed. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
    <param name="hWnd">A handle to the window that owns the dialog box. This parameter can be any valid window handle, or it should be <b>NULL</b> if the dialog box is to have no owner.</param>
    <param name="lpCC">A pointer to a<see cref="COMMCONFIG" /> structure. This structure contains initial settings for the dialog box before the call, and changed values after the call.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CommConfigDialogW">
    <summary>Displays a driver-supplied configuration dialog box.</summary>
    <param name="lpszName">The name of the device for which a dialog box should be displayed. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
    <param name="hWnd">A handle to the window that owns the dialog box. This parameter can be any valid window handle, or it should be <b>NULL</b> if the dialog box is to have no owner.</param>
    <param name="lpCC">A pointer to a<see cref="COMMCONFIG" /> structure. This structure contains initial settings for the dialog box before the call, and changed values after the call.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CommConfigDialog">
    <summary>Displays a driver-supplied configuration dialog box.</summary>
    <param name="lpszName">The name of the device for which a dialog box should be displayed. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
    <param name="hWnd">A handle to the window that owns the dialog box. This parameter can be any valid window handle, or it should be <b>NULL</b> if the dialog box is to have no owner.</param>
    <param name="lpCC">A pointer to a<see cref="COMMCONFIG" /> structure. This structure contains initial settings for the dialog box before the call, and changed values after the call.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CommConfigDialogA">
    <summary>Displays a driver-supplied configuration dialog box.</summary>
    <param name="lpszName">The name of the device for which a dialog box should be displayed. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
    <param name="hWnd">A handle to the window that owns the dialog box. This parameter can be any valid window handle, or it should be <b>NULL</b> if the dialog box is to have no owner.</param>
    <param name="lpCC">A pointer to a<see cref="COMMCONFIG" /> structure. This structure contains initial settings for the dialog box before the call, and changed values after the call.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CommConfigDialogW">
    <summary>Displays a driver-supplied configuration dialog box.</summary>
    <param name="lpszName">The name of the device for which a dialog box should be displayed. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
    <param name="hWnd">A handle to the window that owns the dialog box. This parameter can be any valid window handle, or it should be <b>NULL</b> if the dialog box is to have no owner.</param>
    <param name="lpCC">A pointer to a<see cref="COMMCONFIG" /> structure. This structure contains initial settings for the dialog box before the call, and changed values after the call.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ConvertFiberToThread">
    <summary>Converts the current fiber into a thread.</summary>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ConvertThreadToFiber">
    <summary>Converts the current thread into a fiber. You must convert a thread into a fiber before you can schedule other fibers.</summary>
    <param name="lpParameter">A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the<see cref="GetFiberData" /> macro.</param>
    <returns>
      <para>If the function succeeds, the return value is the address of the fiber.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ConvertThreadToFiberEx">
    <summary>Converts the current thread into a fiber. You must convert a thread into a fiber before you can schedule other fibers.</summary>
    <param name="lpParameter">A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the<see cref="GetFiberData" /> macro.</param>
    <param name="dwFlags">If this parameter is zero, the floating-point state on x86 systems is not switched and data can be corrupted if a fiber uses floating-point arithmetic. If this parameter is FIBER_FLAG_FLOAT_SWITCH, the floating-point state is switched for the fiber.</param>
    <returns>
      <para>If the function succeeds, the return value is the address of the fiber.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CopyContext">
    <summary>Copies a source context structure (including any XState) onto an initialized destination context structure.</summary>
    <param name="Destination">A pointer to a <see cref="CONTEXT" /> structure that receives the context copied from the <i>Source</i>. The<b>CONTEXT</b> structure should be initialized by calling<see cref="InitializeContext" /> before calling this function.</param>
    <param name="ContextFlags">Flags specifying the pieces of the <i>Source</i><see cref="CONTEXT" /> structure that will be copied into the destination. This must be a subset of the <i>ContextFlags</i> specified when calling<see cref="InitializeContext" /> on the<i>Destination</i><b>CONTEXT</b>.</param>
    <param name="Source">A pointer to a <see cref="CONTEXT" /> structure from which to copy processor context data.</param>
    <returns>This function returns <b>TRUE</b> if the context was copied successfully, otherwise<b>FALSE</b>. To get extended error information, call<see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.CopyFile">
    <summary>
      <para>Copies an existing file to a new file.</para>
      <para>The <see cref="CopyFileEx" /> function provides two additional capabilities. <b>CopyFileEx</b> can call a specified callback function each time a portion of the copy operation is completed, and<b>CopyFileEx</b> can be canceled during the copy operation.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>If <i>lpExistingFileName</i> does not exist,<b>CopyFile</b> fails, and<see cref="GetLastError" /> returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="bFailIfExists">If this parameter is <b>TRUE</b> and the new file specified by<i>lpNewFileName</i> already exists, the function fails. If this parameter is<b>FALSE</b> and the new file already exists, the function overwrites the existing file and succeeds.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CopyFileA">
    <summary>
      <para>Copies an existing file to a new file.</para>
      <para>The <see cref="CopyFileEx" /> function provides two additional capabilities. <b>CopyFileEx</b> can call a specified callback function each time a portion of the copy operation is completed, and<b>CopyFileEx</b> can be canceled during the copy operation.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>If <i>lpExistingFileName</i> does not exist,<b>CopyFile</b> fails, and<see cref="GetLastError" /> returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="bFailIfExists">If this parameter is <b>TRUE</b> and the new file specified by<i>lpNewFileName</i> already exists, the function fails. If this parameter is<b>FALSE</b> and the new file already exists, the function overwrites the existing file and succeeds.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CopyFileW">
    <summary>
      <para>Copies an existing file to a new file.</para>
      <para>The <see cref="CopyFileEx" /> function provides two additional capabilities. <b>CopyFileEx</b> can call a specified callback function each time a portion of the copy operation is completed, and<b>CopyFileEx</b> can be canceled during the copy operation.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>If <i>lpExistingFileName</i> does not exist,<b>CopyFile</b> fails, and<see cref="GetLastError" /> returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="bFailIfExists">If this parameter is <b>TRUE</b> and the new file specified by<i>lpNewFileName</i> already exists, the function fails. If this parameter is<b>FALSE</b> and the new file already exists, the function overwrites the existing file and succeeds.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CopyFile">
    <summary>
      <para>Copies an existing file to a new file.</para>
      <para>The <see cref="CopyFileEx" /> function provides two additional capabilities. <b>CopyFileEx</b> can call a specified callback function each time a portion of the copy operation is completed, and<b>CopyFileEx</b> can be canceled during the copy operation.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>If <i>lpExistingFileName</i> does not exist,<b>CopyFile</b> fails, and<see cref="GetLastError" /> returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="bFailIfExists">If this parameter is <b>TRUE</b> and the new file specified by<i>lpNewFileName</i> already exists, the function fails. If this parameter is<b>FALSE</b> and the new file already exists, the function overwrites the existing file and succeeds.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CopyFileA">
    <summary>
      <para>Copies an existing file to a new file.</para>
      <para>The <see cref="CopyFileEx" /> function provides two additional capabilities. <b>CopyFileEx</b> can call a specified callback function each time a portion of the copy operation is completed, and<b>CopyFileEx</b> can be canceled during the copy operation.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>If <i>lpExistingFileName</i> does not exist,<b>CopyFile</b> fails, and<see cref="GetLastError" /> returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="bFailIfExists">If this parameter is <b>TRUE</b> and the new file specified by<i>lpNewFileName</i> already exists, the function fails. If this parameter is<b>FALSE</b> and the new file already exists, the function overwrites the existing file and succeeds.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CopyFileW">
    <summary>
      <para>Copies an existing file to a new file.</para>
      <para>The <see cref="CopyFileEx" /> function provides two additional capabilities. <b>CopyFileEx</b> can call a specified callback function each time a portion of the copy operation is completed, and<b>CopyFileEx</b> can be canceled during the copy operation.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>If <i>lpExistingFileName</i> does not exist,<b>CopyFile</b> fails, and<see cref="GetLastError" /> returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="bFailIfExists">If this parameter is <b>TRUE</b> and the new file specified by<i>lpNewFileName</i> already exists, the function fails. If this parameter is<b>FALSE</b> and the new file already exists, the function overwrites the existing file and succeeds.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CopyFileEx">
    <summary>
      <para>Copies an existing file to a new file, notifying the application of its progress through a callback function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>If <i>lpExistingFileName</i> does not exist, the<b>CopyFileEx</b> function fails, and the<see cref="GetLastError" /> function returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpProgressRoutine">The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For more information on the progress callback function, see the<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.</param>
    <param name="lpData">The argument to be passed to the callback function. This parameter can be<b>NULL</b>.</param>
    <param name="pbCancel">If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled. Otherwise, the copy operation will continue to completion.</param>
    <param name="dwCopyFlags">
      <para>Flags that specify how the file is to be copied. This parameter can be a combination of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to copy an encrypted file will succeed even if the destination copy cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_COPY_SYMLINK</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000800</term>
              </listheader>
            </list>
          </description>
          <description>If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same file that the source symbolic link is pointing to. <para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_FAIL_IF_EXISTS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The copy operation fails immediately if the target file already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_NO_BUFFERING</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00001000</term>
              </listheader>
            </list>
          </description>
          <description>The copy operation is performed using unbuffered I/O, bypassing system I/O cache resources. Recommended for very large file transfers. <para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>The file is copied and the original file is opened for write access.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_RESTARTABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be restarted at a later time by specifying the same values for <i>lpExistingFileName</i> and <i>lpNewFileName</i> as those used in the call that failed. This can significantly slow down the copy operation as the new file may be flushed multiple times during the copy operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_REQUEST_COMPRESSED_TRAFFIC</b>
                </term>
              </listheader>
              <listheader>
                <term> 0x10000000</term>
              </listheader>
            </list>
          </description>
          <description>
            <para>Request the underlying transfer channel compress the data during the copy operation. The request may not be supported for all mediums, in which case it is ignored. The compression attributes and parameters (computational complexity, memory usage) are not configurable through this API, and are subject to change between different OS releases.</para>
            <para>This flag was introduced in Windows 10, version 1903 and Windows Server 2022. On Windows 10, the flag is supported for files residing on SMB shares, where the negotiated SMB protocol version is SMB v3.1.1 or greater.</para>
          </description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information call<see cref="GetLastError" />.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the user canceling the operation, <b>CopyFileEx</b> will return zero and <see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is deleted.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the user stopping the operation, <b>CopyFileEx</b> will return zero and <see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left intact.</para>
    </returns>
  </member>
  <member name="Windows.CopyFileExA">
    <summary>
      <para>Copies an existing file to a new file, notifying the application of its progress through a callback function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>If <i>lpExistingFileName</i> does not exist, the<b>CopyFileEx</b> function fails, and the<see cref="GetLastError" /> function returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpProgressRoutine">The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For more information on the progress callback function, see the<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.</param>
    <param name="lpData">The argument to be passed to the callback function. This parameter can be<b>NULL</b>.</param>
    <param name="pbCancel">If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled. Otherwise, the copy operation will continue to completion.</param>
    <param name="dwCopyFlags">
      <para>Flags that specify how the file is to be copied. This parameter can be a combination of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to copy an encrypted file will succeed even if the destination copy cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_COPY_SYMLINK</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000800</term>
              </listheader>
            </list>
          </description>
          <description>If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same file that the source symbolic link is pointing to. <para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_FAIL_IF_EXISTS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The copy operation fails immediately if the target file already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_NO_BUFFERING</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00001000</term>
              </listheader>
            </list>
          </description>
          <description>The copy operation is performed using unbuffered I/O, bypassing system I/O cache resources. Recommended for very large file transfers. <para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>The file is copied and the original file is opened for write access.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_RESTARTABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be restarted at a later time by specifying the same values for <i>lpExistingFileName</i> and <i>lpNewFileName</i> as those used in the call that failed. This can significantly slow down the copy operation as the new file may be flushed multiple times during the copy operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_REQUEST_COMPRESSED_TRAFFIC</b>
                </term>
              </listheader>
              <listheader>
                <term> 0x10000000</term>
              </listheader>
            </list>
          </description>
          <description>
            <para>Request the underlying transfer channel compress the data during the copy operation. The request may not be supported for all mediums, in which case it is ignored. The compression attributes and parameters (computational complexity, memory usage) are not configurable through this API, and are subject to change between different OS releases.</para>
            <para>This flag was introduced in Windows 10, version 1903 and Windows Server 2022. On Windows 10, the flag is supported for files residing on SMB shares, where the negotiated SMB protocol version is SMB v3.1.1 or greater.</para>
          </description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information call<see cref="GetLastError" />.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the user canceling the operation, <b>CopyFileEx</b> will return zero and <see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is deleted.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the user stopping the operation, <b>CopyFileEx</b> will return zero and <see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left intact.</para>
    </returns>
  </member>
  <member name="Windows.CopyFileExW">
    <summary>
      <para>Copies an existing file to a new file, notifying the application of its progress through a callback function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>If <i>lpExistingFileName</i> does not exist, the<b>CopyFileEx</b> function fails, and the<see cref="GetLastError" /> function returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpProgressRoutine">The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For more information on the progress callback function, see the<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.</param>
    <param name="lpData">The argument to be passed to the callback function. This parameter can be<b>NULL</b>.</param>
    <param name="pbCancel">If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled. Otherwise, the copy operation will continue to completion.</param>
    <param name="dwCopyFlags">
      <para>Flags that specify how the file is to be copied. This parameter can be a combination of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to copy an encrypted file will succeed even if the destination copy cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_COPY_SYMLINK</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000800</term>
              </listheader>
            </list>
          </description>
          <description>If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same file that the source symbolic link is pointing to. <para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_FAIL_IF_EXISTS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The copy operation fails immediately if the target file already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_NO_BUFFERING</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00001000</term>
              </listheader>
            </list>
          </description>
          <description>The copy operation is performed using unbuffered I/O, bypassing system I/O cache resources. Recommended for very large file transfers. <para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>The file is copied and the original file is opened for write access.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_RESTARTABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be restarted at a later time by specifying the same values for <i>lpExistingFileName</i> and <i>lpNewFileName</i> as those used in the call that failed. This can significantly slow down the copy operation as the new file may be flushed multiple times during the copy operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_REQUEST_COMPRESSED_TRAFFIC</b>
                </term>
              </listheader>
              <listheader>
                <term> 0x10000000</term>
              </listheader>
            </list>
          </description>
          <description>
            <para>Request the underlying transfer channel compress the data during the copy operation. The request may not be supported for all mediums, in which case it is ignored. The compression attributes and parameters (computational complexity, memory usage) are not configurable through this API, and are subject to change between different OS releases.</para>
            <para>This flag was introduced in Windows 10, version 1903 and Windows Server 2022. On Windows 10, the flag is supported for files residing on SMB shares, where the negotiated SMB protocol version is SMB v3.1.1 or greater.</para>
          </description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information call<see cref="GetLastError" />.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the user canceling the operation, <b>CopyFileEx</b> will return zero and <see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is deleted.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the user stopping the operation, <b>CopyFileEx</b> will return zero and <see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left intact.</para>
    </returns>
  </member>
  <member name="Windows.CopyFileEx">
    <summary>
      <para>Copies an existing file to a new file, notifying the application of its progress through a callback function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>If <i>lpExistingFileName</i> does not exist, the<b>CopyFileEx</b> function fails, and the<see cref="GetLastError" /> function returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpProgressRoutine">The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For more information on the progress callback function, see the<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.</param>
    <param name="lpData">The argument to be passed to the callback function. This parameter can be<b>NULL</b>.</param>
    <param name="pbCancel">If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled. Otherwise, the copy operation will continue to completion.</param>
    <param name="dwCopyFlags">
      <para>Flags that specify how the file is to be copied. This parameter can be a combination of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to copy an encrypted file will succeed even if the destination copy cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_COPY_SYMLINK</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000800</term>
              </listheader>
            </list>
          </description>
          <description>If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same file that the source symbolic link is pointing to. <para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_FAIL_IF_EXISTS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The copy operation fails immediately if the target file already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_NO_BUFFERING</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00001000</term>
              </listheader>
            </list>
          </description>
          <description>The copy operation is performed using unbuffered I/O, bypassing system I/O cache resources. Recommended for very large file transfers. <para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>The file is copied and the original file is opened for write access.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_RESTARTABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be restarted at a later time by specifying the same values for <i>lpExistingFileName</i> and <i>lpNewFileName</i> as those used in the call that failed. This can significantly slow down the copy operation as the new file may be flushed multiple times during the copy operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_REQUEST_COMPRESSED_TRAFFIC</b>
                </term>
              </listheader>
              <listheader>
                <term> 0x10000000</term>
              </listheader>
            </list>
          </description>
          <description>
            <para>Request the underlying transfer channel compress the data during the copy operation. The request may not be supported for all mediums, in which case it is ignored. The compression attributes and parameters (computational complexity, memory usage) are not configurable through this API, and are subject to change between different OS releases.</para>
            <para>This flag was introduced in Windows 10, version 1903 and Windows Server 2022. On Windows 10, the flag is supported for files residing on SMB shares, where the negotiated SMB protocol version is SMB v3.1.1 or greater.</para>
          </description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information call<see cref="GetLastError" />.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the user canceling the operation, <b>CopyFileEx</b> will return zero and <see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is deleted.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the user stopping the operation, <b>CopyFileEx</b> will return zero and <see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left intact.</para>
    </returns>
  </member>
  <member name="Windows.CopyFileExA">
    <summary>
      <para>Copies an existing file to a new file, notifying the application of its progress through a callback function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>If <i>lpExistingFileName</i> does not exist, the<b>CopyFileEx</b> function fails, and the<see cref="GetLastError" /> function returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpProgressRoutine">The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For more information on the progress callback function, see the<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.</param>
    <param name="lpData">The argument to be passed to the callback function. This parameter can be<b>NULL</b>.</param>
    <param name="pbCancel">If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled. Otherwise, the copy operation will continue to completion.</param>
    <param name="dwCopyFlags">
      <para>Flags that specify how the file is to be copied. This parameter can be a combination of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to copy an encrypted file will succeed even if the destination copy cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_COPY_SYMLINK</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000800</term>
              </listheader>
            </list>
          </description>
          <description>If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same file that the source symbolic link is pointing to. <para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_FAIL_IF_EXISTS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The copy operation fails immediately if the target file already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_NO_BUFFERING</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00001000</term>
              </listheader>
            </list>
          </description>
          <description>The copy operation is performed using unbuffered I/O, bypassing system I/O cache resources. Recommended for very large file transfers. <para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>The file is copied and the original file is opened for write access.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_RESTARTABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be restarted at a later time by specifying the same values for <i>lpExistingFileName</i> and <i>lpNewFileName</i> as those used in the call that failed. This can significantly slow down the copy operation as the new file may be flushed multiple times during the copy operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_REQUEST_COMPRESSED_TRAFFIC</b>
                </term>
              </listheader>
              <listheader>
                <term> 0x10000000</term>
              </listheader>
            </list>
          </description>
          <description>
            <para>Request the underlying transfer channel compress the data during the copy operation. The request may not be supported for all mediums, in which case it is ignored. The compression attributes and parameters (computational complexity, memory usage) are not configurable through this API, and are subject to change between different OS releases.</para>
            <para>This flag was introduced in Windows 10, version 1903 and Windows Server 2022. On Windows 10, the flag is supported for files residing on SMB shares, where the negotiated SMB protocol version is SMB v3.1.1 or greater.</para>
          </description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information call<see cref="GetLastError" />.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the user canceling the operation, <b>CopyFileEx</b> will return zero and <see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is deleted.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the user stopping the operation, <b>CopyFileEx</b> will return zero and <see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left intact.</para>
    </returns>
  </member>
  <member name="Windows.CopyFileExW">
    <summary>
      <para>Copies an existing file to a new file, notifying the application of its progress through a callback function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>If <i>lpExistingFileName</i> does not exist, the<b>CopyFileEx</b> function fails, and the<see cref="GetLastError" /> function returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpProgressRoutine">The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For more information on the progress callback function, see the<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.</param>
    <param name="lpData">The argument to be passed to the callback function. This parameter can be<b>NULL</b>.</param>
    <param name="pbCancel">If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled. Otherwise, the copy operation will continue to completion.</param>
    <param name="dwCopyFlags">
      <para>Flags that specify how the file is to be copied. This parameter can be a combination of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to copy an encrypted file will succeed even if the destination copy cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_COPY_SYMLINK</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000800</term>
              </listheader>
            </list>
          </description>
          <description>If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same file that the source symbolic link is pointing to. <para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_FAIL_IF_EXISTS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The copy operation fails immediately if the target file already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_NO_BUFFERING</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00001000</term>
              </listheader>
            </list>
          </description>
          <description>The copy operation is performed using unbuffered I/O, bypassing system I/O cache resources. Recommended for very large file transfers. <para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>The file is copied and the original file is opened for write access.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_RESTARTABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be restarted at a later time by specifying the same values for <i>lpExistingFileName</i> and <i>lpNewFileName</i> as those used in the call that failed. This can significantly slow down the copy operation as the new file may be flushed multiple times during the copy operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>COPY_FILE_REQUEST_COMPRESSED_TRAFFIC</b>
                </term>
              </listheader>
              <listheader>
                <term> 0x10000000</term>
              </listheader>
            </list>
          </description>
          <description>
            <para>Request the underlying transfer channel compress the data during the copy operation. The request may not be supported for all mediums, in which case it is ignored. The compression attributes and parameters (computational complexity, memory usage) are not configurable through this API, and are subject to change between different OS releases.</para>
            <para>This flag was introduced in Windows 10, version 1903 and Windows Server 2022. On Windows 10, the flag is supported for files residing on SMB shares, where the negotiated SMB protocol version is SMB v3.1.1 or greater.</para>
          </description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information call<see cref="GetLastError" />.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the user canceling the operation, <b>CopyFileEx</b> will return zero and <see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is deleted.</para>
      <para>If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the user stopping the operation, <b>CopyFileEx</b> will return zero and <see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left intact.</para>
    </returns>
  </member>
  <member name="Windows.CopyFile">
    <summary>
      <para>Copies an existing file to a new file.</para>
      <para>The <see cref="CopyFileEx" /> function provides two additional capabilities. <b>CopyFileEx</b> can call a specified callback function each time a portion of the copy operation is completed, and<b>CopyFileEx</b> can be canceled during the copy operation.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>If <i>lpExistingFileName</i> does not exist,<b>CopyFile</b> fails, and<see cref="GetLastError" /> returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="bFailIfExists">If this parameter is <b>TRUE</b> and the new file specified by<i>lpNewFileName</i> already exists, the function fails. If this parameter is<b>FALSE</b> and the new file already exists, the function overwrites the existing file and succeeds.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CopyFileA">
    <summary>
      <para>Copies an existing file to a new file.</para>
      <para>The <see cref="CopyFileEx" /> function provides two additional capabilities. <b>CopyFileEx</b> can call a specified callback function each time a portion of the copy operation is completed, and<b>CopyFileEx</b> can be canceled during the copy operation.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>If <i>lpExistingFileName</i> does not exist,<b>CopyFile</b> fails, and<see cref="GetLastError" /> returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="bFailIfExists">If this parameter is <b>TRUE</b> and the new file specified by<i>lpNewFileName</i> already exists, the function fails. If this parameter is<b>FALSE</b> and the new file already exists, the function overwrites the existing file and succeeds.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CopyFileW">
    <summary>
      <para>Copies an existing file to a new file.</para>
      <para>The <see cref="CopyFileEx" /> function provides two additional capabilities. <b>CopyFileEx</b> can call a specified callback function each time a portion of the copy operation is completed, and<b>CopyFileEx</b> can be canceled during the copy operation.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CopyFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of an existing file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>If <i>lpExistingFileName</i> does not exist,<b>CopyFile</b> fails, and<see cref="GetLastError" /> returns<b>ERROR_FILE_NOT_FOUND</b>.</para>
    </param>
    <param name="lpNewFileName">
      <para>The name of the new file.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="bFailIfExists">If this parameter is <b>TRUE</b> and the new file specified by<i>lpNewFileName</i> already exists, the function fails. If this parameter is<b>FALSE</b> and the new file already exists, the function overwrites the existing file and succeeds.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateActCtx">
    <summary>The<b>CreateActCtx</b> function creates an activation context.</summary>
    <param name="pActCtx">Pointer to an<see cref="ACTCTX" /> structure that contains information about the activation context to be created.</param>
    <returns>
      <para>If the function succeeds, it returns a handle to the returned activation context. Otherwise, it returns INVALID_HANDLE_VALUE.</para>
      <para>This function sets errors that can be retrieved by calling<see cref="GetLastError" />. For an example, see<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
  </member>
  <member name="Windows.CreateActCtxA">
    <summary>The<b>CreateActCtx</b> function creates an activation context.</summary>
    <param name="pActCtx">Pointer to an<see cref="ACTCTX" /> structure that contains information about the activation context to be created.</param>
    <returns>
      <para>If the function succeeds, it returns a handle to the returned activation context. Otherwise, it returns INVALID_HANDLE_VALUE.</para>
      <para>This function sets errors that can be retrieved by calling<see cref="GetLastError" />. For an example, see<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
  </member>
  <member name="Windows.CreateActCtxW">
    <summary>The<b>CreateActCtx</b> function creates an activation context.</summary>
    <param name="pActCtx">Pointer to an<see cref="ACTCTX" /> structure that contains information about the activation context to be created.</param>
    <returns>
      <para>If the function succeeds, it returns a handle to the returned activation context. Otherwise, it returns INVALID_HANDLE_VALUE.</para>
      <para>This function sets errors that can be retrieved by calling<see cref="GetLastError" />. For an example, see<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
  </member>
  <member name="Windows.CreateActCtx">
    <summary>The<b>CreateActCtx</b> function creates an activation context.</summary>
    <param name="pActCtx">Pointer to an<see cref="ACTCTX" /> structure that contains information about the activation context to be created.</param>
    <returns>
      <para>If the function succeeds, it returns a handle to the returned activation context. Otherwise, it returns INVALID_HANDLE_VALUE.</para>
      <para>This function sets errors that can be retrieved by calling<see cref="GetLastError" />. For an example, see<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
  </member>
  <member name="Windows.CreateActCtxA">
    <summary>The<b>CreateActCtx</b> function creates an activation context.</summary>
    <param name="pActCtx">Pointer to an<see cref="ACTCTX" /> structure that contains information about the activation context to be created.</param>
    <returns>
      <para>If the function succeeds, it returns a handle to the returned activation context. Otherwise, it returns INVALID_HANDLE_VALUE.</para>
      <para>This function sets errors that can be retrieved by calling<see cref="GetLastError" />. For an example, see<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
  </member>
  <member name="Windows.CreateActCtxW">
    <summary>The<b>CreateActCtx</b> function creates an activation context.</summary>
    <param name="pActCtx">Pointer to an<see cref="ACTCTX" /> structure that contains information about the activation context to be created.</param>
    <returns>
      <para>If the function succeeds, it returns a handle to the returned activation context. Otherwise, it returns INVALID_HANDLE_VALUE.</para>
      <para>This function sets errors that can be retrieved by calling<see cref="GetLastError" />. For an example, see<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
  </member>
  <member name="Windows.CreateDirectory">
    <summary>
      <para>Creates a new directory. If the underlying file system supports security on files and directories, the function applies a specified security descriptor to the new directory.</para>
      <para>To specify a template directory, use the<see cref="CreateDirectoryEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be created.</para>
      <para>For the ANSI version of this function, there is a default string size limit for paths of 248 characters (<b>MAX_PATH</b> - enough room for a 8.3 filename). To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\?" to the path. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <div>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryW</b>), you can opt-in to remove the 248 character limitation without prepending "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new directory. If <i>lpSecurityAttributes</i> is<b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default security descriptor for a directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect. (This is indicated when <see cref="GetVolumeInformation" />returns <b>FS_PERSISTENT_ACLS</b>.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible errors include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified directory already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One or more intermediate directories do not exist; this function will only create the final directory in the path.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.CreateDirectoryA">
    <summary>
      <para>Creates a new directory. If the underlying file system supports security on files and directories, the function applies a specified security descriptor to the new directory.</para>
      <para>To specify a template directory, use the<see cref="CreateDirectoryEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be created.</para>
      <para>For the ANSI version of this function, there is a default string size limit for paths of 248 characters (<b>MAX_PATH</b> - enough room for a 8.3 filename). To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\?" to the path. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <div>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryW</b>), you can opt-in to remove the 248 character limitation without prepending "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new directory. If <i>lpSecurityAttributes</i> is<b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default security descriptor for a directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect. (This is indicated when <see cref="GetVolumeInformation" />returns <b>FS_PERSISTENT_ACLS</b>.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible errors include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified directory already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One or more intermediate directories do not exist; this function will only create the final directory in the path.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.CreateDirectoryW">
    <summary>
      <para>Creates a new directory. If the underlying file system supports security on files and directories, the function applies a specified security descriptor to the new directory.</para>
      <para>To specify a template directory, use the<see cref="CreateDirectoryEx" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpPathName">
      <para>The path of the directory to be created.</para>
      <para>For the ANSI version of this function, there is a default string size limit for paths of 248 characters (<b>MAX_PATH</b> - enough room for a 8.3 filename). To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\?" to the path. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <div>
        <b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryW</b>), you can opt-in to remove the 248 character limitation without prepending "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new directory. If <i>lpSecurityAttributes</i> is<b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default security descriptor for a directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect. (This is indicated when <see cref="GetVolumeInformation" />returns <b>FS_PERSISTENT_ACLS</b>.)</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible errors include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified directory already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One or more intermediate directories do not exist; this function will only create the final directory in the path.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.CreateDirectoryEx">
    <summary>
      <para>Creates a new directory with the attributes of a specified template directory. If the underlying file system supports security on files and directories, the function applies a specified security descriptor to the new directory. The new directory retains the other attributes of the specified template directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpTemplateDirectory">
      <para>The path of the directory to use as a template when creating the new directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewDirectory">
      <para>The path of the directory to be created.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new directory.</para>
      <para>If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect. This is indicated when <see cref="GetVolumeInformation" />returns <b>FS_PERSISTENT_ACLS</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />. Possible errors include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified directory already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One or more intermediate directories do not exist. This function only creates the final directory in the path. To create all intermediate directories on the path, use the <see cref="SHCreateDirectoryEx" /> function.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.CreateDirectoryExA">
    <summary>
      <para>Creates a new directory with the attributes of a specified template directory. If the underlying file system supports security on files and directories, the function applies a specified security descriptor to the new directory. The new directory retains the other attributes of the specified template directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpTemplateDirectory">
      <para>The path of the directory to use as a template when creating the new directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewDirectory">
      <para>The path of the directory to be created.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new directory.</para>
      <para>If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect. This is indicated when <see cref="GetVolumeInformation" />returns <b>FS_PERSISTENT_ACLS</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />. Possible errors include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified directory already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One or more intermediate directories do not exist. This function only creates the final directory in the path. To create all intermediate directories on the path, use the <see cref="SHCreateDirectoryEx" /> function.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.CreateDirectoryExW">
    <summary>
      <para>Creates a new directory with the attributes of a specified template directory. If the underlying file system supports security on files and directories, the function applies a specified security descriptor to the new directory. The new directory retains the other attributes of the specified template directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpTemplateDirectory">
      <para>The path of the directory to use as a template when creating the new directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewDirectory">
      <para>The path of the directory to be created.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new directory.</para>
      <para>If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect. This is indicated when <see cref="GetVolumeInformation" />returns <b>FS_PERSISTENT_ACLS</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />. Possible errors include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified directory already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One or more intermediate directories do not exist. This function only creates the final directory in the path. To create all intermediate directories on the path, use the <see cref="SHCreateDirectoryEx" /> function.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.CreateDirectoryEx">
    <summary>
      <para>Creates a new directory with the attributes of a specified template directory. If the underlying file system supports security on files and directories, the function applies a specified security descriptor to the new directory. The new directory retains the other attributes of the specified template directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpTemplateDirectory">
      <para>The path of the directory to use as a template when creating the new directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewDirectory">
      <para>The path of the directory to be created.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new directory.</para>
      <para>If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect. This is indicated when <see cref="GetVolumeInformation" />returns <b>FS_PERSISTENT_ACLS</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />. Possible errors include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified directory already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One or more intermediate directories do not exist. This function only creates the final directory in the path. To create all intermediate directories on the path, use the <see cref="SHCreateDirectoryEx" /> function.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.CreateDirectoryExA">
    <summary>
      <para>Creates a new directory with the attributes of a specified template directory. If the underlying file system supports security on files and directories, the function applies a specified security descriptor to the new directory. The new directory retains the other attributes of the specified template directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpTemplateDirectory">
      <para>The path of the directory to use as a template when creating the new directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewDirectory">
      <para>The path of the directory to be created.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new directory.</para>
      <para>If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect. This is indicated when <see cref="GetVolumeInformation" />returns <b>FS_PERSISTENT_ACLS</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />. Possible errors include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified directory already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One or more intermediate directories do not exist. This function only creates the final directory in the path. To create all intermediate directories on the path, use the <see cref="SHCreateDirectoryEx" /> function.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.CreateDirectoryExW">
    <summary>
      <para>Creates a new directory with the attributes of a specified template directory. If the underlying file system supports security on files and directories, the function applies a specified security descriptor to the new directory. The new directory retains the other attributes of the specified template directory.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateDirectoryTransacted" /> function.</para>
    </summary>
    <param name="lpTemplateDirectory">
      <para>The path of the directory to use as a template when creating the new directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewDirectory">
      <para>The path of the directory to be created.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpSecurityAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new directory.</para>
      <para>If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a directory are inherited from its parent directory.</para>
      <para>The target file system must support security on files and directories for this parameter to have an effect. This is indicated when <see cref="GetVolumeInformation" />returns <b>FS_PERSISTENT_ACLS</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />. Possible errors include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified directory already exists.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One or more intermediate directories do not exist. This function only creates the final directory in the path. To create all intermediate directories on the path, use the <see cref="SHCreateDirectoryEx" /> function.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.CreateFiber">
    <summary>
      <para>Allocates a fiber object, assigns it a stack, and sets up execution to begin at the specified start address, typically the fiber function. This function does not schedule the fiber.</para>
      <para>To specify both a commit and reserve stack size, use the<see cref="CreateFiberEx" /> function.</para>
    </summary>
    <param name="dwStackSize">The initial committed size of the stack, in bytes. If this parameter is zero, the new fiber uses the default commit stack size for the executable. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-stack-size">Thread Stack Size</a>.</param>
    <param name="lpStartAddress">A pointer to the application-defined function to be executed by the fiber and represents the starting address of the fiber. Execution of the newly created fiber does not begin until another fiber calls the<see cref="SwitchToFiber" /> function with this address. For more information of the fiber callback function, see<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-pfiber_start_routine">FiberProc</a>.</param>
    <param name="lpParameter">A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the<see cref="GetFiberData" /> macro.</param>
    <returns>
      <para>If the function succeeds, the return value is the address of the fiber.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateFiberEx">
    <summary>Allocates a fiber object, assigns it a stack, and sets up execution to begin at the specified start address, typically the fiber function. This function does not schedule the fiber.</summary>
    <param name="dwStackCommitSize">The initial commit size of the stack, in bytes. If this parameter is zero, the new fiber uses the default commit stack size for the executable. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-stack-size">Thread Stack Size</a>.</param>
    <param name="dwStackReserveSize">The initial reserve size of the stack, in bytes. If this parameter is zero, the new fiber uses the default reserved stack size for the executable. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-stack-size">Thread Stack Size</a>.</param>
    <param name="dwFlags">
      <para>If this parameter is zero, the floating-point state on x86 systems is not switched and data can be corrupted if a fiber uses floating-point arithmetic. If this parameter is <b>FIBER_FLAG_FLOAT_SWITCH</b>, the floating-point state is switched for the fiber.</para>
      <para>
        <b>Windows XP:  </b>The <b>FIBER_FLAG_FLOAT_SWITCH</b> flag is not supported.</para>
    </param>
    <param name="lpStartAddress">A pointer to the application-defined function to be executed by the fiber and represents the starting address of the fiber. Execution of the newly created fiber does not begin until another fiber calls the<see cref="SwitchToFiber" /> function with this address. For more information on the fiber callback function, see<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-pfiber_start_routine">FiberProc</a>.</param>
    <param name="lpParameter">A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the<see cref="GetFiberData" /> macro.</param>
    <returns>
      <para>If the function succeeds, the return value is the address of the fiber.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateFileMapping">
    <summary>
      <para>Creates or opens a named or unnamed file mapping object for a specified file.</para>
      <para>To specify the NUMA node for the physical memory, see<see cref="CreateFileMappingNuma" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the<i>flProtect</i> parameter specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive access. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and<i>dwMaximumSizeLow</i> parameters. In this scenario,<b>CreateFileMapping</b> creates a file mapping object of a specified size that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure that determines whether a returned handle can be inherited by child processes. The<b>lpSecurityDescriptor</b> member of the<b>SECURITY_ATTRIBUTES</b> structure specifies a security descriptor for a new file mapping object.</para>
      <para>If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle cannot be inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token of the creator. For more information, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x20</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access.<para>The file handle specified by the <i>hFile</i> parameter must be created with the<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and Windows Server 2003 with SP1.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x40</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, read/write, or execute access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and<b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and Windows Server 2003 with SP1.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x80</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to <b>PAGE_EXECUTE_READ</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x02</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region results in an access violation.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x04</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or read/write access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and<b>GENERIC_WRITE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x08</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to <b>PAGE_READONLY</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> access right.</para></description>
        </listheader>
      </list> <para>An application can specify one or more of the following attributes for the file mapping object by combining them with one of the preceding page protection values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_COMMIT</b></term></listheader><listheader><term>0x8000000</term></listheader></list></description><description>If the file mapping object is backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that when a view of the file is mapped into a process address space, the entire range of pages is committed rather than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise, <b>CreateFileMapping</b> fails.<para>This attribute has no effect for file mapping objects that are backed by executable image files or data files (the <i>hfile</i> parameter is a handle to a file).</para><para><b>SEC_COMMIT</b> cannot be combined with <b>SEC_RESERVE</b>.</para><para>If no attribute is specified, <b>SEC_COMMIT</b> is assumed.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE</b></term></listheader><listheader><term>0x1000000</term></listheader></list></description><description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file.<para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the executable image file. Page protection for views of an executable image file is determined by the executable file itself.</para><para>No other attributes are valid with <b>SEC_IMAGE</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE_NO_EXECUTE</b></term></listheader><listheader><term>0x11000000</term></listheader></list></description><description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file that will not be executed and the loaded image file will have no forced integrity checks run. Additionally, mapping a view of a file mapping object created with the <b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a> kernel API.<para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the<b>PAGE_READONLY</b> page protection value. No other attributes are valid with<b>SEC_IMAGE_NO_EXECUTE</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_LARGE_PAGES</b></term></listheader><listheader><term>0x80000000</term></listheader></list></description><description>Enables large pages to be used for file mapping objects that are backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>). This attribute is not supported for file mapping objects that are backed by executable image files or data files (the <i>hFile</i> parameter is a handle to an executable image or data file).<para>The maximum size of the file mapping object must be a multiple of the minimum size of a large page returned by the <see cref="GetLargePageMinimum" /> function. If it is not, <b>CreateFileMapping</b> fails. When mapping a view of a file mapping object created with <b>SEC_LARGE_PAGES</b>, the base address and view size must also be multiples of the minimum large page size.</para><para><b>SEC_LARGE_PAGES</b> requires the<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a>privilege to be enabled in the caller's token.</para><para>If <b>SEC_LARGE_PAGES</b> is specified, <b>SEC_COMMIT</b> must also be specified.</para><para><b>Windows Server 2003:  </b>This value is not supported until Windows Server 2003 with SP1.</para><para><b>Windows XP:  </b>This value is not supported.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_NOCACHE</b></term></listheader><listheader><term>0x10000000</term></listheader></list></description><description>Sets all pages to be non-cacheable.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_NOCACHE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_NOCACHE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_RESERVE</b></term></listheader><listheader><term>0x4000000</term></listheader></list></description><description>If the file mapping object is backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that when a view of the file is mapped into a process address space, the entire range of pages is reserved for later use by the process rather than committed.<para>Reserved pages can be committed in subsequent calls to the<see cref="VirtualAlloc" /> function. After the pages are committed, they cannot be freed or decommitted with the<see cref="VirtualFree" /> function.</para><para>This attribute has no effect for file mapping objects that are backed by executable image files or data files (the <i>hfile</i> parameter is a handle to a file).</para><para><b>SEC_RESERVE</b> cannot be combined with <b>SEC_COMMIT</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_WRITECOMBINE</b></term></listheader><listheader><term>0x40000000</term></listheader></list></description><description>Sets all pages to be write-combined.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_WRITECOMBINE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para><para><b>Windows Server 2003 and Windows XP:  </b>This flag is not supported until Windows Vista.</para></description></listheader></list></param>
    <param name="dwMaximumSizeHigh">The high-order <b>DWORD</b> of the maximum size of the file mapping object.</param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and <i>dwMaximumSizeHigh</i> are 0 (zero), the maximum size of the file mapping object is equal to the current size of the file that <i>hFile</i> identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing mapping object, the function requests access to the object with the protection that <i>flProtect</i> specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or job object, the function fails, and the <see cref="GetLastError" />function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). Creating a file mapping object in the global namespace from a session other than session zero requires the<a href="https://docs.microsoft.com//windows/win32/secauthz/privilege-constants#constants">SeCreateGlobalPrivilege</a>privilege. For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the guidelines that are outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its current size, not the specified size), and <see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateFileMappingA">
    <summary>
      <para>Creates or opens a named or unnamed file mapping object for a specified file.</para>
      <para>To specify the NUMA node for the physical memory, see<see cref="CreateFileMappingNuma" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the<i>flProtect</i> parameter specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive access. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and<i>dwMaximumSizeLow</i> parameters. In this scenario,<b>CreateFileMapping</b> creates a file mapping object of a specified size that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure that determines whether a returned handle can be inherited by child processes. The<b>lpSecurityDescriptor</b> member of the<b>SECURITY_ATTRIBUTES</b> structure specifies a security descriptor for a new file mapping object.</para>
      <para>If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle cannot be inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token of the creator. For more information, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x20</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access.<para>The file handle specified by the <i>hFile</i> parameter must be created with the<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and Windows Server 2003 with SP1.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x40</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, read/write, or execute access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and<b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and Windows Server 2003 with SP1.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x80</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to <b>PAGE_EXECUTE_READ</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x02</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region results in an access violation.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x04</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or read/write access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and<b>GENERIC_WRITE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x08</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to <b>PAGE_READONLY</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> access right.</para></description>
        </listheader>
      </list> <para>An application can specify one or more of the following attributes for the file mapping object by combining them with one of the preceding page protection values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_COMMIT</b></term></listheader><listheader><term>0x8000000</term></listheader></list></description><description>If the file mapping object is backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that when a view of the file is mapped into a process address space, the entire range of pages is committed rather than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise, <b>CreateFileMapping</b> fails.<para>This attribute has no effect for file mapping objects that are backed by executable image files or data files (the <i>hfile</i> parameter is a handle to a file).</para><para><b>SEC_COMMIT</b> cannot be combined with <b>SEC_RESERVE</b>.</para><para>If no attribute is specified, <b>SEC_COMMIT</b> is assumed.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE</b></term></listheader><listheader><term>0x1000000</term></listheader></list></description><description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file.<para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the executable image file. Page protection for views of an executable image file is determined by the executable file itself.</para><para>No other attributes are valid with <b>SEC_IMAGE</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE_NO_EXECUTE</b></term></listheader><listheader><term>0x11000000</term></listheader></list></description><description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file that will not be executed and the loaded image file will have no forced integrity checks run. Additionally, mapping a view of a file mapping object created with the <b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a> kernel API.<para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the<b>PAGE_READONLY</b> page protection value. No other attributes are valid with<b>SEC_IMAGE_NO_EXECUTE</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_LARGE_PAGES</b></term></listheader><listheader><term>0x80000000</term></listheader></list></description><description>Enables large pages to be used for file mapping objects that are backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>). This attribute is not supported for file mapping objects that are backed by executable image files or data files (the <i>hFile</i> parameter is a handle to an executable image or data file).<para>The maximum size of the file mapping object must be a multiple of the minimum size of a large page returned by the <see cref="GetLargePageMinimum" /> function. If it is not, <b>CreateFileMapping</b> fails. When mapping a view of a file mapping object created with <b>SEC_LARGE_PAGES</b>, the base address and view size must also be multiples of the minimum large page size.</para><para><b>SEC_LARGE_PAGES</b> requires the<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a>privilege to be enabled in the caller's token.</para><para>If <b>SEC_LARGE_PAGES</b> is specified, <b>SEC_COMMIT</b> must also be specified.</para><para><b>Windows Server 2003:  </b>This value is not supported until Windows Server 2003 with SP1.</para><para><b>Windows XP:  </b>This value is not supported.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_NOCACHE</b></term></listheader><listheader><term>0x10000000</term></listheader></list></description><description>Sets all pages to be non-cacheable.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_NOCACHE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_NOCACHE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_RESERVE</b></term></listheader><listheader><term>0x4000000</term></listheader></list></description><description>If the file mapping object is backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that when a view of the file is mapped into a process address space, the entire range of pages is reserved for later use by the process rather than committed.<para>Reserved pages can be committed in subsequent calls to the<see cref="VirtualAlloc" /> function. After the pages are committed, they cannot be freed or decommitted with the<see cref="VirtualFree" /> function.</para><para>This attribute has no effect for file mapping objects that are backed by executable image files or data files (the <i>hfile</i> parameter is a handle to a file).</para><para><b>SEC_RESERVE</b> cannot be combined with <b>SEC_COMMIT</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_WRITECOMBINE</b></term></listheader><listheader><term>0x40000000</term></listheader></list></description><description>Sets all pages to be write-combined.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_WRITECOMBINE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para><para><b>Windows Server 2003 and Windows XP:  </b>This flag is not supported until Windows Vista.</para></description></listheader></list></param>
    <param name="dwMaximumSizeHigh">The high-order <b>DWORD</b> of the maximum size of the file mapping object.</param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and <i>dwMaximumSizeHigh</i> are 0 (zero), the maximum size of the file mapping object is equal to the current size of the file that <i>hFile</i> identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing mapping object, the function requests access to the object with the protection that <i>flProtect</i> specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or job object, the function fails, and the <see cref="GetLastError" />function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). Creating a file mapping object in the global namespace from a session other than session zero requires the<a href="https://docs.microsoft.com//windows/win32/secauthz/privilege-constants#constants">SeCreateGlobalPrivilege</a>privilege. For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the guidelines that are outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its current size, not the specified size), and <see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateFileMappingW">
    <summary>
      <para>Creates or opens a named or unnamed file mapping object for a specified file.</para>
      <para>To specify the NUMA node for the physical memory, see<see cref="CreateFileMappingNuma" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the<i>flProtect</i> parameter specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive access. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and<i>dwMaximumSizeLow</i> parameters. In this scenario,<b>CreateFileMapping</b> creates a file mapping object of a specified size that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure that determines whether a returned handle can be inherited by child processes. The<b>lpSecurityDescriptor</b> member of the<b>SECURITY_ATTRIBUTES</b> structure specifies a security descriptor for a new file mapping object.</para>
      <para>If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle cannot be inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token of the creator. For more information, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x20</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access.<para>The file handle specified by the <i>hFile</i> parameter must be created with the<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and Windows Server 2003 with SP1.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x40</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, read/write, or execute access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and<b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not available until Windows XP with SP2 and Windows Server 2003 with SP1.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x80</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to <b>PAGE_EXECUTE_READ</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para><para><b>Windows Server 2003 and Windows XP:  </b>This value is not supported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x02</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region results in an access violation.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x04</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or read/write access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and<b>GENERIC_WRITE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x08</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to <b>PAGE_READONLY</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> access right.</para></description>
        </listheader>
      </list> <para>An application can specify one or more of the following attributes for the file mapping object by combining them with one of the preceding page protection values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_COMMIT</b></term></listheader><listheader><term>0x8000000</term></listheader></list></description><description>If the file mapping object is backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that when a view of the file is mapped into a process address space, the entire range of pages is committed rather than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise, <b>CreateFileMapping</b> fails.<para>This attribute has no effect for file mapping objects that are backed by executable image files or data files (the <i>hfile</i> parameter is a handle to a file).</para><para><b>SEC_COMMIT</b> cannot be combined with <b>SEC_RESERVE</b>.</para><para>If no attribute is specified, <b>SEC_COMMIT</b> is assumed.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE</b></term></listheader><listheader><term>0x1000000</term></listheader></list></description><description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file.<para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the executable image file. Page protection for views of an executable image file is determined by the executable file itself.</para><para>No other attributes are valid with <b>SEC_IMAGE</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE_NO_EXECUTE</b></term></listheader><listheader><term>0x11000000</term></listheader></list></description><description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file that will not be executed and the loaded image file will have no forced integrity checks run. Additionally, mapping a view of a file mapping object created with the <b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a> kernel API.<para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the<b>PAGE_READONLY</b> page protection value. No other attributes are valid with<b>SEC_IMAGE_NO_EXECUTE</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_LARGE_PAGES</b></term></listheader><listheader><term>0x80000000</term></listheader></list></description><description>Enables large pages to be used for file mapping objects that are backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>). This attribute is not supported for file mapping objects that are backed by executable image files or data files (the <i>hFile</i> parameter is a handle to an executable image or data file).<para>The maximum size of the file mapping object must be a multiple of the minimum size of a large page returned by the <see cref="GetLargePageMinimum" /> function. If it is not, <b>CreateFileMapping</b> fails. When mapping a view of a file mapping object created with <b>SEC_LARGE_PAGES</b>, the base address and view size must also be multiples of the minimum large page size.</para><para><b>SEC_LARGE_PAGES</b> requires the<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a>privilege to be enabled in the caller's token.</para><para>If <b>SEC_LARGE_PAGES</b> is specified, <b>SEC_COMMIT</b> must also be specified.</para><para><b>Windows Server 2003:  </b>This value is not supported until Windows Server 2003 with SP1.</para><para><b>Windows XP:  </b>This value is not supported.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_NOCACHE</b></term></listheader><listheader><term>0x10000000</term></listheader></list></description><description>Sets all pages to be non-cacheable.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_NOCACHE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_NOCACHE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_RESERVE</b></term></listheader><listheader><term>0x4000000</term></listheader></list></description><description>If the file mapping object is backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that when a view of the file is mapped into a process address space, the entire range of pages is reserved for later use by the process rather than committed.<para>Reserved pages can be committed in subsequent calls to the<see cref="VirtualAlloc" /> function. After the pages are committed, they cannot be freed or decommitted with the<see cref="VirtualFree" /> function.</para><para>This attribute has no effect for file mapping objects that are backed by executable image files or data files (the <i>hfile</i> parameter is a handle to a file).</para><para><b>SEC_RESERVE</b> cannot be combined with <b>SEC_COMMIT</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_WRITECOMBINE</b></term></listheader><listheader><term>0x40000000</term></listheader></list></description><description>Sets all pages to be write-combined.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_WRITECOMBINE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para><para><b>Windows Server 2003 and Windows XP:  </b>This flag is not supported until Windows Vista.</para></description></listheader></list></param>
    <param name="dwMaximumSizeHigh">The high-order <b>DWORD</b> of the maximum size of the file mapping object.</param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and <i>dwMaximumSizeHigh</i> are 0 (zero), the maximum size of the file mapping object is equal to the current size of the file that <i>hFile</i> identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing mapping object, the function requests access to the object with the protection that <i>flProtect</i> specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or job object, the function fails, and the <see cref="GetLastError" />function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). Creating a file mapping object in the global namespace from a session other than session zero requires the<a href="https://docs.microsoft.com//windows/win32/secauthz/privilege-constants#constants">SeCreateGlobalPrivilege</a>privilege. For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the guidelines that are outlined for Terminal Services so that applications can support multiple users.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the newly created file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its current size, not the specified size), and <see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateFileMappingNuma">
    <summary>Creates or opens a named or unnamed file mapping object for a specified file and specifies the NUMA node for the physical memory.</summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the <i>flProtect</i> parameter specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive access. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and<i>dwMaximumSizeLow</i> parameters. In this scenario,<b>CreateFileMappingNuma</b> creates a file mapping object of a specified size that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure that determines whether a returned handle can be inherited by child processes. The<b>lpSecurityDescriptor</b> member of the<br /><b>SECURITY_ATTRIBUTES</b> structure specifies a security descriptor for a new file mapping object.</para>
      <para>If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle cannot be inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token of the creator. For more information, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x20</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x40</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, read/write or execute access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and<b>GENERIC_EXECUTE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x80</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to <b>PAGE_EXECUTE_READ</b>.<para>The file handle that the <i>hFile</i>parameter specifies must be created with the <b>GENERIC_READ</b> and<b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x02</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region results in an access violation.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x04</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or read/write access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x08</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to <b>PAGE_READONLY</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> access right.</para></description>
        </listheader>
      </list> <para>An application can specify one or more of the following attributes for the file mapping object by combining them with one of the preceding page protection values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_COMMIT</b></term></listheader><listheader><term>0x8000000</term></listheader></list></description><description>Allocates physical storage in memory or the paging file for all pages. <para>This is the default setting.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE</b></term></listheader><listheader><term>0x1000000</term></listheader></list></description><description>Sets the file that is specified to be an executable image file.<para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the executable image file. Page protection for views of an executable image file is determined by the executable file itself.</para><para>No other attributes are valid with <b>SEC_IMAGE</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE_NO_EXECUTE</b></term></listheader><listheader><term>0x11000000</term></listheader></list></description><description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file that will not be executed and the loaded image file will have no forced integrity checks run. Additionally, mapping a view of a file mapping object created with the <b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a> kernel API.<para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the<b>PAGE_READONLY</b> page protection value. No other attributes are valid with<b>SEC_IMAGE_NO_EXECUTE</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_LARGE_PAGES</b></term></listheader><listheader><term>0x80000000</term></listheader></list></description><description>Enables large pages to be used when mapping images or backing from the pagefile, but not when mapping data for regular files. Be sure to specify the maximum size of the file mapping object as the minimum size of a large page reported by the <see cref="GetLargePageMinimum" /> function and to enable the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a> privilege.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_NOCACHE</b></term></listheader><listheader><term>0x10000000</term></listheader></list></description><description>Sets all pages to noncachable.<para>Applications should not use this flag except when explicitly required for a device. Using the interlocked functions with memory mapped with <b>SEC_NOCACHE</b>can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_NOCACHE</b> requires either <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> to be set.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_RESERVE</b></term></listheader><listheader><term>0x4000000</term></listheader></list></description><description>Reserves all pages without allocating physical storage.<para>The reserved range of pages cannot be used by any other allocation operations until the range of pages is released.</para><para>Reserved pages can be identified in subsequent calls to the<see cref="VirtualAllocExNuma" /> function. This attribute is valid only if the <i>hFile</i> parameter is <b>INVALID_HANDLE_VALUE</b>(that is, a file mapping object that is backed by the system paging file).</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_WRITECOMBINE</b></term></listheader><listheader><term>0x40000000</term></listheader></list></description><description>Sets all pages to be write-combined.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_WRITECOMBINE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para></description></listheader></list></param>
    <param name="dwMaximumSizeHigh">The high-order <b>DWORD</b> of the maximum size of the file mapping object.</param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and the <i>dwMaximumSizeHigh</i> parameter are 0 (zero), the maximum size of the file mapping object is equal to the current size of the file that the<i>hFile</i> parameter identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing file mapping object, the function requests access to the object with the protection that the <i>flProtect</i> parameter specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If the <i>lpName</i> parameter matches the name of an existing event, semaphore, mutex, waitable timer, or job object, the function fails and the<see cref="GetLastError" /> function returns<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). Creating a file mapping object in the global namespace requires the<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a>privilege. For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the guidelines so that applications can support multiple users.</para>
    </param>
    <param name="nndPreferred">
      <para>The NUMA node where the physical memory should reside.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NUMA_NO_PREFERRED_NODE</b>
                </term>
              </listheader>
              <listheader>
                <term>0xffffffff</term>
              </listheader>
            </list>
          </description>
          <description>No NUMA node is preferred. This is the same as calling the <see cref="CreateFileMapping" /> function.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its current size, not the specified size) and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call the <see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.CreateFileMappingNumaA">
    <summary>Creates or opens a named or unnamed file mapping object for a specified file and specifies the NUMA node for the physical memory.</summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the <i>flProtect</i> parameter specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive access. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and<i>dwMaximumSizeLow</i> parameters. In this scenario,<b>CreateFileMappingNuma</b> creates a file mapping object of a specified size that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure that determines whether a returned handle can be inherited by child processes. The<b>lpSecurityDescriptor</b> member of the<br /><b>SECURITY_ATTRIBUTES</b> structure specifies a security descriptor for a new file mapping object.</para>
      <para>If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle cannot be inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token of the creator. For more information, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x20</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x40</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, read/write or execute access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and<b>GENERIC_EXECUTE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x80</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to <b>PAGE_EXECUTE_READ</b>.<para>The file handle that the <i>hFile</i>parameter specifies must be created with the <b>GENERIC_READ</b> and<b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x02</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region results in an access violation.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x04</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or read/write access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x08</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to <b>PAGE_READONLY</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> access right.</para></description>
        </listheader>
      </list> <para>An application can specify one or more of the following attributes for the file mapping object by combining them with one of the preceding page protection values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_COMMIT</b></term></listheader><listheader><term>0x8000000</term></listheader></list></description><description>Allocates physical storage in memory or the paging file for all pages. <para>This is the default setting.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE</b></term></listheader><listheader><term>0x1000000</term></listheader></list></description><description>Sets the file that is specified to be an executable image file.<para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the executable image file. Page protection for views of an executable image file is determined by the executable file itself.</para><para>No other attributes are valid with <b>SEC_IMAGE</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE_NO_EXECUTE</b></term></listheader><listheader><term>0x11000000</term></listheader></list></description><description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file that will not be executed and the loaded image file will have no forced integrity checks run. Additionally, mapping a view of a file mapping object created with the <b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a> kernel API.<para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the<b>PAGE_READONLY</b> page protection value. No other attributes are valid with<b>SEC_IMAGE_NO_EXECUTE</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_LARGE_PAGES</b></term></listheader><listheader><term>0x80000000</term></listheader></list></description><description>Enables large pages to be used when mapping images or backing from the pagefile, but not when mapping data for regular files. Be sure to specify the maximum size of the file mapping object as the minimum size of a large page reported by the <see cref="GetLargePageMinimum" /> function and to enable the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a> privilege.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_NOCACHE</b></term></listheader><listheader><term>0x10000000</term></listheader></list></description><description>Sets all pages to noncachable.<para>Applications should not use this flag except when explicitly required for a device. Using the interlocked functions with memory mapped with <b>SEC_NOCACHE</b>can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_NOCACHE</b> requires either <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> to be set.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_RESERVE</b></term></listheader><listheader><term>0x4000000</term></listheader></list></description><description>Reserves all pages without allocating physical storage.<para>The reserved range of pages cannot be used by any other allocation operations until the range of pages is released.</para><para>Reserved pages can be identified in subsequent calls to the<see cref="VirtualAllocExNuma" /> function. This attribute is valid only if the <i>hFile</i> parameter is <b>INVALID_HANDLE_VALUE</b>(that is, a file mapping object that is backed by the system paging file).</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_WRITECOMBINE</b></term></listheader><listheader><term>0x40000000</term></listheader></list></description><description>Sets all pages to be write-combined.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_WRITECOMBINE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para></description></listheader></list></param>
    <param name="dwMaximumSizeHigh">The high-order <b>DWORD</b> of the maximum size of the file mapping object.</param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and the <i>dwMaximumSizeHigh</i> parameter are 0 (zero), the maximum size of the file mapping object is equal to the current size of the file that the<i>hFile</i> parameter identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing file mapping object, the function requests access to the object with the protection that the <i>flProtect</i> parameter specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If the <i>lpName</i> parameter matches the name of an existing event, semaphore, mutex, waitable timer, or job object, the function fails and the<see cref="GetLastError" /> function returns<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). Creating a file mapping object in the global namespace requires the<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a>privilege. For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the guidelines so that applications can support multiple users.</para>
    </param>
    <param name="nndPreferred">
      <para>The NUMA node where the physical memory should reside.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NUMA_NO_PREFERRED_NODE</b>
                </term>
              </listheader>
              <listheader>
                <term>0xffffffff</term>
              </listheader>
            </list>
          </description>
          <description>No NUMA node is preferred. This is the same as calling the <see cref="CreateFileMapping" /> function.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its current size, not the specified size) and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call the <see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.CreateFileMappingNumaW">
    <summary>Creates or opens a named or unnamed file mapping object for a specified file and specifies the NUMA node for the physical memory.</summary>
    <param name="hFile">
      <para>A handle to the file from which to create a file mapping object.</para>
      <para>The file must be opened with access rights that are compatible with the protection flags that the <i>flProtect</i> parameter specifies. It is not required, but it is recommended that files you intend to map be opened for exclusive access. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
      <para>If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and<i>dwMaximumSizeLow</i> parameters. In this scenario,<b>CreateFileMappingNuma</b> creates a file mapping object of a specified size that is backed by the system paging file instead of by a file in the file system.</para>
    </param>
    <param name="lpFileMappingAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure that determines whether a returned handle can be inherited by child processes. The<b>lpSecurityDescriptor</b> member of the<br /><b>SECURITY_ATTRIBUTES</b> structure specifies a security descriptor for a new file mapping object.</para>
      <para>If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle cannot be inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token of the creator. For more information, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para>
    </param>
    <param name="flProtect">
      <para>Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with this protection.</para>
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x20</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x40</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, read/write or execute access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and<b>GENERIC_EXECUTE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_EXECUTE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x80</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent to <b>PAGE_EXECUTE_READ</b>.<para>The file handle that the <i>hFile</i>parameter specifies must be created with the <b>GENERIC_READ</b> and<b>GENERIC_EXECUTE</b> access rights.</para><para><b>Windows Vista:  </b>This value is not available until Windows Vista with SP1.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x02</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific region results in an access violation.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x04</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only, copy-on-write, or read/write access.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access rights.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PAGE_WRITECOPY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x08</term>
              </listheader>
            </list>
          </description>
          <description>Allows views to be mapped for read-only or copy-on-write access. This value is equivalent to <b>PAGE_READONLY</b>.<para>The file handle that the <i>hFile</i> parameter specifies must be created with the<b>GENERIC_READ</b> access right.</para></description>
        </listheader>
      </list> <para>An application can specify one or more of the following attributes for the file mapping object by combining them with one of the preceding page protection values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_COMMIT</b></term></listheader><listheader><term>0x8000000</term></listheader></list></description><description>Allocates physical storage in memory or the paging file for all pages. <para>This is the default setting.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE</b></term></listheader><listheader><term>0x1000000</term></listheader></list></description><description>Sets the file that is specified to be an executable image file.<para>The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as<b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the executable image file. Page protection for views of an executable image file is determined by the executable file itself.</para><para>No other attributes are valid with <b>SEC_IMAGE</b>.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_IMAGE_NO_EXECUTE</b></term></listheader><listheader><term>0x11000000</term></listheader></list></description><description>Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file that will not be executed and the loaded image file will have no forced integrity checks run. Additionally, mapping a view of a file mapping object created with the <b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using the <a href="https://docs.microsoft.com//windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-pssetloadimagenotifyroutine">PsSetLoadImageNotifyRoutine</a> kernel API.<para>The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the<b>PAGE_READONLY</b> page protection value. No other attributes are valid with<b>SEC_IMAGE_NO_EXECUTE</b>.</para><para><b>Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista:  </b>This value is not supported before Windows Server 2012 and Windows 8.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_LARGE_PAGES</b></term></listheader><listheader><term>0x80000000</term></listheader></list></description><description>Enables large pages to be used when mapping images or backing from the pagefile, but not when mapping data for regular files. Be sure to specify the maximum size of the file mapping object as the minimum size of a large page reported by the <see cref="GetLargePageMinimum" /> function and to enable the <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a> privilege.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_NOCACHE</b></term></listheader><listheader><term>0x10000000</term></listheader></list></description><description>Sets all pages to noncachable.<para>Applications should not use this flag except when explicitly required for a device. Using the interlocked functions with memory mapped with <b>SEC_NOCACHE</b>can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_NOCACHE</b> requires either <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> to be set.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_RESERVE</b></term></listheader><listheader><term>0x4000000</term></listheader></list></description><description>Reserves all pages without allocating physical storage.<para>The reserved range of pages cannot be used by any other allocation operations until the range of pages is released.</para><para>Reserved pages can be identified in subsequent calls to the<see cref="VirtualAllocExNuma" /> function. This attribute is valid only if the <i>hFile</i> parameter is <b>INVALID_HANDLE_VALUE</b>(that is, a file mapping object that is backed by the system paging file).</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SEC_WRITECOMBINE</b></term></listheader><listheader><term>0x40000000</term></listheader></list></description><description>Sets all pages to be write-combined.<para>Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with<b>SEC_WRITECOMBINE</b> can result in an<b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.</para><para><b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or<b>SEC_COMMIT</b> attribute to be set.</para></description></listheader></list></param>
    <param name="dwMaximumSizeHigh">The high-order <b>DWORD</b> of the maximum size of the file mapping object.</param>
    <param name="dwMaximumSizeLow">
      <para>The low-order <b>DWORD</b> of the maximum size of the file mapping object.</para>
      <para>If this parameter and the <i>dwMaximumSizeHigh</i> parameter are 0 (zero), the maximum size of the file mapping object is equal to the current size of the file that the<i>hFile</i> parameter identifies.</para>
      <para>An attempt to map a file with a length of 0 (zero) fails with an error code of<b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and reject those files.</para>
    </param>
    <param name="lpName">
      <para>The name of the file mapping object.</para>
      <para>If this parameter matches the name of an existing file mapping object, the function requests access to the object with the protection that the <i>flProtect</i> parameter specifies.</para>
      <para>If this parameter is <b>NULL</b>, the file mapping object is created without a name.</para>
      <para>If the <i>lpName</i> parameter matches the name of an existing event, semaphore, mutex, waitable timer, or job object, the function fails and the<see cref="GetLastError" /> function returns<b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). Creating a file mapping object in the global namespace requires the<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/authorization-constants">SeCreateGlobalPrivilege</a>privilege. For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
      <para>Fast user switching is implemented by using Terminal Services sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so on. Kernel object names must follow the guidelines so that applications can support multiple users.</para>
    </param>
    <param name="nndPreferred">
      <para>The NUMA node where the physical memory should reside.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NUMA_NO_PREFERRED_NODE</b>
                </term>
              </listheader>
              <listheader>
                <term>0xffffffff</term>
              </listheader>
            </list>
          </description>
          <description>No NUMA node is preferred. This is the same as calling the <see cref="CreateFileMapping" /> function.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the file mapping object.</para>
      <para>If the object exists before the function call, the function returns a handle to the existing object (with its current size, not the specified size) and the <see cref="GetLastError" /> function returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call the <see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.CreateHardLink">
    <summary>
      <para>Establishes a hard link between an existing file and a new file. This function is only supported on the NTFS file system, and only for files, not directories.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateHardLinkTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the new file.</para>
      <para>This parameter may include the path but cannot specify the name of a directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpExistingFileName">
      <para>The name of the existing file.</para>
      <para>This parameter may include the path cannot specify the name of a directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpSecurityAttributes">Reserved; must be <b>NULL</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call <see cref="GetLastError" />.</para>
      <para>The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 links are created for a file, an error results.</para>
      <para>If you pass a name longer than MAX_PATH characters to the <i>lpFileName</i> or <i>lpExistingFileName</i> parameter of the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
    </returns>
  </member>
  <member name="Windows.CreateHardLinkA">
    <summary>
      <para>Establishes a hard link between an existing file and a new file. This function is only supported on the NTFS file system, and only for files, not directories.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateHardLinkTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the new file.</para>
      <para>This parameter may include the path but cannot specify the name of a directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpExistingFileName">
      <para>The name of the existing file.</para>
      <para>This parameter may include the path cannot specify the name of a directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpSecurityAttributes">Reserved; must be <b>NULL</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call <see cref="GetLastError" />.</para>
      <para>The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 links are created for a file, an error results.</para>
      <para>If you pass a name longer than MAX_PATH characters to the <i>lpFileName</i> or <i>lpExistingFileName</i> parameter of the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
    </returns>
  </member>
  <member name="Windows.CreateHardLinkW">
    <summary>
      <para>Establishes a hard link between an existing file and a new file. This function is only supported on the NTFS file system, and only for files, not directories.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateHardLinkTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the new file.</para>
      <para>This parameter may include the path but cannot specify the name of a directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpExistingFileName">
      <para>The name of the existing file.</para>
      <para>This parameter may include the path cannot specify the name of a directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpSecurityAttributes">Reserved; must be <b>NULL</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call <see cref="GetLastError" />.</para>
      <para>The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 links are created for a file, an error results.</para>
      <para>If you pass a name longer than MAX_PATH characters to the <i>lpFileName</i> or <i>lpExistingFileName</i> parameter of the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
    </returns>
  </member>
  <member name="Windows.CreateHardLink">
    <summary>
      <para>Establishes a hard link between an existing file and a new file. This function is only supported on the NTFS file system, and only for files, not directories.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateHardLinkTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the new file.</para>
      <para>This parameter may include the path but cannot specify the name of a directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpExistingFileName">
      <para>The name of the existing file.</para>
      <para>This parameter may include the path cannot specify the name of a directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpSecurityAttributes">Reserved; must be <b>NULL</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call <see cref="GetLastError" />.</para>
      <para>The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 links are created for a file, an error results.</para>
      <para>If you pass a name longer than MAX_PATH characters to the <i>lpFileName</i> or <i>lpExistingFileName</i> parameter of the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
    </returns>
  </member>
  <member name="Windows.CreateHardLinkA">
    <summary>
      <para>Establishes a hard link between an existing file and a new file. This function is only supported on the NTFS file system, and only for files, not directories.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateHardLinkTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the new file.</para>
      <para>This parameter may include the path but cannot specify the name of a directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpExistingFileName">
      <para>The name of the existing file.</para>
      <para>This parameter may include the path cannot specify the name of a directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpSecurityAttributes">Reserved; must be <b>NULL</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call <see cref="GetLastError" />.</para>
      <para>The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 links are created for a file, an error results.</para>
      <para>If you pass a name longer than MAX_PATH characters to the <i>lpFileName</i> or <i>lpExistingFileName</i> parameter of the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
    </returns>
  </member>
  <member name="Windows.CreateHardLinkW">
    <summary>
      <para>Establishes a hard link between an existing file and a new file. This function is only supported on the NTFS file system, and only for files, not directories.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateHardLinkTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the new file.</para>
      <para>This parameter may include the path but cannot specify the name of a directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpExistingFileName">
      <para>The name of the existing file.</para>
      <para>This parameter may include the path cannot specify the name of a directory.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpSecurityAttributes">Reserved; must be <b>NULL</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call <see cref="GetLastError" />.</para>
      <para>The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 links are created for a file, an error results.</para>
      <para>If you pass a name longer than MAX_PATH characters to the <i>lpFileName</i> or <i>lpExistingFileName</i> parameter of the ANSI version of this function or to the Unicode version of this function without prepending "\\?\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
    </returns>
  </member>
  <member name="Windows.CreateJobObject">
    <summary>Creates or opens a job object.</summary>
    <param name="lpJobAttributes">A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies the security descriptor for the job object and determines whether child processes can inherit the returned handle. If <i>lpJobAttributes</i> is <b>NULL</b>, the job object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a job object come from the primary or impersonation token of the creator.</param>
    <param name="lpName">
      <para>The name of the job. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case-sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the job is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the job object. The handle has the <b>JOB_OBJECT_ALL_ACCESS</b> access right. If the object existed before the function call, the function returns a handle to the existing job object and<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateJobObjectA">
    <summary>Creates or opens a job object.</summary>
    <param name="lpJobAttributes">A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies the security descriptor for the job object and determines whether child processes can inherit the returned handle. If <i>lpJobAttributes</i> is <b>NULL</b>, the job object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a job object come from the primary or impersonation token of the creator.</param>
    <param name="lpName">
      <para>The name of the job. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case-sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the job is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the job object. The handle has the <b>JOB_OBJECT_ALL_ACCESS</b> access right. If the object existed before the function call, the function returns a handle to the existing job object and<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateJobObjectW">
    <summary>Creates or opens a job object.</summary>
    <param name="lpJobAttributes">A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies the security descriptor for the job object and determines whether child processes can inherit the returned handle. If <i>lpJobAttributes</i> is <b>NULL</b>, the job object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a job object come from the primary or impersonation token of the creator.</param>
    <param name="lpName">
      <para>The name of the job. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case-sensitive.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the job is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, semaphore, mutex, waitable timer, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the job object. The handle has the <b>JOB_OBJECT_ALL_ACCESS</b> access right. If the object existed before the function call, the function returns a handle to the existing job object and<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is NULL. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateMailslot">
    <summary>Creates a mailslot with the specified name and returns a handle that a mailslot server can use to perform operations on the mailslot. The mailslot is local to the computer that creates it. An error occurs if a mailslot with the specified name already exists.</summary>
    <param name="lpName">
      <para>The name of the mailslot. This name must have the following form:</para>
      <para>\\.\mailslot\[<i>path</i>]<i>name</i></para>
      <para>The name field must be unique. The name may include multiple levels of pseudo directories separated by backslashes. For example, both \\.\mailslot\example_mailslot_name and \\.\mailslot\abc\def\ghi are valid names.</para>
    </param>
    <param name="nMaxMessageSize">The maximum size of a single message that can be written to the mailslot, in bytes. To specify that the message can be of any size, set this value to zero.</param>
    <param name="lReadTimeout">
      <para>The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in milliseconds. The following values have special meanings.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>Returns immediately if no message is present. (The system does not treat an immediate return as an error.)</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MAILSLOT_WAIT_FOREVER</b>
                </term>
              </listheader>
              <listheader>
                <term>((DWORD)-1)</term>
              </listheader>
            </list>
          </description>
          <description>Waits forever for a message.</description>
        </listheader>
      </list> <para>This time-out value applies to all subsequent read operations and all inherited mailslot handles.</para></param>
    <param name="lpSecurityAttributes">A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. The <b>bInheritHandle</b> member of the structure determines whether the returned handle can be inherited by child processes. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the mailslot, for use in server mailslot operations. The handle returned by this function is asynchronous, or overlapped.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateMailslotA">
    <summary>Creates a mailslot with the specified name and returns a handle that a mailslot server can use to perform operations on the mailslot. The mailslot is local to the computer that creates it. An error occurs if a mailslot with the specified name already exists.</summary>
    <param name="lpName">
      <para>The name of the mailslot. This name must have the following form:</para>
      <para>\\.\mailslot\[<i>path</i>]<i>name</i></para>
      <para>The name field must be unique. The name may include multiple levels of pseudo directories separated by backslashes. For example, both \\.\mailslot\example_mailslot_name and \\.\mailslot\abc\def\ghi are valid names.</para>
    </param>
    <param name="nMaxMessageSize">The maximum size of a single message that can be written to the mailslot, in bytes. To specify that the message can be of any size, set this value to zero.</param>
    <param name="lReadTimeout">
      <para>The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in milliseconds. The following values have special meanings.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>Returns immediately if no message is present. (The system does not treat an immediate return as an error.)</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MAILSLOT_WAIT_FOREVER</b>
                </term>
              </listheader>
              <listheader>
                <term>((DWORD)-1)</term>
              </listheader>
            </list>
          </description>
          <description>Waits forever for a message.</description>
        </listheader>
      </list> <para>This time-out value applies to all subsequent read operations and all inherited mailslot handles.</para></param>
    <param name="lpSecurityAttributes">A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. The <b>bInheritHandle</b> member of the structure determines whether the returned handle can be inherited by child processes. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the mailslot, for use in server mailslot operations. The handle returned by this function is asynchronous, or overlapped.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateMailslotW">
    <summary>Creates a mailslot with the specified name and returns a handle that a mailslot server can use to perform operations on the mailslot. The mailslot is local to the computer that creates it. An error occurs if a mailslot with the specified name already exists.</summary>
    <param name="lpName">
      <para>The name of the mailslot. This name must have the following form:</para>
      <para>\\.\mailslot\[<i>path</i>]<i>name</i></para>
      <para>The name field must be unique. The name may include multiple levels of pseudo directories separated by backslashes. For example, both \\.\mailslot\example_mailslot_name and \\.\mailslot\abc\def\ghi are valid names.</para>
    </param>
    <param name="nMaxMessageSize">The maximum size of a single message that can be written to the mailslot, in bytes. To specify that the message can be of any size, set this value to zero.</param>
    <param name="lReadTimeout">
      <para>The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in milliseconds. The following values have special meanings.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>Returns immediately if no message is present. (The system does not treat an immediate return as an error.)</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MAILSLOT_WAIT_FOREVER</b>
                </term>
              </listheader>
              <listheader>
                <term>((DWORD)-1)</term>
              </listheader>
            </list>
          </description>
          <description>Waits forever for a message.</description>
        </listheader>
      </list> <para>This time-out value applies to all subsequent read operations and all inherited mailslot handles.</para></param>
    <param name="lpSecurityAttributes">A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. The <b>bInheritHandle</b> member of the structure determines whether the returned handle can be inherited by child processes. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the mailslot, for use in server mailslot operations. The handle returned by this function is asynchronous, or overlapped.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateMailslot">
    <summary>Creates a mailslot with the specified name and returns a handle that a mailslot server can use to perform operations on the mailslot. The mailslot is local to the computer that creates it. An error occurs if a mailslot with the specified name already exists.</summary>
    <param name="lpName">
      <para>The name of the mailslot. This name must have the following form:</para>
      <para>\\.\mailslot\[<i>path</i>]<i>name</i></para>
      <para>The name field must be unique. The name may include multiple levels of pseudo directories separated by backslashes. For example, both \\.\mailslot\example_mailslot_name and \\.\mailslot\abc\def\ghi are valid names.</para>
    </param>
    <param name="nMaxMessageSize">The maximum size of a single message that can be written to the mailslot, in bytes. To specify that the message can be of any size, set this value to zero.</param>
    <param name="lReadTimeout">
      <para>The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in milliseconds. The following values have special meanings.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>Returns immediately if no message is present. (The system does not treat an immediate return as an error.)</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MAILSLOT_WAIT_FOREVER</b>
                </term>
              </listheader>
              <listheader>
                <term>((DWORD)-1)</term>
              </listheader>
            </list>
          </description>
          <description>Waits forever for a message.</description>
        </listheader>
      </list> <para>This time-out value applies to all subsequent read operations and all inherited mailslot handles.</para></param>
    <param name="lpSecurityAttributes">A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. The <b>bInheritHandle</b> member of the structure determines whether the returned handle can be inherited by child processes. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the mailslot, for use in server mailslot operations. The handle returned by this function is asynchronous, or overlapped.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateMailslotA">
    <summary>Creates a mailslot with the specified name and returns a handle that a mailslot server can use to perform operations on the mailslot. The mailslot is local to the computer that creates it. An error occurs if a mailslot with the specified name already exists.</summary>
    <param name="lpName">
      <para>The name of the mailslot. This name must have the following form:</para>
      <para>\\.\mailslot\[<i>path</i>]<i>name</i></para>
      <para>The name field must be unique. The name may include multiple levels of pseudo directories separated by backslashes. For example, both \\.\mailslot\example_mailslot_name and \\.\mailslot\abc\def\ghi are valid names.</para>
    </param>
    <param name="nMaxMessageSize">The maximum size of a single message that can be written to the mailslot, in bytes. To specify that the message can be of any size, set this value to zero.</param>
    <param name="lReadTimeout">
      <para>The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in milliseconds. The following values have special meanings.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>Returns immediately if no message is present. (The system does not treat an immediate return as an error.)</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MAILSLOT_WAIT_FOREVER</b>
                </term>
              </listheader>
              <listheader>
                <term>((DWORD)-1)</term>
              </listheader>
            </list>
          </description>
          <description>Waits forever for a message.</description>
        </listheader>
      </list> <para>This time-out value applies to all subsequent read operations and all inherited mailslot handles.</para></param>
    <param name="lpSecurityAttributes">A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. The <b>bInheritHandle</b> member of the structure determines whether the returned handle can be inherited by child processes. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the mailslot, for use in server mailslot operations. The handle returned by this function is asynchronous, or overlapped.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateMailslotW">
    <summary>Creates a mailslot with the specified name and returns a handle that a mailslot server can use to perform operations on the mailslot. The mailslot is local to the computer that creates it. An error occurs if a mailslot with the specified name already exists.</summary>
    <param name="lpName">
      <para>The name of the mailslot. This name must have the following form:</para>
      <para>\\.\mailslot\[<i>path</i>]<i>name</i></para>
      <para>The name field must be unique. The name may include multiple levels of pseudo directories separated by backslashes. For example, both \\.\mailslot\example_mailslot_name and \\.\mailslot\abc\def\ghi are valid names.</para>
    </param>
    <param name="nMaxMessageSize">The maximum size of a single message that can be written to the mailslot, in bytes. To specify that the message can be of any size, set this value to zero.</param>
    <param name="lReadTimeout">
      <para>The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in milliseconds. The following values have special meanings.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>Returns immediately if no message is present. (The system does not treat an immediate return as an error.)</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MAILSLOT_WAIT_FOREVER</b>
                </term>
              </listheader>
              <listheader>
                <term>((DWORD)-1)</term>
              </listheader>
            </list>
          </description>
          <description>Waits forever for a message.</description>
        </listheader>
      </list> <para>This time-out value applies to all subsequent read operations and all inherited mailslot handles.</para></param>
    <param name="lpSecurityAttributes">A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. The <b>bInheritHandle</b> member of the structure determines whether the returned handle can be inherited by child processes. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the handle cannot be inherited.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the mailslot, for use in server mailslot operations. The handle returned by this function is asynchronous, or overlapped.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateNamedPipe">
    <summary>Creates an instance of a named pipe and returns a handle for subsequent pipe operations. A named pipe server process uses this function either to create the first instance of a specific named pipe and establish its basic attributes or to create a new instance of an existing named pipe.</summary>
    <param name="lpName">
      <para>The unique pipe name. This string must have the following form:</para>
      <para>\\.\pipe\<i>pipename</i></para>
      <para>The pipename part of the name can include any character other than a backslash, including numbers and special characters. The entire pipe name string can be up to 256 characters long. Pipe names are not case sensitive.</para>
    </param>
    <param name="dwOpenMode">
      <para>The open mode.</para>
      <para>The function fails if <i>dwOpenMode</i> specifies anything other than 0 or the flags listed in the following tables.</para>
      <para>This parameter must specify one of the following pipe access modes. The same mode must be specified for each instance of the pipe.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_ACCESS_DUPLEX</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000003</term>
              </listheader>
            </list>
          </description>
          <description>The pipe is bi-directional; both server and client processes can read from and write to the pipe. This mode gives the server the equivalent of <b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access to the pipe. The client can specify <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b>, or both, when it connects to the pipe using the <see cref="CreateFile" /> function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_ACCESS_INBOUND</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The flow of data in the pipe goes from client to server only. This mode gives the server the equivalent of <b>GENERIC_READ</b> access to the pipe. The client must specify <b>GENERIC_WRITE</b> access when connecting to the pipe. If the client must read pipe settings by calling the <see cref="GetNamedPipeInfo" /> or <see cref="GetNamedPipeHandleState" /> functions, the client must specify <b>GENERIC_WRITE</b> and <b>FILE_READ_ATTRIBUTES</b> access when connecting to the pipe.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_ACCESS_OUTBOUND</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The flow of data in the pipe goes from server to client only. This mode gives the server the equivalent of <b>GENERIC_WRITE</b> access to the pipe. The client must specify <b>GENERIC_READ</b> access when connecting to the pipe. If the client must change pipe settings by calling the <see cref="SetNamedPipeHandleState" /> function, the client must specify <b>GENERIC_READ</b> and <b>FILE_WRITE_ATTRIBUTES</b> access when connecting to the pipe.</description>
        </listheader>
      </list> <para>This parameter can also include one or more of the following flags, which enable the write-through and overlapped modes. These modes can be different for different instances of the same pipe.</para><list type="table"><listheader><description>Mode</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_FIRST_PIPE_INSTANCE</b></term></listheader><listheader><term>0x00080000</term></listheader></list></description><description>If you attempt to create multiple instances of a pipe with this flag, creation of the first instance succeeds, but creation of the next instance fails with <b>ERROR_ACCESS_DENIED</b>.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_WRITE_THROUGH</b></term></listheader><listheader><term>0x80000000</term></listheader></list></description><description>Write-through mode is enabled. This mode affects only write operations on byte-type pipes and, then, only when the client and server processes are on different computers. If this mode is enabled, functions writing to a named pipe do not return until the data written is transmitted across the network and is in the pipe's buffer on the remote computer. If this mode is not enabled, the system enhances the efficiency of network operations by buffering data until a minimum number of bytes accumulate or until a maximum time elapses.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_OVERLAPPED</b></term></listheader><listheader><term>0x40000000</term></listheader></list></description><description>Overlapped mode is enabled. If this mode is enabled, functions performing read, write, and connect operations that may take a significant time to be completed can return immediately. This mode enables the thread that started the operation to perform other operations while the time-consuming operation executes in the background. For example, in overlapped mode, a thread can handle simultaneous input and output (I/O) operations on multiple instances of a pipe or perform simultaneous read and write operations on the same pipe handle. If overlapped mode is not enabled, functions performing read, write, and connect operations on the pipe handle do not return until the operation is finished. The <see cref="ReadFileEx" /> and <see cref="WriteFileEx" /> functions can only be used with a pipe handle in overlapped mode. The <see cref="ReadFile" />, <see cref="WriteFile" />, <see cref="ConnectNamedPipe" />, and <see cref="TransactNamedPipe" /> functions can execute either synchronously or as overlapped operations.</description></listheader></list> <para>This parameter can include any combination of the following security access modes. These modes can be different for different instances of the same pipe.</para><list type="table"><listheader><description>Mode</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>WRITE_DAC</b></term></listheader><listheader><term>0x00040000L</term></listheader></list></description><description>The caller will have write access to the named pipe's discretionary access control list (ACL).</description></listheader><listheader><description><list type="bullet"><listheader><term><b>WRITE_OWNER</b></term></listheader><listheader><term>0x00080000L</term></listheader></list></description><description>The caller will have write access to the named pipe's owner.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>ACCESS_SYSTEM_SECURITY</b></term></listheader><listheader><term>0x01000000L</term></listheader></list></description><description>The caller will have write access to the named pipe's SACL. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control-lists">Access-Control Lists (ACLs)</a> and <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/sacl-access-right">SACL Access Right</a>.</description></listheader></list></param>
    <param name="dwPipeMode">
      <para>The pipe mode.</para>
      <para>The function fails if <i>dwPipeMode</i> specifies anything other than 0 or the flags listed in the following tables.</para>
      <para>One of the following type modes can be specified. The same type mode must be specified for each instance of the pipe.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_TYPE_BYTE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000000</term>
              </listheader>
            </list>
          </description>
          <description>Data is written to the pipe as a stream of bytes. This mode cannot be used with PIPE_READMODE_MESSAGE. The pipe does not distinguish bytes written during different write operations.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_TYPE_MESSAGE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>Data is written to the pipe as a stream of messages. The pipe treats the bytes written during each write operation as a message unit. The <see cref="GetLastError" /> function returns <b>ERROR_MORE_DATA</b> when a message is not read completely. This mode can be used with either <b>PIPE_READMODE_MESSAGE</b> or <b>PIPE_READMODE_BYTE</b>.</description>
        </listheader>
      </list> <para>One of the following read modes can be specified. Different instances of the same pipe can specify different read modes.</para><list type="table"><listheader><description>Mode</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>PIPE_READMODE_BYTE</b></term></listheader><listheader><term>0x00000000</term></listheader></list></description><description>Data is read from the pipe as a stream of bytes. This mode can be used with either <b>PIPE_TYPE_MESSAGE</b> or <b>PIPE_TYPE_BYTE</b>.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>PIPE_READMODE_MESSAGE</b></term></listheader><listheader><term>0x00000002</term></listheader></list></description><description>Data is read from the pipe as a stream of messages. This mode can be only used if <b>PIPE_TYPE_MESSAGE</b> is also specified.</description></listheader></list> <para>One of the following wait modes can be specified. Different instances of the same pipe can specify different wait modes.</para><list type="table"><listheader><description>Mode</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>PIPE_WAIT</b></term></listheader><listheader><term>0x00000000</term></listheader></list></description><description>Blocking mode is enabled. When the pipe handle is specified in the <see cref="ReadFile" />, <see cref="WriteFile" />, or <see cref="ConnectNamedPipe" /> function, the operations are not completed until there is data to read, all data is written, or a client is connected. Use of this mode can mean waiting indefinitely in some situations for a client process to perform an action.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>PIPE_NOWAIT</b></term></listheader><listheader><term>0x00000001</term></listheader></list></description><description>Nonblocking mode is enabled. In this mode, <see cref="ReadFile" />, <see cref="WriteFile" />, and <see cref="ConnectNamedPipe" /> always return immediately.<para>Note that nonblocking mode is supported for compatibility with Microsoft LAN Manager version 2.0 and should not be used to achieve asynchronous I/O with named pipes. For more information on asynchronous pipe I/O, see<a href="https://docs.microsoft.com//windows/desktop/ipc/synchronous-and-overlapped-input-and-output">Synchronous and Overlapped Input and Output</a>.</para></description></listheader></list> <para>One of the following remote-client modes can be specified. Different instances of the same pipe can specify different remote-client modes.</para><list type="table"><listheader><description>Mode</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>PIPE_ACCEPT_REMOTE_CLIENTS</b></term></listheader><listheader><term>0x00000000</term></listheader></list></description><description>Connections from remote clients can be accepted and checked against the security descriptor for the pipe.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>PIPE_REJECT_REMOTE_CLIENTS</b></term></listheader><listheader><term>0x00000008</term></listheader></list></description><description>Connections from remote clients are automatically rejected.</description></listheader></list></param>
    <param name="nMaxInstances">
      <para>The maximum number of instances that can be created for this pipe. The first instance of the pipe can specify this value; the same number must be specified for other instances of the pipe. Acceptable values are in the range 1 through <b>PIPE_UNLIMITED_INSTANCES</b> (255).</para>
      <para>If this parameter is <b>PIPE_UNLIMITED_INSTANCES</b>, the number of pipe instances that can be created is limited only by the availability of system resources. If <i>nMaxInstances</i> is greater than <b>PIPE_UNLIMITED_INSTANCES</b>, the return value is <b>INVALID_HANDLE_VALUE</b> and <see cref="GetLastError" /> returns <b>ERROR_INVALID_PARAMETER</b>.</para>
    </param>
    <param name="nOutBufferSize">The number of bytes to reserve for the output buffer. For a discussion on sizing named pipe buffers, see the following Remarks section.</param>
    <param name="nInBufferSize">The number of bytes to reserve for the input buffer. For a discussion on sizing named pipe buffers, see the following Remarks section.</param>
    <param name="nDefaultTimeOut">
      <para>The default time-out value, in milliseconds, if the<see cref="WaitNamedPipe" /> function specifies <b>NMPWAIT_USE_DEFAULT_WAIT</b>. Each instance of a named pipe must specify the same value.</para>
      <para>A value of zero will result in a default time-out of 50 milliseconds.</para>
    </param>
    <param name="lpSecurityAttributes">A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new named pipe and determines whether child processes can inherit the returned handle. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the named pipe gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a named pipe grant full control to the LocalSystem account, administrators, and the creator owner. They also grant read access to members of the Everyone group and the anonymous account.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the server end of a named pipe instance.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateNamedPipeA">
    <summary>Creates an instance of a named pipe and returns a handle for subsequent pipe operations. A named pipe server process uses this function either to create the first instance of a specific named pipe and establish its basic attributes or to create a new instance of an existing named pipe.</summary>
    <param name="lpName">
      <para>The unique pipe name. This string must have the following form:</para>
      <para>\\.\pipe\<i>pipename</i></para>
      <para>The pipename part of the name can include any character other than a backslash, including numbers and special characters. The entire pipe name string can be up to 256 characters long. Pipe names are not case sensitive.</para>
    </param>
    <param name="dwOpenMode">
      <para>The open mode.</para>
      <para>The function fails if <i>dwOpenMode</i> specifies anything other than 0 or the flags listed in the following tables.</para>
      <para>This parameter must specify one of the following pipe access modes. The same mode must be specified for each instance of the pipe.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_ACCESS_DUPLEX</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000003</term>
              </listheader>
            </list>
          </description>
          <description>The pipe is bi-directional; both server and client processes can read from and write to the pipe. This mode gives the server the equivalent of <b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access to the pipe. The client can specify <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b>, or both, when it connects to the pipe using the <see cref="CreateFile" /> function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_ACCESS_INBOUND</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The flow of data in the pipe goes from client to server only. This mode gives the server the equivalent of <b>GENERIC_READ</b> access to the pipe. The client must specify <b>GENERIC_WRITE</b> access when connecting to the pipe. If the client must read pipe settings by calling the <see cref="GetNamedPipeInfo" /> or <see cref="GetNamedPipeHandleState" /> functions, the client must specify <b>GENERIC_WRITE</b> and <b>FILE_READ_ATTRIBUTES</b> access when connecting to the pipe.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_ACCESS_OUTBOUND</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The flow of data in the pipe goes from server to client only. This mode gives the server the equivalent of <b>GENERIC_WRITE</b> access to the pipe. The client must specify <b>GENERIC_READ</b> access when connecting to the pipe. If the client must change pipe settings by calling the <see cref="SetNamedPipeHandleState" /> function, the client must specify <b>GENERIC_READ</b> and <b>FILE_WRITE_ATTRIBUTES</b> access when connecting to the pipe.</description>
        </listheader>
      </list> <para>This parameter can also include one or more of the following flags, which enable the write-through and overlapped modes. These modes can be different for different instances of the same pipe.</para><list type="table"><listheader><description>Mode</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_FIRST_PIPE_INSTANCE</b></term></listheader><listheader><term>0x00080000</term></listheader></list></description><description>If you attempt to create multiple instances of a pipe with this flag, creation of the first instance succeeds, but creation of the next instance fails with <b>ERROR_ACCESS_DENIED</b>.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_WRITE_THROUGH</b></term></listheader><listheader><term>0x80000000</term></listheader></list></description><description>Write-through mode is enabled. This mode affects only write operations on byte-type pipes and, then, only when the client and server processes are on different computers. If this mode is enabled, functions writing to a named pipe do not return until the data written is transmitted across the network and is in the pipe's buffer on the remote computer. If this mode is not enabled, the system enhances the efficiency of network operations by buffering data until a minimum number of bytes accumulate or until a maximum time elapses.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_OVERLAPPED</b></term></listheader><listheader><term>0x40000000</term></listheader></list></description><description>Overlapped mode is enabled. If this mode is enabled, functions performing read, write, and connect operations that may take a significant time to be completed can return immediately. This mode enables the thread that started the operation to perform other operations while the time-consuming operation executes in the background. For example, in overlapped mode, a thread can handle simultaneous input and output (I/O) operations on multiple instances of a pipe or perform simultaneous read and write operations on the same pipe handle. If overlapped mode is not enabled, functions performing read, write, and connect operations on the pipe handle do not return until the operation is finished. The <see cref="ReadFileEx" /> and <see cref="WriteFileEx" /> functions can only be used with a pipe handle in overlapped mode. The <see cref="ReadFile" />, <see cref="WriteFile" />, <see cref="ConnectNamedPipe" />, and <see cref="TransactNamedPipe" /> functions can execute either synchronously or as overlapped operations.</description></listheader></list> <para>This parameter can include any combination of the following security access modes. These modes can be different for different instances of the same pipe.</para><list type="table"><listheader><description>Mode</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>WRITE_DAC</b></term></listheader><listheader><term>0x00040000L</term></listheader></list></description><description>The caller will have write access to the named pipe's discretionary access control list (ACL).</description></listheader><listheader><description><list type="bullet"><listheader><term><b>WRITE_OWNER</b></term></listheader><listheader><term>0x00080000L</term></listheader></list></description><description>The caller will have write access to the named pipe's owner.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>ACCESS_SYSTEM_SECURITY</b></term></listheader><listheader><term>0x01000000L</term></listheader></list></description><description>The caller will have write access to the named pipe's SACL. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control-lists">Access-Control Lists (ACLs)</a> and <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/sacl-access-right">SACL Access Right</a>.</description></listheader></list></param>
    <param name="dwPipeMode">
      <para>The pipe mode.</para>
      <para>The function fails if <i>dwPipeMode</i> specifies anything other than 0 or the flags listed in the following tables.</para>
      <para>One of the following type modes can be specified. The same type mode must be specified for each instance of the pipe.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_TYPE_BYTE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000000</term>
              </listheader>
            </list>
          </description>
          <description>Data is written to the pipe as a stream of bytes. This mode cannot be used with PIPE_READMODE_MESSAGE. The pipe does not distinguish bytes written during different write operations.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_TYPE_MESSAGE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>Data is written to the pipe as a stream of messages. The pipe treats the bytes written during each write operation as a message unit. The <see cref="GetLastError" /> function returns <b>ERROR_MORE_DATA</b> when a message is not read completely. This mode can be used with either <b>PIPE_READMODE_MESSAGE</b> or <b>PIPE_READMODE_BYTE</b>.</description>
        </listheader>
      </list> <para>One of the following read modes can be specified. Different instances of the same pipe can specify different read modes.</para><list type="table"><listheader><description>Mode</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>PIPE_READMODE_BYTE</b></term></listheader><listheader><term>0x00000000</term></listheader></list></description><description>Data is read from the pipe as a stream of bytes. This mode can be used with either <b>PIPE_TYPE_MESSAGE</b> or <b>PIPE_TYPE_BYTE</b>.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>PIPE_READMODE_MESSAGE</b></term></listheader><listheader><term>0x00000002</term></listheader></list></description><description>Data is read from the pipe as a stream of messages. This mode can be only used if <b>PIPE_TYPE_MESSAGE</b> is also specified.</description></listheader></list> <para>One of the following wait modes can be specified. Different instances of the same pipe can specify different wait modes.</para><list type="table"><listheader><description>Mode</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>PIPE_WAIT</b></term></listheader><listheader><term>0x00000000</term></listheader></list></description><description>Blocking mode is enabled. When the pipe handle is specified in the <see cref="ReadFile" />, <see cref="WriteFile" />, or <see cref="ConnectNamedPipe" /> function, the operations are not completed until there is data to read, all data is written, or a client is connected. Use of this mode can mean waiting indefinitely in some situations for a client process to perform an action.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>PIPE_NOWAIT</b></term></listheader><listheader><term>0x00000001</term></listheader></list></description><description>Nonblocking mode is enabled. In this mode, <see cref="ReadFile" />, <see cref="WriteFile" />, and <see cref="ConnectNamedPipe" /> always return immediately.<para>Note that nonblocking mode is supported for compatibility with Microsoft LAN Manager version 2.0 and should not be used to achieve asynchronous I/O with named pipes. For more information on asynchronous pipe I/O, see<a href="https://docs.microsoft.com//windows/desktop/ipc/synchronous-and-overlapped-input-and-output">Synchronous and Overlapped Input and Output</a>.</para></description></listheader></list> <para>One of the following remote-client modes can be specified. Different instances of the same pipe can specify different remote-client modes.</para><list type="table"><listheader><description>Mode</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>PIPE_ACCEPT_REMOTE_CLIENTS</b></term></listheader><listheader><term>0x00000000</term></listheader></list></description><description>Connections from remote clients can be accepted and checked against the security descriptor for the pipe.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>PIPE_REJECT_REMOTE_CLIENTS</b></term></listheader><listheader><term>0x00000008</term></listheader></list></description><description>Connections from remote clients are automatically rejected.</description></listheader></list></param>
    <param name="nMaxInstances">
      <para>The maximum number of instances that can be created for this pipe. The first instance of the pipe can specify this value; the same number must be specified for other instances of the pipe. Acceptable values are in the range 1 through <b>PIPE_UNLIMITED_INSTANCES</b> (255).</para>
      <para>If this parameter is <b>PIPE_UNLIMITED_INSTANCES</b>, the number of pipe instances that can be created is limited only by the availability of system resources. If <i>nMaxInstances</i> is greater than <b>PIPE_UNLIMITED_INSTANCES</b>, the return value is <b>INVALID_HANDLE_VALUE</b> and <see cref="GetLastError" /> returns <b>ERROR_INVALID_PARAMETER</b>.</para>
    </param>
    <param name="nOutBufferSize">The number of bytes to reserve for the output buffer. For a discussion on sizing named pipe buffers, see the following Remarks section.</param>
    <param name="nInBufferSize">The number of bytes to reserve for the input buffer. For a discussion on sizing named pipe buffers, see the following Remarks section.</param>
    <param name="nDefaultTimeOut">
      <para>The default time-out value, in milliseconds, if the<see cref="WaitNamedPipe" /> function specifies <b>NMPWAIT_USE_DEFAULT_WAIT</b>. Each instance of a named pipe must specify the same value.</para>
      <para>A value of zero will result in a default time-out of 50 milliseconds.</para>
    </param>
    <param name="lpSecurityAttributes">A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new named pipe and determines whether child processes can inherit the returned handle. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the named pipe gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a named pipe grant full control to the LocalSystem account, administrators, and the creator owner. They also grant read access to members of the Everyone group and the anonymous account.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the server end of a named pipe instance.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateNamedPipeW">
    <summary>Creates an instance of a named pipe and returns a handle for subsequent pipe operations. A named pipe server process uses this function either to create the first instance of a specific named pipe and establish its basic attributes or to create a new instance of an existing named pipe.</summary>
    <param name="lpName">
      <para>The unique pipe name. This string must have the following form:</para>
      <para>\\.\pipe\<i>pipename</i></para>
      <para>The pipename part of the name can include any character other than a backslash, including numbers and special characters. The entire pipe name string can be up to 256 characters long. Pipe names are not case sensitive.</para>
    </param>
    <param name="dwOpenMode">
      <para>The open mode.</para>
      <para>The function fails if <i>dwOpenMode</i> specifies anything other than 0 or the flags listed in the following tables.</para>
      <para>This parameter must specify one of the following pipe access modes. The same mode must be specified for each instance of the pipe.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_ACCESS_DUPLEX</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000003</term>
              </listheader>
            </list>
          </description>
          <description>The pipe is bi-directional; both server and client processes can read from and write to the pipe. This mode gives the server the equivalent of <b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access to the pipe. The client can specify <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b>, or both, when it connects to the pipe using the <see cref="CreateFile" /> function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_ACCESS_INBOUND</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The flow of data in the pipe goes from client to server only. This mode gives the server the equivalent of <b>GENERIC_READ</b> access to the pipe. The client must specify <b>GENERIC_WRITE</b> access when connecting to the pipe. If the client must read pipe settings by calling the <see cref="GetNamedPipeInfo" /> or <see cref="GetNamedPipeHandleState" /> functions, the client must specify <b>GENERIC_WRITE</b> and <b>FILE_READ_ATTRIBUTES</b> access when connecting to the pipe.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_ACCESS_OUTBOUND</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The flow of data in the pipe goes from server to client only. This mode gives the server the equivalent of <b>GENERIC_WRITE</b> access to the pipe. The client must specify <b>GENERIC_READ</b> access when connecting to the pipe. If the client must change pipe settings by calling the <see cref="SetNamedPipeHandleState" /> function, the client must specify <b>GENERIC_READ</b> and <b>FILE_WRITE_ATTRIBUTES</b> access when connecting to the pipe.</description>
        </listheader>
      </list> <para>This parameter can also include one or more of the following flags, which enable the write-through and overlapped modes. These modes can be different for different instances of the same pipe.</para><list type="table"><listheader><description>Mode</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_FIRST_PIPE_INSTANCE</b></term></listheader><listheader><term>0x00080000</term></listheader></list></description><description>If you attempt to create multiple instances of a pipe with this flag, creation of the first instance succeeds, but creation of the next instance fails with <b>ERROR_ACCESS_DENIED</b>.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_WRITE_THROUGH</b></term></listheader><listheader><term>0x80000000</term></listheader></list></description><description>Write-through mode is enabled. This mode affects only write operations on byte-type pipes and, then, only when the client and server processes are on different computers. If this mode is enabled, functions writing to a named pipe do not return until the data written is transmitted across the network and is in the pipe's buffer on the remote computer. If this mode is not enabled, the system enhances the efficiency of network operations by buffering data until a minimum number of bytes accumulate or until a maximum time elapses.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_FLAG_OVERLAPPED</b></term></listheader><listheader><term>0x40000000</term></listheader></list></description><description>Overlapped mode is enabled. If this mode is enabled, functions performing read, write, and connect operations that may take a significant time to be completed can return immediately. This mode enables the thread that started the operation to perform other operations while the time-consuming operation executes in the background. For example, in overlapped mode, a thread can handle simultaneous input and output (I/O) operations on multiple instances of a pipe or perform simultaneous read and write operations on the same pipe handle. If overlapped mode is not enabled, functions performing read, write, and connect operations on the pipe handle do not return until the operation is finished. The <see cref="ReadFileEx" /> and <see cref="WriteFileEx" /> functions can only be used with a pipe handle in overlapped mode. The <see cref="ReadFile" />, <see cref="WriteFile" />, <see cref="ConnectNamedPipe" />, and <see cref="TransactNamedPipe" /> functions can execute either synchronously or as overlapped operations.</description></listheader></list> <para>This parameter can include any combination of the following security access modes. These modes can be different for different instances of the same pipe.</para><list type="table"><listheader><description>Mode</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>WRITE_DAC</b></term></listheader><listheader><term>0x00040000L</term></listheader></list></description><description>The caller will have write access to the named pipe's discretionary access control list (ACL).</description></listheader><listheader><description><list type="bullet"><listheader><term><b>WRITE_OWNER</b></term></listheader><listheader><term>0x00080000L</term></listheader></list></description><description>The caller will have write access to the named pipe's owner.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>ACCESS_SYSTEM_SECURITY</b></term></listheader><listheader><term>0x01000000L</term></listheader></list></description><description>The caller will have write access to the named pipe's SACL. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control-lists">Access-Control Lists (ACLs)</a> and <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/sacl-access-right">SACL Access Right</a>.</description></listheader></list></param>
    <param name="dwPipeMode">
      <para>The pipe mode.</para>
      <para>The function fails if <i>dwPipeMode</i> specifies anything other than 0 or the flags listed in the following tables.</para>
      <para>One of the following type modes can be specified. The same type mode must be specified for each instance of the pipe.</para>
      <list type="table">
        <listheader>
          <description>Mode</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_TYPE_BYTE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000000</term>
              </listheader>
            </list>
          </description>
          <description>Data is written to the pipe as a stream of bytes. This mode cannot be used with PIPE_READMODE_MESSAGE. The pipe does not distinguish bytes written during different write operations.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_TYPE_MESSAGE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>Data is written to the pipe as a stream of messages. The pipe treats the bytes written during each write operation as a message unit. The <see cref="GetLastError" /> function returns <b>ERROR_MORE_DATA</b> when a message is not read completely. This mode can be used with either <b>PIPE_READMODE_MESSAGE</b> or <b>PIPE_READMODE_BYTE</b>.</description>
        </listheader>
      </list> <para>One of the following read modes can be specified. Different instances of the same pipe can specify different read modes.</para><list type="table"><listheader><description>Mode</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>PIPE_READMODE_BYTE</b></term></listheader><listheader><term>0x00000000</term></listheader></list></description><description>Data is read from the pipe as a stream of bytes. This mode can be used with either <b>PIPE_TYPE_MESSAGE</b> or <b>PIPE_TYPE_BYTE</b>.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>PIPE_READMODE_MESSAGE</b></term></listheader><listheader><term>0x00000002</term></listheader></list></description><description>Data is read from the pipe as a stream of messages. This mode can be only used if <b>PIPE_TYPE_MESSAGE</b> is also specified.</description></listheader></list> <para>One of the following wait modes can be specified. Different instances of the same pipe can specify different wait modes.</para><list type="table"><listheader><description>Mode</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>PIPE_WAIT</b></term></listheader><listheader><term>0x00000000</term></listheader></list></description><description>Blocking mode is enabled. When the pipe handle is specified in the <see cref="ReadFile" />, <see cref="WriteFile" />, or <see cref="ConnectNamedPipe" /> function, the operations are not completed until there is data to read, all data is written, or a client is connected. Use of this mode can mean waiting indefinitely in some situations for a client process to perform an action.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>PIPE_NOWAIT</b></term></listheader><listheader><term>0x00000001</term></listheader></list></description><description>Nonblocking mode is enabled. In this mode, <see cref="ReadFile" />, <see cref="WriteFile" />, and <see cref="ConnectNamedPipe" /> always return immediately.<para>Note that nonblocking mode is supported for compatibility with Microsoft LAN Manager version 2.0 and should not be used to achieve asynchronous I/O with named pipes. For more information on asynchronous pipe I/O, see<a href="https://docs.microsoft.com//windows/desktop/ipc/synchronous-and-overlapped-input-and-output">Synchronous and Overlapped Input and Output</a>.</para></description></listheader></list> <para>One of the following remote-client modes can be specified. Different instances of the same pipe can specify different remote-client modes.</para><list type="table"><listheader><description>Mode</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>PIPE_ACCEPT_REMOTE_CLIENTS</b></term></listheader><listheader><term>0x00000000</term></listheader></list></description><description>Connections from remote clients can be accepted and checked against the security descriptor for the pipe.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>PIPE_REJECT_REMOTE_CLIENTS</b></term></listheader><listheader><term>0x00000008</term></listheader></list></description><description>Connections from remote clients are automatically rejected.</description></listheader></list></param>
    <param name="nMaxInstances">
      <para>The maximum number of instances that can be created for this pipe. The first instance of the pipe can specify this value; the same number must be specified for other instances of the pipe. Acceptable values are in the range 1 through <b>PIPE_UNLIMITED_INSTANCES</b> (255).</para>
      <para>If this parameter is <b>PIPE_UNLIMITED_INSTANCES</b>, the number of pipe instances that can be created is limited only by the availability of system resources. If <i>nMaxInstances</i> is greater than <b>PIPE_UNLIMITED_INSTANCES</b>, the return value is <b>INVALID_HANDLE_VALUE</b> and <see cref="GetLastError" /> returns <b>ERROR_INVALID_PARAMETER</b>.</para>
    </param>
    <param name="nOutBufferSize">The number of bytes to reserve for the output buffer. For a discussion on sizing named pipe buffers, see the following Remarks section.</param>
    <param name="nInBufferSize">The number of bytes to reserve for the input buffer. For a discussion on sizing named pipe buffers, see the following Remarks section.</param>
    <param name="nDefaultTimeOut">
      <para>The default time-out value, in milliseconds, if the<see cref="WaitNamedPipe" /> function specifies <b>NMPWAIT_USE_DEFAULT_WAIT</b>. Each instance of a named pipe must specify the same value.</para>
      <para>A value of zero will result in a default time-out of 50 milliseconds.</para>
    </param>
    <param name="lpSecurityAttributes">A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies a security descriptor for the new named pipe and determines whether child processes can inherit the returned handle. If <i>lpSecurityAttributes</i> is <b>NULL</b>, the named pipe gets a default security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a named pipe grant full control to the LocalSystem account, administrators, and the creator owner. They also grant read access to members of the Everyone group and the anonymous account.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the server end of a named pipe instance.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreatePrivateNamespace">
    <summary>Creates a private namespace.</summary>
    <param name="lpPrivateNamespaceAttributes">A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies the security attributes of the namespace object.</param>
    <param name="lpBoundaryDescriptor">A descriptor that defines how the namespace is to be isolated. The caller must be within this boundary. The <see cref="CreateBoundaryDescriptor" /> function creates a boundary descriptor.</param>
    <param name="lpAliasPrefix">
      <para>The prefix for the namespace. To create an object in this namespace, specify the object name as <i>prefix</i>\<i>objectname</i>.</para>
      <para>The system supports multiple private namespaces with the same name, as long as they define different boundaries.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a handle to the new namespace.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreatePrivateNamespaceA">
    <summary>Creates a private namespace.</summary>
    <param name="lpPrivateNamespaceAttributes">A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies the security attributes of the namespace object.</param>
    <param name="lpBoundaryDescriptor">A descriptor that defines how the namespace is to be isolated. The caller must be within this boundary. The <see cref="CreateBoundaryDescriptor" /> function creates a boundary descriptor.</param>
    <param name="lpAliasPrefix">
      <para>The prefix for the namespace. To create an object in this namespace, specify the object name as <i>prefix</i>\<i>objectname</i>.</para>
      <para>The system supports multiple private namespaces with the same name, as long as they define different boundaries.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a handle to the new namespace.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreatePrivateNamespaceW">
    <summary>Creates a private namespace.</summary>
    <param name="lpPrivateNamespaceAttributes">A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies the security attributes of the namespace object.</param>
    <param name="lpBoundaryDescriptor">A descriptor that defines how the namespace is to be isolated. The caller must be within this boundary. The <see cref="CreateBoundaryDescriptor" /> function creates a boundary descriptor.</param>
    <param name="lpAliasPrefix">
      <para>The prefix for the namespace. To create an object in this namespace, specify the object name as <i>prefix</i>\<i>objectname</i>.</para>
      <para>The system supports multiple private namespaces with the same name, as long as they define different boundaries.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a handle to the new namespace.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateProcessWithTokenW">
    <summary>
      <para>Creates a new process and its primary thread. The new process runs in the security context of the specified token. It can optionally load the user profile for the specified user.</para>
      <para>The process that calls <b>CreateProcessWithTokenW</b> must have the SE_IMPERSONATE_NAME privilege. If this function fails with ERROR_PRIVILEGE_NOT_HELD (1314), use the <see cref="CreateProcessAsUser" /> or <see cref="CreateProcessWithLogonW" /> function instead. Typically, the process that calls<br /><b>CreateProcessAsUser</b> must have the SE_INCREASE_QUOTA_NAME privilege and may require the SE_ASSIGNPRIMARYTOKEN_NAME privilege if the token is not assignable. <b>CreateProcessWithLogonW</b> requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use <b>CreateProcessWithLogonW</b> to create a process with alternate credentials.</para>
    </summary>
    <param name="hToken">
      <para>A handle to the primary token that represents a user. The handle must have the TOKEN_QUERY, TOKEN_DUPLICATE, and TOKEN_ASSIGN_PRIMARY access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>. The user represented by the token must have read and execute access to the application specified by the <i>lpApplicationName</i> or the <i>lpCommandLine</i> parameter.</para>
      <para>To get a primary token that represents the specified user, call the<see cref="LogonUser" /> function. Alternatively, you can call the<see cref="DuplicateTokenEx" /> function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.</para>
      <para>
        <b>Terminal Services:  </b>The caller's process always runs in the caller's session, not in the session specified in the token. To run a process in the session specified in the token, use the CreateProcessAsUser function.</para>
    </param>
    <param name="dwLogonFlags">
      <para>The logon option. This parameter can be zero or one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON_WITH_PROFILE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Log on, then load the user's profile in the <b>HKEY_USERS</b> registry key. The function returns after the profile has been loaded. Loading the profile can be time-consuming, so it is best to use this value only if you must access the information in the <b>HKEY_CURRENT_USER</b> registry key. <para><b>Windows Server 2003:  </b>The profile is unloaded after the new process has been terminated, regardless of whether it has created child processes.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON_NETCREDENTIALS_ONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Log on, but use the specified credentials on the network only. The new process uses the same token as the caller, but the system creates a new logon session within LSA, and the process uses the specified credentials as the default credentials. <para>This value can be used to create a process that uses a different set of credentials locally than it does remotely. This is useful in inter-domain scenarios where there is no trust relationship.</para><para>The system does not validate the specified credentials. Therefore, the process can start, but it may not have access to network resources.</para></description>
        </listheader>
      </list>
    </param>
    <param name="lpApplicationName">
      <para>The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.</para>
      <para>The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.</para>
      <para>The <i>lpApplicationName</i> parameter can be NULL. In that case, the module name must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the following order:</para>
      <para>
        <b>c:\program.exe</b>
        <b>c:\program files\sub.exe</b>
        <b>c:\program files\sub dir\program.exe</b>
        <b>c:\program files\sub dir\program name.exe</b>If the executable module is a 16-bit application, <i>lpApplicationName</i> should be NULL, and the string pointed to by <i>lpCommandLine</i> should specify the executable module as well as its arguments.</para>
    </param>
    <param name="lpCommandLine">
      <para>The command line to be executed.</para>
      <para>The maximum length of this string is 1024 characters. If <i>lpApplicationName</i> is NULL, the module name portion of <i>lpCommandLine</i> is limited to MAX_PATH characters.</para>
      <para>The function can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string, the function may cause an access violation.</para>
      <para>The <i>lpCommandLine</i> parameter can be NULL. In that case, the function uses the string pointed to by <i>lpApplicationName</i> as the command line.</para>
      <para>If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-NULL, *<i>lpApplicationName</i> specifies the module to execute, and *<i>lpCommandLine</i> specifies the command line. The new process can use<see cref="GetCommandLine" /> to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.</para>
      <para>If <i>lpApplicationName</i> is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the system searches for the executable file in the following sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory for the parent process.</description>
        </item>
        <item>
          <description>The 32-bit Windows system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is searched.</description>
        </item>
        <item>
          <description>The Windows directory. Use the <see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable. Note that this function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the search sequence, use the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/axe/shellexecute">ShellExecute</a> function.</description>
        </item>
      </list>The system adds a null character to the command line string to separate the file name from the arguments. This divides the original string into two strings for internal processing.</param>
    <param name="dwCreationFlags">
      <para>The flags that control how the process is created. The CREATE_DEFAULT_ERROR_MODE, CREATE_NEW_CONSOLE, and CREATE_NEW_PROCESS_GROUP flags are enabled by default. For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-creation-flags">Process Creation Flags</a>.</para>
      <para>This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see<see cref="GetPriorityClass" />. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process.</para>
      <para>If the dwCreationFlags parameter has a value of 0:</para>
      <list type="bullet">
        <item>
          <description>The process gets the default error mode, creates a new console and creates a new process group.</description>
        </item>
        <item>
          <description>The environment block for the new process is assumed to contain ANSI characters (see <i>lpEnvironment</i> parameter for additional information).</description>
        </item>
        <item>
          <description>A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).</description>
        </item>
      </list>
    </param>
    <param name="lpEnvironment">
      <para>A pointer to an environment block for the new process. If this parameter is NULL, the new process uses an environment created from the profile of the user specified by <i>lpUsername</i>.</para>
      <para>An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:</para>
      <para>
        <i>name</i>=<i>value</i></para>
      <para>Because the equal sign (=) is used as a separator, it must not be used in the name of an environment variable.</para>
      <para>An environment block can contain Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes CREATE_UNICODE_ENVIRONMENT.</para>
      <para>An ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string and two more to terminate the block.</para>
      <para>To retrieve a copy of the environment block for a specific user, use the<see cref="CreateEnvironmentBlock" /> function.</para>
    </param>
    <param name="lpCurrentDirectory">
      <para>The full path to the current directory for the process. The string can also specify a UNC path.</para>
      <para>If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)</para>
    </param>
    <param name="lpStartupInfo">
      <para>A pointer to a<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> structure.</para>
      <para>If the <b>lpDesktop</b> member is NULL or an empty string, the new process inherits the desktop and window station of its parent process. The function adds permission for the specified user account to the inherited window station and desktop. Otherwise, if this member specifies a desktop, it is the responsibility of the application to add permission for the specified user account to the specified window station and desktop, even for WinSta0\Default.</para>
      <para>Handles in<see cref="STARTUPINFO" /> or <see cref="STARTUPINFOEX" /> must be closed with<see cref="CloseHandle" /> when they are no longer needed.</para>
      <div>
        <b>Important</b>  If the <b>dwFlags</b> member of the <see cref="STARTUPINFO" /> structure specifies <b>STARTF_USESTDHANDLES</b>, the standard handle fields are copied unchanged to the child process without validation. The caller is responsible for ensuring that these fields contain valid handle values. Incorrect values can cause the child process to misbehave or crash. Use the <a href="https://docs.microsoft.com//windows-hardware/drivers/devtest/application-verifier">Application Verifier</a> runtime verification tool to detect invalid handles.</div>
    </param>
    <param name="lpProcessInformation">
      <para>A pointer to a<see cref="PROCESS_INFORMATION" /> structure that receives identification information for the new process, including a handle to the process.</para>
      <para>Handles in<see cref="PROCESS_INFORMATION" /> must be closed with the<see cref="CloseHandle" /> function when they are no longer needed.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>Note that the function returns before the process has finished initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the termination status of a process, call <see cref="GetExitCodeProcess" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateSemaphoreA">
    <summary>
      <para>Creates or opens a named or unnamed semaphore object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateSemaphoreEx" /> function.</para>
    </summary>
    <param name="lpSemaphoreAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lInitialCount">The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the<see cref="ReleaseSemaphore" /> function.</param>
    <param name="lMaximumCount">The maximum count for the semaphore object. This value must be greater than zero.</param>
    <param name="lpName">
      <para>The name of the semaphore object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named semaphore object, this function requests the <b>SEMAPHORE_ALL_ACCESS</b> access right. In this case, the <i>lInitialCount</i> and <i>lMaximumCount</i> parameters are ignored because they have already been set by the creating process. If the <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the semaphore object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object existed before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateSemaphoreW">
    <summary>
      <para>Creates or opens a named or unnamed semaphore object.</para>
      <para>To specify an access mask for the object, use the <see cref="CreateSemaphoreEx" /> function.</para>
    </summary>
    <param name="lpSemaphoreAttributes">
      <para>A pointer to a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lInitialCount">The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the<see cref="ReleaseSemaphore" /> function.</param>
    <param name="lMaximumCount">The maximum count for the semaphore object. This value must be greater than zero.</param>
    <param name="lpName">
      <para>The name of the semaphore object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named semaphore object, this function requests the <b>SEMAPHORE_ALL_ACCESS</b> access right. In this case, the <i>lInitialCount</i> and <i>lMaximumCount</i> parameters are ignored because they have already been set by the creating process. If the <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is ignored.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the semaphore object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object existed before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateSemaphoreExA">
    <summary>Creates or opens a named or unnamed semaphore object and returns a handle to the object.</summary>
    <param name="lpSemaphoreAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the semaphore handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lInitialCount">The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the<see cref="ReleaseSemaphore" /> function.</param>
    <param name="lMaximumCount">The maximum count for the semaphore object. This value must be greater than zero.</param>
    <param name="lpName">
      <para>A pointer to a null-terminated string specifying the name of the semaphore object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named semaphore object, the <i>lInitialCount</i> and <i>lMaximumCount</i> parameters are ignored because they have already been set by the creating process. If the <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the semaphore object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">This parameter is reserved and must be 0.</param>
    <param name="dwDesiredAccess">The access mask for the semaphore object. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object existed before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateSemaphoreExW">
    <summary>Creates or opens a named or unnamed semaphore object and returns a handle to the object.</summary>
    <param name="lpSemaphoreAttributes">
      <para>A pointer to a<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure. If this parameter is <b>NULL</b>, the semaphore handle cannot be inherited by child processes.</para>
      <para>The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation token of the creator.</para>
    </param>
    <param name="lInitialCount">The initial count for the semaphore object. This value must be greater than or equal to zero and less than or equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was waiting for the semaphore. The count is increased by a specified amount by calling the<see cref="ReleaseSemaphore" /> function.</param>
    <param name="lMaximumCount">The maximum count for the semaphore object. This value must be greater than zero.</param>
    <param name="lpName">
      <para>A pointer to a null-terminated string specifying the name of the semaphore object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case sensitive.</para>
      <para>If <i>lpName</i> matches the name of an existing named semaphore object, the <i>lInitialCount</i> and <i>lMaximumCount</i> parameters are ignored because they have already been set by the creating process. If the <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited.</para>
      <para>If <i>lpName</i> is <b>NULL</b>, the semaphore object is created without a name.</para>
      <para>If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or file-mapping object, the function fails and the<see cref="GetLastError" /> function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace.</para>
      <para>The name can have a "Global" or "Local" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</para>
      <para>The object can be created in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
    </param>
    <param name="dwFlags">This parameter is reserved and must be 0.</param>
    <param name="dwDesiredAccess">The access mask for the semaphore object. For a list of access rights, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object existed before the function call, the function returns a handle to the existing object and<see cref="GetLastError" /> returns <b>ERROR_ALREADY_EXISTS</b>.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateSymbolicLink">
    <summary>
      <para>Creates a symbolic link.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateSymbolicLinkTransacted" /> function.</para>
    </summary>
    <param name="lpSymlinkFileName">
      <para>The symbolic link to be created.</para>
      <para>This parameter may include the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpTargetFileName">
      <para>The name of the target for the symbolic link to be created.</para>
      <para>If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as an absolute link; otherwise, the link is treated as a relative link.</para>
      <para>This parameter may include the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="dwFlags">
      <para>Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0x0</term>
              </listheader>
            </list>
          </description>
          <description>The link target is a file.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SYMBOLIC_LINK_FLAG_DIRECTORY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x1</term>
              </listheader>
            </list>
          </description>
          <description>The link target is a directory.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x2</term>
              </listheader>
            </list>
          </description>
          <description>Specify this flag to allow creation of symbolic links when the process is not elevated. In UWP, <a href="https://docs.microsoft.com//windows/uwp/get-started/enable-your-device-for-development">Developer Mode</a> must first be enabled on the machine before this option will function. Under MSIX, developer mode is not required to be enabled for this flag.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateSymbolicLinkA">
    <summary>
      <para>Creates a symbolic link.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateSymbolicLinkTransacted" /> function.</para>
    </summary>
    <param name="lpSymlinkFileName">
      <para>The symbolic link to be created.</para>
      <para>This parameter may include the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpTargetFileName">
      <para>The name of the target for the symbolic link to be created.</para>
      <para>If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as an absolute link; otherwise, the link is treated as a relative link.</para>
      <para>This parameter may include the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="dwFlags">
      <para>Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0x0</term>
              </listheader>
            </list>
          </description>
          <description>The link target is a file.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SYMBOLIC_LINK_FLAG_DIRECTORY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x1</term>
              </listheader>
            </list>
          </description>
          <description>The link target is a directory.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x2</term>
              </listheader>
            </list>
          </description>
          <description>Specify this flag to allow creation of symbolic links when the process is not elevated. In UWP, <a href="https://docs.microsoft.com//windows/uwp/get-started/enable-your-device-for-development">Developer Mode</a> must first be enabled on the machine before this option will function. Under MSIX, developer mode is not required to be enabled for this flag.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateSymbolicLinkW">
    <summary>
      <para>Creates a symbolic link.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateSymbolicLinkTransacted" /> function.</para>
    </summary>
    <param name="lpSymlinkFileName">
      <para>The symbolic link to be created.</para>
      <para>This parameter may include the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpTargetFileName">
      <para>The name of the target for the symbolic link to be created.</para>
      <para>If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as an absolute link; otherwise, the link is treated as a relative link.</para>
      <para>This parameter may include the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="dwFlags">
      <para>Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0x0</term>
              </listheader>
            </list>
          </description>
          <description>The link target is a file.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SYMBOLIC_LINK_FLAG_DIRECTORY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x1</term>
              </listheader>
            </list>
          </description>
          <description>The link target is a directory.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x2</term>
              </listheader>
            </list>
          </description>
          <description>Specify this flag to allow creation of symbolic links when the process is not elevated. In UWP, <a href="https://docs.microsoft.com//windows/uwp/get-started/enable-your-device-for-development">Developer Mode</a> must first be enabled on the machine before this option will function. Under MSIX, developer mode is not required to be enabled for this flag.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateSymbolicLink">
    <summary>
      <para>Creates a symbolic link.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateSymbolicLinkTransacted" /> function.</para>
    </summary>
    <param name="lpSymlinkFileName">
      <para>The symbolic link to be created.</para>
      <para>This parameter may include the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpTargetFileName">
      <para>The name of the target for the symbolic link to be created.</para>
      <para>If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as an absolute link; otherwise, the link is treated as a relative link.</para>
      <para>This parameter may include the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="dwFlags">
      <para>Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0x0</term>
              </listheader>
            </list>
          </description>
          <description>The link target is a file.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SYMBOLIC_LINK_FLAG_DIRECTORY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x1</term>
              </listheader>
            </list>
          </description>
          <description>The link target is a directory.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x2</term>
              </listheader>
            </list>
          </description>
          <description>Specify this flag to allow creation of symbolic links when the process is not elevated. <a href="https://docs.microsoft.com//windows/uwp/get-started/enable-your-device-for-development">Developer Mode</a> must first be enabled on the machine before this option will function.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateSymbolicLinkA">
    <summary>
      <para>Creates a symbolic link.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateSymbolicLinkTransacted" /> function.</para>
    </summary>
    <param name="lpSymlinkFileName">
      <para>The symbolic link to be created.</para>
      <para>This parameter may include the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpTargetFileName">
      <para>The name of the target for the symbolic link to be created.</para>
      <para>If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as an absolute link; otherwise, the link is treated as a relative link.</para>
      <para>This parameter may include the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="dwFlags">
      <para>Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0x0</term>
              </listheader>
            </list>
          </description>
          <description>The link target is a file.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SYMBOLIC_LINK_FLAG_DIRECTORY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x1</term>
              </listheader>
            </list>
          </description>
          <description>The link target is a directory.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x2</term>
              </listheader>
            </list>
          </description>
          <description>Specify this flag to allow creation of symbolic links when the process is not elevated. <a href="https://docs.microsoft.com//windows/uwp/get-started/enable-your-device-for-development">Developer Mode</a> must first be enabled on the machine before this option will function.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateSymbolicLinkW">
    <summary>
      <para>Creates a symbolic link.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="CreateSymbolicLinkTransacted" /> function.</para>
    </summary>
    <param name="lpSymlinkFileName">
      <para>The symbolic link to be created.</para>
      <para>This parameter may include the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpTargetFileName">
      <para>The name of the target for the symbolic link to be created.</para>
      <para>If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as an absolute link; otherwise, the link is treated as a relative link.</para>
      <para>This parameter may include the path.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="dwFlags">
      <para>Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0x0</term>
              </listheader>
            </list>
          </description>
          <description>The link target is a file.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SYMBOLIC_LINK_FLAG_DIRECTORY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x1</term>
              </listheader>
            </list>
          </description>
          <description>The link target is a directory.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x2</term>
              </listheader>
            </list>
          </description>
          <description>Specify this flag to allow creation of symbolic links when the process is not elevated. <a href="https://docs.microsoft.com//windows/uwp/get-started/enable-your-device-for-development">Developer Mode</a> must first be enabled on the machine before this option will function.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.CreateTapePartition">
    <summary>The<b>CreateTapePartition</b> function reformats a tape.</summary>
    <param name="hDevice">Handle to the device where the new partition is to be created. This handle is created by using the<see cref="CreateFile" /> function.</param>
    <param name="dwPartitionMethod">
      <para>Type of partition to create. To determine what type of partitions your device supports, see the documentation for your hardware. This parameter can have one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_FIXED_PARTITIONS</b>
                </term>
              </listheader>
              <listheader>
                <term>0L</term>
              </listheader>
            </list>
          </description>
          <description>Partitions the tape based on the device's default definition of partitions. The <i>dwCount</i> and <i>dwSize</i> parameters are ignored.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_INITIATOR_PARTITIONS</b>
                </term>
              </listheader>
              <listheader>
                <term>2L</term>
              </listheader>
            </list>
          </description>
          <description>Partitions the tape into the number and size of partitions specified by <i>dwCount</i> and <i>dwSize</i>, respectively, except for the last partition. The size of the last partition is the remainder of the tape.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_SELECT_PARTITIONS</b>
                </term>
              </listheader>
              <listheader>
                <term>1L</term>
              </listheader>
            </list>
          </description>
          <description>Partitions the tape into the number of partitions specified by <i>dwCount</i>. The <i>dwSize</i> parameter is ignored. The size of the partitions is determined by the device's default partition size. For more specific information, see the documentation for your tape device.</description>
        </listheader>
      </list>
    </param>
    <param name="dwCount">Number of partitions to create. The<see cref="GetTapeParameters" /> function provides the maximum number of partitions a tape can support.</param>
    <param name="dwSize">Size of each partition, in megabytes. This value is ignored if the <i>dwPartitionMethod</i> parameter is <b>TAPE_SELECT_PARTITIONS</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, it can return one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BEGINNING_OF_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1102L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to access data before the beginning-of-medium marker failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BUS_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>1111L</term>
              </listheader>
            </list>
          </description>
          <description>A reset condition was detected on the bus.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_END_OF_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1100L</term>
              </listheader>
            </list>
          </description>
          <description>The end-of-tape marker was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_FILEMARK_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1101L</term>
              </listheader>
            </list>
          </description>
          <description>A filemark was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_SETMARK_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1103L</term>
              </listheader>
            </list>
          </description>
          <description>A setmark was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NO_DATA_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1104L</term>
              </listheader>
            </list>
          </description>
          <description>The end-of-data marker was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PARTITION_FAILURE</b>
                </term>
              </listheader>
              <listheader>
                <term>1105L</term>
              </listheader>
            </list>
          </description>
          <description>The tape could not be partitioned.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_BLOCK_LENGTH</b>
                </term>
              </listheader>
              <listheader>
                <term>1106L</term>
              </listheader>
            </list>
          </description>
          <description>The block size is incorrect on a new tape in a multivolume partition.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_DEVICE_NOT_PARTITIONED</b>
                </term>
              </listheader>
              <listheader>
                <term>1107L</term>
              </listheader>
            </list>
          </description>
          <description>The partition information could not be found when a tape was being loaded.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_MEDIA_CHANGED</b>
                </term>
              </listheader>
              <listheader>
                <term>1110L</term>
              </listheader>
            </list>
          </description>
          <description>The tape that was in the drive has been replaced or removed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NO_MEDIA_IN_DRIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>1112L</term>
              </listheader>
            </list>
          </description>
          <description>There is no media in the drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_SUPPORTED</b>
                </term>
              </listheader>
              <listheader>
                <term>50L</term>
              </listheader>
            </list>
          </description>
          <description>The tape driver does not support a requested function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_UNABLE_TO_LOCK_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1108L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to lock the ejection mechanism failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1109L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to unload the tape failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_WRITE_PROTECT</b>
                </term>
              </listheader>
              <listheader>
                <term>19L</term>
              </listheader>
            </list>
          </description>
          <description>The media is write protected.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.CreateUmsCompletionList">
    <summary>
      <para>Creates a user-mode scheduling (UMS) completion list.</para>
      <blockquote>[!WARNING] As of Windows 11, user-mode scheduling is not supported. All calls fail with the error <code>ERROR_NOT_SUPPORTED</code>.</blockquote>
    </summary>
    <param name="UmsCompletionList">A <b>PUMS_COMPLETION_LIST</b> variable. On output, this parameter receives a pointer to an empty UMS completion list.</param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_ENOUGH_MEMORY</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Not enough memory is available to create the completion list.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_SUPPORTED</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>UMS is not supported.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.CreateUmsThreadContext">
    <summary>
      <para>Creates a user-mode scheduling (UMS) thread context to represent a UMS worker thread.</para>
      <blockquote>[!WARNING] As of Windows 11, user-mode scheduling is not supported. All calls fail with the error <code>ERROR_NOT_SUPPORTED</code>.</blockquote>
    </summary>
    <param name="lpUmsThread">A PUMS_CONTEXT variable. On output, this parameter receives a pointer to a UMS thread context.</param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. Possible error values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_ENOUGH_MEMORY</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Not enough memory is available to create the UMS thread context.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.DeactivateActCtx">
    <summary>The<b>DeactivateActCtx</b> function deactivates the activation context corresponding to the specified cookie.</summary>
    <param name="dwFlags">
      <para>Flags that indicate how the deactivation is to occur.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>0</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>If this value is set and the cookie specified in the <i>ulCookie</i> parameter is in the top frame of the activation stack, the activation context is popped from the stack and thereby deactivated. <para>If this value is set and the cookie specified in the <i>ulCookie</i> parameter is not in the top frame of the activation stack, this function searches down the stack for the cookie.</para><para>If the cookie is found, a STATUS_SXS_EARLY_DEACTIVATION exception is thrown.</para><para>If the cookie is not found, a STATUS_SXS_INVALID_DEACTIVATION exception is thrown.</para><para>This value should be specified in most cases.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>If this value is set and the cookie specified in the <i>ulCookie</i> parameter is in the top frame of the activation stack, the function returns an ERROR_INVALID_PARAMETER error code. Call <see cref="GetLastError" /> to obtain this code. <para>If this value is set and the cookie is not on the activation stack, a STATUS_SXS_INVALID_DEACTIVATION exception will be thrown.</para><para>If this value is set and the cookie is in a lower frame of the activation stack, all of the frames down to and including the frame the cookie is in is popped from the stack.</para></description>
        </listheader>
      </list>
    </param>
    <param name="ulCookie">The ULONG_PTR that was passed into the call to<see cref="ActivateActCtx" />. This value is used as a cookie to identify a specific activated activation context.</param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling<see cref="GetLastError" />. For an example, see<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
  </member>
  <member name="Windows.DebugBreakProcess">
    <summary>Causes a breakpoint exception to occur in the specified process. This allows the calling thread to signal the debugger to handle the exception.</summary>
    <param name="Process">A handle to the process.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DebugSetProcessKillOnExit">
    <summary>Sets the action to be performed when the calling thread exits.</summary>
    <param name="KillOnExit">If this parameter is <b>TRUE</b>, the thread terminates all attached processes on exit (note that this is the default). Otherwise, the thread detaches from all processes being debugged on exit.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DecryptFile">
    <summary>Decrypts an encrypted file or directory.</summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be decrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and <b>SYNCHRONIZE</b> access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="dwReserved">Reserved; must be zero.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DecryptFileA">
    <summary>Decrypts an encrypted file or directory.</summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be decrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and <b>SYNCHRONIZE</b> access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="dwReserved">Reserved; must be zero.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DecryptFileW">
    <summary>Decrypts an encrypted file or directory.</summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be decrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and <b>SYNCHRONIZE</b> access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="dwReserved">Reserved; must be zero.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DecryptFile">
    <summary>Decrypts an encrypted file or directory.</summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be decrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and <b>SYNCHRONIZE</b> access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="dwReserved">Reserved; must be zero.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DecryptFileA">
    <summary>Decrypts an encrypted file or directory.</summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be decrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and <b>SYNCHRONIZE</b> access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="dwReserved">Reserved; must be zero.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DecryptFileW">
    <summary>Decrypts an encrypted file or directory.</summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be decrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and <b>SYNCHRONIZE</b> access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <param name="dwReserved">Reserved; must be zero.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DefineDosDevice">
    <summary>Defines, redefines, or deletes MS-DOS device names.</summary>
    <param name="dwFlags">
      <para>The controllable aspects of the <b>DefineDosDevice</b> function. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_EXACT_MATCH_ON_REMOVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>If this value is specified along with <b>DDD_REMOVE_DEFINITION</b>, the function will use an exact match to determine which mapping to remove. Use this value to ensure that you do not delete something that you did not define.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_NO_BROADCAST_SYSTEM</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>Do not broadcast the <a href="https://docs.microsoft.com//windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message. By default, this message is broadcast to notify the shell and applications of the change.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_RAW_TARGET_PATH</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Uses the <i>lpTargetPath</i> string as is. Otherwise, it is converted from an MS-DOS path to a path.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_REMOVE_DEFINITION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Removes the specified definition for the specified device. To determine which definition to remove, the function walks the list of mappings for the device, looking for a match of <i>lpTargetPath</i> against a prefix of each mapping associated with this device. The first mapping that matches is the one removed, and then the function returns.<para>If <i>lpTargetPath</i> is <b>NULL</b> or a pointer to a<b>NULL</b> string, the function will remove the first mapping associated with the device and pop the most recent one pushed. If there is nothing left to pop, the device name will be removed.</para><para>If this value is not specified, the string pointed to by the <i>lpTargetPath</i>parameter will become the new mapping for this device.</para></description>
        </listheader>
      </list>
    </param>
    <param name="lpDeviceName">A pointer to an MS-DOS device name string specifying the device the function is defining, redefining, or deleting. The device name string must not have a colon as the last character, unless a drive letter is being defined, redefined, or deleted. For example, drive C would be the string "C:". In no case is a trailing backslash ("") allowed.</param>
    <param name="lpTargetPath">A pointer to a path string that will implement this device. The string is an MS-DOS path string unless the<b>DDD_RAW_TARGET_PATH</b> flag is specified, in which case this string is a path string.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DefineDosDeviceA">
    <summary>Defines, redefines, or deletes MS-DOS device names.</summary>
    <param name="dwFlags">
      <para>The controllable aspects of the <b>DefineDosDevice</b> function. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_EXACT_MATCH_ON_REMOVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>If this value is specified along with <b>DDD_REMOVE_DEFINITION</b>, the function will use an exact match to determine which mapping to remove. Use this value to ensure that you do not delete something that you did not define.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_NO_BROADCAST_SYSTEM</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>Do not broadcast the <a href="https://docs.microsoft.com//windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message. By default, this message is broadcast to notify the shell and applications of the change.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_RAW_TARGET_PATH</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Uses the <i>lpTargetPath</i> string as is. Otherwise, it is converted from an MS-DOS path to a path.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_REMOVE_DEFINITION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Removes the specified definition for the specified device. To determine which definition to remove, the function walks the list of mappings for the device, looking for a match of <i>lpTargetPath</i> against a prefix of each mapping associated with this device. The first mapping that matches is the one removed, and then the function returns.<para>If <i>lpTargetPath</i> is <b>NULL</b> or a pointer to a<b>NULL</b> string, the function will remove the first mapping associated with the device and pop the most recent one pushed. If there is nothing left to pop, the device name will be removed.</para><para>If this value is not specified, the string pointed to by the <i>lpTargetPath</i>parameter will become the new mapping for this device.</para></description>
        </listheader>
      </list>
    </param>
    <param name="lpDeviceName">A pointer to an MS-DOS device name string specifying the device the function is defining, redefining, or deleting. The device name string must not have a colon as the last character, unless a drive letter is being defined, redefined, or deleted. For example, drive C would be the string "C:". In no case is a trailing backslash ("") allowed.</param>
    <param name="lpTargetPath">A pointer to a path string that will implement this device. The string is an MS-DOS path string unless the<b>DDD_RAW_TARGET_PATH</b> flag is specified, in which case this string is a path string.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DefineDosDeviceW">
    <summary>Defines, redefines, or deletes MS-DOS device names.</summary>
    <param name="dwFlags">
      <para>The controllable aspects of the <b>DefineDosDevice</b> function. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_EXACT_MATCH_ON_REMOVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>If this value is specified along with <b>DDD_REMOVE_DEFINITION</b>, the function will use an exact match to determine which mapping to remove. Use this value to ensure that you do not delete something that you did not define.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_NO_BROADCAST_SYSTEM</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>Do not broadcast the <a href="https://docs.microsoft.com//windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message. By default, this message is broadcast to notify the shell and applications of the change.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_RAW_TARGET_PATH</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Uses the <i>lpTargetPath</i> string as is. Otherwise, it is converted from an MS-DOS path to a path.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>DDD_REMOVE_DEFINITION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Removes the specified definition for the specified device. To determine which definition to remove, the function walks the list of mappings for the device, looking for a match of <i>lpTargetPath</i> against a prefix of each mapping associated with this device. The first mapping that matches is the one removed, and then the function returns.<para>If <i>lpTargetPath</i> is <b>NULL</b> or a pointer to a<b>NULL</b> string, the function will remove the first mapping associated with the device and pop the most recent one pushed. If there is nothing left to pop, the device name will be removed.</para><para>If this value is not specified, the string pointed to by the <i>lpTargetPath</i>parameter will become the new mapping for this device.</para></description>
        </listheader>
      </list>
    </param>
    <param name="lpDeviceName">A pointer to an MS-DOS device name string specifying the device the function is defining, redefining, or deleting. The device name string must not have a colon as the last character, unless a drive letter is being defined, redefined, or deleted. For example, drive C would be the string "C:". In no case is a trailing backslash ("") allowed.</param>
    <param name="lpTargetPath">A pointer to a path string that will implement this device. The string is an MS-DOS path string unless the<b>DDD_RAW_TARGET_PATH</b> flag is specified, in which case this string is a path string.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DeleteAtom">
    <summary>Decrements the reference count of a local string atom. If the atom's reference count is reduced to zero, <b>DeleteAtom</b> removes the string associated with the atom from the local atom table.</summary>
    <param name="nAtom">The atom to be deleted.</param>
    <returns>
      <para>If the function succeeds, the return value is zero.</para>
      <para>If the function fails, the return value is the<i>nAtom</i> parameter. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DeleteFiber">
    <summary>Deletes an existing fiber.</summary>
    <param name="lpFiber">The address of the fiber to be deleted.</param>
  </member>
  <member name="Windows.DeleteFile">
    <summary>
      <para>Deletes an existing file.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="DeleteFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be deleted.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DeleteFileA">
    <summary>
      <para>Deletes an existing file.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="DeleteFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be deleted.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DeleteFileW">
    <summary>
      <para>Deletes an existing file.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="DeleteFileTransacted" /> function.</para>
    </summary>
    <param name="lpFileName">
      <para>The name of the file to be deleted.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DeleteUmsCompletionList">
    <summary>
      <para>Deletes the specified user-mode scheduling (UMS) completion list. The list must be empty.</para>
      <blockquote>[!WARNING] As of Windows 11, user-mode scheduling is not supported. All calls fail with the error <code>ERROR_NOT_SUPPORTED</code>.</blockquote>
    </summary>
    <param name="UmsCompletionList">A pointer to the UMS completion list to be deleted. The <see cref="CreateUmsCompletionList" /> function provides this pointer.</param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DeleteUmsThreadContext">
    <summary>
      <para>Deletes the specified user-mode scheduling (UMS) thread context. The thread must be terminated.</para>
      <blockquote>[!WARNING] As of Windows 11, user-mode scheduling is not supported. All calls fail with the error <code>ERROR_NOT_SUPPORTED</code>.</blockquote>
    </summary>
    <param name="UmsThread">A pointer to the UMS thread context to be deleted. The <see cref="CreateUmsThreadContext" /> function provides this pointer.</param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DeleteVolumeMountPoint">
    <summary>Deletes a drive letter or mounted folder.</summary>
    <param name="lpszVolumeMountPoint">The drive letter or mounted folder to be deleted. A trailing backslash is required, for example, "X:" or "Y:\MountX".</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DeleteVolumeMountPointA">
    <summary>Deletes a drive letter or mounted folder.</summary>
    <param name="lpszVolumeMountPoint">The drive letter or mounted folder to be deleted. A trailing backslash is required, for example, "X:" or "Y:\MountX".</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DeleteVolumeMountPointW">
    <summary>Deletes a drive letter or mounted folder.</summary>
    <param name="lpszVolumeMountPoint">The drive letter or mounted folder to be deleted. A trailing backslash is required, for example, "X:" or "Y:\MountX".</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DequeueUmsCompletionListItems">
    <summary>
      <para>Retrieves user-mode scheduling (UMS) worker threads from the specified UMS completion list.</para>
      <blockquote>[!WARNING] As of Windows 11, user-mode scheduling is not supported. All calls fail with the error <code>ERROR_NOT_SUPPORTED</code>.</blockquote>
    </summary>
    <param name="UmsCompletionList">A pointer to the completion list from which to retrieve worker threads.</param>
    <param name="WaitTimeOut">
      <para>The time-out interval for the retrieval operation, in milliseconds. The function returns if the interval elapses, even if no worker threads are queued to the completion list.</para>
      <para>If the <i>WaitTimeOut</i> parameter is zero, the completion list is checked for available worker threads without waiting for worker threads to become available. If the <i>WaitTimeOut</i> parameter is INFINITE, the function's time-out interval never elapses. This is not recommended, however, because it causes the function to block until one or more worker threads become available.</para>
    </param>
    <param name="UmsThreadList">
      <para>A pointer to a UMS_CONTEXT variable. On output, this parameter receives a pointer to the first UMS thread context in a list of UMS thread contexts.</para>
      <para>If no worker threads are available before the time-out specified by the <i>WaitTimeOut</i> parameter, this parameter is set to NULL.</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. Possible error values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_TIMEOUT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>No threads became available before the specified time-out interval elapsed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_SUPPORTED</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>UMS is not supported.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.DeregisterEventSource">
    <summary>Closes the specified event log.</summary>
    <param name="hEventLog">A handle to the event log. The<see cref="RegisterEventSource" /> function returns this handle.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.DestroyThreadpoolEnvironment">
    <summary>Deletes the specified callback environment. Call this function when the callback environment is no longer needed for creating new thread pool objects.</summary>
    <param name="pcbe">A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="InitializeThreadpoolEnvironment" /> function returns this structure.</param>
  </member>
  <member name="Windows.DisableThreadProfiling">
    <summary>Disables thread profiling.</summary>
    <param name="PerformanceDataHandle">The handle that the <see cref="EnableThreadProfiling" /> function returned.</param>
    <returns>Returns ERROR_SUCCESS if the call is successful; otherwise, a system error code (see Winerror.h).</returns>
  </member>
  <member name="Windows.DnsHostnameToComputerName">
    <summary>Converts a DNS-style host name to a NetBIOS-style computer name.</summary>
    <param name="Hostname">The DNS name. If the DNS name is not a valid, translatable name, the function fails. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</a>.</param>
    <param name="ComputerName">A pointer to a buffer that receives the computer name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, receives the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails, <see cref="GetLastError" /> returns ERROR_MORE_DATA, and <i>nSize</i> receives the required buffer size, not including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_MORE_DATA</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The <i>ComputerName</i> buffer is too small. The <i>nSize</i> parameter contains the number of bytes required to receive the name.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.DnsHostnameToComputerNameA">
    <summary>Converts a DNS-style host name to a NetBIOS-style computer name.</summary>
    <param name="Hostname">The DNS name. If the DNS name is not a valid, translatable name, the function fails. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</a>.</param>
    <param name="ComputerName">A pointer to a buffer that receives the computer name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, receives the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails, <see cref="GetLastError" /> returns ERROR_MORE_DATA, and <i>nSize</i> receives the required buffer size, not including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_MORE_DATA</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The <i>ComputerName</i> buffer is too small. The <i>nSize</i> parameter contains the number of bytes required to receive the name.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.DnsHostnameToComputerNameW">
    <summary>Converts a DNS-style host name to a NetBIOS-style computer name.</summary>
    <param name="Hostname">The DNS name. If the DNS name is not a valid, translatable name, the function fails. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</a>.</param>
    <param name="ComputerName">A pointer to a buffer that receives the computer name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, receives the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails, <see cref="GetLastError" /> returns ERROR_MORE_DATA, and <i>nSize</i> receives the required buffer size, not including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_MORE_DATA</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The <i>ComputerName</i> buffer is too small. The <i>nSize</i> parameter contains the number of bytes required to receive the name.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.DnsHostnameToComputerName">
    <summary>Converts a DNS-style host name to a NetBIOS-style computer name.</summary>
    <param name="Hostname">The DNS name. If the DNS name is not a valid, translatable name, the function fails. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</a>.</param>
    <param name="ComputerName">A pointer to a buffer that receives the computer name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, receives the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails, <see cref="GetLastError" /> returns ERROR_MORE_DATA, and <i>nSize</i> receives the required buffer size, not including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_MORE_DATA</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The <i>ComputerName</i> buffer is too small. The <i>nSize</i> parameter contains the number of bytes required to receive the name.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.DnsHostnameToComputerNameA">
    <summary>Converts a DNS-style host name to a NetBIOS-style computer name.</summary>
    <param name="Hostname">The DNS name. If the DNS name is not a valid, translatable name, the function fails. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</a>.</param>
    <param name="ComputerName">A pointer to a buffer that receives the computer name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, receives the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails, <see cref="GetLastError" /> returns ERROR_MORE_DATA, and <i>nSize</i> receives the required buffer size, not including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_MORE_DATA</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The <i>ComputerName</i> buffer is too small. The <i>nSize</i> parameter contains the number of bytes required to receive the name.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.DnsHostnameToComputerNameW">
    <summary>Converts a DNS-style host name to a NetBIOS-style computer name.</summary>
    <param name="Hostname">The DNS name. If the DNS name is not a valid, translatable name, the function fails. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/computer-names">Computer Names</a>.</param>
    <param name="ComputerName">A pointer to a buffer that receives the computer name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, receives the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails, <see cref="GetLastError" /> returns ERROR_MORE_DATA, and <i>nSize</i> receives the required buffer size, not including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_MORE_DATA</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The <i>ComputerName</i> buffer is too small. The <i>nSize</i> parameter contains the number of bytes required to receive the name.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.DosDateTimeToFileTime">
    <summary>Converts MS-DOS date and time values to a file time.</summary>
    <param name="wFatDate">
      <para>The MS-DOS date. The date is a packed value with the following format.</para>
      <list type="table">
        <listheader>
          <description>Bits</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>0-4</description>
          <description>Day of the month (1–31)</description>
        </listheader>
        <listheader>
          <description>5-8</description>
          <description>Month (1 = January, 2 = February, and so on)</description>
        </listheader>
        <listheader>
          <description>9-15</description>
          <description>Year offset from 1980 (add 1980 to get actual year)</description>
        </listheader>
      </list>
    </param>
    <param name="wFatTime">
      <para>The MS-DOS time. The time is a packed value with the following format.</para>
      <list type="table">
        <listheader>
          <description>Bits</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>0-4</description>
          <description>Second divided by 2</description>
        </listheader>
        <listheader>
          <description>5-10</description>
          <description>Minute (0–59)</description>
        </listheader>
        <listheader>
          <description>11-15</description>
          <description>Hour (0–23 on a 24-hour clock)</description>
        </listheader>
      </list>
    </param>
    <param name="lpFileTime">A pointer to a<see cref="FILETIME" /> structure that receives the converted file time.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.EnableProcessOptionalXStateFeatures">
    <summary>This function enables a set of optional XState features for the current process.</summary>
    <param name="Features">A bitmask in which each bit represents an optional XState feature to enable for the current process.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.EnableThreadProfiling">
    <summary>Enables thread profiling on the specified thread.</summary>
    <param name="ThreadHandle">The handle to the thread on which you want to enable profiling. This must be the current thread.</param>
    <param name="Flags">To receive thread profiling data such as context switch count, set this parameter to THREAD_PROFILING_FLAG_DISPATCH; otherwise, set to 0.</param>
    <param name="HardwareCounters">To receive hardware performance counter data, set this parameter to a bitmask that identifies the hardware counters to collect. You can specify up to 16 performance counters. Each bit relates directly to the zero-based hardware counter index for the hardware performance counters that you configured. Set to zero if you are not collecting hardware counter data. If you set a bit for a hardware counter that has not been configured, the counter value that is read for that counter is zero.</param>
    <param name="PerformanceDataHandle">An opaque handle that you use when calling the <see cref="ReadThreadProfilingData" /> and <see cref="DisableThreadProfiling" /> functions.</param>
    <returns>Returns ERROR_SUCCESS if the call is successful; otherwise, a system error code (see Winerror.h).</returns>
  </member>
  <member name="Windows.EncryptFile">
    <summary>Encrypts a file or directory. All data streams in a file are encrypted. All new files created in an encrypted directory are encrypted.</summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be encrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>,<b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and<b>SYNCHRONIZE</b> access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.EncryptFileA">
    <summary>Encrypts a file or directory. All data streams in a file are encrypted. All new files created in an encrypted directory are encrypted.</summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be encrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>,<b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and<b>SYNCHRONIZE</b> access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.EncryptFileW">
    <summary>Encrypts a file or directory. All data streams in a file are encrypted. All new files created in an encrypted directory are encrypted.</summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be encrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>,<b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and<b>SYNCHRONIZE</b> access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.EncryptFile">
    <summary>Encrypts a file or directory. All data streams in a file are encrypted. All new files created in an encrypted directory are encrypted.</summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be encrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>,<b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and<b>SYNCHRONIZE</b> access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.EncryptFileA">
    <summary>Encrypts a file or directory. All data streams in a file are encrypted. All new files created in an encrypted directory are encrypted.</summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be encrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>,<b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and<b>SYNCHRONIZE</b> access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.EncryptFileW">
    <summary>Encrypts a file or directory. All data streams in a file are encrypted. All new files created in an encrypted directory are encrypted.</summary>
    <param name="lpFileName">
      <para>The name of the file or directory to be encrypted.</para>
      <para>The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>,<b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and<b>SYNCHRONIZE</b> access rights. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.EndUpdateResource">
    <summary>Commits or discards changes made prior to a call to <see cref="UpdateResource" />.</summary>
    <param name="hUpdate">A module handle returned by the <see cref="BeginUpdateResource" /> function, and used by <see cref="UpdateResource" />, referencing the file to be updated.</param>
    <param name="fDiscard">Indicates whether to write the resource updates to the file. If this parameter is <b>TRUE</b>, no changes are made. If it is <b>FALSE</b>, the changes are made: the resource updates will take effect.</param>
    <returns>Returns <b>TRUE</b> if the function succeeds; <b>FALSE</b> otherwise. If the function succeeds and <i>fDiscard</i> is <b>TRUE</b>, then no resource updates are made to the file; otherwise all successful resource updates are made to the file. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.EndUpdateResourceA">
    <summary>Commits or discards changes made prior to a call to <see cref="UpdateResource" />.</summary>
    <param name="hUpdate">A module handle returned by the <see cref="BeginUpdateResource" /> function, and used by <see cref="UpdateResource" />, referencing the file to be updated.</param>
    <param name="fDiscard">Indicates whether to write the resource updates to the file. If this parameter is <b>TRUE</b>, no changes are made. If it is <b>FALSE</b>, the changes are made: the resource updates will take effect.</param>
    <returns>Returns <b>TRUE</b> if the function succeeds; <b>FALSE</b> otherwise. If the function succeeds and <i>fDiscard</i> is <b>TRUE</b>, then no resource updates are made to the file; otherwise all successful resource updates are made to the file. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.EndUpdateResourceW">
    <summary>Commits or discards changes made prior to a call to <see cref="UpdateResource" />.</summary>
    <param name="hUpdate">A module handle returned by the <see cref="BeginUpdateResource" /> function, and used by <see cref="UpdateResource" />, referencing the file to be updated.</param>
    <param name="fDiscard">Indicates whether to write the resource updates to the file. If this parameter is <b>TRUE</b>, no changes are made. If it is <b>FALSE</b>, the changes are made: the resource updates will take effect.</param>
    <returns>Returns <b>TRUE</b> if the function succeeds; <b>FALSE</b> otherwise. If the function succeeds and <i>fDiscard</i> is <b>TRUE</b>, then no resource updates are made to the file; otherwise all successful resource updates are made to the file. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.EndUpdateResource">
    <summary>Commits or discards changes made prior to a call to <see cref="UpdateResource" />.</summary>
    <param name="hUpdate">A module handle returned by the <see cref="BeginUpdateResource" /> function, and used by <see cref="UpdateResource" />, referencing the file to be updated.</param>
    <param name="fDiscard">Indicates whether to write the resource updates to the file. If this parameter is <b>TRUE</b>, no changes are made. If it is <b>FALSE</b>, the changes are made: the resource updates will take effect.</param>
    <returns>Returns <b>TRUE</b> if the function succeeds; <b>FALSE</b> otherwise. If the function succeeds and <i>fDiscard</i> is <b>TRUE</b>, then no resource updates are made to the file; otherwise all successful resource updates are made to the file. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.EndUpdateResourceA">
    <summary>Commits or discards changes made prior to a call to <see cref="UpdateResource" />.</summary>
    <param name="hUpdate">A module handle returned by the <see cref="BeginUpdateResource" /> function, and used by <see cref="UpdateResource" />, referencing the file to be updated.</param>
    <param name="fDiscard">Indicates whether to write the resource updates to the file. If this parameter is <b>TRUE</b>, no changes are made. If it is <b>FALSE</b>, the changes are made: the resource updates will take effect.</param>
    <returns>Returns <b>TRUE</b> if the function succeeds; <b>FALSE</b> otherwise. If the function succeeds and <i>fDiscard</i> is <b>TRUE</b>, then no resource updates are made to the file; otherwise all successful resource updates are made to the file. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.EndUpdateResourceW">
    <summary>Commits or discards changes made prior to a call to <see cref="UpdateResource" />.</summary>
    <param name="hUpdate">A module handle returned by the <see cref="BeginUpdateResource" /> function, and used by <see cref="UpdateResource" />, referencing the file to be updated.</param>
    <param name="fDiscard">Indicates whether to write the resource updates to the file. If this parameter is <b>TRUE</b>, no changes are made. If it is <b>FALSE</b>, the changes are made: the resource updates will take effect.</param>
    <returns>Returns <b>TRUE</b> if the function succeeds; <b>FALSE</b> otherwise. If the function succeeds and <i>fDiscard</i> is <b>TRUE</b>, then no resource updates are made to the file; otherwise all successful resource updates are made to the file. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.EnterUmsSchedulingMode">
    <summary>
      <para>Converts the calling thread into a user-mode scheduling (UMS) scheduler thread.</para>
      <blockquote>[!WARNING] As of Windows 11, user-mode scheduling is not supported. All calls fail with the error <code>ERROR_NOT_SUPPORTED</code>.</blockquote>
    </summary>
    <param name="SchedulerStartupInfo">A pointer to a <see cref="UMS_SCHEDULER_STARTUP_INFO" /> structure that specifies UMS attributes for the thread, including a completion list and a <a href="https://docs.microsoft.com//windows/desktop/api/winnt/nc-winnt-rtl_ums_scheduler_entry_point">UmsSchedulerProc</a> entry point function.</param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.EnumResourceLanguages">
    <summary>Enumerates language-specific resources, of the specified type and name, associated with a binary module.</summary>
    <param name="hModule">
      <para>The handle to a module to be searched. Starting with Windows Vista, if this is a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), then appropriate .mui files (if any exist) are included in the search. If this is a specific .mui file, only that file is searched for resources.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">The type of resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-types">Resource Types</a>. For more information, see the Remarks section below.</param>
    <param name="lpName">The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</param>
    <param name="lpEnumFunc">A pointer to the callback function to be called for each enumerated resource language. For more information, see <a href="https://docs.microsoft.com/nc-libloaderapi-enumreslangproca.md">EnumResLangProcA</a>.</param>
    <param name="lParam">An application-defined value passed to the callback function. This parameter can be used in error checking.</param>
    <returns>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.EnumResourceLanguagesA">
    <summary>Enumerates language-specific resources, of the specified type and name, associated with a binary module.</summary>
    <param name="hModule">
      <para>The handle to a module to be searched. Starting with Windows Vista, if this is a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), then appropriate .mui files (if any exist) are included in the search. If this is a specific .mui file, only that file is searched for resources.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">The type of resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-types">Resource Types</a>. For more information, see the Remarks section below.</param>
    <param name="lpName">The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</param>
    <param name="lpEnumFunc">A pointer to the callback function to be called for each enumerated resource language. For more information, see <a href="https://docs.microsoft.com/nc-libloaderapi-enumreslangproca.md">EnumResLangProcA</a>.</param>
    <param name="lParam">An application-defined value passed to the callback function. This parameter can be used in error checking.</param>
    <returns>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.EnumResourceLanguagesW">
    <summary>Enumerates language-specific resources, of the specified type and name, associated with a binary module.</summary>
    <param name="hModule">
      <para>The handle to a module to be searched. Starting with Windows Vista, if this is a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), then appropriate .mui files (if any exist) are included in the search. If this is a specific .mui file, only that file is searched for resources.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">The type of resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-types">Resource Types</a>. For more information, see the Remarks section below.</param>
    <param name="lpName">The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</param>
    <param name="lpEnumFunc">A pointer to the callback function to be called for each enumerated resource language. For more information, see <a href="https://docs.microsoft.com/nc-libloaderapi-enumreslangproca.md">EnumResLangProcA</a>.</param>
    <param name="lParam">An application-defined value passed to the callback function. This parameter can be used in error checking.</param>
    <returns>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.EnumResourceLanguages">
    <summary>Enumerates language-specific resources, of the specified type and name, associated with a binary module.</summary>
    <param name="hModule">
      <para>The handle to a module to be searched. Starting with Windows Vista, if this is a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), then appropriate .mui files (if any exist) are included in the search. If this is a specific .mui file, only that file is searched for resources.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">The type of resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-types">Resource Types</a>. For more information, see the Remarks section below.</param>
    <param name="lpName">The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</param>
    <param name="lpEnumFunc">A pointer to the callback function to be called for each enumerated resource language. For more information, see <a href="https://docs.microsoft.com/nc-libloaderapi-enumreslangprocw.md">EnumResLangProcW</a>.</param>
    <param name="lParam">An application-defined value passed to the callback function. This parameter can be used in error checking.</param>
    <returns>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.EnumResourceLanguagesA">
    <summary>Enumerates language-specific resources, of the specified type and name, associated with a binary module.</summary>
    <param name="hModule">
      <para>The handle to a module to be searched. Starting with Windows Vista, if this is a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), then appropriate .mui files (if any exist) are included in the search. If this is a specific .mui file, only that file is searched for resources.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">The type of resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-types">Resource Types</a>. For more information, see the Remarks section below.</param>
    <param name="lpName">The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</param>
    <param name="lpEnumFunc">A pointer to the callback function to be called for each enumerated resource language. For more information, see <a href="https://docs.microsoft.com/nc-libloaderapi-enumreslangprocw.md">EnumResLangProcW</a>.</param>
    <param name="lParam">An application-defined value passed to the callback function. This parameter can be used in error checking.</param>
    <returns>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.EnumResourceLanguagesW">
    <summary>Enumerates language-specific resources, of the specified type and name, associated with a binary module.</summary>
    <param name="hModule">
      <para>The handle to a module to be searched. Starting with Windows Vista, if this is a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), then appropriate .mui files (if any exist) are included in the search. If this is a specific .mui file, only that file is searched for resources.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpType">The type of resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/desktop/direct3d10/d3d10-graphics-programming-guide-resources-types">Resource Types</a>. For more information, see the Remarks section below.</param>
    <param name="lpName">The name of the resource for which the language is being enumerated. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</param>
    <param name="lpEnumFunc">A pointer to the callback function to be called for each enumerated resource language. For more information, see <a href="https://docs.microsoft.com/nc-libloaderapi-enumreslangprocw.md">EnumResLangProcW</a>.</param>
    <param name="lParam">An application-defined value passed to the callback function. This parameter can be used in error checking.</param>
    <returns>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.EnumResourceTypes">
    <summary>
      <para>Enumerates resource types within a binary module. Starting with Windows Vista, this is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration also includes resources from one of the corresponding language-specific resource files (.mui files)—if one exists—that contain localizable language resources. It is also possible to use <i>hModule</i> to specify a .mui file, in which case only that file is searched for resource types.</para>
      <para>Alternately, applications can call <see cref="EnumResourceTypesEx" />, which provides more precise control over which resource files to enumerate.</para>
    </summary>
    <param name="hModule">
      <para>A handle to a module to be searched. This handle must be obtained through <see cref="LoadLibrary" /> or <see cref="LoadLibraryEx" />.</para>
      <para>See Remarks for more information.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpEnumFunc">A pointer to the callback function to be called for each enumerated resource type. For more information, see the <a href="https://docs.microsoft.com//windows/desktop/api/libloaderapi/nc-libloaderapi-enumrestypeprocw">EnumResTypeProc</a> function.</param>
    <param name="lParam">An application-defined value passed to the callback function.</param>
    <returns>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.EnumResourceTypesA">
    <summary>
      <para>Enumerates resource types within a binary module. Starting with Windows Vista, this is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration also includes resources from one of the corresponding language-specific resource files (.mui files)—if one exists—that contain localizable language resources. It is also possible to use <i>hModule</i> to specify a .mui file, in which case only that file is searched for resource types.</para>
      <para>Alternately, applications can call <see cref="EnumResourceTypesEx" />, which provides more precise control over which resource files to enumerate.</para>
    </summary>
    <param name="hModule">
      <para>A handle to a module to be searched. This handle must be obtained through <see cref="LoadLibrary" /> or <see cref="LoadLibraryEx" />.</para>
      <para>See Remarks for more information.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpEnumFunc">A pointer to the callback function to be called for each enumerated resource type. For more information, see the <a href="https://docs.microsoft.com//windows/desktop/api/libloaderapi/nc-libloaderapi-enumrestypeprocw">EnumResTypeProc</a> function.</param>
    <param name="lParam">An application-defined value passed to the callback function.</param>
    <returns>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.EnumResourceTypesW">
    <summary>
      <para>Enumerates resource types within a binary module. Starting with Windows Vista, this is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration also includes resources from one of the corresponding language-specific resource files (.mui files)—if one exists—that contain localizable language resources. It is also possible to use <i>hModule</i> to specify a .mui file, in which case only that file is searched for resource types.</para>
      <para>Alternately, applications can call <see cref="EnumResourceTypesEx" />, which provides more precise control over which resource files to enumerate.</para>
    </summary>
    <param name="hModule">
      <para>A handle to a module to be searched. This handle must be obtained through <see cref="LoadLibrary" /> or <see cref="LoadLibraryEx" />.</para>
      <para>See Remarks for more information.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpEnumFunc">A pointer to the callback function to be called for each enumerated resource type. For more information, see the <a href="https://docs.microsoft.com//windows/desktop/api/libloaderapi/nc-libloaderapi-enumrestypeprocw">EnumResTypeProc</a> function.</param>
    <param name="lParam">An application-defined value passed to the callback function.</param>
    <returns>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.EnumResourceTypes">
    <summary>
      <para>Enumerates resource types within a binary module. Starting with Windows Vista, this is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration also includes resources from one of the corresponding language-specific resource files (.mui files)—if one exists—that contain localizable language resources. It is also possible to use <i>hModule</i> to specify a .mui file, in which case only that file is searched for resource types.</para>
      <para>Alternately, applications can call <see cref="EnumResourceTypesEx" />, which provides more precise control over which resource files to enumerate.</para>
    </summary>
    <param name="hModule">
      <para>A handle to a module to be searched. This handle must be obtained through <see cref="LoadLibrary" /> or <see cref="LoadLibraryEx" />.</para>
      <para>See Remarks for more information.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpEnumFunc">A pointer to the callback function to be called for each enumerated resource type. For more information, see the <a href="https://docs.microsoft.com//windows/desktop/api/libloaderapi/nc-libloaderapi-enumrestypeprocw">EnumResTypeProc</a> function.</param>
    <param name="lParam">An application-defined value passed to the callback function.</param>
    <returns>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.EnumResourceTypesA">
    <summary>
      <para>Enumerates resource types within a binary module. Starting with Windows Vista, this is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration also includes resources from one of the corresponding language-specific resource files (.mui files)—if one exists—that contain localizable language resources. It is also possible to use <i>hModule</i> to specify a .mui file, in which case only that file is searched for resource types.</para>
      <para>Alternately, applications can call <see cref="EnumResourceTypesEx" />, which provides more precise control over which resource files to enumerate.</para>
    </summary>
    <param name="hModule">
      <para>A handle to a module to be searched. This handle must be obtained through <see cref="LoadLibrary" /> or <see cref="LoadLibraryEx" />.</para>
      <para>See Remarks for more information.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpEnumFunc">A pointer to the callback function to be called for each enumerated resource type. For more information, see the <a href="https://docs.microsoft.com//windows/desktop/api/libloaderapi/nc-libloaderapi-enumrestypeprocw">EnumResTypeProc</a> function.</param>
    <param name="lParam">An application-defined value passed to the callback function.</param>
    <returns>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.EnumResourceTypesW">
    <summary>
      <para>Enumerates resource types within a binary module. Starting with Windows Vista, this is typically a <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral Portable Executable</a> (LN file), and the enumeration also includes resources from one of the corresponding language-specific resource files (.mui files)—if one exists—that contain localizable language resources. It is also possible to use <i>hModule</i> to specify a .mui file, in which case only that file is searched for resource types.</para>
      <para>Alternately, applications can call <see cref="EnumResourceTypesEx" />, which provides more precise control over which resource files to enumerate.</para>
    </summary>
    <param name="hModule">
      <para>A handle to a module to be searched. This handle must be obtained through <see cref="LoadLibrary" /> or <see cref="LoadLibraryEx" />.</para>
      <para>See Remarks for more information.</para>
      <para>If this parameter is <b>NULL</b>, that is equivalent to passing in a handle to the module used to create the current process.</para>
    </param>
    <param name="lpEnumFunc">A pointer to the callback function to be called for each enumerated resource type. For more information, see the <a href="https://docs.microsoft.com//windows/desktop/api/libloaderapi/nc-libloaderapi-enumrestypeprocw">EnumResTypeProc</a> function.</param>
    <param name="lParam">An application-defined value passed to the callback function.</param>
    <returns>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.EraseTape">
    <summary>The<b>EraseTape</b> function erases all or part of a tape.</summary>
    <param name="hDevice">Handle to the device where the tape is to be erased. This handle is created by using the<see cref="CreateFile" /> function.</param>
    <param name="dwEraseType">
      <para>Erasing technique. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_ERASE_LONG</b>
                </term>
              </listheader>
              <listheader>
                <term>1L</term>
              </listheader>
            </list>
          </description>
          <description>Erases the tape from the current position to the end of the current partition.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_ERASE_SHORT</b>
                </term>
              </listheader>
              <listheader>
                <term>0L</term>
              </listheader>
            </list>
          </description>
          <description>Writes an erase gap or end-of-data marker at the current position.</description>
        </listheader>
      </list>
    </param>
    <param name="bImmediate">If this parameter is <b>TRUE</b>, the function returns immediately; if it is <b>FALSE</b>, the function does not return until the erase operation has been completed.</param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, it can return one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BEGINNING_OF_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1102L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to access data before the beginning-of-medium marker failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BUS_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>1111L</term>
              </listheader>
            </list>
          </description>
          <description>A reset condition was detected on the bus.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_DEVICE_NOT_PARTITIONED</b>
                </term>
              </listheader>
              <listheader>
                <term>1107L</term>
              </listheader>
            </list>
          </description>
          <description>The partition information could not be found when a tape was being loaded.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_END_OF_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1100L</term>
              </listheader>
            </list>
          </description>
          <description>The end-of-tape marker was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_FILEMARK_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1101L</term>
              </listheader>
            </list>
          </description>
          <description>A filemark was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_BLOCK_LENGTH</b>
                </term>
              </listheader>
              <listheader>
                <term>1106L</term>
              </listheader>
            </list>
          </description>
          <description>The block size is incorrect on a new tape in a multivolume partition.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_MEDIA_CHANGED</b>
                </term>
              </listheader>
              <listheader>
                <term>1110L</term>
              </listheader>
            </list>
          </description>
          <description>The tape that was in the drive has been replaced or removed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NO_DATA_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1104L</term>
              </listheader>
            </list>
          </description>
          <description>The end-of-data marker was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NO_MEDIA_IN_DRIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>1112L</term>
              </listheader>
            </list>
          </description>
          <description>There is no media in the drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_SUPPORTED</b>
                </term>
              </listheader>
              <listheader>
                <term>50L</term>
              </listheader>
            </list>
          </description>
          <description>The tape driver does not support a requested function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PARTITION_FAILURE</b>
                </term>
              </listheader>
              <listheader>
                <term>1105L</term>
              </listheader>
            </list>
          </description>
          <description>The tape could not be partitioned.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_SETMARK_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1103L</term>
              </listheader>
            </list>
          </description>
          <description>A setmark was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_UNABLE_TO_LOCK_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1108L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to lock the ejection mechanism failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1109L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to unload the tape failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_WRITE_PROTECT</b>
                </term>
              </listheader>
              <listheader>
                <term>19L</term>
              </listheader>
            </list>
          </description>
          <description>The media is write protected.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.EscapeCommFunction">
    <summary>Directs the specified communications device to perform an extended function.</summary>
    <param name="hFile">A handle to the communications device. The<see cref="CreateFile" /> function returns this handle.</param>
    <param name="dwFunc">
      <para>The extended function to be performed. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CLRBREAK</b>
                </term>
              </listheader>
              <listheader>
                <term>9</term>
              </listheader>
            </list>
          </description>
          <description>Restores character transmission and places the transmission line in a nonbreak state. The CLRBREAK extended function code is identical to the <see cref="ClearCommBreak" /> function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CLRDTR</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>Clears the DTR (data-terminal-ready) signal.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CLRRTS</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>Clears the RTS (request-to-send) signal.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SETBREAK</b>
                </term>
              </listheader>
              <listheader>
                <term>8</term>
              </listheader>
            </list>
          </description>
          <description>Suspends character transmission and places the transmission line in a break state until the <see cref="ClearCommBreak" /> function is called (or <b>EscapeCommFunction</b> is called with the CLRBREAK extended function code). The SETBREAK extended function code is identical to the <see cref="SetCommBreak" /> function. Note that this extended function does not flush data that has not been transmitted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SETDTR</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>Sends the DTR (data-terminal-ready) signal.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SETRTS</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>Sends the RTS (request-to-send) signal.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SETXOFF</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>Causes transmission to act as if an XOFF character has been received.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SETXON</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>Causes transmission to act as if an XON character has been received.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ExecuteUmsThread">
    <summary>
      <para>Runs the specified UMS worker thread.</para>
      <blockquote>[!WARNING] As of Windows 11, user-mode scheduling is not supported. All calls fail with the error <code>ERROR_NOT_SUPPORTED</code>.</blockquote>
    </summary>
    <param name="UmsThread">A pointer to the UMS thread context of the worker thread to run.</param>
    <returns>
      <para>If the function succeeds, it does not return a value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. Possible error codes include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_RETRY</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified UMS worker thread is temporarily locked by the system. The caller can retry the operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_SUPPORTED</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>UMS is not supported.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.FatalExit">
    <summary>Transfers execution control to the debugger. The behavior of the debugger thereafter is specific to the type of debugger used.</summary>
    <param name="ExitCode">The error code associated with the exit.</param>
    <returns>This function does not return a value.</returns>
  </member>
  <member name="Windows.FileEncryptionStatus">
    <summary>Retrieves the encryption status of the specified file.</summary>
    <param name="lpFileName">The name of the file.</param>
    <param name="lpStatus">
      <para>A pointer to a variable that receives the encryption status of the file. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ENCRYPTABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The file can be encrypted. <para><b>Home, Home Premium, Starter, and ARM Editions of Windows:  </b><b>FILE_ENCRYPTABLE</b> may be returned but EFS does not support encrypting files on these editions of Windows.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_IS_ENCRYPTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>The file is encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_READ_ONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>8</term>
              </listheader>
            </list>
          </description>
          <description>The file is a read-only file.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ROOT_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>The file is a root directory. Root directories cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SYSTEM_ATTR</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>The file is a system file. System files cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SYSTEM_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>The file is a system directory. System directories cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SYSTEM_NOT_SUPPORT</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>The file system does not support file encryption.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_UNKNOWN</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>The encryption status is unknown. The file may be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_USER_DISALLOWED</b>
                </term>
              </listheader>
              <listheader>
                <term>7</term>
              </listheader>
            </list>
          </description>
          <description>Reserved for future use.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FileEncryptionStatusA">
    <summary>Retrieves the encryption status of the specified file.</summary>
    <param name="lpFileName">The name of the file.</param>
    <param name="lpStatus">
      <para>A pointer to a variable that receives the encryption status of the file. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ENCRYPTABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The file can be encrypted. <para><b>Home, Home Premium, Starter, and ARM Editions of Windows:  </b><b>FILE_ENCRYPTABLE</b> may be returned but EFS does not support encrypting files on these editions of Windows.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_IS_ENCRYPTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>The file is encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_READ_ONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>8</term>
              </listheader>
            </list>
          </description>
          <description>The file is a read-only file.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ROOT_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>The file is a root directory. Root directories cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SYSTEM_ATTR</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>The file is a system file. System files cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SYSTEM_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>The file is a system directory. System directories cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SYSTEM_NOT_SUPPORT</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>The file system does not support file encryption.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_UNKNOWN</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>The encryption status is unknown. The file may be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_USER_DISALLOWED</b>
                </term>
              </listheader>
              <listheader>
                <term>7</term>
              </listheader>
            </list>
          </description>
          <description>Reserved for future use.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FileEncryptionStatusW">
    <summary>Retrieves the encryption status of the specified file.</summary>
    <param name="lpFileName">The name of the file.</param>
    <param name="lpStatus">
      <para>A pointer to a variable that receives the encryption status of the file. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ENCRYPTABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The file can be encrypted. <para><b>Home, Home Premium, Starter, and ARM Editions of Windows:  </b><b>FILE_ENCRYPTABLE</b> may be returned but EFS does not support encrypting files on these editions of Windows.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_IS_ENCRYPTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>The file is encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_READ_ONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>8</term>
              </listheader>
            </list>
          </description>
          <description>The file is a read-only file.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ROOT_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>The file is a root directory. Root directories cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SYSTEM_ATTR</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>The file is a system file. System files cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SYSTEM_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>The file is a system directory. System directories cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SYSTEM_NOT_SUPPORT</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>The file system does not support file encryption.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_UNKNOWN</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>The encryption status is unknown. The file may be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_USER_DISALLOWED</b>
                </term>
              </listheader>
              <listheader>
                <term>7</term>
              </listheader>
            </list>
          </description>
          <description>Reserved for future use.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FileEncryptionStatus">
    <summary>Retrieves the encryption status of the specified file.</summary>
    <param name="lpFileName">The name of the file.</param>
    <param name="lpStatus">
      <para>A pointer to a variable that receives the encryption status of the file. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ENCRYPTABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The file can be encrypted. <para><b>Home, Home Premium, Starter, and ARM Editions of Windows:  </b><b>FILE_ENCRYPTABLE</b> may be returned but EFS does not support encrypting files on these editions of Windows.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_IS_ENCRYPTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>The file is encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_READ_ONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>8</term>
              </listheader>
            </list>
          </description>
          <description>The file is a read-only file.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ROOT_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>The file is a root directory. Root directories cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SYSTEM_ATTR</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>The file is a system file. System files cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SYSTEM_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>The file is a system directory. System directories cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SYSTEM_NOT_SUPPORT</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>The file system does not support file encryption.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_UNKNOWN</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>The encryption status is unknown. The file may be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_USER_DISALLOWED</b>
                </term>
              </listheader>
              <listheader>
                <term>7</term>
              </listheader>
            </list>
          </description>
          <description>Reserved for future use.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FileEncryptionStatusA">
    <summary>Retrieves the encryption status of the specified file.</summary>
    <param name="lpFileName">The name of the file.</param>
    <param name="lpStatus">
      <para>A pointer to a variable that receives the encryption status of the file. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ENCRYPTABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The file can be encrypted. <para><b>Home, Home Premium, Starter, and ARM Editions of Windows:  </b><b>FILE_ENCRYPTABLE</b> may be returned but EFS does not support encrypting files on these editions of Windows.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_IS_ENCRYPTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>The file is encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_READ_ONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>8</term>
              </listheader>
            </list>
          </description>
          <description>The file is a read-only file.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ROOT_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>The file is a root directory. Root directories cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SYSTEM_ATTR</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>The file is a system file. System files cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SYSTEM_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>The file is a system directory. System directories cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SYSTEM_NOT_SUPPORT</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>The file system does not support file encryption.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_UNKNOWN</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>The encryption status is unknown. The file may be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_USER_DISALLOWED</b>
                </term>
              </listheader>
              <listheader>
                <term>7</term>
              </listheader>
            </list>
          </description>
          <description>Reserved for future use.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FileEncryptionStatusW">
    <summary>Retrieves the encryption status of the specified file.</summary>
    <param name="lpFileName">The name of the file.</param>
    <param name="lpStatus">
      <para>A pointer to a variable that receives the encryption status of the file. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ENCRYPTABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The file can be encrypted. <para><b>Home, Home Premium, Starter, and ARM Editions of Windows:  </b><b>FILE_ENCRYPTABLE</b> may be returned but EFS does not support encrypting files on these editions of Windows.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_IS_ENCRYPTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>The file is encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_READ_ONLY</b>
                </term>
              </listheader>
              <listheader>
                <term>8</term>
              </listheader>
            </list>
          </description>
          <description>The file is a read-only file.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_ROOT_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>The file is a root directory. Root directories cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SYSTEM_ATTR</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>The file is a system file. System files cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SYSTEM_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>The file is a system directory. System directories cannot be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SYSTEM_NOT_SUPPORT</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>The file system does not support file encryption.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_UNKNOWN</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>The encryption status is unknown. The file may be encrypted.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_USER_DISALLOWED</b>
                </term>
              </listheader>
              <listheader>
                <term>7</term>
              </listheader>
            </list>
          </description>
          <description>Reserved for future use.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FileTimeToDosDateTime">
    <summary>Converts a file time to MS-DOS date and time values.</summary>
    <param name="lpFileTime">A pointer to a<see cref="FILETIME" /> structure containing the file time to convert to MS-DOS date and time format.</param>
    <param name="lpFatDate">
      <para>A pointer to a variable to receive the MS-DOS date. The date is a packed value with the following format.</para>
      <list type="table">
        <listheader>
          <description>Bits</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>0–4</description>
          <description>Day of the month (1–31)</description>
        </listheader>
        <listheader>
          <description>5–8</description>
          <description>Month (1 = January, 2 = February, etc.)</description>
        </listheader>
        <listheader>
          <description>9-15</description>
          <description>Year offset from 1980 (add 1980 to get actual year)</description>
        </listheader>
      </list>
    </param>
    <param name="lpFatTime">
      <para>A pointer to a variable to receive the MS-DOS time. The time is a packed value with the following format.</para>
      <list type="table">
        <listheader>
          <description>Bits</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>0–4</description>
          <description>Second divided by 2</description>
        </listheader>
        <listheader>
          <description>5–10</description>
          <description>Minute (0–59)</description>
        </listheader>
        <listheader>
          <description>11–15</description>
          <description>Hour (0–23 on a 24-hour clock)</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindActCtxSectionGuid">
    <summary>The<b>FindActCtxSectionGuid</b> function retrieves information on a specific GUID in the current activation context and returns a<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure.</summary>
    <param name="dwFlags">
      <para>Flags that determine how this function is to operate. Only the following flag is currently defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This function returns the activation context handle where the redirection data was found in the <b>hActCtx</b> member of the <see cref="ACTCTX_SECTION_KEYED_DATA" /> structure. The caller must use <see cref="ReleaseActCtx" /> to release this activation context.</description>
        </listheader>
      </list>
    </param>
    <param name="lpExtensionGuid">Reserved; must be null.</param>
    <param name="ulSectionId">
      <para>Identifier of the section of the activation context in which to search for the specified GUID.</para>
      <para>The following are valid GUID section identifiers:</para>
      <list type="bullet">
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION</description>
        </item>
      </list>The following is a valid GUID section identifier beginning with Windows Server 2003 and Windows XP with SP1:<list type="bullet"><item><description>ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES</description></item></list></param>
    <param name="lpGuidToFind">Pointer to a GUID to be used as the search criteria.</param>
    <param name="ReturnedData">Pointer to an<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure to be filled out with the requested GUID information.</param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling<see cref="GetLastError" />. For an example, see<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
  </member>
  <member name="Windows.FindActCtxSectionString">
    <summary>The<b>FindActCtxSectionString</b> function retrieves information on a specific string in the current activation context and returns a<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure.</summary>
    <param name="dwFlags">
      <para>Flags that determine how this function is to operate. Only the following flag is currently defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This function returns the activation context handle where the redirection data was found in the <b>hActCtx</b> member of the <see cref="ACTCTX_SECTION_KEYED_DATA" /> structure. The caller must use <see cref="ReleaseActCtx" /> to release this activation context.</description>
        </listheader>
      </list>
    </param>
    <param name="lpExtensionGuid">Reserved; must be null.</param>
    <param name="ulSectionId">
      <para>Identifier of the string section of the activation context in which to search for the specific string.</para>
      <para>The following are valid string section identifiers:</para>
      <list type="bullet">
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION</description>
        </item>
      </list>
    </param>
    <param name="lpStringToFind">Pointer to a null-terminated string to be used as the search criteria.</param>
    <param name="ReturnedData">Pointer to an<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure to be filled out with the requested string information.</param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling<see cref="GetLastError" />. For an example, see<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
  </member>
  <member name="Windows.FindActCtxSectionStringA">
    <summary>The<b>FindActCtxSectionString</b> function retrieves information on a specific string in the current activation context and returns a<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure.</summary>
    <param name="dwFlags">
      <para>Flags that determine how this function is to operate. Only the following flag is currently defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This function returns the activation context handle where the redirection data was found in the <b>hActCtx</b> member of the <see cref="ACTCTX_SECTION_KEYED_DATA" /> structure. The caller must use <see cref="ReleaseActCtx" /> to release this activation context.</description>
        </listheader>
      </list>
    </param>
    <param name="lpExtensionGuid">Reserved; must be null.</param>
    <param name="ulSectionId">
      <para>Identifier of the string section of the activation context in which to search for the specific string.</para>
      <para>The following are valid string section identifiers:</para>
      <list type="bullet">
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION</description>
        </item>
      </list>
    </param>
    <param name="lpStringToFind">Pointer to a null-terminated string to be used as the search criteria.</param>
    <param name="ReturnedData">Pointer to an<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure to be filled out with the requested string information.</param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling<see cref="GetLastError" />. For an example, see<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
  </member>
  <member name="Windows.FindActCtxSectionStringW">
    <summary>The<b>FindActCtxSectionString</b> function retrieves information on a specific string in the current activation context and returns a<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure.</summary>
    <param name="dwFlags">
      <para>Flags that determine how this function is to operate. Only the following flag is currently defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This function returns the activation context handle where the redirection data was found in the <b>hActCtx</b> member of the <see cref="ACTCTX_SECTION_KEYED_DATA" /> structure. The caller must use <see cref="ReleaseActCtx" /> to release this activation context.</description>
        </listheader>
      </list>
    </param>
    <param name="lpExtensionGuid">Reserved; must be null.</param>
    <param name="ulSectionId">
      <para>Identifier of the string section of the activation context in which to search for the specific string.</para>
      <para>The following are valid string section identifiers:</para>
      <list type="bullet">
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION</description>
        </item>
      </list>
    </param>
    <param name="lpStringToFind">Pointer to a null-terminated string to be used as the search criteria.</param>
    <param name="ReturnedData">Pointer to an<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure to be filled out with the requested string information.</param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling<see cref="GetLastError" />. For an example, see<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
  </member>
  <member name="Windows.FindActCtxSectionString">
    <summary>The<b>FindActCtxSectionString</b> function retrieves information on a specific string in the current activation context and returns a<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure.</summary>
    <param name="dwFlags">
      <para>Flags that determine how this function is to operate. Only the following flag is currently defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This function returns the activation context handle where the redirection data was found in the <b>hActCtx</b> member of the <see cref="ACTCTX_SECTION_KEYED_DATA" /> structure. The caller must use <see cref="ReleaseActCtx" /> to release this activation context.</description>
        </listheader>
      </list>
    </param>
    <param name="lpExtensionGuid">Reserved; must be null.</param>
    <param name="ulSectionId">
      <para>Identifier of the string section of the activation context in which to search for the specific string.</para>
      <para>The following are valid string section identifiers:</para>
      <list type="bullet">
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION</description>
        </item>
      </list>
    </param>
    <param name="lpStringToFind">Pointer to a null-terminated string to be used as the search criteria.</param>
    <param name="ReturnedData">Pointer to an<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure to be filled out with the requested string information.</param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling<see cref="GetLastError" />. For an example, see<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
  </member>
  <member name="Windows.FindActCtxSectionStringA">
    <summary>The<b>FindActCtxSectionString</b> function retrieves information on a specific string in the current activation context and returns a<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure.</summary>
    <param name="dwFlags">
      <para>Flags that determine how this function is to operate. Only the following flag is currently defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This function returns the activation context handle where the redirection data was found in the <b>hActCtx</b> member of the <see cref="ACTCTX_SECTION_KEYED_DATA" /> structure. The caller must use <see cref="ReleaseActCtx" /> to release this activation context.</description>
        </listheader>
      </list>
    </param>
    <param name="lpExtensionGuid">Reserved; must be null.</param>
    <param name="ulSectionId">
      <para>Identifier of the string section of the activation context in which to search for the specific string.</para>
      <para>The following are valid string section identifiers:</para>
      <list type="bullet">
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION</description>
        </item>
      </list>
    </param>
    <param name="lpStringToFind">Pointer to a null-terminated string to be used as the search criteria.</param>
    <param name="ReturnedData">Pointer to an<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure to be filled out with the requested string information.</param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling<see cref="GetLastError" />. For an example, see<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
  </member>
  <member name="Windows.FindActCtxSectionStringW">
    <summary>The<b>FindActCtxSectionString</b> function retrieves information on a specific string in the current activation context and returns a<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure.</summary>
    <param name="dwFlags">
      <para>Flags that determine how this function is to operate. Only the following flag is currently defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This function returns the activation context handle where the redirection data was found in the <b>hActCtx</b> member of the <see cref="ACTCTX_SECTION_KEYED_DATA" /> structure. The caller must use <see cref="ReleaseActCtx" /> to release this activation context.</description>
        </listheader>
      </list>
    </param>
    <param name="lpExtensionGuid">Reserved; must be null.</param>
    <param name="ulSectionId">
      <para>Identifier of the string section of the activation context in which to search for the specific string.</para>
      <para>The following are valid string section identifiers:</para>
      <list type="bullet">
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION</description>
        </item>
        <item>
          <description>ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION</description>
        </item>
      </list>
    </param>
    <param name="lpStringToFind">Pointer to a null-terminated string to be used as the search criteria.</param>
    <param name="ReturnedData">Pointer to an<see cref="ACTCTX_SECTION_KEYED_DATA" /> structure to be filled out with the requested string information.</param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling<see cref="GetLastError" />. For an example, see<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
  </member>
  <member name="Windows.FindAtom">
    <summary>Searches the local atom table for the specified character string and retrieves the atom associated with that string.</summary>
    <param name="lpString">
      <para>The character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindAtomA">
    <summary>Searches the local atom table for the specified character string and retrieves the atom associated with that string.</summary>
    <param name="lpString">
      <para>The character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindAtomW">
    <summary>Searches the local atom table for the specified character string and retrieves the atom associated with that string.</summary>
    <param name="lpString">
      <para>The character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindAtom">
    <summary>Searches the local atom table for the specified character string and retrieves the atom associated with that string.</summary>
    <param name="lpString">
      <para>The character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindAtomA">
    <summary>Searches the local atom table for the specified character string and retrieves the atom associated with that string.</summary>
    <param name="lpString">
      <para>The character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindAtomW">
    <summary>Searches the local atom table for the specified character string and retrieves the atom associated with that string.</summary>
    <param name="lpString">
      <para>The character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstVolume">
    <summary>Retrieves the name of a volume on a computer. <b>FindFirstVolume</b> is used to begin scanning the volumes of a computer.</summary>
    <param name="lpszVolumeName">A pointer to a buffer that receives a null-terminated string that specifies a volume<b>GUID</b> path for the first volume that is found.</param>
    <param name="cchBufferLength">The length of the buffer to receive the volume <b>GUID</b> path, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the<see cref="FindNextVolume" /> and<see cref="FindVolumeClose" /> functions.</para>
      <para>If the function fails to find any volumes, the return value is the<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstVolumeA">
    <summary>Retrieves the name of a volume on a computer. <b>FindFirstVolume</b> is used to begin scanning the volumes of a computer.</summary>
    <param name="lpszVolumeName">A pointer to a buffer that receives a null-terminated string that specifies a volume<b>GUID</b> path for the first volume that is found.</param>
    <param name="cchBufferLength">The length of the buffer to receive the volume <b>GUID</b> path, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the<see cref="FindNextVolume" /> and<see cref="FindVolumeClose" /> functions.</para>
      <para>If the function fails to find any volumes, the return value is the<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstVolumeW">
    <summary>Retrieves the name of a volume on a computer. <b>FindFirstVolume</b> is used to begin scanning the volumes of a computer.</summary>
    <param name="lpszVolumeName">A pointer to a buffer that receives a null-terminated string that specifies a volume<b>GUID</b> path for the first volume that is found.</param>
    <param name="cchBufferLength">The length of the buffer to receive the volume <b>GUID</b> path, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the<see cref="FindNextVolume" /> and<see cref="FindVolumeClose" /> functions.</para>
      <para>If the function fails to find any volumes, the return value is the<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstVolumeMountPoint">
    <summary>Retrieves the name of a mounted folder on the specified volume. <b>FindFirstVolumeMountPoint</b> is used to begin scanning the mounted folders on a volume.</summary>
    <param name="lpszRootPathName">A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required.</param>
    <param name="lpszVolumeMountPoint">A pointer to a buffer that receives the name of the first mounted folder that is found.</param>
    <param name="cchBufferLength">The length of the buffer that receives the path to the mounted folder, in<b>TCHAR</b>s.</param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the<see cref="FindNextVolumeMountPoint" /> and<see cref="FindVolumeMountPointClose" /> functions.</para>
      <para>If the function fails to find a mounted folder on the volume, the return value is the<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstVolumeMountPointA">
    <summary>Retrieves the name of a mounted folder on the specified volume. <b>FindFirstVolumeMountPoint</b> is used to begin scanning the mounted folders on a volume.</summary>
    <param name="lpszRootPathName">A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required.</param>
    <param name="lpszVolumeMountPoint">A pointer to a buffer that receives the name of the first mounted folder that is found.</param>
    <param name="cchBufferLength">The length of the buffer that receives the path to the mounted folder, in<b>TCHAR</b>s.</param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the<see cref="FindNextVolumeMountPoint" /> and<see cref="FindVolumeMountPointClose" /> functions.</para>
      <para>If the function fails to find a mounted folder on the volume, the return value is the<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstVolumeMountPointW">
    <summary>Retrieves the name of a mounted folder on the specified volume. <b>FindFirstVolumeMountPoint</b> is used to begin scanning the mounted folders on a volume.</summary>
    <param name="lpszRootPathName">A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required.</param>
    <param name="lpszVolumeMountPoint">A pointer to a buffer that receives the name of the first mounted folder that is found.</param>
    <param name="cchBufferLength">The length of the buffer that receives the path to the mounted folder, in<b>TCHAR</b>s.</param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the<see cref="FindNextVolumeMountPoint" /> and<see cref="FindVolumeMountPointClose" /> functions.</para>
      <para>If the function fails to find a mounted folder on the volume, the return value is the<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstVolumeMountPoint">
    <summary>Retrieves the name of a mounted folder on the specified volume. <b>FindFirstVolumeMountPoint</b> is used to begin scanning the mounted folders on a volume.</summary>
    <param name="lpszRootPathName">A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required.</param>
    <param name="lpszVolumeMountPoint">A pointer to a buffer that receives the name of the first mounted folder that is found.</param>
    <param name="cchBufferLength">The length of the buffer that receives the path to the mounted folder, in<b>TCHAR</b>s.</param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the<see cref="FindNextVolumeMountPoint" /> and<see cref="FindVolumeMountPointClose" /> functions.</para>
      <para>If the function fails to find a mounted folder on the volume, the return value is the<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstVolumeMountPointA">
    <summary>Retrieves the name of a mounted folder on the specified volume. <b>FindFirstVolumeMountPoint</b> is used to begin scanning the mounted folders on a volume.</summary>
    <param name="lpszRootPathName">A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required.</param>
    <param name="lpszVolumeMountPoint">A pointer to a buffer that receives the name of the first mounted folder that is found.</param>
    <param name="cchBufferLength">The length of the buffer that receives the path to the mounted folder, in<b>TCHAR</b>s.</param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the<see cref="FindNextVolumeMountPoint" /> and<see cref="FindVolumeMountPointClose" /> functions.</para>
      <para>If the function fails to find a mounted folder on the volume, the return value is the<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindFirstVolumeMountPointW">
    <summary>Retrieves the name of a mounted folder on the specified volume. <b>FindFirstVolumeMountPoint</b> is used to begin scanning the mounted folders on a volume.</summary>
    <param name="lpszRootPathName">A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required.</param>
    <param name="lpszVolumeMountPoint">A pointer to a buffer that receives the name of the first mounted folder that is found.</param>
    <param name="cchBufferLength">The length of the buffer that receives the path to the mounted folder, in<b>TCHAR</b>s.</param>
    <returns>
      <para>If the function succeeds, the return value is a search handle used in a subsequent call to the<see cref="FindNextVolumeMountPoint" /> and<see cref="FindVolumeMountPointClose" /> functions.</para>
      <para>If the function fails to find a mounted folder on the volume, the return value is the<b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindNextVolume">
    <summary>Continues a volume search started by a call to the<see cref="FindFirstVolume" /> function. <b>FindNextVolume</b> finds one volume per call.</summary>
    <param name="hFindVolume">The volume search handle returned by a previous call to the<see cref="FindFirstVolume" /> function.</param>
    <param name="lpszVolumeName">A pointer to a string that receives the volume <b>GUID</b> path that is found.</param>
    <param name="cchBufferLength">The length of the buffer that receives the volume <b>GUID</b> path, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If no matching files can be found, the<b>GetLastError</b> function returns the<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the<see cref="FindVolumeClose" /> function.</para>
    </returns>
  </member>
  <member name="Windows.FindNextVolumeA">
    <summary>Continues a volume search started by a call to the<see cref="FindFirstVolume" /> function. <b>FindNextVolume</b> finds one volume per call.</summary>
    <param name="hFindVolume">The volume search handle returned by a previous call to the<see cref="FindFirstVolume" /> function.</param>
    <param name="lpszVolumeName">A pointer to a string that receives the volume <b>GUID</b> path that is found.</param>
    <param name="cchBufferLength">The length of the buffer that receives the volume <b>GUID</b> path, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If no matching files can be found, the<b>GetLastError</b> function returns the<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the<see cref="FindVolumeClose" /> function.</para>
    </returns>
  </member>
  <member name="Windows.FindNextVolumeW">
    <summary>Continues a volume search started by a call to the<see cref="FindFirstVolume" /> function. <b>FindNextVolume</b> finds one volume per call.</summary>
    <param name="hFindVolume">The volume search handle returned by a previous call to the<see cref="FindFirstVolume" /> function.</param>
    <param name="lpszVolumeName">A pointer to a string that receives the volume <b>GUID</b> path that is found.</param>
    <param name="cchBufferLength">The length of the buffer that receives the volume <b>GUID</b> path, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If no matching files can be found, the<b>GetLastError</b> function returns the<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the<see cref="FindVolumeClose" /> function.</para>
    </returns>
  </member>
  <member name="Windows.FindNextVolumeMountPoint">
    <summary>Continues a mounted folder search started by a call to the<see cref="FindFirstVolumeMountPoint" />function. <b>FindNextVolumeMountPoint</b> finds one mounted folder per call.</summary>
    <param name="hFindVolumeMountPoint">A mounted folder search handle returned by a previous call to the<see cref="FindFirstVolumeMountPoint" /> function.</param>
    <param name="lpszVolumeMountPoint">A pointer to a buffer that receives the name of the mounted folder that is found.</param>
    <param name="cchBufferLength">The length of the buffer that receives the mounted folder name, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If no more mounted folders can be found, the <b>GetLastError</b> function returns the<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the<see cref="FindVolumeMountPointClose" /> function.</para>
    </returns>
  </member>
  <member name="Windows.FindNextVolumeMountPointA">
    <summary>Continues a mounted folder search started by a call to the<see cref="FindFirstVolumeMountPoint" />function. <b>FindNextVolumeMountPoint</b> finds one mounted folder per call.</summary>
    <param name="hFindVolumeMountPoint">A mounted folder search handle returned by a previous call to the<see cref="FindFirstVolumeMountPoint" /> function.</param>
    <param name="lpszVolumeMountPoint">A pointer to a buffer that receives the name of the mounted folder that is found.</param>
    <param name="cchBufferLength">The length of the buffer that receives the mounted folder name, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If no more mounted folders can be found, the <b>GetLastError</b> function returns the<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the<see cref="FindVolumeMountPointClose" /> function.</para>
    </returns>
  </member>
  <member name="Windows.FindNextVolumeMountPointW">
    <summary>Continues a mounted folder search started by a call to the<see cref="FindFirstVolumeMountPoint" />function. <b>FindNextVolumeMountPoint</b> finds one mounted folder per call.</summary>
    <param name="hFindVolumeMountPoint">A mounted folder search handle returned by a previous call to the<see cref="FindFirstVolumeMountPoint" /> function.</param>
    <param name="lpszVolumeMountPoint">A pointer to a buffer that receives the name of the mounted folder that is found.</param>
    <param name="cchBufferLength">The length of the buffer that receives the mounted folder name, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If no more mounted folders can be found, the <b>GetLastError</b> function returns the<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the<see cref="FindVolumeMountPointClose" /> function.</para>
    </returns>
  </member>
  <member name="Windows.FindNextVolumeMountPoint">
    <summary>Continues a mounted folder search started by a call to the<see cref="FindFirstVolumeMountPoint" />function. <b>FindNextVolumeMountPoint</b> finds one mounted folder per call.</summary>
    <param name="hFindVolumeMountPoint">A mounted folder search handle returned by a previous call to the<see cref="FindFirstVolumeMountPoint" /> function.</param>
    <param name="lpszVolumeMountPoint">A pointer to a buffer that receives the name of the mounted folder that is found.</param>
    <param name="cchBufferLength">The length of the buffer that receives the mounted folder name, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If no more mounted folders can be found, the <b>GetLastError</b> function returns the<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the<see cref="FindVolumeMountPointClose" /> function.</para>
    </returns>
  </member>
  <member name="Windows.FindNextVolumeMountPointA">
    <summary>Continues a mounted folder search started by a call to the<see cref="FindFirstVolumeMountPoint" />function. <b>FindNextVolumeMountPoint</b> finds one mounted folder per call.</summary>
    <param name="hFindVolumeMountPoint">A mounted folder search handle returned by a previous call to the<see cref="FindFirstVolumeMountPoint" /> function.</param>
    <param name="lpszVolumeMountPoint">A pointer to a buffer that receives the name of the mounted folder that is found.</param>
    <param name="cchBufferLength">The length of the buffer that receives the mounted folder name, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If no more mounted folders can be found, the <b>GetLastError</b> function returns the<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the<see cref="FindVolumeMountPointClose" /> function.</para>
    </returns>
  </member>
  <member name="Windows.FindNextVolumeMountPointW">
    <summary>Continues a mounted folder search started by a call to the<see cref="FindFirstVolumeMountPoint" />function. <b>FindNextVolumeMountPoint</b> finds one mounted folder per call.</summary>
    <param name="hFindVolumeMountPoint">A mounted folder search handle returned by a previous call to the<see cref="FindFirstVolumeMountPoint" /> function.</param>
    <param name="lpszVolumeMountPoint">A pointer to a buffer that receives the name of the mounted folder that is found.</param>
    <param name="cchBufferLength">The length of the buffer that receives the mounted folder name, in<b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If no more mounted folders can be found, the <b>GetLastError</b> function returns the<b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the<see cref="FindVolumeMountPointClose" /> function.</para>
    </returns>
  </member>
  <member name="Windows.FindResource">
    <summary>
      <para>Determines the location of a resource with the specified type and name in the specified module.</para>
      <para>To specify a language, use the <see cref="FindResourceEx" /> function.</para>
    </summary>
    <param name="hModule">A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is <b>NULL</b>, the function searches the module used to create the current process.</param>
    <param name="lpName">The name of the resource. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</param>
    <param name="lpType">The resource type. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the given resource type. For standard resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more information, see the Remarks section below.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a handle to the resource, pass this handle to the <see cref="LoadResource" /> function.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindResourceA">
    <summary>
      <para>Determines the location of a resource with the specified type and name in the specified module.</para>
      <para>To specify a language, use the <see cref="FindResourceEx" /> function.</para>
    </summary>
    <param name="hModule">A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is <b>NULL</b>, the function searches the module used to create the current process.</param>
    <param name="lpName">The name of the resource. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</param>
    <param name="lpType">The resource type. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the given resource type. For standard resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more information, see the Remarks section below.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a handle to the resource, pass this handle to the <see cref="LoadResource" /> function.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindResourceW">
    <summary>
      <para>Determines the location of a resource with the specified type and name in the specified module.</para>
      <para>To specify a language, use the <see cref="FindResourceEx" /> function.</para>
    </summary>
    <param name="hModule">A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is <b>NULL</b>, the function searches the module used to create the current process.</param>
    <param name="lpName">The name of the resource. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</param>
    <param name="lpType">The resource type. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the given resource type. For standard resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more information, see the Remarks section below.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a handle to the resource, pass this handle to the <see cref="LoadResource" /> function.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindResourceEx">
    <summary>Determines the location of the resource with the specified type, name, and language in the specified module.</summary>
    <param name="hModule">A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is <b>NULL</b>, the function searches the module used to create the current process.</param>
    <param name="lpType">
      <para>The resource type. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the given</para>
      <para>resource type. For standard resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpName">The name of the resource. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</param>
    <param name="wLanguage">
      <para>The language of the resource. If this parameter is <code>MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)</code>, the current language associated with the calling thread is used.</para>
      <para>To specify a language other than the current language, use the <see cref="MAKELANGID" /> macro to create this parameter. For more information, see <b>MAKELANGID</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a handle to the resource, pass this handle to the <see cref="LoadResource" /> function.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindResourceExA">
    <summary>Determines the location of the resource with the specified type, name, and language in the specified module.</summary>
    <param name="hModule">A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is <b>NULL</b>, the function searches the module used to create the current process.</param>
    <param name="lpType">
      <para>The resource type. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the given</para>
      <para>resource type. For standard resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpName">The name of the resource. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</param>
    <param name="wLanguage">
      <para>The language of the resource. If this parameter is <code>MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)</code>, the current language associated with the calling thread is used.</para>
      <para>To specify a language other than the current language, use the <see cref="MAKELANGID" /> macro to create this parameter. For more information, see <b>MAKELANGID</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a handle to the resource, pass this handle to the <see cref="LoadResource" /> function.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindResourceExW">
    <summary>Determines the location of the resource with the specified type, name, and language in the specified module.</summary>
    <param name="hModule">A handle to the module whose portable executable file or an accompanying MUI file contains the resource. If this parameter is <b>NULL</b>, the function searches the module used to create the current process.</param>
    <param name="lpType">
      <para>The resource type. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the given</para>
      <para>resource type. For standard resource types, see <a href="https://docs.microsoft.com//windows/desktop/menurc/resource-types">Resource Types</a>. For more information, see the Remarks section below.</para>
    </param>
    <param name="lpName">The name of the resource. Alternately, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is the integer identifier of the resource. For more information, see the Remarks section below.</param>
    <param name="wLanguage">
      <para>The language of the resource. If this parameter is <code>MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)</code>, the current language associated with the calling thread is used.</para>
      <para>To specify a language other than the current language, use the <see cref="MAKELANGID" /> macro to create this parameter. For more information, see <b>MAKELANGID</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a handle to the resource, pass this handle to the <see cref="LoadResource" /> function.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.FindVolumeMountPointClose">
    <summary>Closes the specified mounted folder search handle. The<see cref="FindFirstVolumeMountPoint" /> and<see cref="FindNextVolumeMountPoint" /> functions use this search handle to locate mounted folders on a specified volume.</summary>
    <param name="hFindVolumeMountPoint">The mounted folder search handle to be closed. This handle must have been previously opened by the<see cref="FindFirstVolumeMountPoint" /> function.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetActiveProcessorCount">
    <summary>Returns the number of active processors in a processor group or in the system.</summary>
    <param name="GroupNumber">The processor group number. If this parameter is ALL_PROCESSOR_GROUPS, the function returns the number of active processors in the system.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of active processors in the specified group.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetActiveProcessorGroupCount">
    <summary>Returns the number of active processor groups in the system.</summary>
    <returns>
      <para>If the function succeeds, the return value is the number of active processor groups in the system.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.GetApplicationRecoveryCallback">
    <summary>Retrieves a pointer to the callback routine registered for the specified process. The address returned is in the virtual address space of the process.</summary>
    <param name="hProcess">A handle to the process. This handle must have the PROCESS_VM_READ access right.</param>
    <param name="pRecoveryCallback">A pointer to the recovery callback function. For more information, see <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa373202(v=vs.85)">ApplicationRecoveryCallback</a>.</param>
    <param name="ppvParameter">A pointer to the callback parameter.</param>
    <param name="pdwPingInterval">The recovery ping interval, in 100-nanosecond intervals.</param>
    <param name="pdwFlags">Reserved for future use.</param>
    <returns>
      <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>S_FALSE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The application did not register for recovery.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>E_INVALIDARG</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One or more parameters are not valid.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetApplicationRestartSettings">
    <summary>Retrieves the restart information registered for the specified process.</summary>
    <param name="hProcess">A handle to the process. This handle must have the PROCESS_VM_READ access right.</param>
    <param name="pwzCommandline">A pointer to a buffer that receives the restart command line specified by the application when it called the <see cref="RegisterApplicationRestart" /> function. The maximum size of the command line, in characters, is RESTART_MAX_CMD_LINE. Can be <b>NULL</b> if <i>pcchSize</i> is zero.</param>
    <param name="pcchSize">
      <para>On input, specifies the size of the <i>pwzCommandLine</i> buffer, in characters.</para>
      <para>If the buffer is not large enough to receive the command line, the function fails with HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) and sets this parameter to the required buffer size, in characters.</para>
      <para>On output, specifies the size of the buffer that was used.</para>
      <para>To determine the required buffer size, set <i>pwzCommandLine</i> to <b>NULL</b> and this parameter to zero. The size includes one for the <b>null</b>-terminator character. Note that the function returns S_OK, not HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) in this case.</para>
    </param>
    <param name="pdwFlags">A pointer to a variable that receives the flags specified by the application when it called the <see cref="RegisterApplicationRestart" /> function.</param>
    <returns>
      <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>E_INVALIDARG</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One or more parameters are not valid.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>HRESULT_FROM_WIN32(ERROR_NOT_FOUND)</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The application did not register for restart.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The <i>pwzCommandLine</i> buffer is too small. The function returns the required buffer size in <i>pcchSize</i>. Use the required size to reallocate the buffer.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetAtomName">
    <summary>Retrieves a copy of the character string associated with the specified local atom.</summary>
    <param name="nAtom">The local atom that identifies the character string to be retrieved.</param>
    <param name="lpBuffer">The character string.</param>
    <param name="nSize">The size, in characters, of the buffer.</param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetAtomNameA">
    <summary>Retrieves a copy of the character string associated with the specified local atom.</summary>
    <param name="nAtom">The local atom that identifies the character string to be retrieved.</param>
    <param name="lpBuffer">The character string.</param>
    <param name="nSize">The size, in characters, of the buffer.</param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetAtomNameW">
    <summary>Retrieves a copy of the character string associated with the specified local atom.</summary>
    <param name="nAtom">The local atom that identifies the character string to be retrieved.</param>
    <param name="lpBuffer">The character string.</param>
    <param name="nSize">The size, in characters, of the buffer.</param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetAtomName">
    <summary>Retrieves a copy of the character string associated with the specified local atom.</summary>
    <param name="nAtom">The local atom that identifies the character string to be retrieved.</param>
    <param name="lpBuffer">The character string.</param>
    <param name="nSize">The size, in characters, of the buffer.</param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetAtomNameA">
    <summary>Retrieves a copy of the character string associated with the specified local atom.</summary>
    <param name="nAtom">The local atom that identifies the character string to be retrieved.</param>
    <param name="lpBuffer">The character string.</param>
    <param name="nSize">The size, in characters, of the buffer.</param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetAtomNameW">
    <summary>Retrieves a copy of the character string associated with the specified local atom.</summary>
    <param name="nAtom">The local atom that identifies the character string to be retrieved.</param>
    <param name="lpBuffer">The character string.</param>
    <param name="nSize">The size, in characters, of the buffer.</param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetBinaryType">
    <summary>Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable file.</summary>
    <param name="lpApplicationName">
      <para>The full path of the file whose executable type is to be determined.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpBinaryType">
      <para>A pointer to a variable to receive information about the executable type of the file specified by<i>lpApplicationName</i>. The following constants are defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_32BIT_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>A 32-bit Windows-based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_64BIT_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>A 64-bit Windows-based application.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_DOS_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>An MS-DOS – based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_OS216_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>A 16-bit OS/2-based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_PIF_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>A PIF file that executes an MS-DOS – based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_POSIX_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>A POSIX – based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_WOW_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>A 16-bit Windows-based application</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the file is executable, the return value is nonzero. The function sets the variable pointed to by<i>lpBinaryType</i> to indicate the file's executable type.</para>
      <para>If the file is not executable, or if the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. If the file is a DLL, the last error code is <b>ERROR_BAD_EXE_FORMAT</b>.</para>
    </returns>
  </member>
  <member name="Windows.GetBinaryTypeA">
    <summary>Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable file.</summary>
    <param name="lpApplicationName">
      <para>The full path of the file whose executable type is to be determined.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpBinaryType">
      <para>A pointer to a variable to receive information about the executable type of the file specified by<i>lpApplicationName</i>. The following constants are defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_32BIT_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>A 32-bit Windows-based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_64BIT_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>A 64-bit Windows-based application.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_DOS_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>An MS-DOS – based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_OS216_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>A 16-bit OS/2-based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_PIF_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>A PIF file that executes an MS-DOS – based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_POSIX_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>A POSIX – based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_WOW_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>A 16-bit Windows-based application</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the file is executable, the return value is nonzero. The function sets the variable pointed to by<i>lpBinaryType</i> to indicate the file's executable type.</para>
      <para>If the file is not executable, or if the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. If the file is a DLL, the last error code is <b>ERROR_BAD_EXE_FORMAT</b>.</para>
    </returns>
  </member>
  <member name="Windows.GetBinaryTypeW">
    <summary>Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable file.</summary>
    <param name="lpApplicationName">
      <para>The full path of the file whose executable type is to be determined.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpBinaryType">
      <para>A pointer to a variable to receive information about the executable type of the file specified by<i>lpApplicationName</i>. The following constants are defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_32BIT_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>A 32-bit Windows-based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_64BIT_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>A 64-bit Windows-based application.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_DOS_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>An MS-DOS – based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_OS216_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>A 16-bit OS/2-based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_PIF_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>A PIF file that executes an MS-DOS – based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_POSIX_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>A POSIX – based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_WOW_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>A 16-bit Windows-based application</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the file is executable, the return value is nonzero. The function sets the variable pointed to by<i>lpBinaryType</i> to indicate the file's executable type.</para>
      <para>If the file is not executable, or if the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. If the file is a DLL, the last error code is <b>ERROR_BAD_EXE_FORMAT</b>.</para>
    </returns>
  </member>
  <member name="Windows.GetBinaryType">
    <summary>Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable file.</summary>
    <param name="lpApplicationName">
      <para>The full path of the file whose executable type is to be determined.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpBinaryType">
      <para>A pointer to a variable to receive information about the executable type of the file specified by<i>lpApplicationName</i>. The following constants are defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_32BIT_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>A 32-bit Windows-based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_64BIT_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>A 64-bit Windows-based application.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_DOS_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>An MS-DOS – based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_OS216_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>A 16-bit OS/2-based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_PIF_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>A PIF file that executes an MS-DOS – based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_POSIX_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>A POSIX – based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_WOW_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>A 16-bit Windows-based application</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the file is executable, the return value is nonzero. The function sets the variable pointed to by<i>lpBinaryType</i> to indicate the file's executable type.</para>
      <para>If the file is not executable, or if the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. If the file is a DLL, the last error code is <b>ERROR_BAD_EXE_FORMAT</b>.</para>
    </returns>
  </member>
  <member name="Windows.GetBinaryTypeA">
    <summary>Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable file.</summary>
    <param name="lpApplicationName">
      <para>The full path of the file whose executable type is to be determined.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpBinaryType">
      <para>A pointer to a variable to receive information about the executable type of the file specified by<i>lpApplicationName</i>. The following constants are defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_32BIT_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>A 32-bit Windows-based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_64BIT_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>A 64-bit Windows-based application.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_DOS_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>An MS-DOS – based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_OS216_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>A 16-bit OS/2-based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_PIF_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>A PIF file that executes an MS-DOS – based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_POSIX_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>A POSIX – based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_WOW_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>A 16-bit Windows-based application</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the file is executable, the return value is nonzero. The function sets the variable pointed to by<i>lpBinaryType</i> to indicate the file's executable type.</para>
      <para>If the file is not executable, or if the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. If the file is a DLL, the last error code is <b>ERROR_BAD_EXE_FORMAT</b>.</para>
    </returns>
  </member>
  <member name="Windows.GetBinaryTypeW">
    <summary>Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable file.</summary>
    <param name="lpApplicationName">
      <para>The full path of the file whose executable type is to be determined.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpBinaryType">
      <para>A pointer to a variable to receive information about the executable type of the file specified by<i>lpApplicationName</i>. The following constants are defined.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_32BIT_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>A 32-bit Windows-based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_64BIT_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>A 64-bit Windows-based application.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_DOS_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>An MS-DOS – based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_OS216_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>A 16-bit OS/2-based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_PIF_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>A PIF file that executes an MS-DOS – based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_POSIX_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>A POSIX – based application</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SCS_WOW_BINARY</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>A 16-bit Windows-based application</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the file is executable, the return value is nonzero. The function sets the variable pointed to by<i>lpBinaryType</i> to indicate the file's executable type.</para>
      <para>If the file is not executable, or if the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. If the file is a DLL, the last error code is <b>ERROR_BAD_EXE_FORMAT</b>.</para>
    </returns>
  </member>
  <member name="Windows.GetCommConfig">
    <summary>
      <para>Retrieves the current configuration of a communications device.</para>
      <para>To retrieve the default configuration settings from the device manager, use the <see cref="GetDefaultCommConfig" /> function.</para>
    </summary>
    <param name="hCommDev">A handle to the open communications device. The<see cref="CreateFile" /> function returns this handle.</param>
    <param name="lpCC">A pointer to a buffer that receives a<see cref="COMMCONFIG" /> structure.</param>
    <param name="lpdwSize">The size, in bytes, of the buffer pointed to by <i>lpCC</i>. When the function returns, the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the buffer was too small.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the<see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetCommMask">
    <summary>Retrieves the value of the event mask for a specified communications device.</summary>
    <param name="hFile">A handle to the communications device. The<see cref="CreateFile" /> function returns this handle.</param>
    <param name="lpEvtMask">
      <para>A pointer to the variable that receives a mask of events that are currently enabled. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_BREAK</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0040</term>
              </listheader>
            </list>
          </description>
          <description>A break was detected on input.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_CTS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0008</term>
              </listheader>
            </list>
          </description>
          <description>The CTS (clear-to-send) signal changed state.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_DSR</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0010</term>
              </listheader>
            </list>
          </description>
          <description>The DSR (data-set-ready) signal changed state.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_ERR</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0080</term>
              </listheader>
            </list>
          </description>
          <description>A line-status error occurred. Line-status errors are <b>CE_FRAME</b>, <b>CE_OVERRUN</b>, and <b>CE_RXPARITY</b>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_EVENT1</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0800</term>
              </listheader>
            </list>
          </description>
          <description>An event of the first provider-specific type occurred.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_EVENT2</b>
                </term>
              </listheader>
              <listheader>
                <term>0x1000</term>
              </listheader>
            </list>
          </description>
          <description>An event of the second provider-specific type occurred.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_PERR</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0200</term>
              </listheader>
            </list>
          </description>
          <description>A printer error occurred.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_RING</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0100</term>
              </listheader>
            </list>
          </description>
          <description>A ring indicator was detected.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_RLSD</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0020</term>
              </listheader>
            </list>
          </description>
          <description>The RLSD (receive-line-signal-detect) signal changed state.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_RX80FULL</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0400</term>
              </listheader>
            </list>
          </description>
          <description>The receive buffer is 80 percent full.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_RXCHAR</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0001</term>
              </listheader>
            </list>
          </description>
          <description>A character was received and placed in the input buffer.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_RXFLAG</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0002</term>
              </listheader>
            </list>
          </description>
          <description>The event character was received and placed in the input buffer. The event character is specified in the device's <see cref="DCB" /> structure, which is applied to a serial port by using the <see cref="SetCommState" /> function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_TXEMPTY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0004</term>
              </listheader>
            </list>
          </description>
          <description>The last character in the output buffer was sent.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetCommModemStatus">
    <summary>Retrieves the modem control-register values.</summary>
    <param name="hFile">A handle to the communications device. The<see cref="CreateFile" /> function returns this handle.</param>
    <param name="lpModemStat">
      <para>A pointer to a variable that receives the current state of the modem control-register values. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MS_CTS_ON</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0010</term>
              </listheader>
            </list>
          </description>
          <description>The CTS (clear-to-send) signal is on.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MS_DSR_ON</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0020</term>
              </listheader>
            </list>
          </description>
          <description>The DSR (data-set-ready) signal is on.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MS_RING_ON</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0040</term>
              </listheader>
            </list>
          </description>
          <description>The ring indicator signal is on.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MS_RLSD_ON</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0080</term>
              </listheader>
            </list>
          </description>
          <description>The RLSD (receive-line-signal-detect) signal is on.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetCommPorts">
    <summary>
      <para>Gets an array that contains the well-formed COM ports.</para>
      <para>This function obtains the COM port numbers from the <b>HKLM\Hardware\DeviceMap\SERIALCOMM</b> registry key and then writes them to a caller-supplied array. If the array is too small, the function gets the necessary size.</para>
      <div>
        <b>Note</b>  If new entries are added to the registry key, the necessary size can change between API calls.</div>
    </summary>
    <param name="lpPortNumbers">An array for the port numbers.</param>
    <param name="uPortNumbersCount">The length of the array in the <i>lpPortNumbers</i> parameter.</param>
    <param name="puPortNumbersFound">The number of port numbers written to the <i>lpPortNumbers</i> or the length of the array required for the port numbers.</param>
    <returns>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_SUCCESS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The call succeeded. The <i>lpPortNumbers</i> array was large enough for the result.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_MORE_DATA</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The <i>lpPortNumbers</i> array was too small to contain all available port numbers.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_FILE_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>There are no comm ports available.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetCommProperties">
    <summary>Retrieves information about the communications properties for a specified communications device.</summary>
    <param name="hFile">A handle to the communications device. The<see cref="CreateFile" /> function returns this handle.</param>
    <param name="lpCommProp">A pointer to a<see cref="COMMPROP" /> structure in which the communications properties information is returned. This information can be used in subsequent calls to the<see cref="SetCommState" />,<see cref="SetCommTimeouts" />, or<see cref="SetupComm" /> function to configure the communications device.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetCommState">
    <summary>Retrieves the current control settings for a specified communications device.</summary>
    <param name="hFile">A handle to the communications device. The<see cref="CreateFile" /> function returns this handle.</param>
    <param name="lpDCB">A pointer to a<see cref="DCB" /> structure that receives the control settings information.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetCommTimeouts">
    <summary>Retrieves the time-out parameters for all read and write operations on a specified communications device.</summary>
    <param name="hFile">A handle to the communications device. The<see cref="CreateFile" /> function returns this handle.</param>
    <param name="lpCommTimeouts">A pointer to a<see cref="COMMTIMEOUTS" /> structure in which the time-out information is returned.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetComputerName">
    <summary>
      <para>Retrieves the NetBIOS name of the local computer. This name is established at system startup, when the system reads it from the registry.</para>
      <para>
        <b>GetComputerName</b> retrieves only the NetBIOS name of the local computer. To retrieve the DNS host name, DNS domain name, or the fully qualified DNS name, call the<see cref="GetComputerNameEx" /> function. Additional information is provided by the<see cref="IADsADSystemInfo" /> interface.</para>
      <para>The behavior of this function can be affected if the local computer is a node in a cluster. For more information, see <see cref="ResUtilGetEnvironmentWithNetName" /> and <a href="https://docs.microsoft.com//previous-versions/windows/desktop/mscs/generic-applications-usenetworkname">UseNetworkName</a>.</para>
    </summary>
    <param name="lpBuffer">A pointer to a buffer that receives the computer name or the cluster virtual server name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails and <see cref="GetLastError" /> returns ERROR_BUFFER_OVERFLOW. The <i>lpnSize</i> parameter specifies the size of the buffer required, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetComputerNameA">
    <summary>
      <para>Retrieves the NetBIOS name of the local computer. This name is established at system startup, when the system reads it from the registry.</para>
      <para>
        <b>GetComputerName</b> retrieves only the NetBIOS name of the local computer. To retrieve the DNS host name, DNS domain name, or the fully qualified DNS name, call the<see cref="GetComputerNameEx" /> function. Additional information is provided by the<see cref="IADsADSystemInfo" /> interface.</para>
      <para>The behavior of this function can be affected if the local computer is a node in a cluster. For more information, see <see cref="ResUtilGetEnvironmentWithNetName" /> and <a href="https://docs.microsoft.com//previous-versions/windows/desktop/mscs/generic-applications-usenetworkname">UseNetworkName</a>.</para>
    </summary>
    <param name="lpBuffer">A pointer to a buffer that receives the computer name or the cluster virtual server name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails and <see cref="GetLastError" /> returns ERROR_BUFFER_OVERFLOW. The <i>lpnSize</i> parameter specifies the size of the buffer required, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetComputerNameW">
    <summary>
      <para>Retrieves the NetBIOS name of the local computer. This name is established at system startup, when the system reads it from the registry.</para>
      <para>
        <b>GetComputerName</b> retrieves only the NetBIOS name of the local computer. To retrieve the DNS host name, DNS domain name, or the fully qualified DNS name, call the<see cref="GetComputerNameEx" /> function. Additional information is provided by the<see cref="IADsADSystemInfo" /> interface.</para>
      <para>The behavior of this function can be affected if the local computer is a node in a cluster. For more information, see <see cref="ResUtilGetEnvironmentWithNetName" /> and <a href="https://docs.microsoft.com//previous-versions/windows/desktop/mscs/generic-applications-usenetworkname">UseNetworkName</a>.</para>
    </summary>
    <param name="lpBuffer">A pointer to a buffer that receives the computer name or the cluster virtual server name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails and <see cref="GetLastError" /> returns ERROR_BUFFER_OVERFLOW. The <i>lpnSize</i> parameter specifies the size of the buffer required, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetComputerName">
    <summary>
      <para>Retrieves the NetBIOS name of the local computer. This name is established at system startup, when the system reads it from the registry.</para>
      <para>
        <b>GetComputerName</b> retrieves only the NetBIOS name of the local computer. To retrieve the DNS host name, DNS domain name, or the fully qualified DNS name, call the<see cref="GetComputerNameEx" /> function. Additional information is provided by the<see cref="IADsADSystemInfo" /> interface.</para>
      <para>The behavior of this function can be affected if the local computer is a node in a cluster. For more information, see <see cref="ResUtilGetEnvironmentWithNetName" /> and <a href="https://docs.microsoft.com//previous-versions/windows/desktop/mscs/generic-applications-usenetworkname">UseNetworkName</a>.</para>
    </summary>
    <param name="lpBuffer">A pointer to a buffer that receives the computer name or the cluster virtual server name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails and <see cref="GetLastError" /> returns ERROR_BUFFER_OVERFLOW. The <i>lpnSize</i> parameter specifies the size of the buffer required, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetComputerNameA">
    <summary>
      <para>Retrieves the NetBIOS name of the local computer. This name is established at system startup, when the system reads it from the registry.</para>
      <para>
        <b>GetComputerName</b> retrieves only the NetBIOS name of the local computer. To retrieve the DNS host name, DNS domain name, or the fully qualified DNS name, call the<see cref="GetComputerNameEx" /> function. Additional information is provided by the<see cref="IADsADSystemInfo" /> interface.</para>
      <para>The behavior of this function can be affected if the local computer is a node in a cluster. For more information, see <see cref="ResUtilGetEnvironmentWithNetName" /> and <a href="https://docs.microsoft.com//previous-versions/windows/desktop/mscs/generic-applications-usenetworkname">UseNetworkName</a>.</para>
    </summary>
    <param name="lpBuffer">A pointer to a buffer that receives the computer name or the cluster virtual server name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails and <see cref="GetLastError" /> returns ERROR_BUFFER_OVERFLOW. The <i>lpnSize</i> parameter specifies the size of the buffer required, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetComputerNameW">
    <summary>
      <para>Retrieves the NetBIOS name of the local computer. This name is established at system startup, when the system reads it from the registry.</para>
      <para>
        <b>GetComputerName</b> retrieves only the NetBIOS name of the local computer. To retrieve the DNS host name, DNS domain name, or the fully qualified DNS name, call the<see cref="GetComputerNameEx" /> function. Additional information is provided by the<see cref="IADsADSystemInfo" /> interface.</para>
      <para>The behavior of this function can be affected if the local computer is a node in a cluster. For more information, see <see cref="ResUtilGetEnvironmentWithNetName" /> and <a href="https://docs.microsoft.com//previous-versions/windows/desktop/mscs/generic-applications-usenetworkname">UseNetworkName</a>.</para>
    </summary>
    <param name="lpBuffer">A pointer to a buffer that receives the computer name or the cluster virtual server name. The buffer size should be large enough to contain MAX_COMPUTERNAME_LENGTH + 1 characters.</param>
    <param name="nSize">
      <para>On input, specifies the size of the buffer, in <b>TCHARs</b>. On output, the number of <b>TCHARs</b> copied to the destination buffer, not including the terminating null character.</para>
      <para>If the buffer is too small, the function fails and <see cref="GetLastError" /> returns ERROR_BUFFER_OVERFLOW. The <i>lpnSize</i> parameter specifies the size of the buffer required, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetCurrentActCtx">
    <summary>The<b>GetCurrentActCtx</b> function returns the handle to the active activation context of the calling thread.</summary>
    <param name="lphActCtx">Pointer to the returned<see cref="ACTCTX" /> structure that contains information on the active activation context.</param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling<see cref="GetLastError" />. For an example, see<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
  </member>
  <member name="Windows.GetCurrentDirectory">
    <summary>Retrieves the current directory for the current process.</summary>
    <param name="nBufferLength">The length of the buffer for the current directory string, in <b>TCHARs</b>. The buffer length must include room for a terminating null character.</param>
    <param name="lpBuffer">
      <para>A pointer to the buffer that receives the current directory string. This null-terminated string specifies the absolute path to the current directory.</para>
      <para>To determine the required buffer size, set this parameter to <b>NULL</b> and the<i>nBufferLength</i> parameter to 0.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the number of characters that are written to the buffer, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the buffer that is pointed to by <i>lpBuffer</i> is not large enough, the return value specifies the required size of the buffer, in characters, including the null-terminating character.</para>
    </returns>
  </member>
  <member name="Windows.GetCurrentDirectoryA">
    <summary>Retrieves the current directory for the current process.</summary>
    <param name="nBufferLength">The length of the buffer for the current directory string, in <b>TCHARs</b>. The buffer length must include room for a terminating null character.</param>
    <param name="lpBuffer">
      <para>A pointer to the buffer that receives the current directory string. This null-terminated string specifies the absolute path to the current directory.</para>
      <para>To determine the required buffer size, set this parameter to <b>NULL</b> and the<i>nBufferLength</i> parameter to 0.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the number of characters that are written to the buffer, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the buffer that is pointed to by <i>lpBuffer</i> is not large enough, the return value specifies the required size of the buffer, in characters, including the null-terminating character.</para>
    </returns>
  </member>
  <member name="Windows.GetCurrentDirectoryW">
    <summary>Retrieves the current directory for the current process.</summary>
    <param name="nBufferLength">The length of the buffer for the current directory string, in <b>TCHARs</b>. The buffer length must include room for a terminating null character.</param>
    <param name="lpBuffer">
      <para>A pointer to the buffer that receives the current directory string. This null-terminated string specifies the absolute path to the current directory.</para>
      <para>To determine the required buffer size, set this parameter to <b>NULL</b> and the<i>nBufferLength</i> parameter to 0.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies the number of characters that are written to the buffer, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the buffer that is pointed to by <i>lpBuffer</i> is not large enough, the return value specifies the required size of the buffer, in characters, including the null-terminating character.</para>
    </returns>
  </member>
  <member name="Windows.GetCurrentHwProfile">
    <summary>Retrieves information about the current hardware profile for the local computer.</summary>
    <param name="lpHwProfileInfo">A pointer to an<see cref="HW_PROFILE_INFO" /> structure that receives information about the current hardware profile.</param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetCurrentHwProfileA">
    <summary>Retrieves information about the current hardware profile for the local computer.</summary>
    <param name="lpHwProfileInfo">A pointer to an<see cref="HW_PROFILE_INFO" /> structure that receives information about the current hardware profile.</param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetCurrentHwProfileW">
    <summary>Retrieves information about the current hardware profile for the local computer.</summary>
    <param name="lpHwProfileInfo">A pointer to an<see cref="HW_PROFILE_INFO" /> structure that receives information about the current hardware profile.</param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetCurrentHwProfile">
    <summary>Retrieves information about the current hardware profile for the local computer.</summary>
    <param name="lpHwProfileInfo">A pointer to an<see cref="HW_PROFILE_INFO" /> structure that receives information about the current hardware profile.</param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetCurrentHwProfileA">
    <summary>Retrieves information about the current hardware profile for the local computer.</summary>
    <param name="lpHwProfileInfo">A pointer to an<see cref="HW_PROFILE_INFO" /> structure that receives information about the current hardware profile.</param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetCurrentHwProfileW">
    <summary>Retrieves information about the current hardware profile for the local computer.</summary>
    <param name="lpHwProfileInfo">A pointer to an<see cref="HW_PROFILE_INFO" /> structure that receives information about the current hardware profile.</param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetCurrentUmsThread">
    <summary>
      <para>Returns the user-mode scheduling (UMS) thread context of the calling UMS thread.</para>
      <blockquote>[!WARNING] As of Windows 11, user-mode scheduling is not supported. All calls fail with the error <code>ERROR_NOT_SUPPORTED</code>.</blockquote>
    </summary>
    <returns>
      <para>The function returns a pointer to the UMS thread context of the calling thread.</para>
      <para>If calling thread is not a UMS thread, the function returns NULL. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetDefaultCommConfig">
    <summary>Retrieves the default configuration for the specified communications device.</summary>
    <param name="lpszName">The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
    <param name="lpCC">A pointer to a buffer that receives a<see cref="COMMCONFIG" /> structure.</param>
    <param name="lpdwSize">A pointer to a variable that specifies the size of the buffer pointed to by <i>lpCC</i>, in bytes. Upon return, the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the buffer was too small.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the<see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetDefaultCommConfigA">
    <summary>Retrieves the default configuration for the specified communications device.</summary>
    <param name="lpszName">The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
    <param name="lpCC">A pointer to a buffer that receives a<see cref="COMMCONFIG" /> structure.</param>
    <param name="lpdwSize">A pointer to a variable that specifies the size of the buffer pointed to by <i>lpCC</i>, in bytes. Upon return, the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the buffer was too small.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the<see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetDefaultCommConfigW">
    <summary>Retrieves the default configuration for the specified communications device.</summary>
    <param name="lpszName">The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
    <param name="lpCC">A pointer to a buffer that receives a<see cref="COMMCONFIG" /> structure.</param>
    <param name="lpdwSize">A pointer to a variable that specifies the size of the buffer pointed to by <i>lpCC</i>, in bytes. Upon return, the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the buffer was too small.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the<see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetDefaultCommConfig">
    <summary>Retrieves the default configuration for the specified communications device.</summary>
    <param name="lpszName">The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
    <param name="lpCC">A pointer to a buffer that receives a<see cref="COMMCONFIG" /> structure.</param>
    <param name="lpdwSize">A pointer to a variable that specifies the size of the buffer pointed to by <i>lpCC</i>, in bytes. Upon return, the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the buffer was too small.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the<see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetDefaultCommConfigA">
    <summary>Retrieves the default configuration for the specified communications device.</summary>
    <param name="lpszName">The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
    <param name="lpCC">A pointer to a buffer that receives a<see cref="COMMCONFIG" /> structure.</param>
    <param name="lpdwSize">A pointer to a variable that specifies the size of the buffer pointed to by <i>lpCC</i>, in bytes. Upon return, the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the buffer was too small.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the<see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetDefaultCommConfigW">
    <summary>Retrieves the default configuration for the specified communications device.</summary>
    <param name="lpszName">The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
    <param name="lpCC">A pointer to a buffer that receives a<see cref="COMMCONFIG" /> structure.</param>
    <param name="lpdwSize">A pointer to a variable that specifies the size of the buffer pointed to by <i>lpCC</i>, in bytes. Upon return, the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the buffer was too small.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the<see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetDevicePowerState">
    <summary>Retrieves the current power state of the specified device. This function cannot be used to query the power state of a display device.</summary>
    <param name="hDevice">A handle to an object on the device, such as a file or socket, or a handle to the device itself.</param>
    <param name="pfOn">A pointer to the variable that receives the<a href="https://docs.microsoft.com//windows/desktop/Power/system-power-states">power state</a>. This value is <b>TRUE</b> if the device is in the working state. Otherwise, it is <b>FALSE</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.GetDllDirectory">
    <summary>Retrieves the application-specific portion of the search path used to locate DLLs for the application.</summary>
    <param name="nBufferLength">The size of the output buffer, in characters.</param>
    <param name="lpBuffer">A pointer to a buffer that receives the application-specific portion of the search path.</param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to<i>lpBuffer</i>, in characters, not including the terminating null character. If the return value is greater than <i>nBufferLength</i>, it specifies the size of the buffer required for the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetDllDirectoryA">
    <summary>Retrieves the application-specific portion of the search path used to locate DLLs for the application.</summary>
    <param name="nBufferLength">The size of the output buffer, in characters.</param>
    <param name="lpBuffer">A pointer to a buffer that receives the application-specific portion of the search path.</param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to<i>lpBuffer</i>, in characters, not including the terminating null character. If the return value is greater than <i>nBufferLength</i>, it specifies the size of the buffer required for the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetDllDirectoryW">
    <summary>Retrieves the application-specific portion of the search path used to locate DLLs for the application.</summary>
    <param name="nBufferLength">The size of the output buffer, in characters.</param>
    <param name="lpBuffer">A pointer to a buffer that receives the application-specific portion of the search path.</param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to<i>lpBuffer</i>, in characters, not including the terminating null character. If the return value is greater than <i>nBufferLength</i>, it specifies the size of the buffer required for the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetDllDirectory">
    <summary>Retrieves the application-specific portion of the search path used to locate DLLs for the application.</summary>
    <param name="nBufferLength">The size of the output buffer, in characters.</param>
    <param name="lpBuffer">A pointer to a buffer that receives the application-specific portion of the search path.</param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to<i>lpBuffer</i>, in characters, not including the terminating null character. If the return value is greater than <i>nBufferLength</i>, it specifies the size of the buffer required for the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetDllDirectoryA">
    <summary>Retrieves the application-specific portion of the search path used to locate DLLs for the application.</summary>
    <param name="nBufferLength">The size of the output buffer, in characters.</param>
    <param name="lpBuffer">A pointer to a buffer that receives the application-specific portion of the search path.</param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to<i>lpBuffer</i>, in characters, not including the terminating null character. If the return value is greater than <i>nBufferLength</i>, it specifies the size of the buffer required for the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetDllDirectoryW">
    <summary>Retrieves the application-specific portion of the search path used to locate DLLs for the application.</summary>
    <param name="nBufferLength">The size of the output buffer, in characters.</param>
    <param name="lpBuffer">A pointer to a buffer that receives the application-specific portion of the search path.</param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to<i>lpBuffer</i>, in characters, not including the terminating null character. If the return value is greater than <i>nBufferLength</i>, it specifies the size of the buffer required for the path.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetEnabledXStateFeatures">
    <summary>
      <para>Gets a mask of enabled XState features on x86 or x64 processors.</para>
      <para>The definition of XState feature bits are processor vendor specific. Please refer to the relevant processor reference manuals for additional information on a particular feature.</para>
    </summary>
    <returns>This function returns a bitmask in which each bit represents an XState feature that is enabled on the system.</returns>
  </member>
  <member name="Windows.GetEnvironmentVariable">
    <summary>Retrieves the contents of the specified variable from the environment block of the calling process.</summary>
    <param name="lpName">The name of the environment variable.</param>
    <param name="lpBuffer">A pointer to a buffer that receives the contents of the specified environment variable as a null-terminated string. An environment variable has a maximum size limit of 32,767 characters, including the null-terminating character.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpBuffer</i> parameter, including the null-terminating character, in characters.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of characters stored in the buffer pointed to by <i>lpBuffer</i>, not including the terminating null character.</para>
      <para>If <i>lpBuffer</i> is not large enough to hold the data, the return value is the buffer size, in characters, required to hold the string and its terminating null character and the contents of <i>lpBuffer</i> are undefined.</para>
      <para>If the function fails, the return value is zero. If the specified environment variable was not found in the environment block,<see cref="GetLastError" /> returns ERROR_ENVVAR_NOT_FOUND.</para>
    </returns>
  </member>
  <member name="Windows.GetEnvironmentVariableA">
    <summary>Retrieves the contents of the specified variable from the environment block of the calling process.</summary>
    <param name="lpName">The name of the environment variable.</param>
    <param name="lpBuffer">A pointer to a buffer that receives the contents of the specified environment variable as a null-terminated string. An environment variable has a maximum size limit of 32,767 characters, including the null-terminating character.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpBuffer</i> parameter, including the null-terminating character, in characters.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of characters stored in the buffer pointed to by <i>lpBuffer</i>, not including the terminating null character.</para>
      <para>If <i>lpBuffer</i> is not large enough to hold the data, the return value is the buffer size, in characters, required to hold the string and its terminating null character and the contents of <i>lpBuffer</i> are undefined.</para>
      <para>If the function fails, the return value is zero. If the specified environment variable was not found in the environment block,<see cref="GetLastError" /> returns ERROR_ENVVAR_NOT_FOUND.</para>
    </returns>
  </member>
  <member name="Windows.GetEnvironmentVariableW">
    <summary>Retrieves the contents of the specified variable from the environment block of the calling process.</summary>
    <param name="lpName">The name of the environment variable.</param>
    <param name="lpBuffer">A pointer to a buffer that receives the contents of the specified environment variable as a null-terminated string. An environment variable has a maximum size limit of 32,767 characters, including the null-terminating character.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpBuffer</i> parameter, including the null-terminating character, in characters.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of characters stored in the buffer pointed to by <i>lpBuffer</i>, not including the terminating null character.</para>
      <para>If <i>lpBuffer</i> is not large enough to hold the data, the return value is the buffer size, in characters, required to hold the string and its terminating null character and the contents of <i>lpBuffer</i> are undefined.</para>
      <para>If the function fails, the return value is zero. If the specified environment variable was not found in the environment block,<see cref="GetLastError" /> returns ERROR_ENVVAR_NOT_FOUND.</para>
    </returns>
  </member>
  <member name="Windows.GetEventLogInformation">
    <summary>Retrieves information about the specified event log.</summary>
    <param name="hEventLog">A handle to the event log. The<see cref="OpenEventLog" /> or<see cref="RegisterEventSource" /> function returns this handle.</param>
    <param name="dwInfoLevel">
      <para>The level of event log information to return.</para>
      <para>This parameter can be the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_FULL_INFO</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Indicate whether the specified log is full. The <i>lpBuffer</i> parameter will contain an <see cref="EVENTLOG_FULL_INFORMATION" /> structure.</description>
        </listheader>
      </list>
    </param>
    <param name="lpBuffer">An application-allocated buffer that receives the event log information. The format of this data depends on the value of the <i>dwInfoLevel</i> parameter.</param>
    <param name="cbBufSize">The size of the <i>lpBuffer</i> buffer, in bytes.</param>
    <param name="pcbBytesNeeded">The function sets this parameter to the required buffer size for the requested information, regardless of whether the function succeeds. Use this value if the function fails with <b>ERROR_INSUFFICIENT_BUFFER</b> to allocate a buffer of the correct size.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFileBandwidthReservation">
    <summary>Retrieves the bandwidth reservation properties of the volume on which the specified file resides.</summary>
    <param name="hFile">A handle to the file.</param>
    <param name="lpPeriodMilliseconds">A pointer to a variable that receives the period of the reservation, in milliseconds. The period is the time from which the I/O is issued to the kernel until the time the I/O should be completed. If no bandwidth has been reserved for this handle, then the value returned is the minimum reservation period supported for this volume.</param>
    <param name="lpBytesPerPeriod">A pointer to a variable that receives the maximum number of bytes per period that can be reserved on the volume. If no bandwidth has been reserved for this handle, then the value returned is the maximum number of bytes per period supported for the volume.</param>
    <param name="pDiscardable">
      <b>TRUE</b> if I/O should be completed with an error if a driver is unable to satisfy an I/O operation before the period expires. <b>FALSE</b> if the underlying subsystem does not support failing in this manner.</param>
    <param name="lpTransferSize">The minimum size of any individual I/O request that may be issued by the application. All I/O requests should be multiples of <i>TransferSize</i>. If no bandwidth has been reserved for this handle, then the value returned is the minimum transfer size supported for this volume.</param>
    <param name="lpNumOutstandingRequests">The number of <i>TransferSize</i> chunks allowed to be outstanding with the operating system.</param>
    <returns>
      <para>Returns nonzero if successful or zero otherwise.</para>
      <para>To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFileInformationByHandleEx">
    <summary>
      <para>Retrieves file information for the specified file.</para>
      <para>For a more basic version of this function for desktop apps, see<see cref="GetFileInformationByHandle" />.</para>
      <para>To set file information using a file handle, see<see cref="SetFileInformationByHandle" />.</para>
    </summary>
    <param name="hFile">
      <para>A handle to the file that contains the information to be retrieved.</para>
      <para>This handle should not be a pipe handle.</para>
    </param>
    <param name="FileInformationClass">
      <para>A <see cref="FILE_INFO_BY_HANDLE_CLASS" /> enumeration value that specifies the type of information to be retrieved.</para>
      <para>For a table of valid values, see the Remarks section.</para>
    </param>
    <param name="lpFileInformation">A pointer to the buffer that receives the requested file information. The structure that is returned corresponds to the class that is specified by <i>FileInformationClass</i>. For a table of valid structure types, see the Remarks section.</param>
    <param name="dwBufferSize">The size of the <i>lpFileInformation</i> buffer, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero and file information data is contained in the buffer pointed to by the <i>lpFileInformation</i> parameter.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFileSecurity">
    <summary>
      <para>The <b>GetFileSecurity</b> function obtains specified information about the security of a file or directory. The information obtained is constrained by the caller's access rights and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a>.</para>
      <para>The <see cref="GetNamedSecurityInfo" /> function provides functionality similar to <b>GetFileSecurity</b> for files as well as other types of objects.</para>
    </summary>
    <param name="lpFileName">A pointer to a null-terminated string that specifies the file or directory for which security information is retrieved.</param>
    <param name="RequestedInformation">A<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</a> value that identifies the security information being requested.</param>
    <param name="pSecurityDescriptor">A pointer to a buffer that receives a copy of the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> of the object specified by the <i>lpFileName</i> parameter. The calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> must have permission to view the specified aspects of the object's security status. The<see cref="SECURITY_DESCRIPTOR" /> structure is returned in <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">self-relative security descriptor</a> format.</param>
    <param name="nLength">Specifies the size, in bytes, of the buffer pointed to by the <i>pSecurityDescriptor</i> parameter.</param>
    <param name="lpnLengthNeeded">A pointer to the variable that receives the number of bytes necessary to store the complete <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a>. If the returned number of bytes is less than or equal to <i>nLength</i>, the entire security descriptor is returned in the output buffer; otherwise, none of the descriptor is returned.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFileSecurityA">
    <summary>
      <para>The <b>GetFileSecurity</b> function obtains specified information about the security of a file or directory. The information obtained is constrained by the caller's access rights and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a>.</para>
      <para>The <see cref="GetNamedSecurityInfo" /> function provides functionality similar to <b>GetFileSecurity</b> for files as well as other types of objects.</para>
    </summary>
    <param name="lpFileName">A pointer to a null-terminated string that specifies the file or directory for which security information is retrieved.</param>
    <param name="RequestedInformation">A<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</a> value that identifies the security information being requested.</param>
    <param name="pSecurityDescriptor">A pointer to a buffer that receives a copy of the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> of the object specified by the <i>lpFileName</i> parameter. The calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> must have permission to view the specified aspects of the object's security status. The<see cref="SECURITY_DESCRIPTOR" /> structure is returned in <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">self-relative security descriptor</a> format.</param>
    <param name="nLength">Specifies the size, in bytes, of the buffer pointed to by the <i>pSecurityDescriptor</i> parameter.</param>
    <param name="lpnLengthNeeded">A pointer to the variable that receives the number of bytes necessary to store the complete <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a>. If the returned number of bytes is less than or equal to <i>nLength</i>, the entire security descriptor is returned in the output buffer; otherwise, none of the descriptor is returned.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFileSecurityW">
    <summary>
      <para>The <b>GetFileSecurity</b> function obtains specified information about the security of a file or directory. The information obtained is constrained by the caller's access rights and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a>.</para>
      <para>The <see cref="GetNamedSecurityInfo" /> function provides functionality similar to <b>GetFileSecurity</b> for files as well as other types of objects.</para>
    </summary>
    <param name="lpFileName">A pointer to a null-terminated string that specifies the file or directory for which security information is retrieved.</param>
    <param name="RequestedInformation">A<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</a> value that identifies the security information being requested.</param>
    <param name="pSecurityDescriptor">A pointer to a buffer that receives a copy of the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> of the object specified by the <i>lpFileName</i> parameter. The calling <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> must have permission to view the specified aspects of the object's security status. The<see cref="SECURITY_DESCRIPTOR" /> structure is returned in <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">self-relative security descriptor</a> format.</param>
    <param name="nLength">Specifies the size, in bytes, of the buffer pointed to by the <i>pSecurityDescriptor</i> parameter.</param>
    <param name="lpnLengthNeeded">A pointer to the variable that receives the number of bytes necessary to store the complete <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a>. If the returned number of bytes is less than or equal to <i>nLength</i>, the entire security descriptor is returned in the output buffer; otherwise, none of the descriptor is returned.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariable">
    <summary>Retrieves the value of the specified firmware environment variable.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value.</param>
    <param name="pBuffer">A pointer to a buffer that receives the value of the specified firmware environment variable.</param>
    <param name="nSize">The size of the <i>pBuffer</i> buffer, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pBuffer</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariableA">
    <summary>Retrieves the value of the specified firmware environment variable.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value.</param>
    <param name="pBuffer">A pointer to a buffer that receives the value of the specified firmware environment variable.</param>
    <param name="nSize">The size of the <i>pBuffer</i> buffer, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pBuffer</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariableW">
    <summary>Retrieves the value of the specified firmware environment variable.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value.</param>
    <param name="pBuffer">A pointer to a buffer that receives the value of the specified firmware environment variable.</param>
    <param name="nSize">The size of the <i>pBuffer</i> buffer, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pBuffer</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariableEx">
    <summary>Retrieves the value of the specified firmware environment variable and its attributes.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value. The pointer must not be <b>NULL</b>.</param>
    <param name="pBuffer">A pointer to a buffer that receives the value of the specified firmware environment variable.</param>
    <param name="nSize">The size of the <i>pValue</i> buffer, in bytes.</param>
    <param name="pdwAttribubutes">Bitmask identifying UEFI variable attributes associated with the variable. See <see cref="SetFirmwareEnvironmentVariableEx" /> for the bitmask definition.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pValue</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariableExA">
    <summary>Retrieves the value of the specified firmware environment variable and its attributes.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value. The pointer must not be <b>NULL</b>.</param>
    <param name="pBuffer">A pointer to a buffer that receives the value of the specified firmware environment variable.</param>
    <param name="nSize">The size of the <i>pValue</i> buffer, in bytes.</param>
    <param name="pdwAttribubutes">Bitmask identifying UEFI variable attributes associated with the variable. See <see cref="SetFirmwareEnvironmentVariableEx" /> for the bitmask definition.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pValue</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariableExW">
    <summary>Retrieves the value of the specified firmware environment variable and its attributes.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value. The pointer must not be <b>NULL</b>.</param>
    <param name="pBuffer">A pointer to a buffer that receives the value of the specified firmware environment variable.</param>
    <param name="nSize">The size of the <i>pValue</i> buffer, in bytes.</param>
    <param name="pdwAttribubutes">Bitmask identifying UEFI variable attributes associated with the variable. See <see cref="SetFirmwareEnvironmentVariableEx" /> for the bitmask definition.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pValue</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariableEx">
    <summary>Retrieves the value of the specified firmware environment variable and its attributes.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value. The pointer must not be <b>NULL</b>.</param>
    <param name="pBuffer">A pointer to a buffer that receives the value of the specified firmware environment variable.</param>
    <param name="nSize">The size of the <i>pValue</i> buffer, in bytes.</param>
    <param name="pdwAttribubutes">Bitmask identifying UEFI variable attributes associated with the variable. See <see cref="SetFirmwareEnvironmentVariableEx" /> for the bitmask definition.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pValue</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariableExA">
    <summary>Retrieves the value of the specified firmware environment variable and its attributes.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value. The pointer must not be <b>NULL</b>.</param>
    <param name="pBuffer">A pointer to a buffer that receives the value of the specified firmware environment variable.</param>
    <param name="nSize">The size of the <i>pValue</i> buffer, in bytes.</param>
    <param name="pdwAttribubutes">Bitmask identifying UEFI variable attributes associated with the variable. See <see cref="SetFirmwareEnvironmentVariableEx" /> for the bitmask definition.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pValue</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariableExW">
    <summary>Retrieves the value of the specified firmware environment variable and its attributes.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value. The pointer must not be <b>NULL</b>.</param>
    <param name="pBuffer">A pointer to a buffer that receives the value of the specified firmware environment variable.</param>
    <param name="nSize">The size of the <i>pValue</i> buffer, in bytes.</param>
    <param name="pdwAttribubutes">Bitmask identifying UEFI variable attributes associated with the variable. See <see cref="SetFirmwareEnvironmentVariableEx" /> for the bitmask definition.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pValue</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariable">
    <summary>Retrieves the value of the specified firmware environment variable.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value.</param>
    <param name="pBuffer">A pointer to a buffer that receives the value of the specified firmware environment variable.</param>
    <param name="nSize">The size of the <i>pBuffer</i> buffer, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pBuffer</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariableA">
    <summary>Retrieves the value of the specified firmware environment variable.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value.</param>
    <param name="pBuffer">A pointer to a buffer that receives the value of the specified firmware environment variable.</param>
    <param name="nSize">The size of the <i>pBuffer</i> buffer, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pBuffer</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.GetFirmwareEnvironmentVariableW">
    <summary>Retrieves the value of the specified firmware environment variable.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}" where 'x' represents a hexadecimal value.</param>
    <param name="pBuffer">A pointer to a buffer that receives the value of the specified firmware environment variable.</param>
    <param name="nSize">The size of the <i>pBuffer</i> buffer, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of bytes stored in the <i>pBuffer</i> buffer.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.GetFirmwareType">
    <summary>Retrieves the firmware type of the local computer.</summary>
    <param name="FirmwareType">A pointer to a <see cref="FIRMWARE_TYPE" /> enumeration.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call the <see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetLogicalDriveStrings">
    <summary>Fills a buffer with strings that specify valid drives in the system.</summary>
    <param name="nBufferLength">The maximum size of the buffer pointed to by <i>lpBuffer</i>, in<b>TCHARs</b>. This size does not include the terminating null character. If this parameter is zero, <i>lpBuffer</i> is not used.</param>
    <param name="lpBuffer">A pointer to a buffer that receives a series of null-terminated strings, one for each valid drive in the system, plus with an additional null character. Each string is a device name.</param>
    <returns>
      <para>If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer, not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a Unicode (UTF-16) null character uses two bytes.</para>
      <para>If the buffer is not large enough, the return value is greater than <i>nBufferLength</i>. It is the size of the buffer required to hold the drive strings.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the<see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetLogicalDriveStringsA">
    <summary>Fills a buffer with strings that specify valid drives in the system.</summary>
    <param name="nBufferLength">The maximum size of the buffer pointed to by <i>lpBuffer</i>, in<b>TCHARs</b>. This size does not include the terminating null character. If this parameter is zero, <i>lpBuffer</i> is not used.</param>
    <param name="lpBuffer">A pointer to a buffer that receives a series of null-terminated strings, one for each valid drive in the system, plus with an additional null character. Each string is a device name.</param>
    <returns>
      <para>If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer, not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a Unicode (UTF-16) null character uses two bytes.</para>
      <para>If the buffer is not large enough, the return value is greater than <i>nBufferLength</i>. It is the size of the buffer required to hold the drive strings.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the<see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetLogicalDriveStringsW">
    <summary>Fills a buffer with strings that specify valid drives in the system.</summary>
    <param name="nBufferLength">The maximum size of the buffer pointed to by <i>lpBuffer</i>, in<b>TCHARs</b>. This size does not include the terminating null character. If this parameter is zero, <i>lpBuffer</i> is not used.</param>
    <param name="lpBuffer">A pointer to a buffer that receives a series of null-terminated strings, one for each valid drive in the system, plus with an additional null character. Each string is a device name.</param>
    <returns>
      <para>If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer, not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a Unicode (UTF-16) null character uses two bytes.</para>
      <para>If the buffer is not large enough, the return value is greater than <i>nBufferLength</i>. It is the size of the buffer required to hold the drive strings.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use the<see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetMailslotInfo">
    <summary>Retrieves information about the specified mailslot.</summary>
    <param name="hMailslot">A handle to a mailslot. The<see cref="CreateMailslot" /> function must create this handle.</param>
    <param name="lpMaxMessageSize">The maximum message size, in bytes, allowed for this mailslot. This value can be greater than or equal to the value specified in the <i>cbMaxMsg</i> parameter of the<see cref="CreateMailslot" /> function that created the mailslot. This parameter can be <b>NULL</b>.</param>
    <param name="lpNextSize">
      <para>The size of the next message, in bytes. The following value has special meaning.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MAILSLOT_NO_MESSAGE</b>
                </term>
              </listheader>
              <listheader>
                <term>((DWORD)-1)</term>
              </listheader>
            </list>
          </description>
          <description>There is no next message.</description>
        </listheader>
      </list> <para>This parameter can be <b>NULL</b>.</para></param>
    <param name="lpMessageCount">The total number of messages waiting to be read, when the function returns. This parameter can be <b>NULL</b>.</param>
    <param name="lpReadTimeout">The amount of time, in milliseconds, a read operation can wait for a message to be written to the mailslot before a time-out occurs. This parameter is filled in when the function returns. This parameter can be <b>NULL</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetMaximumProcessorCount">
    <summary>Returns the maximum number of logical processors that a processor group or the system can have.</summary>
    <param name="GroupNumber">The processor group number. If this parameter is ALL_PROCESSOR_GROUPS, the function returns the maximum number of processors that the system can have.</param>
    <returns>
      <para>If the function succeeds, the return value is the maximum number of processors that the specified group can have.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetMaximumProcessorGroupCount">
    <summary>Returns the maximum number of processor groups that the system can have.</summary>
    <returns>
      <para>If the function succeeds, the return value is the maximum number of processor groups that the system can have.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.GetNamedPipeClientComputerName">
    <summary>Retrieves the client computer name for the specified named pipe.</summary>
    <param name="Pipe">A handle to an instance of a named pipe. This handle must be created by the<see cref="CreateNamedPipe" /> function.</param>
    <param name="ClientComputerName">The computer name.</param>
    <param name="ClientComputerNameLength">The size of the <i>ClientComputerName</i> buffer, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call the <see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetNamedPipeClientComputerNameA">
    <summary>Retrieves the client computer name for the specified named pipe.</summary>
    <param name="Pipe">A handle to an instance of a named pipe. This handle must be created by the<see cref="CreateNamedPipe" /> function.</param>
    <param name="ClientComputerName">The computer name.</param>
    <param name="ClientComputerNameLength">The size of the <i>ClientComputerName</i> buffer, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call the <see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetNamedPipeClientComputerNameW">
    <summary>Retrieves the client computer name for the specified named pipe.</summary>
    <param name="Pipe">A handle to an instance of a named pipe. This handle must be created by the<see cref="CreateNamedPipe" /> function.</param>
    <param name="ClientComputerName">The computer name.</param>
    <param name="ClientComputerNameLength">The size of the <i>ClientComputerName</i> buffer, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call the <see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetNamedPipeClientProcessId">
    <summary>Retrieves the client process identifier for the specified named pipe.</summary>
    <param name="Pipe">A handle to an instance of a named pipe. This handle must be created by the<see cref="CreateNamedPipe" /> function.</param>
    <param name="ClientProcessId">The process identifier.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call the <see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetNamedPipeClientSessionId">
    <summary>Retrieves the client session identifier for the specified named pipe.</summary>
    <param name="Pipe">A handle to an instance of a named pipe. This handle must be created by the<see cref="CreateNamedPipe" /> function.</param>
    <param name="ClientSessionId">The session identifier.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call the <see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetNamedPipeHandleState">
    <summary>Retrieves information about a specified named pipe. The information returned can vary during the lifetime of an instance of the named pipe.</summary>
    <param name="hNamedPipe">
      <para>A handle to the named pipe for which information is wanted. The handle must have GENERIC_READ access for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a write-only pipe.</para>
      <para>This parameter can also be a handle to an anonymous pipe, as returned by the<see cref="CreatePipe" /> function.</para>
    </param>
    <param name="lpState">
      <para>A pointer to a variable that indicates the current state of the handle. This parameter can be <b>NULL</b> if this information is not needed. Either or both of the following values can be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_NOWAIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The pipe handle is in nonblocking mode. If this flag is not specified, the pipe handle is in blocking mode.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_READMODE_MESSAGE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The pipe handle is in message-read mode. If this flag is not specified, the pipe handle is in byte-read mode.</description>
        </listheader>
      </list>
    </param>
    <param name="lpCurInstances">A pointer to a variable that receives the number of current pipe instances. This parameter can be <b>NULL</b> if this information is not required.</param>
    <param name="lpMaxCollectionCount">A pointer to a variable that receives the maximum number of bytes to be collected on the client's computer before transmission to the server. This parameter must be <b>NULL</b> if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can be <b>NULL</b> if this information is not required.</param>
    <param name="lpCollectDataTimeout">A pointer to a variable that receives the maximum time, in milliseconds, that can pass before a remote named pipe transfers information over the network. This parameter must be <b>NULL</b> if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can be <b>NULL</b> if this information is not required.</param>
    <param name="lpUserName">
      <para>A pointer to a buffer that receives the user name string associated with the client application. The server can only retrieve this information if the client opened the pipe with SECURITY_IMPERSONATION access.</para>
      <para>This parameter must be <b>NULL</b> if the specified pipe handle is to the client end of a named pipe. This parameter can be <b>NULL</b> if this information is not required.</para>
    </param>
    <param name="nMaxUserNameSize">The size of the buffer specified by the <i>lpUserName</i> parameter, in <b>TCHARs</b>. This parameter is ignored if <i>lpUserName</i> is <b>NULL</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetNamedPipeHandleStateA">
    <summary>Retrieves information about a specified named pipe. The information returned can vary during the lifetime of an instance of the named pipe.</summary>
    <param name="hNamedPipe">
      <para>A handle to the named pipe for which information is wanted. The handle must have GENERIC_READ access for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a write-only pipe.</para>
      <para>This parameter can also be a handle to an anonymous pipe, as returned by the<see cref="CreatePipe" /> function.</para>
    </param>
    <param name="lpState">
      <para>A pointer to a variable that indicates the current state of the handle. This parameter can be <b>NULL</b> if this information is not needed. Either or both of the following values can be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_NOWAIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The pipe handle is in nonblocking mode. If this flag is not specified, the pipe handle is in blocking mode.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_READMODE_MESSAGE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The pipe handle is in message-read mode. If this flag is not specified, the pipe handle is in byte-read mode.</description>
        </listheader>
      </list>
    </param>
    <param name="lpCurInstances">A pointer to a variable that receives the number of current pipe instances. This parameter can be <b>NULL</b> if this information is not required.</param>
    <param name="lpMaxCollectionCount">A pointer to a variable that receives the maximum number of bytes to be collected on the client's computer before transmission to the server. This parameter must be <b>NULL</b> if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can be <b>NULL</b> if this information is not required.</param>
    <param name="lpCollectDataTimeout">A pointer to a variable that receives the maximum time, in milliseconds, that can pass before a remote named pipe transfers information over the network. This parameter must be <b>NULL</b> if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can be <b>NULL</b> if this information is not required.</param>
    <param name="lpUserName">
      <para>A pointer to a buffer that receives the user name string associated with the client application. The server can only retrieve this information if the client opened the pipe with SECURITY_IMPERSONATION access.</para>
      <para>This parameter must be <b>NULL</b> if the specified pipe handle is to the client end of a named pipe. This parameter can be <b>NULL</b> if this information is not required.</para>
    </param>
    <param name="nMaxUserNameSize">The size of the buffer specified by the <i>lpUserName</i> parameter, in <b>TCHARs</b>. This parameter is ignored if <i>lpUserName</i> is <b>NULL</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetNamedPipeHandleStateW">
    <summary>Retrieves information about a specified named pipe. The information returned can vary during the lifetime of an instance of the named pipe.</summary>
    <param name="hNamedPipe">
      <para>A handle to the named pipe for which information is wanted. The handle must have GENERIC_READ access for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a write-only pipe.</para>
      <para>This parameter can also be a handle to an anonymous pipe, as returned by the<see cref="CreatePipe" /> function.</para>
    </param>
    <param name="lpState">
      <para>A pointer to a variable that indicates the current state of the handle. This parameter can be <b>NULL</b> if this information is not needed. Either or both of the following values can be specified.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_NOWAIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The pipe handle is in nonblocking mode. If this flag is not specified, the pipe handle is in blocking mode.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PIPE_READMODE_MESSAGE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The pipe handle is in message-read mode. If this flag is not specified, the pipe handle is in byte-read mode.</description>
        </listheader>
      </list>
    </param>
    <param name="lpCurInstances">A pointer to a variable that receives the number of current pipe instances. This parameter can be <b>NULL</b> if this information is not required.</param>
    <param name="lpMaxCollectionCount">A pointer to a variable that receives the maximum number of bytes to be collected on the client's computer before transmission to the server. This parameter must be <b>NULL</b> if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can be <b>NULL</b> if this information is not required.</param>
    <param name="lpCollectDataTimeout">A pointer to a variable that receives the maximum time, in milliseconds, that can pass before a remote named pipe transfers information over the network. This parameter must be <b>NULL</b> if the specified pipe handle is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can be <b>NULL</b> if this information is not required.</param>
    <param name="lpUserName">
      <para>A pointer to a buffer that receives the user name string associated with the client application. The server can only retrieve this information if the client opened the pipe with SECURITY_IMPERSONATION access.</para>
      <para>This parameter must be <b>NULL</b> if the specified pipe handle is to the client end of a named pipe. This parameter can be <b>NULL</b> if this information is not required.</para>
    </param>
    <param name="nMaxUserNameSize">The size of the buffer specified by the <i>lpUserName</i> parameter, in <b>TCHARs</b>. This parameter is ignored if <i>lpUserName</i> is <b>NULL</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetNamedPipeServerProcessId">
    <summary>Retrieves the server process identifier for the specified named pipe.</summary>
    <param name="Pipe">A handle to an instance of a named pipe. This handle must be created by the<see cref="CreateNamedPipe" /> function.</param>
    <param name="ServerProcessId">The process identifier.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call the <see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetNamedPipeServerSessionId">
    <summary>Retrieves the server session identifier for the specified named pipe.</summary>
    <param name="Pipe">A handle to an instance of a named pipe. This handle must be created by the<see cref="CreateNamedPipe" /> function.</param>
    <param name="ServerSessionId">The session identifier.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call the <see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.GetNextUmsListItem">
    <summary>
      <para>Returns the next user-mode scheduling (UMS) thread context in a list of thread contexts.</para>
      <blockquote>[!WARNING] As of Windows 11, user-mode scheduling is not supported. All calls fail with the error <code>ERROR_NOT_SUPPORTED</code>.</blockquote>
    </summary>
    <param name="UmsContext">A pointer to a UMS context in a list of thread contexts. This list is retrieved by the <see cref="DequeueUmsCompletionListItems" /> function.</param>
    <returns>
      <para>If the function succeeds, it returns a pointer to the next thread context in the list.</para>
      <para>If there is no thread context after the context specified by the <i>UmsContext</i> parameter, the function returns NULL. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetNumaAvailableMemoryNode">
    <summary>
      <para>Retrieves the amount of memory available in the specified node.</para>
      <para>Use the <see cref="GetNumaAvailableMemoryNodeEx" /> function to specify the node as a <b>USHORT</b> value.</para>
    </summary>
    <param name="Node">The number of the node.</param>
    <param name="AvailableBytes">The amount of available memory for the node, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetNumaAvailableMemoryNodeEx">
    <summary>Retrieves the amount of memory that is available in a node specified as a <b>USHORT</b> value.</summary>
    <param name="Node">The number of the node.</param>
    <param name="AvailableBytes">The amount of available memory for the node, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetNumaNodeNumberFromHandle">
    <summary>Retrieves the NUMA node associated with the file or I/O device represented by the specified file handle.</summary>
    <param name="hFile">A handle to a file or I/O device. Examples of I/O devices include files, file streams, volumes, physical disks, and sockets. For more information, see the <see cref="CreateFile" /> function.</param>
    <param name="NodeNumber">A pointer to a variable to receive the number of the NUMA node associated with the specified file handle.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, use <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetNumaNodeProcessorMask">
    <summary>Retrieves the processor mask for the specified node.</summary>
    <param name="Node">The number of the node.</param>
    <param name="ProcessorMask">
      <para>The processor mask for the node. A processor mask is a bit vector in which each bit represents a processor and whether it is in the node.</para>
      <para>If the node has no processors configured, the processor mask is zero.</para>
      <para>On systems with more than 64 processors, this parameter is set to the processor mask for the node only if the node is in the same <a href="https://docs.microsoft.com//windows/desktop/ProcThread/processor-groups">processor group</a> as the calling thread. Otherwise, the parameter is set to zero.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetNumaProcessorNode">
    <summary>
      <para>Retrieves the node number for the specified processor.</para>
      <para>Use the <see cref="GetNumaProcessorNodeEx" /> function to specify a processor group and retrieve the node number as a <b>USHORT</b> value.</para>
    </summary>
    <param name="Processor">
      <para>The processor number.</para>
      <para>On a system with more than 64 logical processors, the processor number is relative to the <a href="https://docs.microsoft.com//windows/desktop/ProcThread/processor-groups">processor group</a> that contains the processor on which the calling thread is running.</para>
    </param>
    <param name="NodeNumber">The node number. If the processor does not exist, this parameter is 0xFF.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetNumaProcessorNodeEx">
    <summary>Retrieves the node number as a <b>USHORT</b> value for the specified logical processor.</summary>
    <param name="Processor">A pointer to a <see cref="PROCESSOR_NUMBER" /> structure that represents the logical processor and the processor group to which it is assigned.</param>
    <param name="NodeNumber">A pointer to a variable to receive the node number. If the specified processor does not exist, this parameter is set to MAXUSHORT.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetNumaProximityNode">
    <summary>
      <para>Retrieves the NUMA node number that corresponds to the specified proximity domain identifier.</para>
      <para>Use the <see cref="GetNumaProximityNodeEx" /> function to retrieve the node number as a <b>USHORT</b> value.</para>
    </summary>
    <param name="ProximityId">The proximity domain identifier of the node.</param>
    <param name="NodeNumber">The node number. If the processor does not exist, this parameter is 0xFF.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetNumberOfEventLogRecords">
    <summary>Retrieves the number of records in the specified event log.</summary>
    <param name="hEventLog">A handle to the open event log. The<see cref="OpenEventLog" /> or<see cref="OpenBackupEventLog" /> function returns this handle.</param>
    <param name="NumberOfRecords">A pointer to a variable that receives the number of records in the specified event log.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetOldestEventLogRecord">
    <summary>Retrieves the absolute record number of the oldest record in the specified event log.</summary>
    <param name="hEventLog">A handle to the open event log. The<see cref="OpenEventLog" /> or<see cref="OpenBackupEventLog" /> function returns this handle.</param>
    <param name="OldestRecord">A pointer to a variable that receives the absolute record number of the oldest record in the specified event log.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetPrivateProfileInt">
    <summary>
      <para>Retrieves an integer associated with a key in the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the initialization file.</param>
    <param name="lpKeyName">The name of the key whose value is to be retrieved. This value is in the form of a string; the<b>GetPrivateProfileInt</b> function converts the string into an integer and returns the integer.</param>
    <param name="nDefault">The default value to return if the key name cannot be found in the initialization file.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value is the integer equivalent of the string following the specified key name in the specified initialization file. If the key is not found, the return value is the specified default value.</returns>
  </member>
  <member name="Windows.GetPrivateProfileIntA">
    <summary>
      <para>Retrieves an integer associated with a key in the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the initialization file.</param>
    <param name="lpKeyName">The name of the key whose value is to be retrieved. This value is in the form of a string; the<b>GetPrivateProfileInt</b> function converts the string into an integer and returns the integer.</param>
    <param name="nDefault">The default value to return if the key name cannot be found in the initialization file.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value is the integer equivalent of the string following the specified key name in the specified initialization file. If the key is not found, the return value is the specified default value.</returns>
  </member>
  <member name="Windows.GetPrivateProfileIntW">
    <summary>
      <para>Retrieves an integer associated with a key in the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the initialization file.</param>
    <param name="lpKeyName">The name of the key whose value is to be retrieved. This value is in the form of a string; the<b>GetPrivateProfileInt</b> function converts the string into an integer and returns the integer.</param>
    <param name="nDefault">The default value to return if the key name cannot be found in the initialization file.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value is the integer equivalent of the string following the specified key name in the specified initialization file. If the key is not found, the return value is the specified default value.</returns>
  </member>
  <member name="Windows.GetPrivateProfileInt">
    <summary>
      <para>Retrieves an integer associated with a key in the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the initialization file.</param>
    <param name="lpKeyName">The name of the key whose value is to be retrieved. This value is in the form of a string; the<b>GetPrivateProfileInt</b> function converts the string into an integer and returns the integer.</param>
    <param name="nDefault">The default value to return if the key name cannot be found in the initialization file.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value is the integer equivalent of the string following the specified key name in the specified initialization file. If the key is not found, the return value is the specified default value.</returns>
  </member>
  <member name="Windows.GetPrivateProfileIntA">
    <summary>
      <para>Retrieves an integer associated with a key in the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the initialization file.</param>
    <param name="lpKeyName">The name of the key whose value is to be retrieved. This value is in the form of a string; the<b>GetPrivateProfileInt</b> function converts the string into an integer and returns the integer.</param>
    <param name="nDefault">The default value to return if the key name cannot be found in the initialization file.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value is the integer equivalent of the string following the specified key name in the specified initialization file. If the key is not found, the return value is the specified default value.</returns>
  </member>
  <member name="Windows.GetPrivateProfileIntW">
    <summary>
      <para>Retrieves an integer associated with a key in the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the initialization file.</param>
    <param name="lpKeyName">The name of the key whose value is to be retrieved. This value is in the form of a string; the<b>GetPrivateProfileInt</b> function converts the string into an integer and returns the integer.</param>
    <param name="nDefault">The default value to return if the key name cannot be found in the initialization file.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value is the integer equivalent of the string following the specified key name in the specified initialization file. If the key is not found, the return value is the specified default value.</returns>
  </member>
  <member name="Windows.GetPrivateProfileInt">
    <summary>
      <para>Retrieves an integer associated with a key in the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the initialization file.</param>
    <param name="lpKeyName">The name of the key whose value is to be retrieved. This value is in the form of a string; the<b>GetPrivateProfileInt</b> function converts the string into an integer and returns the integer.</param>
    <param name="nDefault">The default value to return if the key name cannot be found in the initialization file.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value is the integer equivalent of the string following the specified key name in the specified initialization file. If the key is not found, the return value is the specified default value.</returns>
  </member>
  <member name="Windows.GetPrivateProfileIntA">
    <summary>
      <para>Retrieves an integer associated with a key in the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the initialization file.</param>
    <param name="lpKeyName">The name of the key whose value is to be retrieved. This value is in the form of a string; the<b>GetPrivateProfileInt</b> function converts the string into an integer and returns the integer.</param>
    <param name="nDefault">The default value to return if the key name cannot be found in the initialization file.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value is the integer equivalent of the string following the specified key name in the specified initialization file. If the key is not found, the return value is the specified default value.</returns>
  </member>
  <member name="Windows.GetPrivateProfileIntW">
    <summary>
      <para>Retrieves an integer associated with a key in the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the initialization file.</param>
    <param name="lpKeyName">The name of the key whose value is to be retrieved. This value is in the form of a string; the<b>GetPrivateProfileInt</b> function converts the string into an integer and returns the integer.</param>
    <param name="nDefault">The default value to return if the key name cannot be found in the initialization file.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value is the integer equivalent of the string following the specified key name in the specified initialization file. If the key is not found, the return value is the specified default value.</returns>
  </member>
  <member name="Windows.GetPrivateProfileSection">
    <summary>
      <para>Retrieves all the keys and values for the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit applications written for Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the initialization file.</param>
    <param name="lpReturnedString">A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value specifies the number of characters copied to the buffer, not including the terminating null character. If the buffer is not large enough to contain all the key name and value pairs associated with the named section, the return value is equal to <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetPrivateProfileSectionA">
    <summary>
      <para>Retrieves all the keys and values for the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit applications written for Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the initialization file.</param>
    <param name="lpReturnedString">A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value specifies the number of characters copied to the buffer, not including the terminating null character. If the buffer is not large enough to contain all the key name and value pairs associated with the named section, the return value is equal to <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetPrivateProfileSectionW">
    <summary>
      <para>Retrieves all the keys and values for the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit applications written for Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the initialization file.</param>
    <param name="lpReturnedString">A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value specifies the number of characters copied to the buffer, not including the terminating null character. If the buffer is not large enough to contain all the key name and value pairs associated with the named section, the return value is equal to <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetPrivateProfileSection">
    <summary>
      <para>Retrieves all the keys and values for the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit applications written for Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the initialization file.</param>
    <param name="lpReturnedString">A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value specifies the number of characters copied to the buffer, not including the terminating null character. If the buffer is not large enough to contain all the key name and value pairs associated with the named section, the return value is equal to <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetPrivateProfileSectionA">
    <summary>
      <para>Retrieves all the keys and values for the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit applications written for Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the initialization file.</param>
    <param name="lpReturnedString">A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value specifies the number of characters copied to the buffer, not including the terminating null character. If the buffer is not large enough to contain all the key name and value pairs associated with the named section, the return value is equal to <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetPrivateProfileSectionW">
    <summary>
      <para>Retrieves all the keys and values for the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit applications written for Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the initialization file.</param>
    <param name="lpReturnedString">A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value specifies the number of characters copied to the buffer, not including the terminating null character. If the buffer is not large enough to contain all the key name and value pairs associated with the named section, the return value is equal to <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetPrivateProfileSectionNames">
    <summary>
      <para>Retrieves the names of all sections in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszReturnBuffer">A pointer to a buffer that receives the section names associated with the named file. The buffer is filled with one or more <b>null</b>-terminated strings; the last string is followed by a second <b>null</b> character.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpszReturnBuffer</i> parameter, in characters.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter is <b>NULL</b>, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value specifies the number of characters copied to the specified buffer, not including the terminating <b>null</b> character. If the buffer is not large enough to contain all the section names associated with the specified initialization file, the return value is equal to the size specified by <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetPrivateProfileSectionNamesA">
    <summary>
      <para>Retrieves the names of all sections in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszReturnBuffer">A pointer to a buffer that receives the section names associated with the named file. The buffer is filled with one or more <b>null</b>-terminated strings; the last string is followed by a second <b>null</b> character.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpszReturnBuffer</i> parameter, in characters.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter is <b>NULL</b>, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value specifies the number of characters copied to the specified buffer, not including the terminating <b>null</b> character. If the buffer is not large enough to contain all the section names associated with the specified initialization file, the return value is equal to the size specified by <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetPrivateProfileSectionNamesW">
    <summary>
      <para>Retrieves the names of all sections in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszReturnBuffer">A pointer to a buffer that receives the section names associated with the named file. The buffer is filled with one or more <b>null</b>-terminated strings; the last string is followed by a second <b>null</b> character.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpszReturnBuffer</i> parameter, in characters.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter is <b>NULL</b>, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value specifies the number of characters copied to the specified buffer, not including the terminating <b>null</b> character. If the buffer is not large enough to contain all the section names associated with the specified initialization file, the return value is equal to the size specified by <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetPrivateProfileSectionNames">
    <summary>
      <para>Retrieves the names of all sections in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszReturnBuffer">A pointer to a buffer that receives the section names associated with the named file. The buffer is filled with one or more <b>null</b>-terminated strings; the last string is followed by a second <b>null</b> character.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpszReturnBuffer</i> parameter, in characters.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter is <b>NULL</b>, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value specifies the number of characters copied to the specified buffer, not including the terminating <b>null</b> character. If the buffer is not large enough to contain all the section names associated with the specified initialization file, the return value is equal to the size specified by <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetPrivateProfileSectionNamesA">
    <summary>
      <para>Retrieves the names of all sections in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszReturnBuffer">A pointer to a buffer that receives the section names associated with the named file. The buffer is filled with one or more <b>null</b>-terminated strings; the last string is followed by a second <b>null</b> character.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpszReturnBuffer</i> parameter, in characters.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter is <b>NULL</b>, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value specifies the number of characters copied to the specified buffer, not including the terminating <b>null</b> character. If the buffer is not large enough to contain all the section names associated with the specified initialization file, the return value is equal to the size specified by <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetPrivateProfileSectionNamesW">
    <summary>
      <para>Retrieves the names of all sections in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszReturnBuffer">A pointer to a buffer that receives the section names associated with the named file. The buffer is filled with one or more <b>null</b>-terminated strings; the last string is followed by a second <b>null</b> character.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpszReturnBuffer</i> parameter, in characters.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter is <b>NULL</b>, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value specifies the number of characters copied to the specified buffer, not including the terminating <b>null</b> character. If the buffer is not large enough to contain all the section names associated with the specified initialization file, the return value is equal to the size specified by <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetPrivateProfileSectionNames">
    <summary>
      <para>Retrieves the names of all sections in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszReturnBuffer">A pointer to a buffer that receives the section names associated with the named file. The buffer is filled with one or more <b>null</b>-terminated strings; the last string is followed by a second <b>null</b> character.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpszReturnBuffer</i> parameter, in characters.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter is <b>NULL</b>, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value specifies the number of characters copied to the specified buffer, not including the terminating <b>null</b> character. If the buffer is not large enough to contain all the section names associated with the specified initialization file, the return value is equal to the size specified by <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetPrivateProfileSectionNamesA">
    <summary>
      <para>Retrieves the names of all sections in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszReturnBuffer">A pointer to a buffer that receives the section names associated with the named file. The buffer is filled with one or more <b>null</b>-terminated strings; the last string is followed by a second <b>null</b> character.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpszReturnBuffer</i> parameter, in characters.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter is <b>NULL</b>, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value specifies the number of characters copied to the specified buffer, not including the terminating <b>null</b> character. If the buffer is not large enough to contain all the section names associated with the specified initialization file, the return value is equal to the size specified by <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetPrivateProfileSectionNamesW">
    <summary>
      <para>Retrieves the names of all sections in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszReturnBuffer">A pointer to a buffer that receives the section names associated with the named file. The buffer is filled with one or more <b>null</b>-terminated strings; the last string is followed by a second <b>null</b> character.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpszReturnBuffer</i> parameter, in characters.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter is <b>NULL</b>, the function searches the Win.ini file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value specifies the number of characters copied to the specified buffer, not including the terminating <b>null</b> character. If the buffer is not large enough to contain all the section names associated with the specified initialization file, the return value is equal to the size specified by <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetPrivateProfileSection">
    <summary>
      <para>Retrieves all the keys and values for the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit applications written for Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the initialization file.</param>
    <param name="lpReturnedString">A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value specifies the number of characters copied to the buffer, not including the terminating null character. If the buffer is not large enough to contain all the key name and value pairs associated with the named section, the return value is equal to <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetPrivateProfileSectionA">
    <summary>
      <para>Retrieves all the keys and values for the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit applications written for Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the initialization file.</param>
    <param name="lpReturnedString">A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value specifies the number of characters copied to the buffer, not including the terminating null character. If the buffer is not large enough to contain all the key name and value pairs associated with the named section, the return value is equal to <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetPrivateProfileSectionW">
    <summary>
      <para>Retrieves all the keys and values for the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit applications written for Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the initialization file.</param>
    <param name="lpReturnedString">A pointer to a buffer that receives the key name and value pairs associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>The return value specifies the number of characters copied to the buffer, not including the terminating null character. If the buffer is not large enough to contain all the key name and value pairs associated with the named section, the return value is equal to <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetPrivateProfileString">
    <summary>
      <para>Retrieves a string from the specified section in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section containing the key name. If this parameter is <b>NULL</b>, the<b>GetPrivateProfileString</b> function copies all section names in the file to the supplied buffer.</param>
    <param name="lpKeyName">The name of the key whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all key names in the section specified by the <i>lpAppName</i> parameter are copied to the buffer specified by the <i>lpReturnedString</i> parameter.</param>
    <param name="lpDefault">
      <para>A default string. If the <i>lpKeyName</i> key cannot be found in the initialization file,<b>GetPrivateProfileString</b> copies the default string to the <i>lpReturnedString</i> buffer.</para>
      <para>If this parameter is <b>NULL</b>, the default is an empty string, "".</para>
      <para>Avoid specifying a default string with trailing blank characters. The function inserts a <b>null</b> character in the <i>lpReturnedString</i> buffer to strip any trailing blanks.</para>
    </param>
    <param name="lpReturnedString">A pointer to the buffer that receives the retrieved string.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>
      <para>The return value is the number of characters copied to the buffer, not including the terminating <b>null</b> character.</para>
      <para>If neither <i>lpAppName</i> nor <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a <b>null</b> character, and the return value is equal to <i>nSize</i> minus one.</para>
      <para>If either <i>lpAppName</i> or <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters. In this case, the return value is equal to <i>nSize</i> minus two.</para>
      <para>In the event the initialization file specified by <i>lpFileName</i> is not found, or contains invalid values, calling <b>GetLastError</b> will return '0x2' (File Not Found). To retrieve extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetPrivateProfileStringA">
    <summary>
      <para>Retrieves a string from the specified section in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section containing the key name. If this parameter is <b>NULL</b>, the<b>GetPrivateProfileString</b> function copies all section names in the file to the supplied buffer.</param>
    <param name="lpKeyName">The name of the key whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all key names in the section specified by the <i>lpAppName</i> parameter are copied to the buffer specified by the <i>lpReturnedString</i> parameter.</param>
    <param name="lpDefault">
      <para>A default string. If the <i>lpKeyName</i> key cannot be found in the initialization file,<b>GetPrivateProfileString</b> copies the default string to the <i>lpReturnedString</i> buffer.</para>
      <para>If this parameter is <b>NULL</b>, the default is an empty string, "".</para>
      <para>Avoid specifying a default string with trailing blank characters. The function inserts a <b>null</b> character in the <i>lpReturnedString</i> buffer to strip any trailing blanks.</para>
    </param>
    <param name="lpReturnedString">A pointer to the buffer that receives the retrieved string.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>
      <para>The return value is the number of characters copied to the buffer, not including the terminating <b>null</b> character.</para>
      <para>If neither <i>lpAppName</i> nor <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a <b>null</b> character, and the return value is equal to <i>nSize</i> minus one.</para>
      <para>If either <i>lpAppName</i> or <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters. In this case, the return value is equal to <i>nSize</i> minus two.</para>
      <para>In the event the initialization file specified by <i>lpFileName</i> is not found, or contains invalid values, calling <b>GetLastError</b> will return '0x2' (File Not Found). To retrieve extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetPrivateProfileStringW">
    <summary>
      <para>Retrieves a string from the specified section in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section containing the key name. If this parameter is <b>NULL</b>, the<b>GetPrivateProfileString</b> function copies all section names in the file to the supplied buffer.</param>
    <param name="lpKeyName">The name of the key whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all key names in the section specified by the <i>lpAppName</i> parameter are copied to the buffer specified by the <i>lpReturnedString</i> parameter.</param>
    <param name="lpDefault">
      <para>A default string. If the <i>lpKeyName</i> key cannot be found in the initialization file,<b>GetPrivateProfileString</b> copies the default string to the <i>lpReturnedString</i> buffer.</para>
      <para>If this parameter is <b>NULL</b>, the default is an empty string, "".</para>
      <para>Avoid specifying a default string with trailing blank characters. The function inserts a <b>null</b> character in the <i>lpReturnedString</i> buffer to strip any trailing blanks.</para>
    </param>
    <param name="lpReturnedString">A pointer to the buffer that receives the retrieved string.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>
      <para>The return value is the number of characters copied to the buffer, not including the terminating <b>null</b> character.</para>
      <para>If neither <i>lpAppName</i> nor <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a <b>null</b> character, and the return value is equal to <i>nSize</i> minus one.</para>
      <para>If either <i>lpAppName</i> or <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters. In this case, the return value is equal to <i>nSize</i> minus two.</para>
      <para>In the event the initialization file specified by <i>lpFileName</i> is not found, or contains invalid values, calling <b>GetLastError</b> will return '0x2' (File Not Found). To retrieve extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetPrivateProfileString">
    <summary>
      <para>Retrieves a string from the specified section in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section containing the key name. If this parameter is <b>NULL</b>, the<b>GetPrivateProfileString</b> function copies all section names in the file to the supplied buffer.</param>
    <param name="lpKeyName">The name of the key whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all key names in the section specified by the <i>lpAppName</i> parameter are copied to the buffer specified by the <i>lpReturnedString</i> parameter.</param>
    <param name="lpDefault">
      <para>A default string. If the <i>lpKeyName</i> key cannot be found in the initialization file,<b>GetPrivateProfileString</b> copies the default string to the <i>lpReturnedString</i> buffer.</para>
      <para>If this parameter is <b>NULL</b>, the default is an empty string, "".</para>
      <para>Avoid specifying a default string with trailing blank characters. The function inserts a <b>null</b> character in the <i>lpReturnedString</i> buffer to strip any trailing blanks.</para>
    </param>
    <param name="lpReturnedString">A pointer to the buffer that receives the retrieved string.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>
      <para>The return value is the number of characters copied to the buffer, not including the terminating <b>null</b> character.</para>
      <para>If neither <i>lpAppName</i> nor <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a <b>null</b> character, and the return value is equal to <i>nSize</i> minus one.</para>
      <para>If either <i>lpAppName</i> or <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters. In this case, the return value is equal to <i>nSize</i> minus two.</para>
      <para>In the event the initialization file specified by <i>lpFileName</i> is not found, or contains invalid values, this function will set <b>errorno</b> with a value of '0x2' (File Not Found). To retrieve extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetPrivateProfileStringA">
    <summary>
      <para>Retrieves a string from the specified section in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section containing the key name. If this parameter is <b>NULL</b>, the<b>GetPrivateProfileString</b> function copies all section names in the file to the supplied buffer.</param>
    <param name="lpKeyName">The name of the key whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all key names in the section specified by the <i>lpAppName</i> parameter are copied to the buffer specified by the <i>lpReturnedString</i> parameter.</param>
    <param name="lpDefault">
      <para>A default string. If the <i>lpKeyName</i> key cannot be found in the initialization file,<b>GetPrivateProfileString</b> copies the default string to the <i>lpReturnedString</i> buffer.</para>
      <para>If this parameter is <b>NULL</b>, the default is an empty string, "".</para>
      <para>Avoid specifying a default string with trailing blank characters. The function inserts a <b>null</b> character in the <i>lpReturnedString</i> buffer to strip any trailing blanks.</para>
    </param>
    <param name="lpReturnedString">A pointer to the buffer that receives the retrieved string.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>
      <para>The return value is the number of characters copied to the buffer, not including the terminating <b>null</b> character.</para>
      <para>If neither <i>lpAppName</i> nor <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a <b>null</b> character, and the return value is equal to <i>nSize</i> minus one.</para>
      <para>If either <i>lpAppName</i> or <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters. In this case, the return value is equal to <i>nSize</i> minus two.</para>
      <para>In the event the initialization file specified by <i>lpFileName</i> is not found, or contains invalid values, this function will set <b>errorno</b> with a value of '0x2' (File Not Found). To retrieve extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetPrivateProfileStringW">
    <summary>
      <para>Retrieves a string from the specified section in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section containing the key name. If this parameter is <b>NULL</b>, the<b>GetPrivateProfileString</b> function copies all section names in the file to the supplied buffer.</param>
    <param name="lpKeyName">The name of the key whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all key names in the section specified by the <i>lpAppName</i> parameter are copied to the buffer specified by the <i>lpReturnedString</i> parameter.</param>
    <param name="lpDefault">
      <para>A default string. If the <i>lpKeyName</i> key cannot be found in the initialization file,<b>GetPrivateProfileString</b> copies the default string to the <i>lpReturnedString</i> buffer.</para>
      <para>If this parameter is <b>NULL</b>, the default is an empty string, "".</para>
      <para>Avoid specifying a default string with trailing blank characters. The function inserts a <b>null</b> character in the <i>lpReturnedString</i> buffer to strip any trailing blanks.</para>
    </param>
    <param name="lpReturnedString">A pointer to the buffer that receives the retrieved string.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>
      <para>The return value is the number of characters copied to the buffer, not including the terminating <b>null</b> character.</para>
      <para>If neither <i>lpAppName</i> nor <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a <b>null</b> character, and the return value is equal to <i>nSize</i> minus one.</para>
      <para>If either <i>lpAppName</i> or <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters. In this case, the return value is equal to <i>nSize</i> minus two.</para>
      <para>In the event the initialization file specified by <i>lpFileName</i> is not found, or contains invalid values, this function will set <b>errorno</b> with a value of '0x2' (File Not Found). To retrieve extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetPrivateProfileString">
    <summary>
      <para>Retrieves a string from the specified section in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section containing the key name. If this parameter is <b>NULL</b>, the<b>GetPrivateProfileString</b> function copies all section names in the file to the supplied buffer.</param>
    <param name="lpKeyName">The name of the key whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all key names in the section specified by the <i>lpAppName</i> parameter are copied to the buffer specified by the <i>lpReturnedString</i> parameter.</param>
    <param name="lpDefault">
      <para>A default string. If the <i>lpKeyName</i> key cannot be found in the initialization file,<b>GetPrivateProfileString</b> copies the default string to the <i>lpReturnedString</i> buffer.</para>
      <para>If this parameter is <b>NULL</b>, the default is an empty string, "".</para>
      <para>Avoid specifying a default string with trailing blank characters. The function inserts a <b>null</b> character in the <i>lpReturnedString</i> buffer to strip any trailing blanks.</para>
    </param>
    <param name="lpReturnedString">A pointer to the buffer that receives the retrieved string.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>
      <para>The return value is the number of characters copied to the buffer, not including the terminating <b>null</b> character.</para>
      <para>If neither <i>lpAppName</i> nor <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a <b>null</b> character, and the return value is equal to <i>nSize</i> minus one.</para>
      <para>If either <i>lpAppName</i> or <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters. In this case, the return value is equal to <i>nSize</i> minus two.</para>
      <para>In the event the initialization file specified by <i>lpFileName</i> is not found, or contains invalid values, this function will set <b>errorno</b> with a value of '0x2' (File Not Found). To retrieve extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetPrivateProfileStringA">
    <summary>
      <para>Retrieves a string from the specified section in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section containing the key name. If this parameter is <b>NULL</b>, the<b>GetPrivateProfileString</b> function copies all section names in the file to the supplied buffer.</param>
    <param name="lpKeyName">The name of the key whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all key names in the section specified by the <i>lpAppName</i> parameter are copied to the buffer specified by the <i>lpReturnedString</i> parameter.</param>
    <param name="lpDefault">
      <para>A default string. If the <i>lpKeyName</i> key cannot be found in the initialization file,<b>GetPrivateProfileString</b> copies the default string to the <i>lpReturnedString</i> buffer.</para>
      <para>If this parameter is <b>NULL</b>, the default is an empty string, "".</para>
      <para>Avoid specifying a default string with trailing blank characters. The function inserts a <b>null</b> character in the <i>lpReturnedString</i> buffer to strip any trailing blanks.</para>
    </param>
    <param name="lpReturnedString">A pointer to the buffer that receives the retrieved string.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>
      <para>The return value is the number of characters copied to the buffer, not including the terminating <b>null</b> character.</para>
      <para>If neither <i>lpAppName</i> nor <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a <b>null</b> character, and the return value is equal to <i>nSize</i> minus one.</para>
      <para>If either <i>lpAppName</i> or <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters. In this case, the return value is equal to <i>nSize</i> minus two.</para>
      <para>In the event the initialization file specified by <i>lpFileName</i> is not found, or contains invalid values, this function will set <b>errorno</b> with a value of '0x2' (File Not Found). To retrieve extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetPrivateProfileStringW">
    <summary>
      <para>Retrieves a string from the specified section in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section containing the key name. If this parameter is <b>NULL</b>, the<b>GetPrivateProfileString</b> function copies all section names in the file to the supplied buffer.</param>
    <param name="lpKeyName">The name of the key whose associated string is to be retrieved. If this parameter is <b>NULL</b>, all key names in the section specified by the <i>lpAppName</i> parameter are copied to the buffer specified by the <i>lpReturnedString</i> parameter.</param>
    <param name="lpDefault">
      <para>A default string. If the <i>lpKeyName</i> key cannot be found in the initialization file,<b>GetPrivateProfileString</b> copies the default string to the <i>lpReturnedString</i> buffer.</para>
      <para>If this parameter is <b>NULL</b>, the default is an empty string, "".</para>
      <para>Avoid specifying a default string with trailing blank characters. The function inserts a <b>null</b> character in the <i>lpReturnedString</i> buffer to strip any trailing blanks.</para>
    </param>
    <param name="lpReturnedString">A pointer to the buffer that receives the retrieved string.</param>
    <param name="nSize">The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</param>
    <param name="lpFileName">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>
      <para>The return value is the number of characters copied to the buffer, not including the terminating <b>null</b> character.</para>
      <para>If neither <i>lpAppName</i> nor <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold the requested string, the string is truncated and followed by a <b>null</b> character, and the return value is equal to <i>nSize</i> minus one.</para>
      <para>If either <i>lpAppName</i> or <i>lpKeyName</i> is <b>NULL</b> and the supplied destination buffer is too small to hold all the strings, the last string is truncated and followed by two <b>null</b> characters. In this case, the return value is equal to <i>nSize</i> minus two.</para>
      <para>In the event the initialization file specified by <i>lpFileName</i> is not found, or contains invalid values, this function will set <b>errorno</b> with a value of '0x2' (File Not Found). To retrieve extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetPrivateProfileStruct">
    <summary>
      <para>Retrieves the data associated with a key in the specified section of an initialization file. As it retrieves the data, the function calculates a checksum and compares it with the checksum calculated by the<see cref="WritePrivateProfileStruct" /> function when the data was added to the file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszSection">The name of the section in the initialization file.</param>
    <param name="lpszKey">The name of the key whose data is to be retrieved.</param>
    <param name="lpStruct">A pointer to the buffer that receives the data associated with the file, section, and key names.</param>
    <param name="uSizeStruct">The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</param>
    <param name="szFile">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.GetPrivateProfileStructA">
    <summary>
      <para>Retrieves the data associated with a key in the specified section of an initialization file. As it retrieves the data, the function calculates a checksum and compares it with the checksum calculated by the<see cref="WritePrivateProfileStruct" /> function when the data was added to the file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszSection">The name of the section in the initialization file.</param>
    <param name="lpszKey">The name of the key whose data is to be retrieved.</param>
    <param name="lpStruct">A pointer to the buffer that receives the data associated with the file, section, and key names.</param>
    <param name="uSizeStruct">The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</param>
    <param name="szFile">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.GetPrivateProfileStructW">
    <summary>
      <para>Retrieves the data associated with a key in the specified section of an initialization file. As it retrieves the data, the function calculates a checksum and compares it with the checksum calculated by the<see cref="WritePrivateProfileStruct" /> function when the data was added to the file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszSection">The name of the section in the initialization file.</param>
    <param name="lpszKey">The name of the key whose data is to be retrieved.</param>
    <param name="lpStruct">A pointer to the buffer that receives the data associated with the file, section, and key names.</param>
    <param name="uSizeStruct">The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</param>
    <param name="szFile">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.GetPrivateProfileStruct">
    <summary>
      <para>Retrieves the data associated with a key in the specified section of an initialization file. As it retrieves the data, the function calculates a checksum and compares it with the checksum calculated by the<see cref="WritePrivateProfileStruct" /> function when the data was added to the file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszSection">The name of the section in the initialization file.</param>
    <param name="lpszKey">The name of the key whose data is to be retrieved.</param>
    <param name="lpStruct">A pointer to the buffer that receives the data associated with the file, section, and key names.</param>
    <param name="uSizeStruct">The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</param>
    <param name="szFile">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.GetPrivateProfileStructA">
    <summary>
      <para>Retrieves the data associated with a key in the specified section of an initialization file. As it retrieves the data, the function calculates a checksum and compares it with the checksum calculated by the<see cref="WritePrivateProfileStruct" /> function when the data was added to the file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszSection">The name of the section in the initialization file.</param>
    <param name="lpszKey">The name of the key whose data is to be retrieved.</param>
    <param name="lpStruct">A pointer to the buffer that receives the data associated with the file, section, and key names.</param>
    <param name="uSizeStruct">The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</param>
    <param name="szFile">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.GetPrivateProfileStructW">
    <summary>
      <para>Retrieves the data associated with a key in the specified section of an initialization file. As it retrieves the data, the function calculates a checksum and compares it with the checksum calculated by the<see cref="WritePrivateProfileStruct" /> function when the data was added to the file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszSection">The name of the section in the initialization file.</param>
    <param name="lpszKey">The name of the key whose data is to be retrieved.</param>
    <param name="lpStruct">A pointer to the buffer that receives the data associated with the file, section, and key names.</param>
    <param name="uSizeStruct">The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</param>
    <param name="szFile">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.GetPrivateProfileStruct">
    <summary>
      <para>Retrieves the data associated with a key in the specified section of an initialization file. As it retrieves the data, the function calculates a checksum and compares it with the checksum calculated by the<see cref="WritePrivateProfileStruct" /> function when the data was added to the file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszSection">The name of the section in the initialization file.</param>
    <param name="lpszKey">The name of the key whose data is to be retrieved.</param>
    <param name="lpStruct">A pointer to the buffer that receives the data associated with the file, section, and key names.</param>
    <param name="uSizeStruct">The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</param>
    <param name="szFile">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.GetPrivateProfileStructA">
    <summary>
      <para>Retrieves the data associated with a key in the specified section of an initialization file. As it retrieves the data, the function calculates a checksum and compares it with the checksum calculated by the<see cref="WritePrivateProfileStruct" /> function when the data was added to the file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszSection">The name of the section in the initialization file.</param>
    <param name="lpszKey">The name of the key whose data is to be retrieved.</param>
    <param name="lpStruct">A pointer to the buffer that receives the data associated with the file, section, and key names.</param>
    <param name="uSizeStruct">The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</param>
    <param name="szFile">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.GetPrivateProfileStructW">
    <summary>
      <para>Retrieves the data associated with a key in the specified section of an initialization file. As it retrieves the data, the function calculates a checksum and compares it with the checksum calculated by the<see cref="WritePrivateProfileStruct" /> function when the data was added to the file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszSection">The name of the section in the initialization file.</param>
    <param name="lpszKey">The name of the key whose data is to be retrieved.</param>
    <param name="lpStruct">A pointer to the buffer that receives the data associated with the file, section, and key names.</param>
    <param name="uSizeStruct">The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</param>
    <param name="szFile">The name of the initialization file. If this parameter does not contain a full path to the file, the system searches for the file in the Windows directory.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.GetProcessAffinityMask">
    <summary>Retrieves the process affinity mask for the specified process and the system affinity mask for the system.</summary>
    <param name="hProcess">
      <para>A handle to the process whose affinity mask is desired.</para>
      <para>This handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpProcessAffinityMask">A pointer to a variable that receives the affinity mask for the specified process.</param>
    <param name="lpSystemAffinityMask">A pointer to a variable that receives the affinity mask for the system.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero and the function sets the variables pointed to by <i>lpProcessAffinityMask</i> and <i>lpSystemAffinityMask</i> to the appropriate affinity masks.</para>
      <para>On a system with more than 64 processors, if the threads of the calling process are in a single <a href="https://docs.microsoft.com//windows/desktop/ProcThread/processor-groups">processor group</a>, the function sets the variables pointed to by <i>lpProcessAffinityMask</i> and <i>lpSystemAffinityMask</i> to the process affinity mask and the processor mask of active logical processors for that group. If the calling process contains threads in multiple groups, the function returns zero for both affinity masks.</para>
      <para>If the function fails, the return value is zero, and the values of the variables pointed to by <i>lpProcessAffinityMask</i> and <i>lpSystemAffinityMask</i> are undefined. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetProcessDEPPolicy">
    <summary>Gets the data execution prevention (DEP) and DEP-ATL thunk emulation settings for the specified 32-bit process.<b>Windows XP with SP3:  </b>Gets the DEP and DEP-ATL thunk emulation settings for the current process.</summary>
    <param name="hProcess">
      <para>A handle to the process. <b>PROCESS_QUERY_INFORMATION</b> privilege is required to get the DEP policy of a process.</para>
      <para>
        <b>Windows XP with SP3:  </b>The <i>hProcess</i> parameter is ignored.</para>
    </param>
    <param name="lpFlags">
      <para>A <b>DWORD</b> that receives one or more of the following flags.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>DEP is disabled for the specified process.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PROCESS_DEP_ENABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>DEP is enabled for the specified process.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>DEP-ATL thunk emulation is disabled for the specified process. For information about DEP-ATL thunk emulation, see <see cref="SetProcessDEPPolicy" />.</description>
        </listheader>
      </list>
    </param>
    <param name="lpPermanent">
      <b>TRUE</b> if DEP is enabled or disabled permanently for the specified process; otherwise <b>FALSE</b>. If <i>lpPermanent</i> is <b>TRUE</b>, the current DEP setting persists for the life of the process and cannot be changed by calling <see cref="SetProcessDEPPolicy" />.</param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>.</para>
      <para>If the function fails, it returns <b>FALSE</b>. To retrieve error values defined for this function, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetProcessIoCounters">
    <summary>Retrieves accounting information for all I/O operations performed by the specified process.</summary>
    <param name="hProcess">
      <para>A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b> access right.</para>
    </param>
    <param name="lpIoCounters">A pointer to an<see cref="IO_COUNTERS" /> structure that receives the I/O accounting information for the process.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetProfileInt">
    <summary>
      <para>Retrieves an integer from a key in the specified section of the Win.ini file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section containing the key name.</param>
    <param name="lpKeyName">The name of the key whose value is to be retrieved. This value is in the form of a string; the<b>GetProfileInt</b> function converts the string into an integer and returns the integer.</param>
    <param name="nDefault">The default value to return if the key name cannot be found in the initialization file.</param>
    <returns>The return value is the integer equivalent of the string following the key name in Win.ini. If the function cannot find the key, the return value is the default value. If the value of the key is less than zero, the return value is zero.</returns>
  </member>
  <member name="Windows.GetProfileIntA">
    <summary>
      <para>Retrieves an integer from a key in the specified section of the Win.ini file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section containing the key name.</param>
    <param name="lpKeyName">The name of the key whose value is to be retrieved. This value is in the form of a string; the<b>GetProfileInt</b> function converts the string into an integer and returns the integer.</param>
    <param name="nDefault">The default value to return if the key name cannot be found in the initialization file.</param>
    <returns>The return value is the integer equivalent of the string following the key name in Win.ini. If the function cannot find the key, the return value is the default value. If the value of the key is less than zero, the return value is zero.</returns>
  </member>
  <member name="Windows.GetProfileIntW">
    <summary>
      <para>Retrieves an integer from a key in the specified section of the Win.ini file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section containing the key name.</param>
    <param name="lpKeyName">The name of the key whose value is to be retrieved. This value is in the form of a string; the<b>GetProfileInt</b> function converts the string into an integer and returns the integer.</param>
    <param name="nDefault">The default value to return if the key name cannot be found in the initialization file.</param>
    <returns>The return value is the integer equivalent of the string following the key name in Win.ini. If the function cannot find the key, the return value is the default value. If the value of the key is less than zero, the return value is zero.</returns>
  </member>
  <member name="Windows.GetProfileInt">
    <summary>
      <para>Retrieves an integer from a key in the specified section of the Win.ini file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section containing the key name.</param>
    <param name="lpKeyName">The name of the key whose value is to be retrieved. This value is in the form of a string; the<b>GetProfileInt</b> function converts the string into an integer and returns the integer.</param>
    <param name="nDefault">The default value to return if the key name cannot be found in the initialization file.</param>
    <returns>The return value is the integer equivalent of the string following the key name in Win.ini. If the function cannot find the key, the return value is the default value. If the value of the key is less than zero, the return value is zero.</returns>
  </member>
  <member name="Windows.GetProfileIntA">
    <summary>
      <para>Retrieves an integer from a key in the specified section of the Win.ini file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section containing the key name.</param>
    <param name="lpKeyName">The name of the key whose value is to be retrieved. This value is in the form of a string; the<b>GetProfileInt</b> function converts the string into an integer and returns the integer.</param>
    <param name="nDefault">The default value to return if the key name cannot be found in the initialization file.</param>
    <returns>The return value is the integer equivalent of the string following the key name in Win.ini. If the function cannot find the key, the return value is the default value. If the value of the key is less than zero, the return value is zero.</returns>
  </member>
  <member name="Windows.GetProfileIntW">
    <summary>
      <para>Retrieves an integer from a key in the specified section of the Win.ini file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section containing the key name.</param>
    <param name="lpKeyName">The name of the key whose value is to be retrieved. This value is in the form of a string; the<b>GetProfileInt</b> function converts the string into an integer and returns the integer.</param>
    <param name="nDefault">The default value to return if the key name cannot be found in the initialization file.</param>
    <returns>The return value is the integer equivalent of the string following the key name in Win.ini. If the function cannot find the key, the return value is the default value. If the value of the key is less than zero, the return value is zero.</returns>
  </member>
  <member name="Windows.GetProfileSection">
    <summary>
      <para>Retrieves all the keys and values for the specified section of the Win.ini file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the Win.ini file.</param>
    <param name="lpReturnedString">A pointer to a buffer that receives the keys and values associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <returns>The return value specifies the number of characters copied to the specified buffer, not including the terminating null character. If the buffer is not large enough to contain all the keys and values associated with the named section, the return value is equal to the size specified by <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetProfileSectionA">
    <summary>
      <para>Retrieves all the keys and values for the specified section of the Win.ini file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the Win.ini file.</param>
    <param name="lpReturnedString">A pointer to a buffer that receives the keys and values associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <returns>The return value specifies the number of characters copied to the specified buffer, not including the terminating null character. If the buffer is not large enough to contain all the keys and values associated with the named section, the return value is equal to the size specified by <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetProfileSectionW">
    <summary>
      <para>Retrieves all the keys and values for the specified section of the Win.ini file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the Win.ini file.</param>
    <param name="lpReturnedString">A pointer to a buffer that receives the keys and values associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <returns>The return value specifies the number of characters copied to the specified buffer, not including the terminating null character. If the buffer is not large enough to contain all the keys and values associated with the named section, the return value is equal to the size specified by <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetProfileSection">
    <summary>
      <para>Retrieves all the keys and values for the specified section of the Win.ini file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the Win.ini file.</param>
    <param name="lpReturnedString">A pointer to a buffer that receives the keys and values associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <returns>The return value specifies the number of characters copied to the specified buffer, not including the terminating null character. If the buffer is not large enough to contain all the keys and values associated with the named section, the return value is equal to the size specified by <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetProfileSectionA">
    <summary>
      <para>Retrieves all the keys and values for the specified section of the Win.ini file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the Win.ini file.</param>
    <param name="lpReturnedString">A pointer to a buffer that receives the keys and values associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <returns>The return value specifies the number of characters copied to the specified buffer, not including the terminating null character. If the buffer is not large enough to contain all the keys and values associated with the named section, the return value is equal to the size specified by <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetProfileSectionW">
    <summary>
      <para>Retrieves all the keys and values for the specified section of the Win.ini file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in the Win.ini file.</param>
    <param name="lpReturnedString">A pointer to a buffer that receives the keys and values associated with the named section. The buffer is filled with one or more null-terminated strings; the last string is followed by a second null character.</param>
    <param name="nSize">
      <para>The size of the buffer pointed to by the <i>lpReturnedString</i> parameter, in characters.</para>
      <para>The maximum profile section size is 32,767 characters.</para>
    </param>
    <returns>The return value specifies the number of characters copied to the specified buffer, not including the terminating null character. If the buffer is not large enough to contain all the keys and values associated with the named section, the return value is equal to the size specified by <i>nSize</i> minus two.</returns>
  </member>
  <member name="Windows.GetShortPathName">
    <summary>
      <para>Retrieves the short path form of the specified path.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </summary>
    <param name="lpszLongPath">
      <para>The path string.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpszShortPath">
      <para>A pointer to a buffer to receive the null-terminated short form of the path that<i>lpszLongPath</i> specifies.</para>
      <para>Passing <b>NULL</b> for this parameter and zero for <i>cchBuffer</i>will always return the required buffer size for a specified <i>lpszLongPath</i>.</para>
    </param>
    <param name="cchBuffer">
      <para>The size of the buffer that <i>lpszShortPath</i> points to, in<b>TCHARs</b>.</para>
      <para>Set this parameter to zero if <i>lpszShortPath</i> is set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string that is copied to <i>lpszShortPath</i>, not including the terminating null character.</para>
      <para>If the <i>lpszShortPath</i> buffer is too small to contain the path, the return value is the size of the buffer, in <b>TCHARs</b>, that is required to hold the path and the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetShortPathNameA">
    <summary>
      <para>Retrieves the short path form of the specified path.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </summary>
    <param name="lpszLongPath">
      <para>The path string.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpszShortPath">
      <para>A pointer to a buffer to receive the null-terminated short form of the path that<i>lpszLongPath</i> specifies.</para>
      <para>Passing <b>NULL</b> for this parameter and zero for <i>cchBuffer</i>will always return the required buffer size for a specified <i>lpszLongPath</i>.</para>
    </param>
    <param name="cchBuffer">
      <para>The size of the buffer that <i>lpszShortPath</i> points to, in<b>TCHARs</b>.</para>
      <para>Set this parameter to zero if <i>lpszShortPath</i> is set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string that is copied to <i>lpszShortPath</i>, not including the terminating null character.</para>
      <para>If the <i>lpszShortPath</i> buffer is too small to contain the path, the return value is the size of the buffer, in <b>TCHARs</b>, that is required to hold the path and the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetShortPathNameW">
    <summary>
      <para>Retrieves the short path form of the specified path.</para>
      <para>For more information about file and path names, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
    </summary>
    <param name="lpszLongPath">
      <para>The path string.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpszShortPath">
      <para>A pointer to a buffer to receive the null-terminated short form of the path that<i>lpszLongPath</i> specifies.</para>
      <para>Passing <b>NULL</b> for this parameter and zero for <i>cchBuffer</i>will always return the required buffer size for a specified <i>lpszLongPath</i>.</para>
    </param>
    <param name="cchBuffer">
      <para>The size of the buffer that <i>lpszShortPath</i> points to, in<b>TCHARs</b>.</para>
      <para>Set this parameter to zero if <i>lpszShortPath</i> is set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the string that is copied to <i>lpszShortPath</i>, not including the terminating null character.</para>
      <para>If the <i>lpszShortPath</i> buffer is too small to contain the path, the return value is the size of the buffer, in <b>TCHARs</b>, that is required to hold the path and the terminating null character.</para>
      <para>If the function fails for any other reason, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetSystemDEPPolicy">
    <summary>Gets the data execution prevention (DEP) policy setting for the system.</summary>
    <returns>
      <para>This function returns a value of type <b>DEP_SYSTEM_POLICY_TYPE</b>, which can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>AlwaysOff</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>DEP is disabled for all parts of the system, regardless of hardware support for DEP. The processor runs in PAE mode with 32-bit versions of Windows unless PAE is disabled in the boot configuration data.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>AlwaysOn</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>DEP is enabled for all parts of the system. All processes always run with DEP enabled. DEP cannot be explicitly disabled for selected applications. System compatibility fixes are ignored.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OptIn</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>On systems with processors that are capable of hardware-enforced DEP, DEP is automatically enabled only for operating system components. This is the default setting for client versions of Windows. DEP can be explicitly enabled for selected applications or the current process.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OptOut</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>DEP is automatically enabled for operating system components and all processes. This is the default setting for Windows Server versions. DEP can be explicitly disabled for selected applications or the current process. System compatibility fixes for DEP are in effect.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetSystemPowerStatus">
    <summary>Retrieves the power status of the system. The status indicates whether the system is running on AC or DC power, whether the battery is currently charging, how much battery life remains, and if battery saver is on or off.</summary>
    <param name="lpSystemPowerStatus">A pointer to a<see cref="SYSTEM_POWER_STATUS" /> structure that receives status information.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetSystemRegistryQuota">
    <summary>Retrieves the current size of the registry and the maximum size that the registry is allowed to attain on the system.</summary>
    <param name="pdwQuotaAllowed">A pointer to a variable that receives the maximum size that the registry is allowed to attain on this system, in bytes.</param>
    <param name="pdwQuotaUsed">A pointer to a variable that receives the current size of the registry, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetTapeParameters">
    <summary>The<b>GetTapeParameters</b> function retrieves information that describes the tape or the tape drive.</summary>
    <param name="hDevice">Handle to the device about which information is sought. This handle is created by using the<see cref="CreateFile" /> function.</param>
    <param name="dwOperation">
      <para>Type of information requested. This parameter must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>GET_TAPE_DRIVE_INFORMATION</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>Retrieves information about the tape device.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>GET_TAPE_MEDIA_INFORMATION</b>
                </term>
              </listheader>
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>Retrieves information about the tape in the tape device.</description>
        </listheader>
      </list>
    </param>
    <param name="lpdwSize">Pointer to a variable that receives the size, in bytes, of the buffer specified by the <i>lpTapeInformation</i> parameter. If the buffer is too small, this parameter receives the required size.</param>
    <param name="lpTapeInformation">
      <para>Pointer to a structure that contains the requested information. If the <i>dwOperation</i> parameter is <b>GET_TAPE_MEDIA_INFORMATION</b>, <i>lpTapeInformation</i> points to a<see cref="TAPE_GET_MEDIA_PARAMETERS" /> structure.</para>
      <para>If <i>dwOperation</i> is <b>GET_TAPE_DRIVE_INFORMATION</b>, <i>lpTapeInformation</i> points to a<see cref="TAPE_GET_DRIVE_PARAMETERS" /> structure.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>NO_ERROR</b>.</para>
      <para>If the function fails, it can return one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BEGINNING_OF_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1102L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to access data before the beginning-of-medium marker failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BUS_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>1111L</term>
              </listheader>
            </list>
          </description>
          <description>A reset condition was detected on the bus.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_DEVICE_NOT_PARTITIONED</b>
                </term>
              </listheader>
              <listheader>
                <term>1107L</term>
              </listheader>
            </list>
          </description>
          <description>The partition information could not be found when a tape was being loaded.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_END_OF_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1100L</term>
              </listheader>
            </list>
          </description>
          <description>The end-of-tape marker was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_FILEMARK_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1101L</term>
              </listheader>
            </list>
          </description>
          <description>A filemark was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_BLOCK_LENGTH</b>
                </term>
              </listheader>
              <listheader>
                <term>1106L</term>
              </listheader>
            </list>
          </description>
          <description>The block size is incorrect on a new tape in a multivolume partition.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_MEDIA_CHANGED</b>
                </term>
              </listheader>
              <listheader>
                <term>1110L</term>
              </listheader>
            </list>
          </description>
          <description>The tape that was in the drive has been replaced or removed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NO_DATA_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1104L</term>
              </listheader>
            </list>
          </description>
          <description>The end-of-data marker was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NO_MEDIA_IN_DRIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>1112L</term>
              </listheader>
            </list>
          </description>
          <description>There is no media in the drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_SUPPORTED</b>
                </term>
              </listheader>
              <listheader>
                <term>50L</term>
              </listheader>
            </list>
          </description>
          <description>The tape driver does not support a requested function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PARTITION_FAILURE</b>
                </term>
              </listheader>
              <listheader>
                <term>1105L</term>
              </listheader>
            </list>
          </description>
          <description>The tape could not be partitioned.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_SETMARK_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1103L</term>
              </listheader>
            </list>
          </description>
          <description>A setmark was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_UNABLE_TO_LOCK_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1108L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to lock the ejection mechanism failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1109L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to unload the tape failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_WRITE_PROTECT</b>
                </term>
              </listheader>
              <listheader>
                <term>19L</term>
              </listheader>
            </list>
          </description>
          <description>The media is write protected.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetTapePosition">
    <summary>The<b>GetTapePosition</b> function retrieves the current address of the tape, in logical or absolute blocks.</summary>
    <param name="hDevice">Handle to the device on which to get the tape position. This handle is created by using<see cref="CreateFile" />.</param>
    <param name="dwPositionType">
      <para>Type of address to obtain. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_ABSOLUTE_POSITION</b>
                </term>
              </listheader>
              <listheader>
                <term>0L</term>
              </listheader>
            </list>
          </description>
          <description>The <i>lpdwOffsetLow</i> and <i>lpdwOffsetHigh</i> parameters receive the device-specific block address. The <i>dwPartition</i> parameter receives zero.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_LOGICAL_POSITION</b>
                </term>
              </listheader>
              <listheader>
                <term>1L</term>
              </listheader>
            </list>
          </description>
          <description>The <i>lpdwOffsetLow</i> and <i>lpdwOffsetHigh</i> parameters receive the logical block address. The <i>dwPartition</i> parameter receives the logical tape partition.</description>
        </listheader>
      </list>
    </param>
    <param name="lpdwPartition">Pointer to a variable that receives the number of the current tape partition. Partitions are numbered logically from 1 through n, where 1 is the first partition on the tape and n is the last. When a device-specific block address is retrieved, or if the device supports only one partition, this parameter receives zero.</param>
    <param name="lpdwOffsetLow">Pointer to a variable that receives the low-order bits of the current tape position.</param>
    <param name="lpdwOffsetHigh">Pointer to a variable that receives the high-order bits of the current tape position. This parameter can be <b>NULL</b> if the high-order bits are not required.</param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, it can return one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BEGINNING_OF_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1102L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to access data before the beginning-of-medium marker failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BUS_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>1111L</term>
              </listheader>
            </list>
          </description>
          <description>A reset condition was detected on the bus.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_DEVICE_NOT_PARTITIONED</b>
                </term>
              </listheader>
              <listheader>
                <term>1107L</term>
              </listheader>
            </list>
          </description>
          <description>The partition information could not be found when a tape was being loaded.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_END_OF_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1100L</term>
              </listheader>
            </list>
          </description>
          <description>The end-of-tape marker was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_FILEMARK_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1101L</term>
              </listheader>
            </list>
          </description>
          <description>A filemark was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_BLOCK_LENGTH</b>
                </term>
              </listheader>
              <listheader>
                <term>1106L</term>
              </listheader>
            </list>
          </description>
          <description>The block size is incorrect on a new tape in a multivolume partition.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_MEDIA_CHANGED</b>
                </term>
              </listheader>
              <listheader>
                <term>1110L</term>
              </listheader>
            </list>
          </description>
          <description>The tape that was in the drive has been replaced or removed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NO_DATA_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1104L</term>
              </listheader>
            </list>
          </description>
          <description>The end-of-data marker was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NO_MEDIA_IN_DRIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>1112L</term>
              </listheader>
            </list>
          </description>
          <description>There is no media in the drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_SUPPORTED</b>
                </term>
              </listheader>
              <listheader>
                <term>50L</term>
              </listheader>
            </list>
          </description>
          <description>The tape driver does not support a requested function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PARTITION_FAILURE</b>
                </term>
              </listheader>
              <listheader>
                <term>1105L</term>
              </listheader>
            </list>
          </description>
          <description>The tape could not be partitioned.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_SETMARK_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1103L</term>
              </listheader>
            </list>
          </description>
          <description>A setmark was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_UNABLE_TO_LOCK_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1108L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to lock the ejection mechanism failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1109L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to unload the tape failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_WRITE_PROTECT</b>
                </term>
              </listheader>
              <listheader>
                <term>19L</term>
              </listheader>
            </list>
          </description>
          <description>The media is write protected.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetTapeStatus">
    <summary>The<b>GetTapeStatus</b> function determines whether the tape device is ready to process tape commands.</summary>
    <param name="hDevice">Handle to the device for which to get the device status. This handle is created by using the<see cref="CreateFile" /> function.</param>
    <returns>
      <para>If the tape device is ready to accept appropriate tape-access commands without returning errors, the return value is NO_ERROR.</para>
      <para>If the function fails, it can return one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BEGINNING_OF_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1102L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to access data before the beginning-of-medium marker failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BUS_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>1111L</term>
              </listheader>
            </list>
          </description>
          <description>A reset condition was detected on the bus.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_DEVICE_NOT_PARTITIONED</b>
                </term>
              </listheader>
              <listheader>
                <term>1107L</term>
              </listheader>
            </list>
          </description>
          <description>The partition information could not be found when a tape was being loaded.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_DEVICE_REQUIRES_CLEANING</b>
                </term>
              </listheader>
              <listheader>
                <term>1165L</term>
              </listheader>
            </list>
          </description>
          <description>The tape drive is capable of reporting that it requires cleaning, and reports that it does require cleaning.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_END_OF_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1100L</term>
              </listheader>
            </list>
          </description>
          <description>The end-of-tape marker was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_FILEMARK_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1101L</term>
              </listheader>
            </list>
          </description>
          <description>A filemark was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_BLOCK_LENGTH</b>
                </term>
              </listheader>
              <listheader>
                <term>1106L</term>
              </listheader>
            </list>
          </description>
          <description>The block size is incorrect on a new tape in a multivolume partition.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_MEDIA_CHANGED</b>
                </term>
              </listheader>
              <listheader>
                <term>1110L</term>
              </listheader>
            </list>
          </description>
          <description>The tape that was in the drive has been replaced or removed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NO_DATA_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1104L</term>
              </listheader>
            </list>
          </description>
          <description>The end-of-data marker was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NO_MEDIA_IN_DRIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>1112L</term>
              </listheader>
            </list>
          </description>
          <description>There is no media in the drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_SUPPORTED</b>
                </term>
              </listheader>
              <listheader>
                <term>50L</term>
              </listheader>
            </list>
          </description>
          <description>The tape driver does not support a requested function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PARTITION_FAILURE</b>
                </term>
              </listheader>
              <listheader>
                <term>1105L</term>
              </listheader>
            </list>
          </description>
          <description>The tape could not be partitioned.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_SETMARK_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1103L</term>
              </listheader>
            </list>
          </description>
          <description>A setmark was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_UNABLE_TO_LOCK_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1108L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to lock the ejection mechanism failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1109L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to unload the tape failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_WRITE_PROTECT</b>
                </term>
              </listheader>
              <listheader>
                <term>19L</term>
              </listheader>
            </list>
          </description>
          <description>The media is write protected.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetTempFileName">
    <summary>Creates a name for a temporary file. If a unique file name is generated, an empty file is created and the handle to it is released; otherwise, only a file name is generated.</summary>
    <param name="lpPathName">The directory path for the file name. Applications typically specify a period (.) for the current directory or the result of the <see cref="GetTempPath" /> function. The string cannot be longer than <b>MAX_PATH</b>–14 characters or<b>GetTempFileName</b> will fail. If this parameter is<b>NULL</b>, the function fails.</param>
    <param name="lpPrefixString">The null-terminated prefix string. The function uses up to the first three characters of this string as the prefix of the file name. This string must consist of characters in the OEM-defined character set.</param>
    <param name="uUnique">
      <para>An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.</para>
      <para>If <i>uUnique</i> is zero, the function attempts to form a unique file name using the current system time. If the file already exists, the number is increased by one and the functions tests if this file already exists. This continues until a unique filename is found; the function creates a file by that name and closes it. Note that the function does not attempt to verify the uniqueness of the file name when<i>uUnique</i> is nonzero.</para>
    </param>
    <param name="lpTempFileName">A pointer to the buffer that receives the temporary file name. This buffer should be<b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.</param>
    <returns>
      <para>If the function succeeds, the return value specifies the unique numeric value used in the temporary file name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same number.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The following is a possible return value.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BUFFER_OVERFLOW</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The length of the string pointed to by the <i>lpPathName</i> parameter is more than <b>MAX_PATH</b>–14 characters.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetTempFileNameA">
    <summary>Creates a name for a temporary file. If a unique file name is generated, an empty file is created and the handle to it is released; otherwise, only a file name is generated.</summary>
    <param name="lpPathName">The directory path for the file name. Applications typically specify a period (.) for the current directory or the result of the <see cref="GetTempPath" /> function. The string cannot be longer than <b>MAX_PATH</b>–14 characters or<b>GetTempFileName</b> will fail. If this parameter is<b>NULL</b>, the function fails.</param>
    <param name="lpPrefixString">The null-terminated prefix string. The function uses up to the first three characters of this string as the prefix of the file name. This string must consist of characters in the OEM-defined character set.</param>
    <param name="uUnique">
      <para>An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.</para>
      <para>If <i>uUnique</i> is zero, the function attempts to form a unique file name using the current system time. If the file already exists, the number is increased by one and the functions tests if this file already exists. This continues until a unique filename is found; the function creates a file by that name and closes it. Note that the function does not attempt to verify the uniqueness of the file name when<i>uUnique</i> is nonzero.</para>
    </param>
    <param name="lpTempFileName">A pointer to the buffer that receives the temporary file name. This buffer should be<b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.</param>
    <returns>
      <para>If the function succeeds, the return value specifies the unique numeric value used in the temporary file name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same number.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The following is a possible return value.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BUFFER_OVERFLOW</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The length of the string pointed to by the <i>lpPathName</i> parameter is more than <b>MAX_PATH</b>–14 characters.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetTempFileNameW">
    <summary>Creates a name for a temporary file. If a unique file name is generated, an empty file is created and the handle to it is released; otherwise, only a file name is generated.</summary>
    <param name="lpPathName">The directory path for the file name. Applications typically specify a period (.) for the current directory or the result of the <see cref="GetTempPath" /> function. The string cannot be longer than <b>MAX_PATH</b>–14 characters or<b>GetTempFileName</b> will fail. If this parameter is<b>NULL</b>, the function fails.</param>
    <param name="lpPrefixString">The null-terminated prefix string. The function uses up to the first three characters of this string as the prefix of the file name. This string must consist of characters in the OEM-defined character set.</param>
    <param name="uUnique">
      <para>An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.</para>
      <para>If <i>uUnique</i> is zero, the function attempts to form a unique file name using the current system time. If the file already exists, the number is increased by one and the functions tests if this file already exists. This continues until a unique filename is found; the function creates a file by that name and closes it. Note that the function does not attempt to verify the uniqueness of the file name when<i>uUnique</i> is nonzero.</para>
    </param>
    <param name="lpTempFileName">A pointer to the buffer that receives the temporary file name. This buffer should be<b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.</param>
    <returns>
      <para>If the function succeeds, the return value specifies the unique numeric value used in the temporary file name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same number.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The following is a possible return value.</para>
      <list type="table">
        <listheader>
          <description>Return value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BUFFER_OVERFLOW</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The length of the string pointed to by the <i>lpPathName</i> parameter is more than <b>MAX_PATH</b>–14 characters.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.GetThreadEnabledXStateFeatures">
    <summary>This function returns the set of XState features that are currently enabled for the current thread.</summary>
    <returns>The return value is a bitmask in which each bit represents an XState feature that is currently enabled for the current thread.</returns>
  </member>
  <member name="Windows.GetThreadSelectorEntry">
    <summary>Retrieves a descriptor table entry for the specified selector and thread.</summary>
    <param name="hThread">A handle to the thread containing the specified selector. The handle must have THREAD_QUERY_INFORMATION access. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</param>
    <param name="dwSelector">The global or local selector value to look up in the thread's descriptor tables.</param>
    <param name="lpSelectorEntry">A pointer to an<see cref="LDT_ENTRY" /> structure that receives a copy of the descriptor table entry if the specified selector has an entry in the specified thread's descriptor table. This information can be used to convert a segment-relative address to a linear virtual address.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero. In that case, the structure pointed to by the <i>lpSelectorEntry</i> parameter receives a copy of the specified descriptor table entry.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetUmsCompletionListEvent">
    <summary>
      <para>Retrieves a handle to the event associated with the specified user-mode scheduling (UMS) completion list.</para>
      <blockquote>[!WARNING] As of Windows 11, user-mode scheduling is not supported. All calls fail with the error <code>ERROR_NOT_SUPPORTED</code>.</blockquote>
    </summary>
    <param name="UmsCompletionList">A pointer to a UMS completion list. The <see cref="CreateUmsCompletionList" /> function provides this pointer.</param>
    <param name="UmsCompletionEvent">A pointer to a HANDLE variable. On output, the <i>UmsCompletionEvent</i> parameter is set to a handle to the event associated with the specified completion list.</param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetUmsSystemThreadInformation">
    <summary>
      <para>Queries whether the specified thread is a UMS scheduler thread, a UMS worker thread, or a non-UMS thread.</para>
      <blockquote>[!WARNING] As of Windows 11, user-mode scheduling is not supported. All calls fail with the error <code>ERROR_NOT_SUPPORTED</code>.</blockquote>
    </summary>
    <param name="ThreadHandle">A handle to a thread. The thread handle must have the THREAD_QUERY_INFORMATION access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</param>
    <param name="SystemThreadInfo">A pointer to an initialized <see cref="UMS_SYSTEM_THREAD_INFORMATION" /> structure that specifies the kind of thread for the query.</param>
    <returns>Returns TRUE if the specified thread matches the kind of thread specified by the <i>SystemThreadInfo</i> parameter. Otherwise, the function returns FALSE.</returns>
  </member>
  <member name="Windows.GetUserName">
    <summary>
      <para>Retrieves the name of the user associated with the current thread.</para>
      <para>Use the<see cref="GetUserNameEx" /> function to retrieve the user name in a specified format. Additional information is provided by the<see cref="IADsADSystemInfo" /> interface.</para>
    </summary>
    <param name="lpBuffer">A pointer to the buffer to receive the user's logon name. If this buffer is not large enough to contain the entire user name, the function fails. A buffer size of (UNLEN + 1) characters will hold the maximum length user name including the terminating null character. UNLEN is defined in Lmcons.h.</param>
    <param name="pcbBuffer">
      <para>On input, this variable specifies the size of the <i>lpBuffer</i> buffer, in <b>TCHARs</b>. On output, the variable receives the number of <b>TCHARs</b> copied to the buffer, including the terminating null character.</para>
      <para>If <i>lpBuffer</i> is too small, the function fails and <see cref="GetLastError" /> returns ERROR_INSUFFICIENT_BUFFER. This parameter receives the required buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value, and the variable pointed to by <i>lpnSize</i> contains the number of <b>TCHARs</b> copied to the buffer specified by <i>lpBuffer</i>, including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetUserNameA">
    <summary>
      <para>Retrieves the name of the user associated with the current thread.</para>
      <para>Use the<see cref="GetUserNameEx" /> function to retrieve the user name in a specified format. Additional information is provided by the<see cref="IADsADSystemInfo" /> interface.</para>
    </summary>
    <param name="lpBuffer">A pointer to the buffer to receive the user's logon name. If this buffer is not large enough to contain the entire user name, the function fails. A buffer size of (UNLEN + 1) characters will hold the maximum length user name including the terminating null character. UNLEN is defined in Lmcons.h.</param>
    <param name="pcbBuffer">
      <para>On input, this variable specifies the size of the <i>lpBuffer</i> buffer, in <b>TCHARs</b>. On output, the variable receives the number of <b>TCHARs</b> copied to the buffer, including the terminating null character.</para>
      <para>If <i>lpBuffer</i> is too small, the function fails and <see cref="GetLastError" /> returns ERROR_INSUFFICIENT_BUFFER. This parameter receives the required buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value, and the variable pointed to by <i>lpnSize</i> contains the number of <b>TCHARs</b> copied to the buffer specified by <i>lpBuffer</i>, including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetUserNameW">
    <summary>
      <para>Retrieves the name of the user associated with the current thread.</para>
      <para>Use the<see cref="GetUserNameEx" /> function to retrieve the user name in a specified format. Additional information is provided by the<see cref="IADsADSystemInfo" /> interface.</para>
    </summary>
    <param name="lpBuffer">A pointer to the buffer to receive the user's logon name. If this buffer is not large enough to contain the entire user name, the function fails. A buffer size of (UNLEN + 1) characters will hold the maximum length user name including the terminating null character. UNLEN is defined in Lmcons.h.</param>
    <param name="pcbBuffer">
      <para>On input, this variable specifies the size of the <i>lpBuffer</i> buffer, in <b>TCHARs</b>. On output, the variable receives the number of <b>TCHARs</b> copied to the buffer, including the terminating null character.</para>
      <para>If <i>lpBuffer</i> is too small, the function fails and <see cref="GetLastError" /> returns ERROR_INSUFFICIENT_BUFFER. This parameter receives the required buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value, and the variable pointed to by <i>lpnSize</i> contains the number of <b>TCHARs</b> copied to the buffer specified by <i>lpBuffer</i>, including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetUserName">
    <summary>
      <para>Retrieves the name of the user associated with the current thread.</para>
      <para>Use the<see cref="GetUserNameEx" /> function to retrieve the user name in a specified format. Additional information is provided by the<see cref="IADsADSystemInfo" /> interface.</para>
    </summary>
    <param name="lpBuffer">A pointer to the buffer to receive the user's logon name. If this buffer is not large enough to contain the entire user name, the function fails. A buffer size of (UNLEN + 1) characters will hold the maximum length user name including the terminating null character. UNLEN is defined in Lmcons.h.</param>
    <param name="pcbBuffer">
      <para>On input, this variable specifies the size of the <i>lpBuffer</i> buffer, in <b>TCHARs</b>. On output, the variable receives the number of <b>TCHARs</b> copied to the buffer, including the terminating null character.</para>
      <para>If <i>lpBuffer</i> is too small, the function fails and <see cref="GetLastError" /> returns ERROR_INSUFFICIENT_BUFFER. This parameter receives the required buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value, and the variable pointed to by <i>lpnSize</i> contains the number of <b>TCHARs</b> copied to the buffer specified by <i>lpBuffer</i>, including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetUserNameA">
    <summary>
      <para>Retrieves the name of the user associated with the current thread.</para>
      <para>Use the<see cref="GetUserNameEx" /> function to retrieve the user name in a specified format. Additional information is provided by the<see cref="IADsADSystemInfo" /> interface.</para>
    </summary>
    <param name="lpBuffer">A pointer to the buffer to receive the user's logon name. If this buffer is not large enough to contain the entire user name, the function fails. A buffer size of (UNLEN + 1) characters will hold the maximum length user name including the terminating null character. UNLEN is defined in Lmcons.h.</param>
    <param name="pcbBuffer">
      <para>On input, this variable specifies the size of the <i>lpBuffer</i> buffer, in <b>TCHARs</b>. On output, the variable receives the number of <b>TCHARs</b> copied to the buffer, including the terminating null character.</para>
      <para>If <i>lpBuffer</i> is too small, the function fails and <see cref="GetLastError" /> returns ERROR_INSUFFICIENT_BUFFER. This parameter receives the required buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value, and the variable pointed to by <i>lpnSize</i> contains the number of <b>TCHARs</b> copied to the buffer specified by <i>lpBuffer</i>, including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetUserNameW">
    <summary>
      <para>Retrieves the name of the user associated with the current thread.</para>
      <para>Use the<see cref="GetUserNameEx" /> function to retrieve the user name in a specified format. Additional information is provided by the<see cref="IADsADSystemInfo" /> interface.</para>
    </summary>
    <param name="lpBuffer">A pointer to the buffer to receive the user's logon name. If this buffer is not large enough to contain the entire user name, the function fails. A buffer size of (UNLEN + 1) characters will hold the maximum length user name including the terminating null character. UNLEN is defined in Lmcons.h.</param>
    <param name="pcbBuffer">
      <para>On input, this variable specifies the size of the <i>lpBuffer</i> buffer, in <b>TCHARs</b>. On output, the variable receives the number of <b>TCHARs</b> copied to the buffer, including the terminating null character.</para>
      <para>If <i>lpBuffer</i> is too small, the function fails and <see cref="GetLastError" /> returns ERROR_INSUFFICIENT_BUFFER. This parameter receives the required buffer size, including the terminating null character.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value, and the variable pointed to by <i>lpnSize</i> contains the number of <b>TCHARs</b> copied to the buffer specified by <i>lpBuffer</i>, including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetVolumeNameForVolumeMountPoint">
    <summary>Retrieves a volume <b>GUID</b> path for the volume that is associated with the specified volume mount point ( drive letter, volume <b>GUID</b> path, or mounted folder).</summary>
    <param name="lpszVolumeMountPoint">A pointer to a string that contains the path of a mounted folder (for example, "Y:\MountX") or a drive letter (for example, "X:\"). The string must end with a trailing backslash ('').</param>
    <param name="lpszVolumeName">A pointer to a string that receives the volume <b>GUID</b> path. This path is of the form "\?\Volume{<i>GUID</i>}" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. If there is more than one volume <b>GUID</b> path for the volume, only the first one in the mount manager's cache is returned.</param>
    <param name="cchBufferLength">The length of the output buffer, in <b>TCHARs</b>. A reasonable size for the buffer to accommodate the largest possible volume <b>GUID</b> path is 50 characters.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetVolumeNameForVolumeMountPointA">
    <summary>Retrieves a volume <b>GUID</b> path for the volume that is associated with the specified volume mount point ( drive letter, volume <b>GUID</b> path, or mounted folder).</summary>
    <param name="lpszVolumeMountPoint">A pointer to a string that contains the path of a mounted folder (for example, "Y:\MountX") or a drive letter (for example, "X:\"). The string must end with a trailing backslash ('').</param>
    <param name="lpszVolumeName">A pointer to a string that receives the volume <b>GUID</b> path. This path is of the form "\?\Volume{<i>GUID</i>}" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. If there is more than one volume <b>GUID</b> path for the volume, only the first one in the mount manager's cache is returned.</param>
    <param name="cchBufferLength">The length of the output buffer, in <b>TCHARs</b>. A reasonable size for the buffer to accommodate the largest possible volume <b>GUID</b> path is 50 characters.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetVolumeNameForVolumeMountPointW">
    <summary>Retrieves a volume <b>GUID</b> path for the volume that is associated with the specified volume mount point ( drive letter, volume <b>GUID</b> path, or mounted folder).</summary>
    <param name="lpszVolumeMountPoint">A pointer to a string that contains the path of a mounted folder (for example, "Y:\MountX") or a drive letter (for example, "X:\"). The string must end with a trailing backslash ('').</param>
    <param name="lpszVolumeName">A pointer to a string that receives the volume <b>GUID</b> path. This path is of the form "\?\Volume{<i>GUID</i>}" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. If there is more than one volume <b>GUID</b> path for the volume, only the first one in the mount manager's cache is returned.</param>
    <param name="cchBufferLength">The length of the output buffer, in <b>TCHARs</b>. A reasonable size for the buffer to accommodate the largest possible volume <b>GUID</b> path is 50 characters.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GetVolumePathNamesForVolumeName">
    <summary>Retrieves a list of drive letters and mounted folder paths for the specified volume.</summary>
    <param name="lpszVolumeName">A volume <b>GUID</b> path for the volume. A volume <b>GUID</b>path is of the form "\?\Volume{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}".</param>
    <param name="lpszVolumePathNames">A pointer to a buffer that receives the list of drive letters and mounted folder paths. The list is an array of null-terminated strings terminated by an additional <b>NULL</b> character. If the buffer is not large enough to hold the complete list, the buffer holds as much of the list as possible.</param>
    <param name="cchBufferLength">The length of the <i>lpszVolumePathNames</i> buffer, in<b>TCHARs</b>, including all <b>NULL</b> characters.</param>
    <param name="lpcchReturnLength">If the call is successful, this parameter is the number of <b>TCHARs</b> copied to the <i>lpszVolumePathNames</i> buffer. Otherwise, this parameter is the size of the buffer required to hold the complete list, in <b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If the buffer is not large enough to hold the complete list, the error code is <b>ERROR_MORE_DATA</b> and the<i>lpcchReturnLength</i> parameter receives the required buffer size.</para>
    </returns>
  </member>
  <member name="Windows.GetVolumePathNamesForVolumeNameA">
    <summary>Retrieves a list of drive letters and mounted folder paths for the specified volume.</summary>
    <param name="lpszVolumeName">A volume <b>GUID</b> path for the volume. A volume <b>GUID</b>path is of the form "\?\Volume{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}".</param>
    <param name="lpszVolumePathNames">A pointer to a buffer that receives the list of drive letters and mounted folder paths. The list is an array of null-terminated strings terminated by an additional <b>NULL</b> character. If the buffer is not large enough to hold the complete list, the buffer holds as much of the list as possible.</param>
    <param name="cchBufferLength">The length of the <i>lpszVolumePathNames</i> buffer, in<b>TCHARs</b>, including all <b>NULL</b> characters.</param>
    <param name="lpcchReturnLength">If the call is successful, this parameter is the number of <b>TCHARs</b> copied to the <i>lpszVolumePathNames</i> buffer. Otherwise, this parameter is the size of the buffer required to hold the complete list, in <b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If the buffer is not large enough to hold the complete list, the error code is <b>ERROR_MORE_DATA</b> and the<i>lpcchReturnLength</i> parameter receives the required buffer size.</para>
    </returns>
  </member>
  <member name="Windows.GetVolumePathNamesForVolumeNameW">
    <summary>Retrieves a list of drive letters and mounted folder paths for the specified volume.</summary>
    <param name="lpszVolumeName">A volume <b>GUID</b> path for the volume. A volume <b>GUID</b>path is of the form "\?\Volume{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}".</param>
    <param name="lpszVolumePathNames">A pointer to a buffer that receives the list of drive letters and mounted folder paths. The list is an array of null-terminated strings terminated by an additional <b>NULL</b> character. If the buffer is not large enough to hold the complete list, the buffer holds as much of the list as possible.</param>
    <param name="cchBufferLength">The length of the <i>lpszVolumePathNames</i> buffer, in<b>TCHARs</b>, including all <b>NULL</b> characters.</param>
    <param name="lpcchReturnLength">If the call is successful, this parameter is the number of <b>TCHARs</b> copied to the <i>lpszVolumePathNames</i> buffer. Otherwise, this parameter is the size of the buffer required to hold the complete list, in <b>TCHARs</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. If the buffer is not large enough to hold the complete list, the error code is <b>ERROR_MORE_DATA</b> and the<i>lpcchReturnLength</i> parameter receives the required buffer size.</para>
    </returns>
  </member>
  <member name="Windows.GetXStateFeaturesMask">
    <summary>Returns the mask of XState features set within a<see cref="CONTEXT" /> structure.</summary>
    <param name="Context">A pointer to a <see cref="CONTEXT" /> structure that has been initialized with <see cref="InitializeContext" />.</param>
    <param name="FeatureMask">A pointer to a variable that receives the mask of XState features which are present in the specified<b>CONTEXT</b> structure.</param>
    <returns>This function returns <b>TRUE</b> if successful, otherwise<b>FALSE</b>.</returns>
  </member>
  <member name="Windows.GlobalAddAtom">
    <summary>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalAddAtomA">
    <summary>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalAddAtomW">
    <summary>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalAddAtomEx">
    <summary>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalAddAtomExA">
    <summary>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalAddAtomExW">
    <summary>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalAddAtomEx">
    <summary>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalAddAtomExA">
    <summary>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalAddAtomExW">
    <summary>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalAddAtom">
    <summary>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalAddAtomA">
    <summary>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalAddAtomW">
    <summary>Adds a character string to the global atom table and returns a unique value (an atom) identifying the string.</summary>
    <param name="lpString">
      <para>The null-terminated string to be added. The string can have a maximum size of 255 bytes. Strings that differ only in case are considered identical. The case of the first string of this name added to the table is preserved and returned by the <see cref="GlobalGetAtomName" /> function.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the newly created atom.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalDeleteAtom">
    <summary>Decrements the reference count of a global string atom. If the atom's reference count reaches zero, <b>GlobalDeleteAtom</b> removes the string associated with the atom from the global atom table.</summary>
    <param name="nAtom">The atom and character string to be deleted.</param>
    <returns>
      <para>The function always returns (<b>ATOM</b>) 0.</para>
      <para>To determine whether the function has failed, call <see cref="SetLastError" /> with <b>ERROR_SUCCESS</b> before calling <b>GlobalDeleteAtom</b>, then call <see cref="GetLastError" />. If the last error code is still <b>ERROR_SUCCESS</b>, <b>GlobalDeleteAtom</b> has succeeded.</para>
    </returns>
  </member>
  <member name="Windows.GlobalDiscard">
    <summary>
      <para>Discards the specified global memory block. The lock count of the memory object must be zero.</para>
      <div>
        <b>Note</b>  The global functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a global function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</div>
    </summary>
    <param name="h">A handle to the global memory object. This handle is returned by either the<see cref="GlobalAlloc" /> or<see cref="GlobalReAlloc" /> function.</param>
  </member>
  <member name="Windows.GlobalFindAtom">
    <summary>Searches the global atom table for the specified character string and retrieves the global atom associated with that string.</summary>
    <param name="lpString">
      <para>The null-terminated character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the global atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalFindAtomA">
    <summary>Searches the global atom table for the specified character string and retrieves the global atom associated with that string.</summary>
    <param name="lpString">
      <para>The null-terminated character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the global atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalFindAtomW">
    <summary>Searches the global atom table for the specified character string and retrieves the global atom associated with that string.</summary>
    <param name="lpString">
      <para>The null-terminated character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the global atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalFindAtom">
    <summary>Searches the global atom table for the specified character string and retrieves the global atom associated with that string.</summary>
    <param name="lpString">
      <para>The null-terminated character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the global atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalFindAtomA">
    <summary>Searches the global atom table for the specified character string and retrieves the global atom associated with that string.</summary>
    <param name="lpString">
      <para>The null-terminated character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the global atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalFindAtomW">
    <summary>Searches the global atom table for the specified character string and retrieves the global atom associated with that string.</summary>
    <param name="lpString">
      <para>The null-terminated character string for which to search.</para>
      <para>Alternatively, you can use an integer atom that has been converted using the <see cref="MAKEINTATOM" /> macro. See the Remarks for more information.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the global atom associated with the given string.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalFlags">
    <summary>
      <para>Retrieves information about the specified global memory object.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a>. For more information, see Remarks.</div>
    </summary>
    <param name="hMem">A handle to the global memory object. This handle is returned by either the<see cref="GlobalAlloc" /> or<see cref="GlobalReAlloc" /> function.</param>
    <returns>
      <para>If the function succeeds, the return value specifies the allocation values and the lock count for the memory object.</para>
      <para>If the function fails, the return value is <b>GMEM_INVALID_HANDLE</b>, indicating that the global handle is not valid. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalFree">
    <summary>
      <para>Frees the specified global memory object and invalidates its handle.</para>
      <div>
        <b>Note</b>  The global functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a global function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</div>
    </summary>
    <param name="hMem">A handle to the global memory object. This handle is returned by either the<see cref="GlobalAlloc" /> or<see cref="GlobalReAlloc" /> function. It is not safe to free memory allocated with <see cref="LocalAlloc" />.</param>
    <returns>
      <para>If the function succeeds, the return value is <b>NULL</b>.</para>
      <para>If the function fails, the return value is equal to a handle to the global memory object. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalGetAtomName">
    <summary>Retrieves a copy of the character string associated with the specified global atom.</summary>
    <param name="nAtom">The global atom associated with the character string to be retrieved.</param>
    <param name="lpBuffer">The buffer for the character string.</param>
    <param name="nSize">The size, in characters, of the buffer.</param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalGetAtomNameA">
    <summary>Retrieves a copy of the character string associated with the specified global atom.</summary>
    <param name="nAtom">The global atom associated with the character string to be retrieved.</param>
    <param name="lpBuffer">The buffer for the character string.</param>
    <param name="nSize">The size, in characters, of the buffer.</param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalGetAtomNameW">
    <summary>Retrieves a copy of the character string associated with the specified global atom.</summary>
    <param name="nAtom">The global atom associated with the character string to be retrieved.</param>
    <param name="lpBuffer">The buffer for the character string.</param>
    <param name="nSize">The size, in characters, of the buffer.</param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalGetAtomName">
    <summary>Retrieves a copy of the character string associated with the specified global atom.</summary>
    <param name="nAtom">The global atom associated with the character string to be retrieved.</param>
    <param name="lpBuffer">The buffer for the character string.</param>
    <param name="nSize">The size, in characters, of the buffer.</param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalGetAtomNameA">
    <summary>Retrieves a copy of the character string associated with the specified global atom.</summary>
    <param name="nAtom">The global atom associated with the character string to be retrieved.</param>
    <param name="lpBuffer">The buffer for the character string.</param>
    <param name="nSize">The size, in characters, of the buffer.</param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalGetAtomNameW">
    <summary>Retrieves a copy of the character string associated with the specified global atom.</summary>
    <param name="nAtom">The global atom associated with the character string to be retrieved.</param>
    <param name="lpBuffer">The buffer for the character string.</param>
    <param name="nSize">The size, in characters, of the buffer.</param>
    <returns>
      <para>If the function succeeds, the return value is the length of the string copied to the buffer, in characters, not including the terminating null character.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalHandle">
    <summary>
      <para>Retrieves the handle associated with the specified pointer to a global memory block.</para>
      <div>
        <b>Note</b>  The global functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a global function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</div>
    </summary>
    <param name="pMem">A pointer to the first byte of the global memory block. This pointer is returned by the<see cref="GlobalLock" /> function.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the specified global memory object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalLock">
    <summary>
      <para>Locks a global memory object and returns a pointer to the first byte of the object's memory block.</para>
      <div>
        <b>Note</b>  The global functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a global function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</div>
    </summary>
    <param name="hMem">A handle to the global memory object. This handle is returned by either the<see cref="GlobalAlloc" /> or<see cref="GlobalReAlloc" /> function.</param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the first byte of the memory block.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalReAlloc">
    <summary>
      <para>Changes the size or attributes of a specified global memory object. The size can increase or decrease.</para>
      <div>
        <b>Note</b>  The global functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a global function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</div>
    </summary>
    <param name="hMem">A handle to the global memory object to be reallocated. This handle is returned by either the<see cref="GlobalAlloc" /> or<b>GlobalReAlloc</b> function.</param>
    <param name="dwBytes">The new size of the memory block, in bytes. If <i>uFlags</i> specifies <b>GMEM_MODIFY</b>, this parameter is ignored.</param>
    <param name="uFlags">
      <para>The reallocation options. If <b>GMEM_MODIFY</b> is specified, the function modifies the attributes of the memory object only (the <i>dwBytes</i> parameter is ignored.) Otherwise, the function reallocates the memory object.</para>
      <para>You can optionally combine <b>GMEM_MODIFY</b> with the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>GMEM_MOVEABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0002</term>
              </listheader>
            </list>
          </description>
          <description>Allocates movable memory.<para>If the memory is a locked <b>GMEM_MOVEABLE</b> memory block or a <b>GMEM_FIXED</b> memory block and this flag is not specified, the memory can only be reallocated in place.</para></description>
        </listheader>
      </list> <para>If this parameter does not specify <b>GMEM_MODIFY</b>, you can use the following value.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>GMEM_ZEROINIT</b></term></listheader><listheader><term>0x0040</term></listheader></list></description><description>Causes the additional memory contents to be initialized to zero if the memory object is growing in size.</description></listheader></list></param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the reallocated memory object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalSize">
    <summary>
      <para>Retrieves the current size of the specified global memory object, in bytes.</para>
      <div>
        <b>Note</b>  The global functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a global function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</div>
    </summary>
    <param name="hMem">A handle to the global memory object. This handle is returned by either the<see cref="GlobalAlloc" /> or<see cref="GlobalReAlloc" /> function.</param>
    <returns>
      <para>If the function succeeds, the return value is the size of the specified global memory object, in bytes.</para>
      <para>If the specified handle is not valid or if the object has been discarded, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.GlobalUnlock">
    <summary>
      <para>Decrements the lock count associated with a memory object that was allocated with <b>GMEM_MOVEABLE</b>. This function has no effect on memory objects allocated with <b>GMEM_FIXED</b>.</para>
      <div>
        <b>Note</b>  The global functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a global function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</div>
    </summary>
    <param name="hMem">A handle to the global memory object. This handle is returned by either the<see cref="GlobalAlloc" /> or<see cref="GlobalReAlloc" /> function.</param>
    <returns>
      <para>If the memory object is still locked after decrementing the lock count, the return value is a nonzero value. If the memory object is unlocked after decrementing the lock count, the function returns zero and <see cref="GetLastError" /> returns <b>NO_ERROR</b>.</para>
      <para>If the function fails, the return value is zero and<see cref="GetLastError" /> returns a value other than <b>NO_ERROR</b>.</para>
    </returns>
  </member>
  <member name="Windows.HasOverlappedIoCompleted">
    <summary>Provides a high performance test operation that can be used to poll for the completion of an outstanding I/O operation.</summary>
    <param name="lpOverlapped">A pointer to an<see cref="OVERLAPPED" /> structure that was specified when the overlapped I/O operation was started.</param>
  </member>
  <member name="Windows.InitAtomTable">
    <summary>Initializes the local atom table and sets the number of hash buckets to the specified size.</summary>
    <param name="nSize">
      <para>The number of hash buckets to use for the atom table. If this parameter is zero, the default number of hash buckets are created.</para>
      <para>To achieve better performance, specify a prime number in<i>nSize</i>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero.</para>
    </returns>
  </member>
  <member name="Windows.InitializeContext">
    <summary>Initializes a <see cref="CONTEXT" /> structure inside a buffer with the necessary size and alignment.</summary>
    <param name="Buffer">A pointer to a buffer within which to initialize a<see cref="CONTEXT" /> structure. This parameter can be<b>NULL</b> to determine the buffer size required to hold a context record with the specified <i>ContextFlags</i>.</param>
    <param name="ContextFlags">
      <para>A value indicating which portions of the <i>Context</i> structure should be initialized. This parameter influences the size of the initialized <i>Context</i> structure.</para>
      <div>
        <b>Note</b>  <b>CONTEXT_XSTATE</b> is not part of <b>CONTEXT_FULL</b> or <b>CONTEXT_ALL</b>. It must be specified separately if an XState context is desired.</div>
    </param>
    <param name="Context">
      <para>A pointer to a variable which receives the address of the initialized<see cref="CONTEXT" /> structure within the<i>Buffer</i>.</para>
      <div>
        <b>Note</b>  Due to alignment requirements of <see cref="CONTEXT" /> structures, the value returned in <i>Context</i> may not be at the beginning of the supplied buffer.</div>
    </param>
    <param name="ContextLength">On input, specifies the length of the buffer pointed to by <i>Buffer</i>, in bytes. If the buffer is not large enough to contain the specified portions of the<see cref="CONTEXT" />, the function fails,<see cref="GetLastError" /> returns<b>ERROR_INSUFFICIENT_BUFFER</b>, and <i>ContextLength</i> is set to the required size of the buffer. If the function fails with an error other than<b>ERROR_INSUFFICIENT_BUFFER</b>, the contents of<i>ContextLength</i> are undefined.</param>
    <returns>This function returns <b>TRUE</b> if successful, otherwise<b>FALSE</b>. To get extended error information, call<see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.InitializeContext2">
    <summary>Initializes a <see cref="CONTEXT" /> structure inside a buffer with the necessary size and alignment, with the option to specify an XSTATE compaction mask.</summary>
    <param name="Buffer">A pointer to a buffer within which to initialize a<see cref="CONTEXT" /> structure. This parameter can be<b>NULL</b> to determine the buffer size required to hold a context record with the specified <i>ContextFlags</i>.</param>
    <param name="ContextFlags">
      <para>A value indicating which portions of the <i>Context</i> structure should be initialized. This parameter influences the size of the initialized <i>Context</i> structure.</para>
      <div>
        <b>Note</b>  <b>CONTEXT_XSTATE</b> is not part of <b>CONTEXT_FULL</b> or <b>CONTEXT_ALL</b>. It must be specified separately if an XState context is desired.</div>
    </param>
    <param name="Context">
      <para>A pointer to a variable which receives the address of the initialized<see cref="CONTEXT" /> structure within the<i>Buffer</i>.</para>
      <div>
        <b>Note</b>  Due to alignment requirements of <see cref="CONTEXT" /> structures, the value returned in <i>Context</i> may not be at the beginning of the supplied buffer.</div>
    </param>
    <param name="ContextLength">On input, specifies the length of the buffer pointed to by <i>Buffer</i>, in bytes. If the buffer is not large enough to contain the specified portions of the<see cref="CONTEXT" />, the function fails,<see cref="GetLastError" /> returns<b>ERROR_INSUFFICIENT_BUFFER</b>, and <i>ContextLength</i> is set to the required size of the buffer. If the function fails with an error other than<b>ERROR_INSUFFICIENT_BUFFER</b>, the contents of<i>ContextLength</i> are undefined.</param>
    <param name="XStateCompactionMask">Supplies the XState compaction mask to use when allocating the <i>Context</i> structure. This parameter is only used when <b>CONTEXT_XSTATE</b> is supplied to <i>ContextFlags</i> and the system has XState enabled in compaction mode.</param>
    <returns>This function returns <b>TRUE</b> if successful, otherwise<b>FALSE</b>. To get extended error information, call<see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.InitializeThreadpoolEnvironment">
    <summary>Initializes a callback environment.</summary>
    <param name="pcbe">A <b>TP_CALLBACK_ENVIRON</b> structure that defines a callback environment.</param>
  </member>
  <member name="Windows.InterlockedExchangeSubtract">
    <summary>Performs an atomic subtraction of two values.</summary>
    <param name="Addend">A pointer to a variable. The value of this variable is replaced with the result of the operation.</param>
    <param name="Value">The value to be subtracted from the variable pointed to by the <i>Addend</i> parameter.</param>
    <returns>The function returns the initial value of the <i>Addend</i> parameter.</returns>
  </member>
  <member name="Windows.IsBadCodePtr">
    <summary>
      <para>Determines whether the calling process has read access to the memory at the specified address.</para>
      <div>
        <b>Important</b>  This function is obsolete and should not be used. Despite its name, it does not guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks on this page.</div>
    </summary>
    <param name="lpfn">A pointer to a memory address.</param>
    <returns>
      <para>If the calling process has read access to the specified memory, the return value is zero.</para>
      <para>If the calling process does not have read access to the specified memory, the return value is nonzero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the application is compiled as a debugging version, and the process does not have read access to the specified memory location, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value. This behavior is by design, as a debugging aid.</para>
    </returns>
  </member>
  <member name="Windows.IsBadReadPtr">
    <summary>
      <para>Verifies that the calling process has read access to the specified range of memory.</para>
      <div>
        <b>Important</b>  This function is obsolete and should not be used. Despite its name, it does not guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks on this page.</div>
    </summary>
    <param name="lp">A pointer to the first byte of the memory block.</param>
    <param name="ucb">The size of the memory block, in bytes. If this parameter is zero, the return value is zero.</param>
    <returns>
      <para>If the calling process has read access to all bytes in the specified memory range, the return value is zero.</para>
      <para>If the calling process does not have read access to all bytes in the specified memory range, the return value is nonzero.</para>
      <para>If the application is compiled as a debugging version, and the process does not have read access to all bytes in the specified memory range, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value. This behavior is by design, as a debugging aid.</para>
    </returns>
  </member>
  <member name="Windows.IsBadStringPtr">
    <summary>
      <para>Verifies that the calling process has read access to the specified range of memory.</para>
      <div>
        <b>Important</b>  This function is obsolete and should not be used. Despite its name, it does not guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks on this page.</div>
    </summary>
    <param name="lpsz">A pointer to a null-terminated string, either Unicode or ASCII.</param>
    <param name="ucchMax">The maximum size of the string, in <b>TCHARs</b>. The function checks for read access in all characters up to the string's terminating null character or up to the number of characters specified by this parameter, whichever is smaller. If this parameter is zero, the return value is zero.</param>
    <returns>
      <para>If the calling process has read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is zero.</para>
      <para>If the calling process does not have read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is nonzero.</para>
      <para>If the application is compiled as a debugging version, and the process does not have read access to the entire memory range specified, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value This behavior is by design, as a debugging aid.</para>
    </returns>
  </member>
  <member name="Windows.IsBadStringPtrA">
    <summary>
      <para>Verifies that the calling process has read access to the specified range of memory.</para>
      <div>
        <b>Important</b>  This function is obsolete and should not be used. Despite its name, it does not guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks on this page.</div>
    </summary>
    <param name="lpsz">A pointer to a null-terminated string, either Unicode or ASCII.</param>
    <param name="ucchMax">The maximum size of the string, in <b>TCHARs</b>. The function checks for read access in all characters up to the string's terminating null character or up to the number of characters specified by this parameter, whichever is smaller. If this parameter is zero, the return value is zero.</param>
    <returns>
      <para>If the calling process has read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is zero.</para>
      <para>If the calling process does not have read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is nonzero.</para>
      <para>If the application is compiled as a debugging version, and the process does not have read access to the entire memory range specified, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value This behavior is by design, as a debugging aid.</para>
    </returns>
  </member>
  <member name="Windows.IsBadStringPtrW">
    <summary>
      <para>Verifies that the calling process has read access to the specified range of memory.</para>
      <div>
        <b>Important</b>  This function is obsolete and should not be used. Despite its name, it does not guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks on this page.</div>
    </summary>
    <param name="lpsz">A pointer to a null-terminated string, either Unicode or ASCII.</param>
    <param name="ucchMax">The maximum size of the string, in <b>TCHARs</b>. The function checks for read access in all characters up to the string's terminating null character or up to the number of characters specified by this parameter, whichever is smaller. If this parameter is zero, the return value is zero.</param>
    <returns>
      <para>If the calling process has read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is zero.</para>
      <para>If the calling process does not have read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is nonzero.</para>
      <para>If the application is compiled as a debugging version, and the process does not have read access to the entire memory range specified, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value This behavior is by design, as a debugging aid.</para>
    </returns>
  </member>
  <member name="Windows.IsBadStringPtr">
    <summary>
      <para>Verifies that the calling process has read access to the specified range of memory.</para>
      <div>
        <b>Important</b>  This function is obsolete and should not be used. Despite its name, it does not guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks on this page.</div>
    </summary>
    <param name="lpsz">A pointer to a null-terminated string, either Unicode or ASCII.</param>
    <param name="ucchMax">The maximum size of the string, in <b>TCHARs</b>. The function checks for read access in all characters up to the string's terminating null character or up to the number of characters specified by this parameter, whichever is smaller. If this parameter is zero, the return value is zero.</param>
    <returns>
      <para>If the calling process has read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is zero.</para>
      <para>If the calling process does not have read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is nonzero.</para>
      <para>If the application is compiled as a debugging version, and the process does not have read access to the entire memory range specified, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value This behavior is by design, as a debugging aid.</para>
    </returns>
  </member>
  <member name="Windows.IsBadStringPtrA">
    <summary>
      <para>Verifies that the calling process has read access to the specified range of memory.</para>
      <div>
        <b>Important</b>  This function is obsolete and should not be used. Despite its name, it does not guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks on this page.</div>
    </summary>
    <param name="lpsz">A pointer to a null-terminated string, either Unicode or ASCII.</param>
    <param name="ucchMax">The maximum size of the string, in <b>TCHARs</b>. The function checks for read access in all characters up to the string's terminating null character or up to the number of characters specified by this parameter, whichever is smaller. If this parameter is zero, the return value is zero.</param>
    <returns>
      <para>If the calling process has read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is zero.</para>
      <para>If the calling process does not have read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is nonzero.</para>
      <para>If the application is compiled as a debugging version, and the process does not have read access to the entire memory range specified, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value This behavior is by design, as a debugging aid.</para>
    </returns>
  </member>
  <member name="Windows.IsBadStringPtrW">
    <summary>
      <para>Verifies that the calling process has read access to the specified range of memory.</para>
      <div>
        <b>Important</b>  This function is obsolete and should not be used. Despite its name, it does not guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks on this page.</div>
    </summary>
    <param name="lpsz">A pointer to a null-terminated string, either Unicode or ASCII.</param>
    <param name="ucchMax">The maximum size of the string, in <b>TCHARs</b>. The function checks for read access in all characters up to the string's terminating null character or up to the number of characters specified by this parameter, whichever is smaller. If this parameter is zero, the return value is zero.</param>
    <returns>
      <para>If the calling process has read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is zero.</para>
      <para>If the calling process does not have read access to all characters up to the string's terminating null character or up to the number of characters specified by <i>ucchMax</i>, the return value is nonzero.</para>
      <para>If the application is compiled as a debugging version, and the process does not have read access to the entire memory range specified, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value This behavior is by design, as a debugging aid.</para>
    </returns>
  </member>
  <member name="Windows.IsBadWritePtr">
    <summary>
      <para>Verifies that the calling process has write access to the specified range of memory.</para>
      <div>
        <b>Important</b>  This function is obsolete and should not be used. Despite its name, it does not guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks on this page.</div>
    </summary>
    <param name="lp">A pointer to the first byte of the memory block.</param>
    <param name="ucb">The size of the memory block, in bytes. If this parameter is zero, the return value is zero.</param>
    <returns>
      <para>If the calling process has write access to all bytes in the specified memory range, the return value is zero.</para>
      <para>If the calling process does not have write access to all bytes in the specified memory range, the return value is nonzero.</para>
      <para>If the application is run under a debugger and the process does not have write access to all bytes in the specified memory range, the function causes a first chance STATUS_ACCESS_VIOLATION exception. The debugger can be configured to break for this condition. After resuming process execution in the debugger, the function continues as usual and returns a nonzero value This behavior is by design and serves as a debugging aid.</para>
    </returns>
  </member>
  <member name="Windows.IsNativeVhdBoot">
    <summary>Indicates if the OS was booted from a VHD container.</summary>
    <param name="NativeVhdBoot">Pointer to a variable that receives a boolean indicating if the OS was booted from a VHD.</param>
    <returns>
      <para>TRUE if the OS was a native VHD boot; otherwise, FALSE.</para>
      <para>Call <see cref="GetLastError" /> to get extended error information.</para>
    </returns>
  </member>
  <member name="Windows.IsSystemResumeAutomatic">
    <summary>Determines the current state of the computer.</summary>
    <returns>If the system was restored to the working state automatically and the user is not active, the function returns <b>TRUE</b>. Otherwise, the function returns <b>FALSE</b>.</returns>
  </member>
  <member name="Windows.IsTextUnicode">
    <summary>Determines if a buffer is likely to contain a form of Unicode text.</summary>
    <param name="lpv">Pointer to the input buffer to examine.</param>
    <param name="iSize">Size, in bytes, of the input buffer indicated by <i>lpv</i>.</param>
    <param name="lpiResult">
      <para>On input, pointer to the tests to apply to the input buffer text. On output, this parameter receives the results of the specified tests: 1 if the contents of the buffer pass a test, 0 for failure. Only flags that are set upon input to the function are significant upon output.</para>
      <para>If <i>lpiResult</i> is <b>NULL</b>, the function uses all available tests to determine if the data in the buffer is likely to be Unicode text.</para>
      <para>This parameter can be one or more of the following values. Values can be combined with binary "OR".</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>IS_TEXT_UNICODE_ASCII16</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The text is Unicode, and contains only zero-extended ASCII values/characters.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>IS_TEXT_UNICODE_REVERSE_ASCII16</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Same as the preceding, except that the Unicode text is byte-reversed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>IS_TEXT_UNICODE_STATISTICS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The text is probably Unicode, with the determination made by applying statistical analysis. Absolute certainty is not guaranteed. See the Remarks section.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>IS_TEXT_UNICODE_REVERSE_STATISTICS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Same as the preceding, except that the text that is probably Unicode is byte-reversed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>IS_TEXT_UNICODE_CONTROLS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The text contains Unicode representations of one or more of these nonprinting characters: RETURN, LINEFEED, SPACE, CJK_SPACE, TAB.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>IS_TEXT_UNICODE_REVERSE_CONTROLS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Same as the preceding, except that the Unicode characters are byte-reversed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>IS_TEXT_UNICODE_BUFFER_TOO_SMALL</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>There are too few characters in the buffer for meaningful analysis (fewer than two bytes).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>IS_TEXT_UNICODE_SIGNATURE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The text contains the Unicode byte-order mark (BOM) 0xFEFF as its first character.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>IS_TEXT_UNICODE_REVERSE_SIGNATURE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The text contains the Unicode byte-reversed byte-order mark (Reverse BOM) 0xFFFE as its first character.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>IS_TEXT_UNICODE_ILLEGAL_CHARS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The text contains one of these Unicode-illegal characters: embedded Reverse BOM, UNICODE_NUL, CRLF (packed into one word), or 0xFFFF.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>IS_TEXT_UNICODE_ODD_LENGTH</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The number of characters in the string is odd. A string of odd length cannot (by definition) be Unicode text.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>IS_TEXT_UNICODE_NULL_BYTES</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The text contains null bytes, which indicate non-ASCII text.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>IS_TEXT_UNICODE_UNICODE_MASK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The value is a combination of IS_TEXT_UNICODE_ASCII16, IS_TEXT_UNICODE_STATISTICS, IS_TEXT_UNICODE_CONTROLS, IS_TEXT_UNICODE_SIGNATURE.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>IS_TEXT_UNICODE_REVERSE_MASK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The value is a combination of IS_TEXT_UNICODE_REVERSE_ASCII16, IS_TEXT_UNICODE_REVERSE_STATISTICS, IS_TEXT_UNICODE_REVERSE_CONTROLS, IS_TEXT_UNICODE_REVERSE_SIGNATURE.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>IS_TEXT_UNICODE_NOT_UNICODE_MASK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The value is a combination of IS_TEXT_UNICODE_ILLEGAL_CHARS, IS_TEXT_UNICODE_ODD_LENGTH, and two currently unused bit flags.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>IS_TEXT_UNICODE_NOT_ASCII_MASK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The value is a combination of IS_TEXT_UNICODE_NULL_BYTES and three currently unused bit flags.</description>
        </listheader>
      </list>
    </param>
    <returns>Returns a nonzero value if the data in the buffer passes the specified tests. The function returns 0 if the data in the buffer does not pass the specified tests.</returns>
  </member>
  <member name="Windows.LoadModule">
    <summary>
      <para>Loads and executes an application or creates a new instance of an existing application.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the <see cref="CreateProcess" /> function.</div>
    </summary>
    <param name="lpModuleName">
      <para>The file name of the application to be run. When specifying a path, be sure to use backslashes (\), not forward slashes (/). If the <i>lpModuleName</i> parameter does not contain a directory path, the system searches for the executable file in this order:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory.</description>
        </item>
        <item>
          <description>The system directory. Use the <see cref="GetSystemDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description> The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</description>
        </item>
        <item>
          <description>The Windows directory. Use the <see cref="GetWindowsDirectory" /> function to get the path of this directory.</description>
        </item>
        <item>
          <description>The directories that are listed in the PATH environment variable.</description>
        </item>
      </list>
    </param>
    <param name="lpParameterBlock">
      <para>A pointer to an application-defined <b>LOADPARMS32</b> structure that defines the new application's parameter block.</para>
      <para>Set all unused members to NULL, except for <b>lpCmdLine</b>, which must point to a null-terminated string if it is not used. For more information, see Remarks.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is greater than 31.</para>
      <para>If the function fails, the return value is an error value, which may be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The system is out of memory or resources.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BAD_FORMAT</b>
                </term>
              </listheader>
              <listheader>
                <term>11L</term>
              </listheader>
            </list>
          </description>
          <description>The .exe file is invalid.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_FILE_NOT_FOUND</b>
                </term>
              </listheader>
              <listheader>
                <term>2L</term>
              </listheader>
            </list>
          </description>
          <description>The specified file was not found.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
              <listheader>
                <term>3L</term>
              </listheader>
            </list>
          </description>
          <description>The specified path was not found.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.LoadPackagedLibrary">
    <summary>Loads the specified packaged module and its dependencies into the address space of the calling process.</summary>
    <param name="lpwLibFileName">
      <para>The file name of the packaged module to load. The module can be a library module (a .dll file) or an executable module (an .exe file).</para>
      <para>If this parameter specifies a module name without a path and the file name extension is omitted, the function appends the default library extension .dll to the module name. To prevent the function from appending .dll to the module name, include a trailing point character (.) in the module name string.</para>
      <para>If this parameter specifies a path, the function searches that path for the module. The path cannot be an absolute path or a relative path that contains ".." in the path. When specifying a path, be sure to use backslashes (\), not forward slashes (/). For more information about paths, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <para>If the specified module is already loaded in the process, the function returns a handle to the loaded module. The module must have been originally loaded from the package dependency graph of the process.</para>
      <para>If loading the specified module causes the system to load other associated modules, the function first searches loaded modules, then it searches the package dependency graph of the process. For more information, see Remarks.</para>
    </param>
    <param name="Reserved">This parameter is reserved. It must be 0.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the loaded module.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LocalFlags">
    <summary>
      <para>Retrieves information about the specified local memory object.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a>. For more information, see Remarks.</div>
    </summary>
    <param name="hMem">A handle to the local memory object. This handle is returned by either the<see cref="LocalAlloc" /> or<see cref="LocalReAlloc" /> function.</param>
    <returns>
      <para>If the function succeeds, the return value specifies the allocation values and the lock count for the memory object.</para>
      <para>If the function fails, the return value is <b>LMEM_INVALID_HANDLE</b>, indicating that the local handle is not valid. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LocalFree">
    <summary>
      <para>Frees the specified local memory object and invalidates its handle.</para>
      <div>
        <b>Note</b>  The local functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a local function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</div>
    </summary>
    <param name="hMem">A handle to the local memory object. This handle is returned by either the<see cref="LocalAlloc" /> or<see cref="LocalReAlloc" /> function. It is not safe to free memory allocated with <see cref="GlobalAlloc" />.</param>
    <returns>
      <para>If the function succeeds, the return value is <b>NULL</b>.</para>
      <para>If the function fails, the return value is equal to a handle to the local memory object. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LocalHandle">
    <summary>
      <para>Retrieves the handle associated with the specified pointer to a local memory object.</para>
      <div>
        <b>Note</b>  The local functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a local function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</div>
    </summary>
    <param name="pMem">A pointer to the first byte of the local memory object. This pointer is returned by the<see cref="LocalLock" /> function.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the specified local memory object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LocalLock">
    <summary>
      <para>Locks a local memory object and returns a pointer to the first byte of the object's memory block.</para>
      <div>
        <b>Note</b>  The local functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a local function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</div>
    </summary>
    <param name="hMem">A handle to the local memory object. This handle is returned by either the<see cref="LocalAlloc" /> or<see cref="LocalReAlloc" /> function.</param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the first byte of the memory block.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LocalReAlloc">
    <summary>
      <para>Changes the size or the attributes of a specified local memory object. The size can increase or decrease.</para>
      <div>
        <b>Note</b>  The local functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a local function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</div>
    </summary>
    <param name="hMem">A handle to the local memory object to be reallocated. This handle is returned by either the<see cref="LocalAlloc" /> or<b>LocalReAlloc</b> function.</param>
    <param name="uBytes">The new size of the memory block, in bytes. If <i>uFlags</i> specifies <b>LMEM_MODIFY</b>, this parameter is ignored.</param>
    <param name="uFlags">
      <para>The reallocation options. If <b>LMEM_MODIFY</b> is specified, the function modifies the attributes of the memory object only (the <i>uBytes</i> parameter is ignored.) Otherwise, the function reallocates the memory object.</para>
      <para>You can optionally combine <b>LMEM_MODIFY</b> with the following value.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LMEM_MOVEABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0002</term>
              </listheader>
            </list>
          </description>
          <description>Allocates fixed or movable memory. <para>If the memory is a locked <b>LMEM_MOVEABLE</b> memory block or a <b>LMEM_FIXED</b> memory block and this flag is not specified, the memory can only be reallocated in place.</para></description>
        </listheader>
      </list> <para>If this parameter does not specify <b>LMEM_MODIFY</b>, you can use the following value.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>LMEM_ZEROINIT</b></term></listheader><listheader><term>0x0040</term></listheader></list></description><description>Causes the additional memory contents to be initialized to zero if the memory object is growing in size.</description></listheader></list></param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the reallocated memory object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LocalSize">
    <summary>
      <para>Retrieves the current size of the specified local memory object, in bytes.</para>
      <div>
        <b>Note</b>  The local functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a local function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</div>
    </summary>
    <param name="hMem">A handle to the local memory object. This handle is returned by the<see cref="LocalAlloc" />,<see cref="LocalReAlloc" />, or<see cref="LocalHandle" /> function.</param>
    <returns>If the function succeeds, the return value is the size of the specified local memory object, in bytes. If the specified handle is not valid or if the object has been discarded, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.LocalUnlock">
    <summary>
      <para>Decrements the lock count associated with a memory object that was allocated with <b>LMEM_MOVEABLE</b>. This function has no effect on memory objects allocated with <b>LMEM_FIXED</b>.</para>
      <div>
        <b>Note</b>  The local functions have greater overhead and provide fewer features than other memory management functions. New applications should use the <a href="https://docs.microsoft.com//windows/desktop/Memory/heap-functions">heap functions</a> unless documentation states that a local function should be used. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Memory/global-and-local-functions">Global and Local Functions</a>.</div>
    </summary>
    <param name="hMem">A handle to the local memory object. This handle is returned by either the<see cref="LocalAlloc" /> or<see cref="LocalReAlloc" /> function.</param>
    <returns>
      <para>If the memory object is still locked after decrementing the lock count, the return value is nonzero. If the memory object is unlocked after decrementing the lock count, the function returns zero and <see cref="GetLastError" /> returns <b>NO_ERROR</b>.</para>
      <para>If the function fails, the return value is zero and<see cref="GetLastError" /> returns a value other than <b>NO_ERROR</b>.</para>
    </returns>
  </member>
  <member name="Windows.LocateXStateFeature">
    <summary>
      <para>Retrieves a pointer to the processor state for an XState feature within a<see cref="CONTEXT" /> structure.</para>
      <para>The definition of XState feature bits are processor vendor specific. Please refer to the relevant processor reference manuals for additional information on a particular feature.</para>
    </summary>
    <param name="Context">A pointer to a <see cref="CONTEXT" /> structure containing the state to retrieve or set. This <b>CONTEXT</b> should have been initialized with <see cref="InitializeContext" /> with the<b>CONTEXT_XSTATE</b> flag set in the <i>ContextFlags</i>parameter.</param>
    <param name="FeatureId">The number of the feature to locate within the<see cref="CONTEXT" /> structure.</param>
    <param name="Length">A pointer to a variable which receives the length of the feature area in bytes. The contents of this variable are undefined if this function returns <b>NULL</b>.</param>
    <returns>
      <para>If the specified feature is supported by the system and the specified<see cref="CONTEXT" /> structure has been initialized with the<b>CONTEXT_XSTATE</b> flag, this function returns a pointer to the feature area for the specified feature. The contents and layout of this area is processor-specific.</para>
      <para>If the <b>CONTEXT_XSTATE</b> flag is not set in the<see cref="CONTEXT" /> structure or the<i>FeatureID</i> is not supported by the system, the return value is<b>NULL</b>. No additional error information is available.</para>
    </returns>
  </member>
  <member name="Windows.LogonUser">
    <summary>The <b>LogonUser</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUser</b> was called. You cannot use <b>LogonUser</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">plaintext</a> password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> that runs in the context of the specified user.</summary>
    <param name="lpszUsername">A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, <i>User</i><b>@</b><i>DNSDomainName</i>, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</param>
    <param name="lpszDomain">A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</param>
    <param name="lpszPassword">A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>. When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values, defined in Winbase.h.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_BATCH</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_INTERACTIVE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUser</b> function does not cache credentials for this logon type.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUser</b>, verify that the user can access the system across the network, and still communicate with other servers.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.<para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para><para>Note: As of January 2023, it is not possible to use the LOGON32_LOGON_NEW_CREDENTIALS logon type with a Group Managed Service Account (gMSA).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_SERVICE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Indicates a service-type logon. The account provided must have the service privilege enabled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_UNLOCK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>GINAs are no longer supported.<para><b>Windows Server 2003 and Windows XP:  </b>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</para></description>
        </listheader>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>Specifies the logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_DEFAULT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is negotiate, unless you pass <b>NULL</b> for the domain name and the user name is not in UPN format. In this case, the default provider is NTLM.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT50</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the negotiate logon provider.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT40</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the NTLM logon provider.</description>
        </listheader>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUser</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert it to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the<see cref="CloseHandle" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LogonUserA">
    <summary>The <b>LogonUser</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUser</b> was called. You cannot use <b>LogonUser</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">plaintext</a> password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> that runs in the context of the specified user.</summary>
    <param name="lpszUsername">A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, <i>User</i><b>@</b><i>DNSDomainName</i>, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</param>
    <param name="lpszDomain">A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</param>
    <param name="lpszPassword">A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>. When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values, defined in Winbase.h.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_BATCH</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_INTERACTIVE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUser</b> function does not cache credentials for this logon type.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUser</b>, verify that the user can access the system across the network, and still communicate with other servers.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.<para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para><para>Note: As of January 2023, it is not possible to use the LOGON32_LOGON_NEW_CREDENTIALS logon type with a Group Managed Service Account (gMSA).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_SERVICE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Indicates a service-type logon. The account provided must have the service privilege enabled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_UNLOCK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>GINAs are no longer supported.<para><b>Windows Server 2003 and Windows XP:  </b>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</para></description>
        </listheader>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>Specifies the logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_DEFAULT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is negotiate, unless you pass <b>NULL</b> for the domain name and the user name is not in UPN format. In this case, the default provider is NTLM.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT50</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the negotiate logon provider.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT40</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the NTLM logon provider.</description>
        </listheader>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUser</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert it to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the<see cref="CloseHandle" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LogonUserW">
    <summary>The <b>LogonUser</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUser</b> was called. You cannot use <b>LogonUser</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">plaintext</a> password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> that runs in the context of the specified user.</summary>
    <param name="lpszUsername">A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, <i>User</i><b>@</b><i>DNSDomainName</i>, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</param>
    <param name="lpszDomain">A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</param>
    <param name="lpszPassword">A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>. When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values, defined in Winbase.h.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_BATCH</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_INTERACTIVE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUser</b> function does not cache credentials for this logon type.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUser</b>, verify that the user can access the system across the network, and still communicate with other servers.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.<para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para><para>Note: As of January 2023, it is not possible to use the LOGON32_LOGON_NEW_CREDENTIALS logon type with a Group Managed Service Account (gMSA).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_SERVICE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Indicates a service-type logon. The account provided must have the service privilege enabled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_UNLOCK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>GINAs are no longer supported.<para><b>Windows Server 2003 and Windows XP:  </b>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</para></description>
        </listheader>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>Specifies the logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_DEFAULT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is negotiate, unless you pass <b>NULL</b> for the domain name and the user name is not in UPN format. In this case, the default provider is NTLM.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT50</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the negotiate logon provider.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT40</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the NTLM logon provider.</description>
        </listheader>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUser</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert it to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the<see cref="CloseHandle" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LogonUserEx">
    <summary>The <b>LogonUserEx</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUserEx</b> was called. You cannot use <b>LogonUserEx</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a plaintext password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> that runs in the context of the specified user.</summary>
    <param name="lpszUsername">A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, user@DNS_domain_name, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</param>
    <param name="lpszDomain">A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</param>
    <param name="lpszPassword">A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>. When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_BATCH</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_INTERACTIVE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUserEx</b>, verify that the user can access the system across the network, and still communicate with other servers. 							</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.<para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_SERVICE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Indicates a service-type logon. The account provided must have the service privilege enabled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_UNLOCK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</description>
        </listheader>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>The logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_DEFAULT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is NTLM.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT50</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the negotiate logon provider. 							</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT40</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the NTLM logon provider.</description>
        </listheader>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUserEx</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert the impersonation token to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the<see cref="CloseHandle" /> function.</para>
    </param>
    <param name="ppLogonSid">
      <para>A pointer to a pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) that receives the SID of the user logged on.</para>
      <para>When you have finished using the SID, free it by calling the <see cref="LocalFree" /> function.</para>
    </param>
    <param name="ppProfileBuffer">A pointer to a pointer that receives the address of a buffer that contains the logged on user's profile.</param>
    <param name="pdwProfileLength">A pointer to a <b>DWORD</b> that receives the length of the profile buffer.</param>
    <param name="pQuotaLimits">A pointer to a <see cref="QUOTA_LIMITS" /> structure that receives information about the quotas for the logged on user.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LogonUserExA">
    <summary>The <b>LogonUserEx</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUserEx</b> was called. You cannot use <b>LogonUserEx</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a plaintext password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> that runs in the context of the specified user.</summary>
    <param name="lpszUsername">A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, user@DNS_domain_name, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</param>
    <param name="lpszDomain">A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</param>
    <param name="lpszPassword">A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>. When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_BATCH</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_INTERACTIVE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUserEx</b>, verify that the user can access the system across the network, and still communicate with other servers. 							</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.<para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_SERVICE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Indicates a service-type logon. The account provided must have the service privilege enabled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_UNLOCK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</description>
        </listheader>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>The logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_DEFAULT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is NTLM.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT50</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the negotiate logon provider. 							</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT40</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the NTLM logon provider.</description>
        </listheader>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUserEx</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert the impersonation token to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the<see cref="CloseHandle" /> function.</para>
    </param>
    <param name="ppLogonSid">
      <para>A pointer to a pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) that receives the SID of the user logged on.</para>
      <para>When you have finished using the SID, free it by calling the <see cref="LocalFree" /> function.</para>
    </param>
    <param name="ppProfileBuffer">A pointer to a pointer that receives the address of a buffer that contains the logged on user's profile.</param>
    <param name="pdwProfileLength">A pointer to a <b>DWORD</b> that receives the length of the profile buffer.</param>
    <param name="pQuotaLimits">A pointer to a <see cref="QUOTA_LIMITS" /> structure that receives information about the quotas for the logged on user.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LogonUserExW">
    <summary>The <b>LogonUserEx</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUserEx</b> was called. You cannot use <b>LogonUserEx</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a plaintext password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> that runs in the context of the specified user.</summary>
    <param name="lpszUsername">A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, user@DNS_domain_name, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</param>
    <param name="lpszDomain">A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</param>
    <param name="lpszPassword">A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>. When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_BATCH</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_INTERACTIVE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUserEx</b>, verify that the user can access the system across the network, and still communicate with other servers. 							</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.<para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_SERVICE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Indicates a service-type logon. The account provided must have the service privilege enabled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_UNLOCK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</description>
        </listheader>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>The logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_DEFAULT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is NTLM.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT50</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the negotiate logon provider. 							</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT40</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the NTLM logon provider.</description>
        </listheader>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUserEx</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert the impersonation token to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the<see cref="CloseHandle" /> function.</para>
    </param>
    <param name="ppLogonSid">
      <para>A pointer to a pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) that receives the SID of the user logged on.</para>
      <para>When you have finished using the SID, free it by calling the <see cref="LocalFree" /> function.</para>
    </param>
    <param name="ppProfileBuffer">A pointer to a pointer that receives the address of a buffer that contains the logged on user's profile.</param>
    <param name="pdwProfileLength">A pointer to a <b>DWORD</b> that receives the length of the profile buffer.</param>
    <param name="pQuotaLimits">A pointer to a <see cref="QUOTA_LIMITS" /> structure that receives information about the quotas for the logged on user.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LogonUserEx">
    <summary>The <b>LogonUserEx</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUserEx</b> was called. You cannot use <b>LogonUserEx</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a plaintext password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> that runs in the context of the specified user.</summary>
    <param name="lpszUsername">A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, user@DNS_domain_name, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</param>
    <param name="lpszDomain">A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</param>
    <param name="lpszPassword">A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>. When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_BATCH</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_INTERACTIVE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUserEx</b>, verify that the user can access the system across the network, and still communicate with other servers. 							</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.<para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_SERVICE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Indicates a service-type logon. The account provided must have the service privilege enabled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_UNLOCK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</description>
        </listheader>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>The logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_DEFAULT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is NTLM.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT50</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the negotiate logon provider. 							</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT40</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the NTLM logon provider.</description>
        </listheader>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUserEx</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert the impersonation token to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the<see cref="CloseHandle" /> function.</para>
    </param>
    <param name="ppLogonSid">
      <para>A pointer to a pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) that receives the SID of the user logged on.</para>
      <para>When you have finished using the SID, free it by calling the <see cref="LocalFree" /> function.</para>
    </param>
    <param name="ppProfileBuffer">A pointer to a pointer that receives the address of a buffer that contains the logged on user's profile.</param>
    <param name="pdwProfileLength">A pointer to a <b>DWORD</b> that receives the length of the profile buffer.</param>
    <param name="pQuotaLimits">A pointer to a <see cref="QUOTA_LIMITS" /> structure that receives information about the quotas for the logged on user.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LogonUserExA">
    <summary>The <b>LogonUserEx</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUserEx</b> was called. You cannot use <b>LogonUserEx</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a plaintext password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> that runs in the context of the specified user.</summary>
    <param name="lpszUsername">A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, user@DNS_domain_name, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</param>
    <param name="lpszDomain">A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</param>
    <param name="lpszPassword">A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>. When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_BATCH</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_INTERACTIVE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUserEx</b>, verify that the user can access the system across the network, and still communicate with other servers. 							</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.<para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_SERVICE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Indicates a service-type logon. The account provided must have the service privilege enabled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_UNLOCK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</description>
        </listheader>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>The logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_DEFAULT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is NTLM.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT50</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the negotiate logon provider. 							</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT40</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the NTLM logon provider.</description>
        </listheader>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUserEx</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert the impersonation token to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the<see cref="CloseHandle" /> function.</para>
    </param>
    <param name="ppLogonSid">
      <para>A pointer to a pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) that receives the SID of the user logged on.</para>
      <para>When you have finished using the SID, free it by calling the <see cref="LocalFree" /> function.</para>
    </param>
    <param name="ppProfileBuffer">A pointer to a pointer that receives the address of a buffer that contains the logged on user's profile.</param>
    <param name="pdwProfileLength">A pointer to a <b>DWORD</b> that receives the length of the profile buffer.</param>
    <param name="pQuotaLimits">A pointer to a <see cref="QUOTA_LIMITS" /> structure that receives information about the quotas for the logged on user.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LogonUserExW">
    <summary>The <b>LogonUserEx</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUserEx</b> was called. You cannot use <b>LogonUserEx</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a plaintext password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> that runs in the context of the specified user.</summary>
    <param name="lpszUsername">A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, user@DNS_domain_name, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</param>
    <param name="lpszDomain">A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</param>
    <param name="lpszPassword">A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>. When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_BATCH</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_INTERACTIVE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUserEx</b> function does not cache credentials for this logon type.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUserEx</b>, verify that the user can access the system across the network, and still communicate with other servers. 							</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.<para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_SERVICE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Indicates a service-type logon. The account provided must have the service privilege enabled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_UNLOCK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</description>
        </listheader>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>The logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_DEFAULT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is NTLM.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT50</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the negotiate logon provider. 							</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT40</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the NTLM logon provider.</description>
        </listheader>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUserEx</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert the impersonation token to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the<see cref="CloseHandle" /> function.</para>
    </param>
    <param name="ppLogonSid">
      <para>A pointer to a pointer to a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) that receives the SID of the user logged on.</para>
      <para>When you have finished using the SID, free it by calling the <see cref="LocalFree" /> function.</para>
    </param>
    <param name="ppProfileBuffer">A pointer to a pointer that receives the address of a buffer that contains the logged on user's profile.</param>
    <param name="pdwProfileLength">A pointer to a <b>DWORD</b> that receives the length of the profile buffer.</param>
    <param name="pQuotaLimits">A pointer to a <see cref="QUOTA_LIMITS" /> structure that receives information about the quotas for the logged on user.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LogonUser">
    <summary>The <b>LogonUser</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUser</b> was called. You cannot use <b>LogonUser</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">plaintext</a> password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> that runs in the context of the specified user.</summary>
    <param name="lpszUsername">A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, <i>User</i><b>@</b><i>DNSDomainName</i>, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</param>
    <param name="lpszDomain">A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</param>
    <param name="lpszPassword">A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>. When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values, defined in Winbase.h.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_BATCH</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_INTERACTIVE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUser</b> function does not cache credentials for this logon type.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUser</b>, verify that the user can access the system across the network, and still communicate with other servers.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.<para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para><para>Note: As of January 2023, it is not possible to use the LOGON32_LOGON_NEW_CREDENTIALS logon type with a Group Managed Service Account (gMSA).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_SERVICE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Indicates a service-type logon. The account provided must have the service privilege enabled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_UNLOCK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>GINAs are no longer supported.<para><b>Windows Server 2003 and Windows XP:  </b>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</para></description>
        </listheader>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>Specifies the logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_DEFAULT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is negotiate, unless you pass <b>NULL</b> for the domain name and the user name is not in UPN format. In this case, the default provider is NTLM.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT50</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the negotiate logon provider.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT40</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the NTLM logon provider.</description>
        </listheader>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUser</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert it to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the<see cref="CloseHandle" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LogonUserA">
    <summary>The <b>LogonUser</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUser</b> was called. You cannot use <b>LogonUser</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">plaintext</a> password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> that runs in the context of the specified user.</summary>
    <param name="lpszUsername">A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, <i>User</i><b>@</b><i>DNSDomainName</i>, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</param>
    <param name="lpszDomain">A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</param>
    <param name="lpszPassword">A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>. When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values, defined in Winbase.h.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_BATCH</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_INTERACTIVE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUser</b> function does not cache credentials for this logon type.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUser</b>, verify that the user can access the system across the network, and still communicate with other servers.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.<para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para><para>Note: As of January 2023, it is not possible to use the LOGON32_LOGON_NEW_CREDENTIALS logon type with a Group Managed Service Account (gMSA).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_SERVICE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Indicates a service-type logon. The account provided must have the service privilege enabled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_UNLOCK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>GINAs are no longer supported.<para><b>Windows Server 2003 and Windows XP:  </b>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</para></description>
        </listheader>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>Specifies the logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_DEFAULT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is negotiate, unless you pass <b>NULL</b> for the domain name and the user name is not in UPN format. In this case, the default provider is NTLM.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT50</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the negotiate logon provider.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT40</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the NTLM logon provider.</description>
        </listheader>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUser</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert it to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the<see cref="CloseHandle" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LogonUserW">
    <summary>The <b>LogonUser</b> function attempts to log a user on to the local computer. The local computer is the computer from which <b>LogonUser</b> was called. You cannot use <b>LogonUser</b> to log on to a remote computer. You specify the user with a user name and domain and <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authenticate</a> the user with a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">plaintext</a> password. If the function succeeds, you receive a handle to a token that represents the logged-on user. You can then use this token handle to impersonate the specified user or, in most cases, to create a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">process</a> that runs in the context of the specified user.</summary>
    <param name="lpszUsername">A pointer to a null-terminated string that specifies the name of the user. This is the name of the user account to log on to. If you use the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/u-gly">user principal name</a> (UPN) format, <i>User</i><b>@</b><i>DNSDomainName</i>, the <i>lpszDomain</i> parameter must be <b>NULL</b>.</param>
    <param name="lpszDomain">A pointer to a null-terminated string that specifies the name of the domain or server whose account database contains the <i>lpszUsername</i> account. If this parameter is <b>NULL</b>, the user name must be specified in UPN format. If this parameter is ".", the function validates the account by using only the local account database.</param>
    <param name="lpszPassword">A pointer to a null-terminated string that specifies the plaintext password for the user account specified by <i>lpszUsername</i>. When you have finished using the password, clear the password from memory by calling the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa366877(v=vs.85)">SecureZeroMemory</a> function. For more information about protecting passwords, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/handling-passwords">Handling Passwords</a>.</param>
    <param name="dwLogonType">
      <para>The type of logon operation to perform. This parameter can be one of the following values, defined in Winbase.h.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_BATCH</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or web servers.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_INTERACTIVE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/t-gly">terminal</a> server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type is intended for high performance servers to authenticate plaintext passwords. The <b>LogonUser</b> function does not cache credentials for this logon type.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NETWORK_CLEARTEXT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type preserves the name and password in the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">authentication package</a>, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call <b>LogonUser</b>, verify that the user can access the system across the network, and still communicate with other servers.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_NEW_CREDENTIALS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.<para>This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.</para><para>Note: As of January 2023, it is not possible to use the LOGON32_LOGON_NEW_CREDENTIALS logon type with a Group Managed Service Account (gMSA).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_SERVICE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Indicates a service-type logon. The account provided must have the service privilege enabled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_LOGON_UNLOCK</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>GINAs are no longer supported.<para><b>Windows Server 2003 and Windows XP:  </b>This logon type is for <a href="https://docs.microsoft.com//windows/desktop/SecGloss/g-gly">GINA</a> DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.</para></description>
        </listheader>
      </list>
    </param>
    <param name="dwLogonProvider">
      <para>Specifies the logon provider. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_DEFAULT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the standard logon provider for the system. The default <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security provider</a> is negotiate, unless you pass <b>NULL</b> for the domain name and the user name is not in UPN format. In this case, the default provider is NTLM.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT50</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the negotiate logon provider.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>LOGON32_PROVIDER_WINNT40</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use the NTLM logon provider.</description>
        </listheader>
      </list>
    </param>
    <param name="phToken">
      <para>A pointer to a handle variable that receives a handle to a token that represents the specified user.</para>
      <para>You can use the returned handle in calls to the<see cref="ImpersonateLoggedOnUser" /> function.</para>
      <para>In most cases, the returned handle is a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">primary token</a> that you can use in calls to the<see cref="CreateProcessAsUser" /> function. However, if you specify the LOGON32_LOGON_NETWORK flag, <b>LogonUser</b> returns an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/i-gly">impersonation token</a> that you cannot use in <b>CreateProcessAsUser</b> unless you call <see cref="DuplicateTokenEx" /> to convert it to a primary token.</para>
      <para>When you no longer need this handle, close it by calling the<see cref="CloseHandle" /> function.</para>
    </param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupAccountName">
    <summary>
      <para>The <b>LookupAccountName</b> function accepts the name of a system and an account as input. It retrieves a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) for the account and the name of the domain on which the account was found.</para>
      <para>The <see cref="LsaLookupNames" /> function can also retrieve computer accounts.</para>
    </summary>
    <param name="lpSystemName">A pointer to a <b>null</b>-terminated character string that specifies the name of the system. This string can be the name of a remote computer. If this string is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for <i>lpSystemName</i> only when the account is in an untrusted domain and the name of a computer in that domain is known.</param>
    <param name="lpAccountName">
      <para>A pointer to a <b>null</b>-terminated string that specifies the account name.</para>
      <para>Use a fully qualified string in the domain_name\user_name format to ensure that <b>LookupAccountName</b> finds the account in the desired domain.</para>
    </param>
    <param name="Sid">A pointer to a buffer that receives the<see cref="SID" /> structure that corresponds to the account name pointed to by the <i>lpAccountName</i> parameter. If this parameter is <b>NULL</b>, <i>cbSid</i> must be zero.</param>
    <param name="cbSid">A pointer to a variable. On input, this value specifies the size, in bytes, of the <i>Sid</i> buffer. If the function fails because the buffer is too small or if <i>cbSid</i> is zero, this variable receives the required buffer size.</param>
    <param name="ReferencedDomainName">A pointer to a buffer that receives the name of the domain where the account name is found. For computers that are not joined to a domain, this buffer receives the computer name. If this parameter is <b>NULL</b>, the function returns the required buffer size.</param>
    <param name="cchReferencedDomainName">A pointer to a variable. On input, this value specifies the size, in <b>TCHAR</b>s, of the <i>ReferencedDomainName</i> buffer. If the function fails because the buffer is too small, this variable receives the required buffer size, including the terminating <b>null</b> character. If the <i>ReferencedDomainName</i> parameter is <b>NULL</b>, this parameter must be zero.</param>
    <param name="peUse">A pointer to a<see cref="SID_NAME_USE" /> enumerated type that indicates the type of the account when the function returns.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. For extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupAccountNameA">
    <summary>
      <para>The <b>LookupAccountName</b> function accepts the name of a system and an account as input. It retrieves a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) for the account and the name of the domain on which the account was found.</para>
      <para>The <see cref="LsaLookupNames" /> function can also retrieve computer accounts.</para>
    </summary>
    <param name="lpSystemName">A pointer to a <b>null</b>-terminated character string that specifies the name of the system. This string can be the name of a remote computer. If this string is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for <i>lpSystemName</i> only when the account is in an untrusted domain and the name of a computer in that domain is known.</param>
    <param name="lpAccountName">
      <para>A pointer to a <b>null</b>-terminated string that specifies the account name.</para>
      <para>Use a fully qualified string in the domain_name\user_name format to ensure that <b>LookupAccountName</b> finds the account in the desired domain.</para>
    </param>
    <param name="Sid">A pointer to a buffer that receives the<see cref="SID" /> structure that corresponds to the account name pointed to by the <i>lpAccountName</i> parameter. If this parameter is <b>NULL</b>, <i>cbSid</i> must be zero.</param>
    <param name="cbSid">A pointer to a variable. On input, this value specifies the size, in bytes, of the <i>Sid</i> buffer. If the function fails because the buffer is too small or if <i>cbSid</i> is zero, this variable receives the required buffer size.</param>
    <param name="ReferencedDomainName">A pointer to a buffer that receives the name of the domain where the account name is found. For computers that are not joined to a domain, this buffer receives the computer name. If this parameter is <b>NULL</b>, the function returns the required buffer size.</param>
    <param name="cchReferencedDomainName">A pointer to a variable. On input, this value specifies the size, in <b>TCHAR</b>s, of the <i>ReferencedDomainName</i> buffer. If the function fails because the buffer is too small, this variable receives the required buffer size, including the terminating <b>null</b> character. If the <i>ReferencedDomainName</i> parameter is <b>NULL</b>, this parameter must be zero.</param>
    <param name="peUse">A pointer to a<see cref="SID_NAME_USE" /> enumerated type that indicates the type of the account when the function returns.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. For extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupAccountNameW">
    <summary>
      <para>The <b>LookupAccountName</b> function accepts the name of a system and an account as input. It retrieves a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) for the account and the name of the domain on which the account was found.</para>
      <para>The <see cref="LsaLookupNames" /> function can also retrieve computer accounts.</para>
    </summary>
    <param name="lpSystemName">A pointer to a <b>null</b>-terminated character string that specifies the name of the system. This string can be the name of a remote computer. If this string is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for <i>lpSystemName</i> only when the account is in an untrusted domain and the name of a computer in that domain is known.</param>
    <param name="lpAccountName">
      <para>A pointer to a <b>null</b>-terminated string that specifies the account name.</para>
      <para>Use a fully qualified string in the domain_name\user_name format to ensure that <b>LookupAccountName</b> finds the account in the desired domain.</para>
    </param>
    <param name="Sid">A pointer to a buffer that receives the<see cref="SID" /> structure that corresponds to the account name pointed to by the <i>lpAccountName</i> parameter. If this parameter is <b>NULL</b>, <i>cbSid</i> must be zero.</param>
    <param name="cbSid">A pointer to a variable. On input, this value specifies the size, in bytes, of the <i>Sid</i> buffer. If the function fails because the buffer is too small or if <i>cbSid</i> is zero, this variable receives the required buffer size.</param>
    <param name="ReferencedDomainName">A pointer to a buffer that receives the name of the domain where the account name is found. For computers that are not joined to a domain, this buffer receives the computer name. If this parameter is <b>NULL</b>, the function returns the required buffer size.</param>
    <param name="cchReferencedDomainName">A pointer to a variable. On input, this value specifies the size, in <b>TCHAR</b>s, of the <i>ReferencedDomainName</i> buffer. If the function fails because the buffer is too small, this variable receives the required buffer size, including the terminating <b>null</b> character. If the <i>ReferencedDomainName</i> parameter is <b>NULL</b>, this parameter must be zero.</param>
    <param name="peUse">A pointer to a<see cref="SID_NAME_USE" /> enumerated type that indicates the type of the account when the function returns.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. For extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupAccountName">
    <summary>
      <para>The <b>LookupAccountName</b> function accepts the name of a system and an account as input. It retrieves a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) for the account and the name of the domain on which the account was found.</para>
      <para>The <see cref="LsaLookupNames" /> function can also retrieve computer accounts.</para>
    </summary>
    <param name="lpSystemName">A pointer to a <b>null</b>-terminated character string that specifies the name of the system. This string can be the name of a remote computer. If this string is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for <i>lpSystemName</i> only when the account is in an untrusted domain and the name of a computer in that domain is known.</param>
    <param name="lpAccountName">
      <para>A pointer to a <b>null</b>-terminated string that specifies the account name.</para>
      <para>Use a fully qualified string in the domain_name\user_name format to ensure that <b>LookupAccountName</b> finds the account in the desired domain.</para>
    </param>
    <param name="Sid">A pointer to a buffer that receives the<see cref="SID" /> structure that corresponds to the account name pointed to by the <i>lpAccountName</i> parameter. If this parameter is <b>NULL</b>, <i>cbSid</i> must be zero.</param>
    <param name="cbSid">A pointer to a variable. On input, this value specifies the size, in bytes, of the <i>Sid</i> buffer. If the function fails because the buffer is too small or if <i>cbSid</i> is zero, this variable receives the required buffer size.</param>
    <param name="ReferencedDomainName">A pointer to a buffer that receives the name of the domain where the account name is found. For computers that are not joined to a domain, this buffer receives the computer name. If this parameter is <b>NULL</b>, the function returns the required buffer size.</param>
    <param name="cchReferencedDomainName">A pointer to a variable. On input, this value specifies the size, in <b>TCHAR</b>s, of the <i>ReferencedDomainName</i> buffer. If the function fails because the buffer is too small, this variable receives the required buffer size, including the terminating <b>null</b> character. If the <i>ReferencedDomainName</i> parameter is <b>NULL</b>, this parameter must be zero.</param>
    <param name="peUse">A pointer to a<see cref="SID_NAME_USE" /> enumerated type that indicates the type of the account when the function returns.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. For extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupAccountNameA">
    <summary>
      <para>The <b>LookupAccountName</b> function accepts the name of a system and an account as input. It retrieves a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) for the account and the name of the domain on which the account was found.</para>
      <para>The <see cref="LsaLookupNames" /> function can also retrieve computer accounts.</para>
    </summary>
    <param name="lpSystemName">A pointer to a <b>null</b>-terminated character string that specifies the name of the system. This string can be the name of a remote computer. If this string is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for <i>lpSystemName</i> only when the account is in an untrusted domain and the name of a computer in that domain is known.</param>
    <param name="lpAccountName">
      <para>A pointer to a <b>null</b>-terminated string that specifies the account name.</para>
      <para>Use a fully qualified string in the domain_name\user_name format to ensure that <b>LookupAccountName</b> finds the account in the desired domain.</para>
    </param>
    <param name="Sid">A pointer to a buffer that receives the<see cref="SID" /> structure that corresponds to the account name pointed to by the <i>lpAccountName</i> parameter. If this parameter is <b>NULL</b>, <i>cbSid</i> must be zero.</param>
    <param name="cbSid">A pointer to a variable. On input, this value specifies the size, in bytes, of the <i>Sid</i> buffer. If the function fails because the buffer is too small or if <i>cbSid</i> is zero, this variable receives the required buffer size.</param>
    <param name="ReferencedDomainName">A pointer to a buffer that receives the name of the domain where the account name is found. For computers that are not joined to a domain, this buffer receives the computer name. If this parameter is <b>NULL</b>, the function returns the required buffer size.</param>
    <param name="cchReferencedDomainName">A pointer to a variable. On input, this value specifies the size, in <b>TCHAR</b>s, of the <i>ReferencedDomainName</i> buffer. If the function fails because the buffer is too small, this variable receives the required buffer size, including the terminating <b>null</b> character. If the <i>ReferencedDomainName</i> parameter is <b>NULL</b>, this parameter must be zero.</param>
    <param name="peUse">A pointer to a<see cref="SID_NAME_USE" /> enumerated type that indicates the type of the account when the function returns.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. For extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupAccountNameW">
    <summary>
      <para>The <b>LookupAccountName</b> function accepts the name of a system and an account as input. It retrieves a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) for the account and the name of the domain on which the account was found.</para>
      <para>The <see cref="LsaLookupNames" /> function can also retrieve computer accounts.</para>
    </summary>
    <param name="lpSystemName">A pointer to a <b>null</b>-terminated character string that specifies the name of the system. This string can be the name of a remote computer. If this string is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for <i>lpSystemName</i> only when the account is in an untrusted domain and the name of a computer in that domain is known.</param>
    <param name="lpAccountName">
      <para>A pointer to a <b>null</b>-terminated string that specifies the account name.</para>
      <para>Use a fully qualified string in the domain_name\user_name format to ensure that <b>LookupAccountName</b> finds the account in the desired domain.</para>
    </param>
    <param name="Sid">A pointer to a buffer that receives the<see cref="SID" /> structure that corresponds to the account name pointed to by the <i>lpAccountName</i> parameter. If this parameter is <b>NULL</b>, <i>cbSid</i> must be zero.</param>
    <param name="cbSid">A pointer to a variable. On input, this value specifies the size, in bytes, of the <i>Sid</i> buffer. If the function fails because the buffer is too small or if <i>cbSid</i> is zero, this variable receives the required buffer size.</param>
    <param name="ReferencedDomainName">A pointer to a buffer that receives the name of the domain where the account name is found. For computers that are not joined to a domain, this buffer receives the computer name. If this parameter is <b>NULL</b>, the function returns the required buffer size.</param>
    <param name="cchReferencedDomainName">A pointer to a variable. On input, this value specifies the size, in <b>TCHAR</b>s, of the <i>ReferencedDomainName</i> buffer. If the function fails because the buffer is too small, this variable receives the required buffer size, including the terminating <b>null</b> character. If the <i>ReferencedDomainName</i> parameter is <b>NULL</b>, this parameter must be zero.</param>
    <param name="peUse">A pointer to a<see cref="SID_NAME_USE" /> enumerated type that indicates the type of the account when the function returns.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. For extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupAccountSid">
    <summary>The <b>LookupAccountSid</b> function accepts a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) as input. It retrieves the name of the account for this SID and the name of the first domain on which this SID is found.</summary>
    <param name="lpSystemName">A pointer to a <b>null</b>-terminated character string that specifies the target computer. This string can be the name of a remote computer. If this parameter is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for <i>lpSystemName</i> only when the account is in an untrusted domain and the name of a computer in that domain is known.</param>
    <param name="Sid">A pointer to the<see cref="SID" /> to look up.</param>
    <param name="Name">A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</param>
    <param name="cchName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="peUse">A pointer to a variable that receives a<see cref="SID_NAME_USE" /> value that indicates the type of the account.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupAccountSidA">
    <summary>The <b>LookupAccountSid</b> function accepts a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) as input. It retrieves the name of the account for this SID and the name of the first domain on which this SID is found.</summary>
    <param name="lpSystemName">A pointer to a <b>null</b>-terminated character string that specifies the target computer. This string can be the name of a remote computer. If this parameter is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for <i>lpSystemName</i> only when the account is in an untrusted domain and the name of a computer in that domain is known.</param>
    <param name="Sid">A pointer to the<see cref="SID" /> to look up.</param>
    <param name="Name">A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</param>
    <param name="cchName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="peUse">A pointer to a variable that receives a<see cref="SID_NAME_USE" /> value that indicates the type of the account.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupAccountSidW">
    <summary>The <b>LookupAccountSid</b> function accepts a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) as input. It retrieves the name of the account for this SID and the name of the first domain on which this SID is found.</summary>
    <param name="lpSystemName">A pointer to a <b>null</b>-terminated character string that specifies the target computer. This string can be the name of a remote computer. If this parameter is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for <i>lpSystemName</i> only when the account is in an untrusted domain and the name of a computer in that domain is known.</param>
    <param name="Sid">A pointer to the<see cref="SID" /> to look up.</param>
    <param name="Name">A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</param>
    <param name="cchName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="peUse">A pointer to a variable that receives a<see cref="SID_NAME_USE" /> value that indicates the type of the account.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupAccountSidLocal">
    <summary>
      <b>LookupAccountSidLocalA</b> is defined as a macro that calls <see cref="LookupAccountSidA" /> with <code>NULL</code> as the first parameter. Retrieves the name of the account for the specified SID on the local machine.</summary>
    <param name="Sid">A pointer to the<see cref="SID" /> to look up.</param>
    <param name="Name">A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</param>
    <param name="cchName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="peUse">A pointer to a variable that receives a<see cref="SID_NAME_USE" /> value that indicates the type of the account.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupAccountSidLocalA">
    <summary>
      <b>LookupAccountSidLocalA</b> is defined as a macro that calls <see cref="LookupAccountSidA" /> with <code>NULL</code> as the first parameter. Retrieves the name of the account for the specified SID on the local machine.</summary>
    <param name="Sid">A pointer to the<see cref="SID" /> to look up.</param>
    <param name="Name">A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</param>
    <param name="cchName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="peUse">A pointer to a variable that receives a<see cref="SID_NAME_USE" /> value that indicates the type of the account.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupAccountSidLocalW">
    <summary>
      <b>LookupAccountSidLocalA</b> is defined as a macro that calls <see cref="LookupAccountSidA" /> with <code>NULL</code> as the first parameter. Retrieves the name of the account for the specified SID on the local machine.</summary>
    <param name="Sid">A pointer to the<see cref="SID" /> to look up.</param>
    <param name="Name">A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</param>
    <param name="cchName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="peUse">A pointer to a variable that receives a<see cref="SID_NAME_USE" /> value that indicates the type of the account.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupAccountSidLocal">
    <summary>
      <b>LookupAccountSidLocalW</b> is defined as a macro that calls <see cref="LookupAccountSidW" /> with <code>NULL</code> as the first parameter. Retrieves the name of the account for the specified SID on the local machine.</summary>
    <param name="Sid">A pointer to the<see cref="SID" /> to look up.</param>
    <param name="Name">A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</param>
    <param name="cchName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="peUse">A pointer to a variable that receives a<see cref="SID_NAME_USE" /> value that indicates the type of the account.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupAccountSidLocalA">
    <summary>
      <b>LookupAccountSidLocalW</b> is defined as a macro that calls <see cref="LookupAccountSidW" /> with <code>NULL</code> as the first parameter. Retrieves the name of the account for the specified SID on the local machine.</summary>
    <param name="Sid">A pointer to the<see cref="SID" /> to look up.</param>
    <param name="Name">A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</param>
    <param name="cchName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="peUse">A pointer to a variable that receives a<see cref="SID_NAME_USE" /> value that indicates the type of the account.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupAccountSidLocalW">
    <summary>
      <b>LookupAccountSidLocalW</b> is defined as a macro that calls <see cref="LookupAccountSidW" /> with <code>NULL</code> as the first parameter. Retrieves the name of the account for the specified SID on the local machine.</summary>
    <param name="Sid">A pointer to the<see cref="SID" /> to look up.</param>
    <param name="Name">A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</param>
    <param name="cchName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="peUse">A pointer to a variable that receives a<see cref="SID_NAME_USE" /> value that indicates the type of the account.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupAccountSid">
    <summary>The <b>LookupAccountSid</b> function accepts a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) as input. It retrieves the name of the account for this SID and the name of the first domain on which this SID is found.</summary>
    <param name="lpSystemName">A pointer to a <b>null</b>-terminated character string that specifies the target computer. This string can be the name of a remote computer. If this parameter is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for <i>lpSystemName</i> only when the account is in an untrusted domain and the name of a computer in that domain is known.</param>
    <param name="Sid">A pointer to the<see cref="SID" /> to look up.</param>
    <param name="Name">A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</param>
    <param name="cchName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="peUse">A pointer to a variable that receives a<see cref="SID_NAME_USE" /> value that indicates the type of the account.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupAccountSidA">
    <summary>The <b>LookupAccountSid</b> function accepts a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) as input. It retrieves the name of the account for this SID and the name of the first domain on which this SID is found.</summary>
    <param name="lpSystemName">A pointer to a <b>null</b>-terminated character string that specifies the target computer. This string can be the name of a remote computer. If this parameter is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for <i>lpSystemName</i> only when the account is in an untrusted domain and the name of a computer in that domain is known.</param>
    <param name="Sid">A pointer to the<see cref="SID" /> to look up.</param>
    <param name="Name">A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</param>
    <param name="cchName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="peUse">A pointer to a variable that receives a<see cref="SID_NAME_USE" /> value that indicates the type of the account.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupAccountSidW">
    <summary>The <b>LookupAccountSid</b> function accepts a <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security identifier</a> (SID) as input. It retrieves the name of the account for this SID and the name of the first domain on which this SID is found.</summary>
    <param name="lpSystemName">A pointer to a <b>null</b>-terminated character string that specifies the target computer. This string can be the name of a remote computer. If this parameter is <b>NULL</b>, the account name translation begins on the local system. If the name cannot be resolved on the local system, this function will try to resolve the name using domain controllers trusted by the local system. Generally, specify a value for <i>lpSystemName</i> only when the account is in an untrusted domain and the name of a computer in that domain is known.</param>
    <param name="Sid">A pointer to the<see cref="SID" /> to look up.</param>
    <param name="Name">A pointer to a buffer that receives a <b>null</b>-terminated string that contains the account name that corresponds to the <i>lpSid</i> parameter.</param>
    <param name="cchName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpName</i> buffer. If the function fails because the buffer is too small or if <i>cchName</i> is zero, <i>cchName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="ReferencedDomainName">
      <para>A pointer to a buffer that receives a <b>null</b>-terminated string that contains the name of the domain where the account name was found.</para>
      <para>On a server, the domain name returned for most accounts in the security database of the local computer is the name of the domain for which the server is a domain controller.</para>
      <para>On a workstation, the domain name returned for most accounts in the security database of the local computer is the name of the computer as of the last start of the system (backslashes are excluded). If the name of the computer changes, the old name continues to be returned as the domain name until the system is restarted.</para>
      <para>Some accounts are predefined by the system. The domain name returned for these accounts is BUILTIN.</para>
    </param>
    <param name="cchReferencedDomainName">On input, specifies the size, in <b>TCHAR</b>s, of the <i>lpReferencedDomainName</i> buffer. If the function fails because the buffer is too small or if <i>cchReferencedDomainName</i> is zero, <i>cchReferencedDomainName</i> receives the required buffer size, including the terminating <b>null</b> character.</param>
    <param name="peUse">A pointer to a variable that receives a<see cref="SID_NAME_USE" /> value that indicates the type of the account.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupPrivilegeDisplayName">
    <summary>The <b>LookupPrivilegeDisplayName</b> function retrieves the display name that represents a specified privilege.</summary>
    <param name="lpSystemName">A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the display name on the local system.</param>
    <param name="lpName">A pointer to a null-terminated string that specifies the name of the privilege, as defined in Winnt.h. For example, this parameter could specify the constant, SE_REMOTE_SHUTDOWN_NAME, or its corresponding string, "SeRemoteShutdownPrivilege". For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</param>
    <param name="lpDisplayName">A pointer to a buffer that receives a null-terminated string that specifies the privilege display name. For example, if the <i>lpName</i> parameter is SE_REMOTE_SHUTDOWN_NAME, the privilege display name is "Force shutdown from a remote system."</param>
    <param name="cchDisplayName">A pointer to a variable that specifies the size, in <b>TCHAR</b>s, of the <i>lpDisplayName</i> buffer. When the function returns, this parameter contains the length of the privilege display name, not including the terminating null character. If the buffer pointed to by the <i>lpDisplayName</i> parameter is too small, this variable contains the required size.</param>
    <param name="lpLanguageId">A pointer to a variable that receives the language identifier for the returned display name.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupPrivilegeDisplayNameA">
    <summary>The <b>LookupPrivilegeDisplayName</b> function retrieves the display name that represents a specified privilege.</summary>
    <param name="lpSystemName">A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the display name on the local system.</param>
    <param name="lpName">A pointer to a null-terminated string that specifies the name of the privilege, as defined in Winnt.h. For example, this parameter could specify the constant, SE_REMOTE_SHUTDOWN_NAME, or its corresponding string, "SeRemoteShutdownPrivilege". For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</param>
    <param name="lpDisplayName">A pointer to a buffer that receives a null-terminated string that specifies the privilege display name. For example, if the <i>lpName</i> parameter is SE_REMOTE_SHUTDOWN_NAME, the privilege display name is "Force shutdown from a remote system."</param>
    <param name="cchDisplayName">A pointer to a variable that specifies the size, in <b>TCHAR</b>s, of the <i>lpDisplayName</i> buffer. When the function returns, this parameter contains the length of the privilege display name, not including the terminating null character. If the buffer pointed to by the <i>lpDisplayName</i> parameter is too small, this variable contains the required size.</param>
    <param name="lpLanguageId">A pointer to a variable that receives the language identifier for the returned display name.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupPrivilegeDisplayNameW">
    <summary>The <b>LookupPrivilegeDisplayName</b> function retrieves the display name that represents a specified privilege.</summary>
    <param name="lpSystemName">A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the display name on the local system.</param>
    <param name="lpName">A pointer to a null-terminated string that specifies the name of the privilege, as defined in Winnt.h. For example, this parameter could specify the constant, SE_REMOTE_SHUTDOWN_NAME, or its corresponding string, "SeRemoteShutdownPrivilege". For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</param>
    <param name="lpDisplayName">A pointer to a buffer that receives a null-terminated string that specifies the privilege display name. For example, if the <i>lpName</i> parameter is SE_REMOTE_SHUTDOWN_NAME, the privilege display name is "Force shutdown from a remote system."</param>
    <param name="cchDisplayName">A pointer to a variable that specifies the size, in <b>TCHAR</b>s, of the <i>lpDisplayName</i> buffer. When the function returns, this parameter contains the length of the privilege display name, not including the terminating null character. If the buffer pointed to by the <i>lpDisplayName</i> parameter is too small, this variable contains the required size.</param>
    <param name="lpLanguageId">A pointer to a variable that receives the language identifier for the returned display name.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupPrivilegeDisplayName">
    <summary>The <b>LookupPrivilegeDisplayName</b> function retrieves the display name that represents a specified privilege.</summary>
    <param name="lpSystemName">A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the display name on the local system.</param>
    <param name="lpName">A pointer to a null-terminated string that specifies the name of the privilege, as defined in Winnt.h. For example, this parameter could specify the constant, SE_REMOTE_SHUTDOWN_NAME, or its corresponding string, "SeRemoteShutdownPrivilege". For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</param>
    <param name="lpDisplayName">A pointer to a buffer that receives a null-terminated string that specifies the privilege display name. For example, if the <i>lpName</i> parameter is SE_REMOTE_SHUTDOWN_NAME, the privilege display name is "Force shutdown from a remote system."</param>
    <param name="cchDisplayName">A pointer to a variable that specifies the size, in <b>TCHAR</b>s, of the <i>lpDisplayName</i> buffer. When the function returns, this parameter contains the length of the privilege display name, not including the terminating null character. If the buffer pointed to by the <i>lpDisplayName</i> parameter is too small, this variable contains the required size.</param>
    <param name="lpLanguageId">A pointer to a variable that receives the language identifier for the returned display name.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupPrivilegeDisplayNameA">
    <summary>The <b>LookupPrivilegeDisplayName</b> function retrieves the display name that represents a specified privilege.</summary>
    <param name="lpSystemName">A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the display name on the local system.</param>
    <param name="lpName">A pointer to a null-terminated string that specifies the name of the privilege, as defined in Winnt.h. For example, this parameter could specify the constant, SE_REMOTE_SHUTDOWN_NAME, or its corresponding string, "SeRemoteShutdownPrivilege". For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</param>
    <param name="lpDisplayName">A pointer to a buffer that receives a null-terminated string that specifies the privilege display name. For example, if the <i>lpName</i> parameter is SE_REMOTE_SHUTDOWN_NAME, the privilege display name is "Force shutdown from a remote system."</param>
    <param name="cchDisplayName">A pointer to a variable that specifies the size, in <b>TCHAR</b>s, of the <i>lpDisplayName</i> buffer. When the function returns, this parameter contains the length of the privilege display name, not including the terminating null character. If the buffer pointed to by the <i>lpDisplayName</i> parameter is too small, this variable contains the required size.</param>
    <param name="lpLanguageId">A pointer to a variable that receives the language identifier for the returned display name.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupPrivilegeDisplayNameW">
    <summary>The <b>LookupPrivilegeDisplayName</b> function retrieves the display name that represents a specified privilege.</summary>
    <param name="lpSystemName">A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the display name on the local system.</param>
    <param name="lpName">A pointer to a null-terminated string that specifies the name of the privilege, as defined in Winnt.h. For example, this parameter could specify the constant, SE_REMOTE_SHUTDOWN_NAME, or its corresponding string, "SeRemoteShutdownPrivilege". For a list of values, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/privilege-constants">Privilege Constants</a>.</param>
    <param name="lpDisplayName">A pointer to a buffer that receives a null-terminated string that specifies the privilege display name. For example, if the <i>lpName</i> parameter is SE_REMOTE_SHUTDOWN_NAME, the privilege display name is "Force shutdown from a remote system."</param>
    <param name="cchDisplayName">A pointer to a variable that specifies the size, in <b>TCHAR</b>s, of the <i>lpDisplayName</i> buffer. When the function returns, this parameter contains the length of the privilege display name, not including the terminating null character. If the buffer pointed to by the <i>lpDisplayName</i> parameter is too small, this variable contains the required size.</param>
    <param name="lpLanguageId">A pointer to a variable that receives the language identifier for the returned display name.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupPrivilegeName">
    <summary>The <b>LookupPrivilegeName</b> function retrieves the name that corresponds to the privilege represented on a specific system by a specified <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID).</summary>
    <param name="lpSystemName">A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</param>
    <param name="lpLuid">A pointer to the LUID by which the privilege is known on the target system.</param>
    <param name="lpName">A pointer to a buffer that receives a null-terminated string that represents the privilege name. For example, this string could be "SeSecurityPrivilege".</param>
    <param name="cchName">A pointer to a variable that specifies the size, in a <b>TCHAR</b> value, of the <i>lpName</i> buffer. When the function returns, this parameter contains the length of the privilege name, not including the terminating null character. If the buffer pointed to by the <i>lpName</i> parameter is too small, this variable contains the required size.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupPrivilegeNameA">
    <summary>The <b>LookupPrivilegeName</b> function retrieves the name that corresponds to the privilege represented on a specific system by a specified <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID).</summary>
    <param name="lpSystemName">A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</param>
    <param name="lpLuid">A pointer to the LUID by which the privilege is known on the target system.</param>
    <param name="lpName">A pointer to a buffer that receives a null-terminated string that represents the privilege name. For example, this string could be "SeSecurityPrivilege".</param>
    <param name="cchName">A pointer to a variable that specifies the size, in a <b>TCHAR</b> value, of the <i>lpName</i> buffer. When the function returns, this parameter contains the length of the privilege name, not including the terminating null character. If the buffer pointed to by the <i>lpName</i> parameter is too small, this variable contains the required size.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupPrivilegeNameW">
    <summary>The <b>LookupPrivilegeName</b> function retrieves the name that corresponds to the privilege represented on a specific system by a specified <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID).</summary>
    <param name="lpSystemName">A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</param>
    <param name="lpLuid">A pointer to the LUID by which the privilege is known on the target system.</param>
    <param name="lpName">A pointer to a buffer that receives a null-terminated string that represents the privilege name. For example, this string could be "SeSecurityPrivilege".</param>
    <param name="cchName">A pointer to a variable that specifies the size, in a <b>TCHAR</b> value, of the <i>lpName</i> buffer. When the function returns, this parameter contains the length of the privilege name, not including the terminating null character. If the buffer pointed to by the <i>lpName</i> parameter is too small, this variable contains the required size.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupPrivilegeName">
    <summary>The <b>LookupPrivilegeName</b> function retrieves the name that corresponds to the privilege represented on a specific system by a specified <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID).</summary>
    <param name="lpSystemName">A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</param>
    <param name="lpLuid">A pointer to the LUID by which the privilege is known on the target system.</param>
    <param name="lpName">A pointer to a buffer that receives a null-terminated string that represents the privilege name. For example, this string could be "SeSecurityPrivilege".</param>
    <param name="cchName">A pointer to a variable that specifies the size, in a <b>TCHAR</b> value, of the <i>lpName</i> buffer. When the function returns, this parameter contains the length of the privilege name, not including the terminating null character. If the buffer pointed to by the <i>lpName</i> parameter is too small, this variable contains the required size.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupPrivilegeNameA">
    <summary>The <b>LookupPrivilegeName</b> function retrieves the name that corresponds to the privilege represented on a specific system by a specified <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID).</summary>
    <param name="lpSystemName">A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</param>
    <param name="lpLuid">A pointer to the LUID by which the privilege is known on the target system.</param>
    <param name="lpName">A pointer to a buffer that receives a null-terminated string that represents the privilege name. For example, this string could be "SeSecurityPrivilege".</param>
    <param name="cchName">A pointer to a variable that specifies the size, in a <b>TCHAR</b> value, of the <i>lpName</i> buffer. When the function returns, this parameter contains the length of the privilege name, not including the terminating null character. If the buffer pointed to by the <i>lpName</i> parameter is too small, this variable contains the required size.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupPrivilegeNameW">
    <summary>The <b>LookupPrivilegeName</b> function retrieves the name that corresponds to the privilege represented on a specific system by a specified <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID).</summary>
    <param name="lpSystemName">A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</param>
    <param name="lpLuid">A pointer to the LUID by which the privilege is known on the target system.</param>
    <param name="lpName">A pointer to a buffer that receives a null-terminated string that represents the privilege name. For example, this string could be "SeSecurityPrivilege".</param>
    <param name="cchName">A pointer to a variable that specifies the size, in a <b>TCHAR</b> value, of the <i>lpName</i> buffer. When the function returns, this parameter contains the length of the privilege name, not including the terminating null character. If the buffer pointed to by the <i>lpName</i> parameter is too small, this variable contains the required size.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupPrivilegeValue">
    <summary>The <b>LookupPrivilegeValue</b> function retrieves the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID) used on a specified system to locally represent the specified privilege name.</summary>
    <param name="lpSystemName">A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</param>
    <param name="lpName">A pointer to a null-terminated string that specifies the name of the privilege, as defined in the Winnt.h header file. For example, this parameter could specify the constant, SE_SECURITY_NAME, or its corresponding string, "SeSecurityPrivilege".</param>
    <param name="lpLuid">A pointer to a variable that receives the LUID by which the privilege is known on the system specified by the <i>lpSystemName</i> parameter.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupPrivilegeValueA">
    <summary>The <b>LookupPrivilegeValue</b> function retrieves the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID) used on a specified system to locally represent the specified privilege name.</summary>
    <param name="lpSystemName">A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</param>
    <param name="lpName">A pointer to a null-terminated string that specifies the name of the privilege, as defined in the Winnt.h header file. For example, this parameter could specify the constant, SE_SECURITY_NAME, or its corresponding string, "SeSecurityPrivilege".</param>
    <param name="lpLuid">A pointer to a variable that receives the LUID by which the privilege is known on the system specified by the <i>lpSystemName</i> parameter.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupPrivilegeValueW">
    <summary>The <b>LookupPrivilegeValue</b> function retrieves the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID) used on a specified system to locally represent the specified privilege name.</summary>
    <param name="lpSystemName">A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</param>
    <param name="lpName">A pointer to a null-terminated string that specifies the name of the privilege, as defined in the Winnt.h header file. For example, this parameter could specify the constant, SE_SECURITY_NAME, or its corresponding string, "SeSecurityPrivilege".</param>
    <param name="lpLuid">A pointer to a variable that receives the LUID by which the privilege is known on the system specified by the <i>lpSystemName</i> parameter.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupPrivilegeValue">
    <summary>The <b>LookupPrivilegeValue</b> function retrieves the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID) used on a specified system to locally represent the specified privilege name.</summary>
    <param name="lpSystemName">A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</param>
    <param name="lpName">A pointer to a null-terminated string that specifies the name of the privilege, as defined in the Winnt.h header file. For example, this parameter could specify the constant, SE_SECURITY_NAME, or its corresponding string, "SeSecurityPrivilege".</param>
    <param name="lpLuid">A pointer to a variable that receives the LUID by which the privilege is known on the system specified by the <i>lpSystemName</i> parameter.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupPrivilegeValueA">
    <summary>The <b>LookupPrivilegeValue</b> function retrieves the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID) used on a specified system to locally represent the specified privilege name.</summary>
    <param name="lpSystemName">A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</param>
    <param name="lpName">A pointer to a null-terminated string that specifies the name of the privilege, as defined in the Winnt.h header file. For example, this parameter could specify the constant, SE_SECURITY_NAME, or its corresponding string, "SeSecurityPrivilege".</param>
    <param name="lpLuid">A pointer to a variable that receives the LUID by which the privilege is known on the system specified by the <i>lpSystemName</i> parameter.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.LookupPrivilegeValueW">
    <summary>The <b>LookupPrivilegeValue</b> function retrieves the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/l-gly">locally unique identifier</a> (LUID) used on a specified system to locally represent the specified privilege name.</summary>
    <param name="lpSystemName">A pointer to a null-terminated string that specifies the name of the system on which the privilege name is retrieved. If a null string is specified, the function attempts to find the privilege name on the local system.</param>
    <param name="lpName">A pointer to a null-terminated string that specifies the name of the privilege, as defined in the Winnt.h header file. For example, this parameter could specify the constant, SE_SECURITY_NAME, or its corresponding string, "SeSecurityPrivilege".</param>
    <param name="lpLuid">A pointer to a variable that receives the LUID by which the privilege is known on the system specified by the <i>lpSystemName</i> parameter.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.lstrcat">
    <summary>
      <para>Appends one string to another.</para>
      <div>
        <b>Warning</b>  Do not use. Consider using <see cref="StringCchCat" /> instead. See Security Considerations.</div>
    </summary>
    <param name="lpString1">The first null-terminated string. This buffer must be large enough to contain both strings.</param>
    <param name="lpString2">The null-terminated string to be appended to the string specified in the <i>lpString1</i> parameter.</param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
  </member>
  <member name="Windows.lstrcatA">
    <summary>
      <para>Appends one string to another.</para>
      <div>
        <b>Warning</b>  Do not use. Consider using <see cref="StringCchCat" /> instead. See Security Considerations.</div>
    </summary>
    <param name="lpString1">The first null-terminated string. This buffer must be large enough to contain both strings.</param>
    <param name="lpString2">The null-terminated string to be appended to the string specified in the <i>lpString1</i> parameter.</param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
  </member>
  <member name="Windows.lstrcatW">
    <summary>
      <para>Appends one string to another.</para>
      <div>
        <b>Warning</b>  Do not use. Consider using <see cref="StringCchCat" /> instead. See Security Considerations.</div>
    </summary>
    <param name="lpString1">The first null-terminated string. This buffer must be large enough to contain both strings.</param>
    <param name="lpString2">The null-terminated string to be appended to the string specified in the <i>lpString1</i> parameter.</param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
  </member>
  <member name="Windows.lstrcat">
    <summary>
      <para>Appends one string to another.</para>
      <div>
        <b>Warning</b>  Do not use. Consider using <see cref="StringCchCat" /> instead. See Security Considerations.</div>
    </summary>
    <param name="lpString1">The first null-terminated string. This buffer must be large enough to contain both strings.</param>
    <param name="lpString2">The null-terminated string to be appended to the string specified in the <i>lpString1</i> parameter.</param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
  </member>
  <member name="Windows.lstrcatA">
    <summary>
      <para>Appends one string to another.</para>
      <div>
        <b>Warning</b>  Do not use. Consider using <see cref="StringCchCat" /> instead. See Security Considerations.</div>
    </summary>
    <param name="lpString1">The first null-terminated string. This buffer must be large enough to contain both strings.</param>
    <param name="lpString2">The null-terminated string to be appended to the string specified in the <i>lpString1</i> parameter.</param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
  </member>
  <member name="Windows.lstrcatW">
    <summary>
      <para>Appends one string to another.</para>
      <div>
        <b>Warning</b>  Do not use. Consider using <see cref="StringCchCat" /> instead. See Security Considerations.</div>
    </summary>
    <param name="lpString1">The first null-terminated string. This buffer must be large enough to contain both strings.</param>
    <param name="lpString2">The null-terminated string to be appended to the string specified in the <i>lpString1</i> parameter.</param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
  </member>
  <member name="Windows.lstrcmp">
    <summary>
      <para>Compares two character strings. The comparison is case-sensitive.</para>
      <para>To perform a comparison that is not case-sensitive, use the <see cref="lstrcmpi" /> function.</para>
    </summary>
    <param name="lpString1">The first null-terminated string to be compared.</param>
    <param name="lpString2">The second null-terminated string to be compared.</param>
    <returns>If the string pointed to by<i>lpString1</i> is less than the string pointed to by<i>lpString2</i>, the return value is negative. If the string pointed to by<i>lpString1</i> is greater than the string pointed to by<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</returns>
  </member>
  <member name="Windows.lstrcmpA">
    <summary>
      <para>Compares two character strings. The comparison is case-sensitive.</para>
      <para>To perform a comparison that is not case-sensitive, use the <see cref="lstrcmpi" /> function.</para>
    </summary>
    <param name="lpString1">The first null-terminated string to be compared.</param>
    <param name="lpString2">The second null-terminated string to be compared.</param>
    <returns>If the string pointed to by<i>lpString1</i> is less than the string pointed to by<i>lpString2</i>, the return value is negative. If the string pointed to by<i>lpString1</i> is greater than the string pointed to by<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</returns>
  </member>
  <member name="Windows.lstrcmpW">
    <summary>
      <para>Compares two character strings. The comparison is case-sensitive.</para>
      <para>To perform a comparison that is not case-sensitive, use the <see cref="lstrcmpi" /> function.</para>
    </summary>
    <param name="lpString1">The first null-terminated string to be compared.</param>
    <param name="lpString2">The second null-terminated string to be compared.</param>
    <returns>If the string pointed to by<i>lpString1</i> is less than the string pointed to by<i>lpString2</i>, the return value is negative. If the string pointed to by<i>lpString1</i> is greater than the string pointed to by<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</returns>
  </member>
  <member name="Windows.lstrcmpi">
    <summary>
      <para>Compares two character strings. The comparison is not case-sensitive.</para>
      <para>To perform a comparison that is case-sensitive, use the <see cref="lstrcmp" /> function.</para>
    </summary>
    <param name="lpString1">The first null-terminated string to be compared.</param>
    <param name="lpString2">The second null-terminated string to be compared.</param>
    <returns>If the string pointed to by<i>lpString1</i> is less than the string pointed to by<i>lpString2</i>, the return value is negative. If the string pointed to by<i>lpString1</i> is greater than the string pointed to by<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</returns>
  </member>
  <member name="Windows.lstrcmpiA">
    <summary>
      <para>Compares two character strings. The comparison is not case-sensitive.</para>
      <para>To perform a comparison that is case-sensitive, use the <see cref="lstrcmp" /> function.</para>
    </summary>
    <param name="lpString1">The first null-terminated string to be compared.</param>
    <param name="lpString2">The second null-terminated string to be compared.</param>
    <returns>If the string pointed to by<i>lpString1</i> is less than the string pointed to by<i>lpString2</i>, the return value is negative. If the string pointed to by<i>lpString1</i> is greater than the string pointed to by<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</returns>
  </member>
  <member name="Windows.lstrcmpiW">
    <summary>
      <para>Compares two character strings. The comparison is not case-sensitive.</para>
      <para>To perform a comparison that is case-sensitive, use the <see cref="lstrcmp" /> function.</para>
    </summary>
    <param name="lpString1">The first null-terminated string to be compared.</param>
    <param name="lpString2">The second null-terminated string to be compared.</param>
    <returns>If the string pointed to by<i>lpString1</i> is less than the string pointed to by<i>lpString2</i>, the return value is negative. If the string pointed to by<i>lpString1</i> is greater than the string pointed to by<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</returns>
  </member>
  <member name="Windows.lstrcmpi">
    <summary>
      <para>Compares two character strings. The comparison is not case-sensitive.</para>
      <para>To perform a comparison that is case-sensitive, use the <see cref="lstrcmp" /> function.</para>
    </summary>
    <param name="lpString1">The first null-terminated string to be compared.</param>
    <param name="lpString2">The second null-terminated string to be compared.</param>
    <returns>If the string pointed to by<i>lpString1</i> is less than the string pointed to by<i>lpString2</i>, the return value is negative. If the string pointed to by<i>lpString1</i> is greater than the string pointed to by<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</returns>
  </member>
  <member name="Windows.lstrcmpiA">
    <summary>
      <para>Compares two character strings. The comparison is not case-sensitive.</para>
      <para>To perform a comparison that is case-sensitive, use the <see cref="lstrcmp" /> function.</para>
    </summary>
    <param name="lpString1">The first null-terminated string to be compared.</param>
    <param name="lpString2">The second null-terminated string to be compared.</param>
    <returns>If the string pointed to by<i>lpString1</i> is less than the string pointed to by<i>lpString2</i>, the return value is negative. If the string pointed to by<i>lpString1</i> is greater than the string pointed to by<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</returns>
  </member>
  <member name="Windows.lstrcmpiW">
    <summary>
      <para>Compares two character strings. The comparison is not case-sensitive.</para>
      <para>To perform a comparison that is case-sensitive, use the <see cref="lstrcmp" /> function.</para>
    </summary>
    <param name="lpString1">The first null-terminated string to be compared.</param>
    <param name="lpString2">The second null-terminated string to be compared.</param>
    <returns>If the string pointed to by<i>lpString1</i> is less than the string pointed to by<i>lpString2</i>, the return value is negative. If the string pointed to by<i>lpString1</i> is greater than the string pointed to by<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</returns>
  </member>
  <member name="Windows.lstrcmp">
    <summary>
      <para>Compares two character strings. The comparison is case-sensitive.</para>
      <para>To perform a comparison that is not case-sensitive, use the <see cref="lstrcmpi" /> function.</para>
    </summary>
    <param name="lpString1">The first null-terminated string to be compared.</param>
    <param name="lpString2">The second null-terminated string to be compared.</param>
    <returns>If the string pointed to by<i>lpString1</i> is less than the string pointed to by<i>lpString2</i>, the return value is negative. If the string pointed to by<i>lpString1</i> is greater than the string pointed to by<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</returns>
  </member>
  <member name="Windows.lstrcmpA">
    <summary>
      <para>Compares two character strings. The comparison is case-sensitive.</para>
      <para>To perform a comparison that is not case-sensitive, use the <see cref="lstrcmpi" /> function.</para>
    </summary>
    <param name="lpString1">The first null-terminated string to be compared.</param>
    <param name="lpString2">The second null-terminated string to be compared.</param>
    <returns>If the string pointed to by<i>lpString1</i> is less than the string pointed to by<i>lpString2</i>, the return value is negative. If the string pointed to by<i>lpString1</i> is greater than the string pointed to by<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</returns>
  </member>
  <member name="Windows.lstrcmpW">
    <summary>
      <para>Compares two character strings. The comparison is case-sensitive.</para>
      <para>To perform a comparison that is not case-sensitive, use the <see cref="lstrcmpi" /> function.</para>
    </summary>
    <param name="lpString1">The first null-terminated string to be compared.</param>
    <param name="lpString2">The second null-terminated string to be compared.</param>
    <returns>If the string pointed to by<i>lpString1</i> is less than the string pointed to by<i>lpString2</i>, the return value is negative. If the string pointed to by<i>lpString1</i> is greater than the string pointed to by<i>lpString2</i>, the return value is positive. If the strings are equal, the return value is zero.</returns>
  </member>
  <member name="Windows.lstrcpy">
    <summary>
      <para>Copies a string to a buffer.</para>
      <div>
        <b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</div>
    </summary>
    <param name="lpString1">A buffer to receive the contents of the string pointed to by the<i>lpString2</i> parameter. The buffer must be large enough to contain the string, including the terminating null character.</param>
    <param name="lpString2">The null-terminated string to be copied.</param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
  </member>
  <member name="Windows.lstrcpyA">
    <summary>
      <para>Copies a string to a buffer.</para>
      <div>
        <b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</div>
    </summary>
    <param name="lpString1">A buffer to receive the contents of the string pointed to by the<i>lpString2</i> parameter. The buffer must be large enough to contain the string, including the terminating null character.</param>
    <param name="lpString2">The null-terminated string to be copied.</param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
  </member>
  <member name="Windows.lstrcpyW">
    <summary>
      <para>Copies a string to a buffer.</para>
      <div>
        <b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</div>
    </summary>
    <param name="lpString1">A buffer to receive the contents of the string pointed to by the<i>lpString2</i> parameter. The buffer must be large enough to contain the string, including the terminating null character.</param>
    <param name="lpString2">The null-terminated string to be copied.</param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
  </member>
  <member name="Windows.lstrcpyn">
    <summary>
      <para>Copies a specified number of characters from a source string into a buffer.</para>
      <div>
        <b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</div>
    </summary>
    <param name="lpString1">The destination buffer, which receives the copied characters. The buffer must be large enough to contain the number of <b>TCHAR</b> values specified by <i>iMaxLength</i>, including room for a terminating null character.</param>
    <param name="lpString2">The source string from which the function is to copy characters.</param>
    <param name="iMaxLength">The number of <b>TCHAR</b> values to be copied from the string pointed to by <i>lpString2</i> into the buffer pointed to by <i>lpString1</i>, including a terminating null character.</param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the buffer. The function can succeed even if the source string is greater than<i>iMaxLength</i> characters.</para>
      <para>If the function fails, the return value is <b>NULL</b>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
  </member>
  <member name="Windows.lstrcpynA">
    <summary>
      <para>Copies a specified number of characters from a source string into a buffer.</para>
      <div>
        <b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</div>
    </summary>
    <param name="lpString1">The destination buffer, which receives the copied characters. The buffer must be large enough to contain the number of <b>TCHAR</b> values specified by <i>iMaxLength</i>, including room for a terminating null character.</param>
    <param name="lpString2">The source string from which the function is to copy characters.</param>
    <param name="iMaxLength">The number of <b>TCHAR</b> values to be copied from the string pointed to by <i>lpString2</i> into the buffer pointed to by <i>lpString1</i>, including a terminating null character.</param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the buffer. The function can succeed even if the source string is greater than<i>iMaxLength</i> characters.</para>
      <para>If the function fails, the return value is <b>NULL</b>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
  </member>
  <member name="Windows.lstrcpynW">
    <summary>
      <para>Copies a specified number of characters from a source string into a buffer.</para>
      <div>
        <b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</div>
    </summary>
    <param name="lpString1">The destination buffer, which receives the copied characters. The buffer must be large enough to contain the number of <b>TCHAR</b> values specified by <i>iMaxLength</i>, including room for a terminating null character.</param>
    <param name="lpString2">The source string from which the function is to copy characters.</param>
    <param name="iMaxLength">The number of <b>TCHAR</b> values to be copied from the string pointed to by <i>lpString2</i> into the buffer pointed to by <i>lpString1</i>, including a terminating null character.</param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the buffer. The function can succeed even if the source string is greater than<i>iMaxLength</i> characters.</para>
      <para>If the function fails, the return value is <b>NULL</b>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
  </member>
  <member name="Windows.lstrcpyn">
    <summary>
      <para>Copies a specified number of characters from a source string into a buffer.</para>
      <div>
        <b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</div>
    </summary>
    <param name="lpString1">The destination buffer, which receives the copied characters. The buffer must be large enough to contain the number of <b>TCHAR</b> values specified by <i>iMaxLength</i>, including room for a terminating null character.</param>
    <param name="lpString2">The source string from which the function is to copy characters.</param>
    <param name="iMaxLength">The number of <b>TCHAR</b> values to be copied from the string pointed to by <i>lpString2</i> into the buffer pointed to by <i>lpString1</i>, including a terminating null character.</param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the buffer. The function can succeed even if the source string is greater than<i>iMaxLength</i> characters.</para>
      <para>If the function fails, the return value is <b>NULL</b>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
  </member>
  <member name="Windows.lstrcpynA">
    <summary>
      <para>Copies a specified number of characters from a source string into a buffer.</para>
      <div>
        <b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</div>
    </summary>
    <param name="lpString1">The destination buffer, which receives the copied characters. The buffer must be large enough to contain the number of <b>TCHAR</b> values specified by <i>iMaxLength</i>, including room for a terminating null character.</param>
    <param name="lpString2">The source string from which the function is to copy characters.</param>
    <param name="iMaxLength">The number of <b>TCHAR</b> values to be copied from the string pointed to by <i>lpString2</i> into the buffer pointed to by <i>lpString1</i>, including a terminating null character.</param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the buffer. The function can succeed even if the source string is greater than<i>iMaxLength</i> characters.</para>
      <para>If the function fails, the return value is <b>NULL</b>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
  </member>
  <member name="Windows.lstrcpynW">
    <summary>
      <para>Copies a specified number of characters from a source string into a buffer.</para>
      <div>
        <b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</div>
    </summary>
    <param name="lpString1">The destination buffer, which receives the copied characters. The buffer must be large enough to contain the number of <b>TCHAR</b> values specified by <i>iMaxLength</i>, including room for a terminating null character.</param>
    <param name="lpString2">The source string from which the function is to copy characters.</param>
    <param name="iMaxLength">The number of <b>TCHAR</b> values to be copied from the string pointed to by <i>lpString2</i> into the buffer pointed to by <i>lpString1</i>, including a terminating null character.</param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the buffer. The function can succeed even if the source string is greater than<i>iMaxLength</i> characters.</para>
      <para>If the function fails, the return value is <b>NULL</b>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
  </member>
  <member name="Windows.lstrcpy">
    <summary>
      <para>Copies a string to a buffer.</para>
      <div>
        <b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</div>
    </summary>
    <param name="lpString1">A buffer to receive the contents of the string pointed to by the<i>lpString2</i> parameter. The buffer must be large enough to contain the string, including the terminating null character.</param>
    <param name="lpString2">The null-terminated string to be copied.</param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
  </member>
  <member name="Windows.lstrcpyA">
    <summary>
      <para>Copies a string to a buffer.</para>
      <div>
        <b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</div>
    </summary>
    <param name="lpString1">A buffer to receive the contents of the string pointed to by the<i>lpString2</i> parameter. The buffer must be large enough to contain the string, including the terminating null character.</param>
    <param name="lpString2">The null-terminated string to be copied.</param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
  </member>
  <member name="Windows.lstrcpyW">
    <summary>
      <para>Copies a string to a buffer.</para>
      <div>
        <b>Warning</b>  Do not use. Consider using <see cref="StringCchCopy" /> instead. See Remarks.</div>
    </summary>
    <param name="lpString1">A buffer to receive the contents of the string pointed to by the<i>lpString2</i> parameter. The buffer must be large enough to contain the string, including the terminating null character.</param>
    <param name="lpString2">The null-terminated string to be copied.</param>
    <returns>
      <para>If the function succeeds, the return value is a pointer to the buffer.</para>
      <para>If the function fails, the return value is <b>NULL</b>and <i>lpString1</i> may not be null-terminated.</para>
    </returns>
  </member>
  <member name="Windows.lstrlen">
    <summary>Determines the length of the specified string (not including the terminating null character).</summary>
    <param name="lpString">The null-terminated string to be checked.</param>
    <returns>The function returns the length of the string, in characters. If <i>lpString</i> is <b>NULL</b>, the function returns 0.</returns>
  </member>
  <member name="Windows.lstrlenA">
    <summary>Determines the length of the specified string (not including the terminating null character).</summary>
    <param name="lpString">The null-terminated string to be checked.</param>
    <returns>The function returns the length of the string, in characters. If <i>lpString</i> is <b>NULL</b>, the function returns 0.</returns>
  </member>
  <member name="Windows.lstrlenW">
    <summary>Determines the length of the specified string (not including the terminating null character).</summary>
    <param name="lpString">The null-terminated string to be checked.</param>
    <returns>The function returns the length of the string, in characters. If <i>lpString</i> is <b>NULL</b>, the function returns 0.</returns>
  </member>
  <member name="Windows.lstrlen">
    <summary>Determines the length of the specified string (not including the terminating null character).</summary>
    <param name="lpString">The null-terminated string to be checked.</param>
    <returns>The function returns the length of the string, in characters. If <i>lpString</i> is <b>NULL</b>, the function returns 0.</returns>
  </member>
  <member name="Windows.lstrlenA">
    <summary>Determines the length of the specified string (not including the terminating null character).</summary>
    <param name="lpString">The null-terminated string to be checked.</param>
    <returns>The function returns the length of the string, in characters. If <i>lpString</i> is <b>NULL</b>, the function returns 0.</returns>
  </member>
  <member name="Windows.lstrlenW">
    <summary>Determines the length of the specified string (not including the terminating null character).</summary>
    <param name="lpString">The null-terminated string to be checked.</param>
    <returns>The function returns the length of the string, in characters. If <i>lpString</i> is <b>NULL</b>, the function returns 0.</returns>
  </member>
  <member name="Windows.MAKEINTATOM">
    <summary>Converts the specified atom into a string, so it can be passed to functions which accept either atoms or strings.</summary>
    <param name="i">The numeric value to be made into an integer atom. This parameter can be either an integer atom or a string atom.</param>
  </member>
  <member name="Windows.MapUserPhysicalPagesScatter">
    <summary>
      <para>Maps previously allocated physical memory pages at a specified address in an<a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) region.</para>
      <para>
        <b>64-bit Windows on Itanium-based systems:  </b>Due to the difference in page sizes,<b>MapUserPhysicalPagesScatter</b> is not supported for 32-bit applications.</para>
    </summary>
    <param name="VirtualAddresses">
      <para>A pointer to an array of starting addresses of the regions of memory to remap.</para>
      <para>Each entry in<i>VirtualAddresses</i> must be within the address range that the<see cref="VirtualAlloc" /> function returns when the <a href="https://docs.microsoft.com//windows/desktop/Memory/address-windowing-extensions">Address Windowing Extensions</a> (AWE) region is allocated. The value in <i>NumberOfPages</i> indicates the size of the array. Entries can be from multiple Address Windowing Extensions (AWE) regions.</para>
    </param>
    <param name="NumberOfPages">
      <para>The size of the physical memory and virtual address space for which to establish translations, in pages.</para>
      <para>The array at <i>VirtualAddresses</i> specifies the virtual address range.</para>
    </param>
    <param name="PageArray">
      <para>A pointer to an array of values that indicates how each corresponding page in<i>VirtualAddresses</i> should be treated.</para>
      <para>A 0 (zero) indicates that the corresponding entry in<i>VirtualAddresses</i> should be unmapped, and any nonzero value that it has should be mapped.</para>
      <para>If this parameter is <b>NULL</b>, then every address in the <i>VirtualAddresses</i> array is unmapped.</para>
      <para>The value in <i>NumberOfPages</i> indicates the size of the array.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is <b>TRUE</b>.</para>
      <para>If the function fails, the return value is <b>FALSE</b>, and the function does not map or unmap—partial or otherwise. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.MapViewOfFileExNuma">
    <summary>Maps a view of a file mapping into the address space of a calling process and specifies the NUMA node for the physical memory.</summary>
    <param name="hFileMappingObject">A handle to a file mapping object. The<see cref="CreateFileMappingNuma" /> and<see cref="OpenFileMapping" /> functions return this handle.</param>
    <param name="dwDesiredAccess">
      <para>The type of access to a file mapping object, which determines the page protection of the pages. This parameter can be one of the following values, or a bitwise OR combination of multiple values where appropriate.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_MAP_ALL_ACCESS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>A read/write view of the file is mapped. The file mapping object must have been created with <b>PAGE_READWRITE</b> or <b>PAGE_EXECUTE_READWRITE</b> protection.<para>When used with <b>MapViewOfFileExNuma</b>, <b>FILE_MAP_ALL_ACCESS</b> is equivalent to<b>FILE_MAP_WRITE</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_MAP_READ</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>A read-only view of the file is mapped. An attempt to write to the file view results in an access violation.<para>The file mapping object must have been created with <b>PAGE_READONLY</b>,<b>PAGE_READWRITE</b>, <b>PAGE_EXECUTE_READ</b>, or<b>PAGE_EXECUTE_READWRITE</b> protection.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_MAP_WRITE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>A read/write view of the file is mapped. The file mapping object must have been created with <b>PAGE_READWRITE</b> or <b>PAGE_EXECUTE_READWRITE</b> protection.<para>When used with <b>MapViewOfFileExNuma</b>,<code>(FILE_MAP_WRITE | FILE_MAP_READ)</code> is equivalent to <b>FILE_MAP_WRITE</b>.</para></description>
        </listheader>
      </list> <para>Using bitwise OR, you can combine the values above with these values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_MAP_COPY</b></term></listheader></list></description><description>A copy-on-write view of the file is mapped. The file mapping object must have been created with <b>PAGE_READONLY</b>, <b>PAGE_READ_EXECUTE</b>, <b>PAGE_WRITECOPY</b>, <b>PAGE_EXECUTE_WRITECOPY</b>, <b>PAGE_READWRITE</b>, or <b>PAGE_EXECUTE_READWRITE</b> protection.<para>When a process writes to a copy-on-write page, the system copies the original page to a new page that is private to the process. The new page is backed by the paging file. The protection of the new page changes from copy-on-write to read/write.</para><para>When copy-on-write access is specified, the system and process commit charge taken is for the entire view because the calling process can potentially write to every page in the view, making all pages private. The contents of the new page are never written back to the original file and are lost when the view is unmapped.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_MAP_EXECUTE</b></term></listheader></list></description><description>An executable view of the file is mapped (mapped memory can be run as code). The file mapping object must have been created with <b>PAGE_EXECUTE_READ</b>, <b>PAGE_EXECUTE_WRITECOPY</b>, or <b>PAGE_EXECUTE_READWRITE</b> protection.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_MAP_LARGE_PAGES</b></term></listheader></list></description><description>Starting with Windows 10, version 1703, this flag specifies that the view should be mapped using <a href="https://docs.microsoft.com//windows/desktop/Memory/large-page-support">large page support</a>. The size of the view must be a multiple of the size of a large page reported by the <see cref="GetLargePageMinimum" /> function, and the file-mapping object must have been created using the <b>SEC_LARGE_PAGES</b> option. If you provide a non-null value for <i>lpBaseAddress</i>, then the value must be a multiple of <b>GetLargePageMinimum</b>.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>FILE_MAP_TARGETS_INVALID</b></term></listheader></list></description><description>Sets all the locations in the mapped file as invalid targets for Control Flow Guard (CFG). This flag is similar to <b>PAGE_TARGETS_INVALID</b>. Use this flag in combination with the execute access right <b>FILE_MAP_EXECUTE</b>. Any indirect call to locations in those pages will fail CFG checks, and the process will be terminated. The default behavior for executable pages allocated is to be marked valid call targets for CFG.</description></listheader></list> <para>For file-mapping objects created with the <b>SEC_IMAGE</b> attribute, the<i>dwDesiredAccess</i> parameter has no effect, and should be set to any valid value such as<b>FILE_MAP_READ</b>.</para><para>For more information about access to file mapping objects, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</para></param>
    <param name="dwFileOffsetHigh">The high-order <b>DWORD</b> of the file offset where the view is to begin.</param>
    <param name="dwFileOffsetLow">The low-order <b>DWORD</b> of the file offset where the view is to begin. The combination of the high and low offsets must specify an offset within the file mapping. They must also match the memory allocation granularity of the system. That is, the offset must be a multiple of the allocation granularity. To obtain the memory allocation granularity of the system, use the<see cref="GetSystemInfo" /> function, which fills in the members of a <see cref="SYSTEM_INFO" /> structure.</param>
    <param name="dwNumberOfBytesToMap">The number of bytes of a file mapping to map to a view. All bytes must be within the maximum size specified by <see cref="CreateFileMapping" />. If this parameter is 0 (zero), the mapping extends from the specified offset to the end of the file mapping.</param>
    <param name="lpBaseAddress">
      <para>A pointer to the memory address in the calling process address space where mapping begins. This must be a multiple of the system's memory allocation granularity, or the function fails. To determine the memory allocation granularity of the system, use the<see cref="GetSystemInfo" /> function. If there is not enough address space at the specified address, the function fails.</para>
      <para>If the <i>lpBaseAddress</i> parameter is <b>NULL</b>, the operating system chooses the mapping address.</para>
      <para>While it is possible to specify an address that is safe now (not used by the operating system), there is no guarantee that the address will remain safe over time. Therefore, it is better to let the operating system choose the address. In this case, you would not store pointers in the memory mapped file; you would store offsets from the base of the file mapping so that the mapping can be used at any address.</para>
    </param>
    <param name="nndPreferred">
      <para>The NUMA node where the physical memory should reside.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NUMA_NO_PREFERRED_NODE</b>
                </term>
              </listheader>
              <listheader>
                <term>0xffffffff</term>
              </listheader>
            </list>
          </description>
          <description>No NUMA node is preferred. This is the same as calling the <see cref="MapViewOfFileEx" /> function.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the starting address of the mapped view.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call the <see cref="GetLastError" /> function.</para>
    </returns>
  </member>
  <member name="Windows.MoveFile">
    <summary>
      <para>Moves an existing file or a directory, including its children.</para>
      <para>To specify how to move the file, use the<see cref="MoveFileEx" /> or<see cref="MoveFileWithProgress" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name for the file or directory. The new name must not already exist. A new file may be on a different file system or drive. A new directory must be on the same drive.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.MoveFileA">
    <summary>
      <para>Moves an existing file or a directory, including its children.</para>
      <para>To specify how to move the file, use the<see cref="MoveFileEx" /> or<see cref="MoveFileWithProgress" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name for the file or directory. The new name must not already exist. A new file may be on a different file system or drive. A new directory must be on the same drive.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.MoveFileW">
    <summary>
      <para>Moves an existing file or a directory, including its children.</para>
      <para>To specify how to move the file, use the<see cref="MoveFileEx" /> or<see cref="MoveFileWithProgress" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name for the file or directory. The new name must not already exist. A new file may be on a different file system or drive. A new directory must be on the same drive.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.MoveFile">
    <summary>
      <para>Moves an existing file or a directory, including its children.</para>
      <para>To specify how to move the file, use the<see cref="MoveFileEx" /> or<see cref="MoveFileWithProgress" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name for the file or directory. The new name must not already exist. A new file may be on a different file system or drive. A new directory must be on the same drive.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.MoveFileA">
    <summary>
      <para>Moves an existing file or a directory, including its children.</para>
      <para>To specify how to move the file, use the<see cref="MoveFileEx" /> or<see cref="MoveFileWithProgress" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name for the file or directory. The new name must not already exist. A new file may be on a different file system or drive. A new directory must be on the same drive.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.MoveFileW">
    <summary>
      <para>Moves an existing file or a directory, including its children.</para>
      <para>To specify how to move the file, use the<see cref="MoveFileEx" /> or<see cref="MoveFileWithProgress" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name for the file or directory. The new name must not already exist. A new file may be on a different file system or drive. A new directory must be on the same drive.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.MoveFileEx">
    <summary>
      <para>Moves an existing file or directory, including its children, with various move options.</para>
      <para>The <see cref="MoveFileWithProgress" /> function is equivalent to the <b>MoveFileEx</b> function, except that<b>MoveFileWithProgress</b> allows you to provide a callback function that receives progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the file cannot exist on a remote share, because delayed operations are performed before the network is available.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory on the local computer.</para>
      <para>When moving a file, the destination can be on a different file system or volume. If the destination is on another drive, you must set the <b>MOVEFILE_COPY_ALLOWED</b> flag in<i>dwFlags</i>.</para>
      <para>When moving a directory, the destination must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and<i>lpNewFileName</i> is <b>NULL</b>,<b>MoveFileEx</b> registers the<i>lpExistingFileName</i> file to be deleted when the system restarts. If<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart only if the directory is empty.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </term>
              </listheader>
              <listheader>
                <term>2 (0x2)</term>
              </listheader>
            </list>
          </description>
          <description>If the file is to be moved to a different volume, the function simulates the move by using the <see cref="CopyFile" /> and <see cref="DeleteFile" /> functions.<para>If the file is successfully copied to a different volume and the original file is unable to be deleted, the function succeeds leaving the source file intact.</para><para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </term>
              </listheader>
              <listheader>
                <term>16 (0x10)</term>
              </listheader>
            </list>
          </description>
          <description>Reserved for future use.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </term>
              </listheader>
              <listheader>
                <term>4 (0x4)</term>
              </listheader>
            </list>
          </description>
          <description>The system does not move the file until the operating system is restarted. The system moves the file immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter enables the function to delete paging files from previous startups.<para>This value can be used only if the process is in the context of a user who belongs to the administrators group or the LocalSystem account.</para><para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>32 (0x20)</term>
              </listheader>
            </list>
          </description>
          <description>The function fails if the source file is a link source, but the file cannot be tracked after the move. This situation can occur if the destination is a volume formatted with the FAT file system.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </term>
              </listheader>
              <listheader>
                <term>1 (0x1)</term>
              </listheader>
            </list>
          </description>
          <description>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with the contents of the <i>lpExistingFileName</i> file, provided that security requirements regarding access control lists (ACLs) are met. For more information, see the Remarks section of this topic.<para>If <i>lpNewFileName</i> names an existing directory, an error is reported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </term>
              </listheader>
              <listheader>
                <term>8 (0x8)</term>
              </listheader>
            </list>
          </description>
          <description>The function does not return until the file is actually moved on the disk.<para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk before the function returns. The flush occurs at the end of the copy operation.</para><para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.MoveFileExA">
    <summary>
      <para>Moves an existing file or directory, including its children, with various move options.</para>
      <para>The <see cref="MoveFileWithProgress" /> function is equivalent to the <b>MoveFileEx</b> function, except that<b>MoveFileWithProgress</b> allows you to provide a callback function that receives progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the file cannot exist on a remote share, because delayed operations are performed before the network is available.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory on the local computer.</para>
      <para>When moving a file, the destination can be on a different file system or volume. If the destination is on another drive, you must set the <b>MOVEFILE_COPY_ALLOWED</b> flag in<i>dwFlags</i>.</para>
      <para>When moving a directory, the destination must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and<i>lpNewFileName</i> is <b>NULL</b>,<b>MoveFileEx</b> registers the<i>lpExistingFileName</i> file to be deleted when the system restarts. If<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart only if the directory is empty.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </term>
              </listheader>
              <listheader>
                <term>2 (0x2)</term>
              </listheader>
            </list>
          </description>
          <description>If the file is to be moved to a different volume, the function simulates the move by using the <see cref="CopyFile" /> and <see cref="DeleteFile" /> functions.<para>If the file is successfully copied to a different volume and the original file is unable to be deleted, the function succeeds leaving the source file intact.</para><para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </term>
              </listheader>
              <listheader>
                <term>16 (0x10)</term>
              </listheader>
            </list>
          </description>
          <description>Reserved for future use.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </term>
              </listheader>
              <listheader>
                <term>4 (0x4)</term>
              </listheader>
            </list>
          </description>
          <description>The system does not move the file until the operating system is restarted. The system moves the file immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter enables the function to delete paging files from previous startups.<para>This value can be used only if the process is in the context of a user who belongs to the administrators group or the LocalSystem account.</para><para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>32 (0x20)</term>
              </listheader>
            </list>
          </description>
          <description>The function fails if the source file is a link source, but the file cannot be tracked after the move. This situation can occur if the destination is a volume formatted with the FAT file system.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </term>
              </listheader>
              <listheader>
                <term>1 (0x1)</term>
              </listheader>
            </list>
          </description>
          <description>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with the contents of the <i>lpExistingFileName</i> file, provided that security requirements regarding access control lists (ACLs) are met. For more information, see the Remarks section of this topic.<para>If <i>lpNewFileName</i> names an existing directory, an error is reported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </term>
              </listheader>
              <listheader>
                <term>8 (0x8)</term>
              </listheader>
            </list>
          </description>
          <description>The function does not return until the file is actually moved on the disk.<para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk before the function returns. The flush occurs at the end of the copy operation.</para><para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.MoveFileExW">
    <summary>
      <para>Moves an existing file or directory, including its children, with various move options.</para>
      <para>The <see cref="MoveFileWithProgress" /> function is equivalent to the <b>MoveFileEx</b> function, except that<b>MoveFileWithProgress</b> allows you to provide a callback function that receives progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the file cannot exist on a remote share, because delayed operations are performed before the network is available.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory on the local computer.</para>
      <para>When moving a file, the destination can be on a different file system or volume. If the destination is on another drive, you must set the <b>MOVEFILE_COPY_ALLOWED</b> flag in<i>dwFlags</i>.</para>
      <para>When moving a directory, the destination must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and<i>lpNewFileName</i> is <b>NULL</b>,<b>MoveFileEx</b> registers the<i>lpExistingFileName</i> file to be deleted when the system restarts. If<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart only if the directory is empty.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </term>
              </listheader>
              <listheader>
                <term>2 (0x2)</term>
              </listheader>
            </list>
          </description>
          <description>If the file is to be moved to a different volume, the function simulates the move by using the <see cref="CopyFile" /> and <see cref="DeleteFile" /> functions.<para>If the file is successfully copied to a different volume and the original file is unable to be deleted, the function succeeds leaving the source file intact.</para><para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </term>
              </listheader>
              <listheader>
                <term>16 (0x10)</term>
              </listheader>
            </list>
          </description>
          <description>Reserved for future use.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </term>
              </listheader>
              <listheader>
                <term>4 (0x4)</term>
              </listheader>
            </list>
          </description>
          <description>The system does not move the file until the operating system is restarted. The system moves the file immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter enables the function to delete paging files from previous startups.<para>This value can be used only if the process is in the context of a user who belongs to the administrators group or the LocalSystem account.</para><para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>32 (0x20)</term>
              </listheader>
            </list>
          </description>
          <description>The function fails if the source file is a link source, but the file cannot be tracked after the move. This situation can occur if the destination is a volume formatted with the FAT file system.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </term>
              </listheader>
              <listheader>
                <term>1 (0x1)</term>
              </listheader>
            </list>
          </description>
          <description>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with the contents of the <i>lpExistingFileName</i> file, provided that security requirements regarding access control lists (ACLs) are met. For more information, see the Remarks section of this topic.<para>If <i>lpNewFileName</i> names an existing directory, an error is reported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </term>
              </listheader>
              <listheader>
                <term>8 (0x8)</term>
              </listheader>
            </list>
          </description>
          <description>The function does not return until the file is actually moved on the disk.<para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk before the function returns. The flush occurs at the end of the copy operation.</para><para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.MoveFileEx">
    <summary>
      <para>Moves an existing file or directory, including its children, with various move options.</para>
      <para>The <see cref="MoveFileWithProgress" /> function is equivalent to the <b>MoveFileEx</b> function, except that<b>MoveFileWithProgress</b> allows you to provide a callback function that receives progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the file cannot exist on a remote share, because delayed operations are performed before the network is available.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory on the local computer.</para>
      <para>When moving a file, the destination can be on a different file system or volume. If the destination is on another drive, you must set the <b>MOVEFILE_COPY_ALLOWED</b> flag in<i>dwFlags</i>.</para>
      <para>When moving a directory, the destination must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and<i>lpNewFileName</i> is <b>NULL</b>,<b>MoveFileEx</b> registers the<i>lpExistingFileName</i> file to be deleted when the system restarts. If<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart only if the directory is empty.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\?" to the path. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </term>
              </listheader>
              <listheader>
                <term>2 (0x2)</term>
              </listheader>
            </list>
          </description>
          <description>If the file is to be moved to a different volume, the function simulates the move by using the <see cref="CopyFile" /> and <see cref="DeleteFile" /> functions.<para>If the file is successfully copied to a different volume and the original file is unable to be deleted, the function succeeds leaving the source file intact.</para><para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </term>
              </listheader>
              <listheader>
                <term>16 (0x10)</term>
              </listheader>
            </list>
          </description>
          <description>Reserved for future use.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </term>
              </listheader>
              <listheader>
                <term>4 (0x4)</term>
              </listheader>
            </list>
          </description>
          <description>The system does not move the file until the operating system is restarted. The system moves the file immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter enables the function to delete paging files from previous startups.<para>This value can be used only if the process is in the context of a user who belongs to the administrators group or the LocalSystem account.</para><para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>32 (0x20)</term>
              </listheader>
            </list>
          </description>
          <description>The function fails if the source file is a link source, but the file cannot be tracked after the move. This situation can occur if the destination is a volume formatted with the FAT file system.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </term>
              </listheader>
              <listheader>
                <term>1 (0x1)</term>
              </listheader>
            </list>
          </description>
          <description>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with the contents of the <i>lpExistingFileName</i> file, provided that security requirements regarding access control lists (ACLs) are met. For more information, see the Remarks section of this topic.<para>If <i>lpNewFileName</i> names an existing directory, an error is reported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </term>
              </listheader>
              <listheader>
                <term>8 (0x8)</term>
              </listheader>
            </list>
          </description>
          <description>The function does not return until the file is actually moved on the disk.<para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk before the function returns. The flush occurs at the end of the copy operation.</para><para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.MoveFileExA">
    <summary>
      <para>Moves an existing file or directory, including its children, with various move options.</para>
      <para>The <see cref="MoveFileWithProgress" /> function is equivalent to the <b>MoveFileEx</b> function, except that<b>MoveFileWithProgress</b> allows you to provide a callback function that receives progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the file cannot exist on a remote share, because delayed operations are performed before the network is available.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory on the local computer.</para>
      <para>When moving a file, the destination can be on a different file system or volume. If the destination is on another drive, you must set the <b>MOVEFILE_COPY_ALLOWED</b> flag in<i>dwFlags</i>.</para>
      <para>When moving a directory, the destination must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and<i>lpNewFileName</i> is <b>NULL</b>,<b>MoveFileEx</b> registers the<i>lpExistingFileName</i> file to be deleted when the system restarts. If<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart only if the directory is empty.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\?" to the path. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </term>
              </listheader>
              <listheader>
                <term>2 (0x2)</term>
              </listheader>
            </list>
          </description>
          <description>If the file is to be moved to a different volume, the function simulates the move by using the <see cref="CopyFile" /> and <see cref="DeleteFile" /> functions.<para>If the file is successfully copied to a different volume and the original file is unable to be deleted, the function succeeds leaving the source file intact.</para><para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </term>
              </listheader>
              <listheader>
                <term>16 (0x10)</term>
              </listheader>
            </list>
          </description>
          <description>Reserved for future use.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </term>
              </listheader>
              <listheader>
                <term>4 (0x4)</term>
              </listheader>
            </list>
          </description>
          <description>The system does not move the file until the operating system is restarted. The system moves the file immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter enables the function to delete paging files from previous startups.<para>This value can be used only if the process is in the context of a user who belongs to the administrators group or the LocalSystem account.</para><para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>32 (0x20)</term>
              </listheader>
            </list>
          </description>
          <description>The function fails if the source file is a link source, but the file cannot be tracked after the move. This situation can occur if the destination is a volume formatted with the FAT file system.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </term>
              </listheader>
              <listheader>
                <term>1 (0x1)</term>
              </listheader>
            </list>
          </description>
          <description>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with the contents of the <i>lpExistingFileName</i> file, provided that security requirements regarding access control lists (ACLs) are met. For more information, see the Remarks section of this topic.<para>If <i>lpNewFileName</i> names an existing directory, an error is reported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </term>
              </listheader>
              <listheader>
                <term>8 (0x8)</term>
              </listheader>
            </list>
          </description>
          <description>The function does not return until the file is actually moved on the disk.<para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk before the function returns. The flush occurs at the end of the copy operation.</para><para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.MoveFileExW">
    <summary>
      <para>Moves an existing file or directory, including its children, with various move options.</para>
      <para>The <see cref="MoveFileWithProgress" /> function is equivalent to the <b>MoveFileEx</b> function, except that<b>MoveFileWithProgress</b> allows you to provide a callback function that receives progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the file cannot exist on a remote share, because delayed operations are performed before the network is available.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory on the local computer.</para>
      <para>When moving a file, the destination can be on a different file system or volume. If the destination is on another drive, you must set the <b>MOVEFILE_COPY_ALLOWED</b> flag in<i>dwFlags</i>.</para>
      <para>When moving a directory, the destination must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and<i>lpNewFileName</i> is <b>NULL</b>,<b>MoveFileEx</b> registers the<i>lpExistingFileName</i> file to be deleted when the system restarts. If<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart only if the directory is empty.</para>
      <para>In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\?" to the path. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">Naming a File</a></para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </term>
              </listheader>
              <listheader>
                <term>2 (0x2)</term>
              </listheader>
            </list>
          </description>
          <description>If the file is to be moved to a different volume, the function simulates the move by using the <see cref="CopyFile" /> and <see cref="DeleteFile" /> functions.<para>If the file is successfully copied to a different volume and the original file is unable to be deleted, the function succeeds leaving the source file intact.</para><para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </term>
              </listheader>
              <listheader>
                <term>16 (0x10)</term>
              </listheader>
            </list>
          </description>
          <description>Reserved for future use.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </term>
              </listheader>
              <listheader>
                <term>4 (0x4)</term>
              </listheader>
            </list>
          </description>
          <description>The system does not move the file until the operating system is restarted. The system moves the file immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter enables the function to delete paging files from previous startups.<para>This value can be used only if the process is in the context of a user who belongs to the administrators group or the LocalSystem account.</para><para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>32 (0x20)</term>
              </listheader>
            </list>
          </description>
          <description>The function fails if the source file is a link source, but the file cannot be tracked after the move. This situation can occur if the destination is a volume formatted with the FAT file system.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </term>
              </listheader>
              <listheader>
                <term>1 (0x1)</term>
              </listheader>
            </list>
          </description>
          <description>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with the contents of the <i>lpExistingFileName</i> file, provided that security requirements regarding access control lists (ACLs) are met. For more information, see the Remarks section of this topic.<para>If <i>lpNewFileName</i> names an existing directory, an error is reported.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </term>
              </listheader>
              <listheader>
                <term>8 (0x8)</term>
              </listheader>
            </list>
          </description>
          <description>The function does not return until the file is actually moved on the disk.<para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk before the function returns. The flush occurs at the end of the copy operation.</para><para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero (0). To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.MoveFile">
    <summary>
      <para>Moves an existing file or a directory, including its children.</para>
      <para>To specify how to move the file, use the<see cref="MoveFileEx" /> or<see cref="MoveFileWithProgress" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name for the file or directory. The new name must not already exist. A new file may be on a different file system or drive. A new directory must be on the same drive.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.MoveFileA">
    <summary>
      <para>Moves an existing file or a directory, including its children.</para>
      <para>To specify how to move the file, use the<see cref="MoveFileEx" /> or<see cref="MoveFileWithProgress" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name for the file or directory. The new name must not already exist. A new file may be on a different file system or drive. A new directory must be on the same drive.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.MoveFileW">
    <summary>
      <para>Moves an existing file or a directory, including its children.</para>
      <para>To specify how to move the file, use the<see cref="MoveFileEx" /> or<see cref="MoveFileWithProgress" /> function.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The current name of the file or directory on the local computer.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name for the file or directory. The new name must not already exist. A new file may be on a different file system or drive. A new directory must be on the same drive.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.MoveFileWithProgress">
    <summary>
      <para>Moves a file or directory, including its children. You can provide a callback function that receives progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of the existing file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the file cannot exist on a remote share because delayed operations are performed before the network is available.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory on the local computer.</para>
      <para>When moving a file, <i>lpNewFileName</i> can be on a different file system or volume. If<i>lpNewFileName</i> is on another drive, you must set the<b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>.</para>
      <para>When moving a directory, <i>lpExistingFileName</i> and<i>lpNewFileName</i> must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and<i>lpNewFileName</i> is <b>NULL</b>,<b>MoveFileWithProgress</b> registers<i>lpExistingFileName</i> to be deleted when the system restarts. The function fails if it cannot access the registry to store the information about the delete operation. If<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart only if the directory is empty.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpProgressRoutine">A pointer to a <a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function that is called each time another portion of the file has been moved. The callback function can be useful if you provide a user interface that displays the progress of the operation. This parameter can be<b>NULL</b>.</param>
    <param name="lpData">An argument to be passed to the<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This parameter can be <b>NULL</b>.</param>
    <param name="dwFlags">
      <para>The move options. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </term>
              </listheader>
              <listheader>
                <term>2 (0x2)</term>
              </listheader>
            </list>
          </description>
          <description>If the file is to be moved to a different volume, the function simulates the move by using the <see cref="CopyFile" /> and <see cref="DeleteFile" /> functions.<para>If the file is successfully copied to a different volume and the original file is unable to be deleted, the function succeeds leaving the source file intact.</para><para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </term>
              </listheader>
              <listheader>
                <term>16 (0x10)</term>
              </listheader>
            </list>
          </description>
          <description>Reserved for future use.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </term>
              </listheader>
              <listheader>
                <term>4 (0x4)</term>
              </listheader>
            </list>
          </description>
          <description>The system does not move the file until the operating system is restarted. The system moves the file immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter enables the function to delete paging files from previous startups.<para>This value can only be used if the process is in the context of a user who belongs to the administrators group or the LocalSystem account.</para><para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>32 (0x20)</term>
              </listheader>
            </list>
          </description>
          <description>The function fails if the source file is a link source, but the file cannot be tracked after the move. This situation can occur if the destination is a volume formatted with the FAT file system.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </term>
              </listheader>
              <listheader>
                <term>1 (0x1)</term>
              </listheader>
            </list>
          </description>
          <description>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with the contents of the <i>lpExistingFileName</i> file.<para>This value cannot be used if <i>lpNewFileName</i> or<i>lpExistingFileName</i> names a directory.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </term>
              </listheader>
              <listheader>
                <term>8 (0x8)</term>
              </listheader>
            </list>
          </description>
          <description>The function does not return until the file has actually been moved on the disk.<para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk before the function returns. The flush occurs at the end of the copy operation.</para><para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns<b>PROGRESS_CANCEL</b> due to the user canceling the operation,<b>MoveFileWithProgress</b> will return zero and<see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns<b>PROGRESS_STOP</b> due to the user stopping the operation,<b>MoveFileWithProgress</b> will return zero and<see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
    </returns>
  </member>
  <member name="Windows.MoveFileWithProgressA">
    <summary>
      <para>Moves a file or directory, including its children. You can provide a callback function that receives progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of the existing file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the file cannot exist on a remote share because delayed operations are performed before the network is available.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory on the local computer.</para>
      <para>When moving a file, <i>lpNewFileName</i> can be on a different file system or volume. If<i>lpNewFileName</i> is on another drive, you must set the<b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>.</para>
      <para>When moving a directory, <i>lpExistingFileName</i> and<i>lpNewFileName</i> must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and<i>lpNewFileName</i> is <b>NULL</b>,<b>MoveFileWithProgress</b> registers<i>lpExistingFileName</i> to be deleted when the system restarts. The function fails if it cannot access the registry to store the information about the delete operation. If<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart only if the directory is empty.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpProgressRoutine">A pointer to a <a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function that is called each time another portion of the file has been moved. The callback function can be useful if you provide a user interface that displays the progress of the operation. This parameter can be<b>NULL</b>.</param>
    <param name="lpData">An argument to be passed to the<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This parameter can be <b>NULL</b>.</param>
    <param name="dwFlags">
      <para>The move options. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </term>
              </listheader>
              <listheader>
                <term>2 (0x2)</term>
              </listheader>
            </list>
          </description>
          <description>If the file is to be moved to a different volume, the function simulates the move by using the <see cref="CopyFile" /> and <see cref="DeleteFile" /> functions.<para>If the file is successfully copied to a different volume and the original file is unable to be deleted, the function succeeds leaving the source file intact.</para><para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </term>
              </listheader>
              <listheader>
                <term>16 (0x10)</term>
              </listheader>
            </list>
          </description>
          <description>Reserved for future use.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </term>
              </listheader>
              <listheader>
                <term>4 (0x4)</term>
              </listheader>
            </list>
          </description>
          <description>The system does not move the file until the operating system is restarted. The system moves the file immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter enables the function to delete paging files from previous startups.<para>This value can only be used if the process is in the context of a user who belongs to the administrators group or the LocalSystem account.</para><para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>32 (0x20)</term>
              </listheader>
            </list>
          </description>
          <description>The function fails if the source file is a link source, but the file cannot be tracked after the move. This situation can occur if the destination is a volume formatted with the FAT file system.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </term>
              </listheader>
              <listheader>
                <term>1 (0x1)</term>
              </listheader>
            </list>
          </description>
          <description>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with the contents of the <i>lpExistingFileName</i> file.<para>This value cannot be used if <i>lpNewFileName</i> or<i>lpExistingFileName</i> names a directory.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </term>
              </listheader>
              <listheader>
                <term>8 (0x8)</term>
              </listheader>
            </list>
          </description>
          <description>The function does not return until the file has actually been moved on the disk.<para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk before the function returns. The flush occurs at the end of the copy operation.</para><para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns<b>PROGRESS_CANCEL</b> due to the user canceling the operation,<b>MoveFileWithProgress</b> will return zero and<see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns<b>PROGRESS_STOP</b> due to the user stopping the operation,<b>MoveFileWithProgress</b> will return zero and<see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
    </returns>
  </member>
  <member name="Windows.MoveFileWithProgressW">
    <summary>
      <para>Moves a file or directory, including its children. You can provide a callback function that receives progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of the existing file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the file cannot exist on a remote share because delayed operations are performed before the network is available.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory on the local computer.</para>
      <para>When moving a file, <i>lpNewFileName</i> can be on a different file system or volume. If<i>lpNewFileName</i> is on another drive, you must set the<b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>.</para>
      <para>When moving a directory, <i>lpExistingFileName</i> and<i>lpNewFileName</i> must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and<i>lpNewFileName</i> is <b>NULL</b>,<b>MoveFileWithProgress</b> registers<i>lpExistingFileName</i> to be deleted when the system restarts. The function fails if it cannot access the registry to store the information about the delete operation. If<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart only if the directory is empty.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpProgressRoutine">A pointer to a <a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function that is called each time another portion of the file has been moved. The callback function can be useful if you provide a user interface that displays the progress of the operation. This parameter can be<b>NULL</b>.</param>
    <param name="lpData">An argument to be passed to the<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This parameter can be <b>NULL</b>.</param>
    <param name="dwFlags">
      <para>The move options. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </term>
              </listheader>
              <listheader>
                <term>2 (0x2)</term>
              </listheader>
            </list>
          </description>
          <description>If the file is to be moved to a different volume, the function simulates the move by using the <see cref="CopyFile" /> and <see cref="DeleteFile" /> functions.<para>If the file is successfully copied to a different volume and the original file is unable to be deleted, the function succeeds leaving the source file intact.</para><para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </term>
              </listheader>
              <listheader>
                <term>16 (0x10)</term>
              </listheader>
            </list>
          </description>
          <description>Reserved for future use.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </term>
              </listheader>
              <listheader>
                <term>4 (0x4)</term>
              </listheader>
            </list>
          </description>
          <description>The system does not move the file until the operating system is restarted. The system moves the file immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter enables the function to delete paging files from previous startups.<para>This value can only be used if the process is in the context of a user who belongs to the administrators group or the LocalSystem account.</para><para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>32 (0x20)</term>
              </listheader>
            </list>
          </description>
          <description>The function fails if the source file is a link source, but the file cannot be tracked after the move. This situation can occur if the destination is a volume formatted with the FAT file system.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </term>
              </listheader>
              <listheader>
                <term>1 (0x1)</term>
              </listheader>
            </list>
          </description>
          <description>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with the contents of the <i>lpExistingFileName</i> file.<para>This value cannot be used if <i>lpNewFileName</i> or<i>lpExistingFileName</i> names a directory.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </term>
              </listheader>
              <listheader>
                <term>8 (0x8)</term>
              </listheader>
            </list>
          </description>
          <description>The function does not return until the file has actually been moved on the disk.<para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk before the function returns. The flush occurs at the end of the copy operation.</para><para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns<b>PROGRESS_CANCEL</b> due to the user canceling the operation,<b>MoveFileWithProgress</b> will return zero and<see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns<b>PROGRESS_STOP</b> due to the user stopping the operation,<b>MoveFileWithProgress</b> will return zero and<see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
    </returns>
  </member>
  <member name="Windows.MoveFileWithProgress">
    <summary>
      <para>Moves a file or directory, including its children. You can provide a callback function that receives progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of the existing file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the file cannot exist on a remote share because delayed operations are performed before the network is available.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory on the local computer.</para>
      <para>When moving a file, <i>lpNewFileName</i> can be on a different file system or volume. If<i>lpNewFileName</i> is on another drive, you must set the<b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>.</para>
      <para>When moving a directory, <i>lpExistingFileName</i> and<i>lpNewFileName</i> must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and<i>lpNewFileName</i> is <b>NULL</b>,<b>MoveFileWithProgress</b> registers<i>lpExistingFileName</i> to be deleted when the system restarts. The function fails if it cannot access the registry to store the information about the delete operation. If<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart only if the directory is empty.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpProgressRoutine">A pointer to a <a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function that is called each time another portion of the file has been moved. The callback function can be useful if you provide a user interface that displays the progress of the operation. This parameter can be<b>NULL</b>.</param>
    <param name="lpData">An argument to be passed to the<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This parameter can be <b>NULL</b>.</param>
    <param name="dwFlags">
      <para>The move options. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </term>
              </listheader>
              <listheader>
                <term>2 (0x2)</term>
              </listheader>
            </list>
          </description>
          <description>If the file is to be moved to a different volume, the function simulates the move by using the <see cref="CopyFile" /> and <see cref="DeleteFile" /> functions.<para>If the file is successfully copied to a different volume and the original file is unable to be deleted, the function succeeds leaving the source file intact.</para><para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </term>
              </listheader>
              <listheader>
                <term>16 (0x10)</term>
              </listheader>
            </list>
          </description>
          <description>Reserved for future use.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </term>
              </listheader>
              <listheader>
                <term>4 (0x4)</term>
              </listheader>
            </list>
          </description>
          <description>The system does not move the file until the operating system is restarted. The system moves the file immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter enables the function to delete paging files from previous startups.<para>This value can only be used if the process is in the context of a user who belongs to the administrators group or the LocalSystem account.</para><para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>32 (0x20)</term>
              </listheader>
            </list>
          </description>
          <description>The function fails if the source file is a link source, but the file cannot be tracked after the move. This situation can occur if the destination is a volume formatted with the FAT file system.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </term>
              </listheader>
              <listheader>
                <term>1 (0x1)</term>
              </listheader>
            </list>
          </description>
          <description>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with the contents of the <i>lpExistingFileName</i> file.<para>This value cannot be used if <i>lpNewFileName</i> or<i>lpExistingFileName</i> names a directory.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </term>
              </listheader>
              <listheader>
                <term>8 (0x8)</term>
              </listheader>
            </list>
          </description>
          <description>The function does not return until the file has actually been moved on the disk.<para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk before the function returns. The flush occurs at the end of the copy operation.</para><para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns<b>PROGRESS_CANCEL</b> due to the user canceling the operation,<b>MoveFileWithProgress</b> will return zero and<see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns<b>PROGRESS_STOP</b> due to the user stopping the operation,<b>MoveFileWithProgress</b> will return zero and<see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
    </returns>
  </member>
  <member name="Windows.MoveFileWithProgressA">
    <summary>
      <para>Moves a file or directory, including its children. You can provide a callback function that receives progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of the existing file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the file cannot exist on a remote share because delayed operations are performed before the network is available.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory on the local computer.</para>
      <para>When moving a file, <i>lpNewFileName</i> can be on a different file system or volume. If<i>lpNewFileName</i> is on another drive, you must set the<b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>.</para>
      <para>When moving a directory, <i>lpExistingFileName</i> and<i>lpNewFileName</i> must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and<i>lpNewFileName</i> is <b>NULL</b>,<b>MoveFileWithProgress</b> registers<i>lpExistingFileName</i> to be deleted when the system restarts. The function fails if it cannot access the registry to store the information about the delete operation. If<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart only if the directory is empty.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpProgressRoutine">A pointer to a <a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function that is called each time another portion of the file has been moved. The callback function can be useful if you provide a user interface that displays the progress of the operation. This parameter can be<b>NULL</b>.</param>
    <param name="lpData">An argument to be passed to the<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This parameter can be <b>NULL</b>.</param>
    <param name="dwFlags">
      <para>The move options. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </term>
              </listheader>
              <listheader>
                <term>2 (0x2)</term>
              </listheader>
            </list>
          </description>
          <description>If the file is to be moved to a different volume, the function simulates the move by using the <see cref="CopyFile" /> and <see cref="DeleteFile" /> functions.<para>If the file is successfully copied to a different volume and the original file is unable to be deleted, the function succeeds leaving the source file intact.</para><para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </term>
              </listheader>
              <listheader>
                <term>16 (0x10)</term>
              </listheader>
            </list>
          </description>
          <description>Reserved for future use.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </term>
              </listheader>
              <listheader>
                <term>4 (0x4)</term>
              </listheader>
            </list>
          </description>
          <description>The system does not move the file until the operating system is restarted. The system moves the file immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter enables the function to delete paging files from previous startups.<para>This value can only be used if the process is in the context of a user who belongs to the administrators group or the LocalSystem account.</para><para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>32 (0x20)</term>
              </listheader>
            </list>
          </description>
          <description>The function fails if the source file is a link source, but the file cannot be tracked after the move. This situation can occur if the destination is a volume formatted with the FAT file system.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </term>
              </listheader>
              <listheader>
                <term>1 (0x1)</term>
              </listheader>
            </list>
          </description>
          <description>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with the contents of the <i>lpExistingFileName</i> file.<para>This value cannot be used if <i>lpNewFileName</i> or<i>lpExistingFileName</i> names a directory.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </term>
              </listheader>
              <listheader>
                <term>8 (0x8)</term>
              </listheader>
            </list>
          </description>
          <description>The function does not return until the file has actually been moved on the disk.<para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk before the function returns. The flush occurs at the end of the copy operation.</para><para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns<b>PROGRESS_CANCEL</b> due to the user canceling the operation,<b>MoveFileWithProgress</b> will return zero and<see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns<b>PROGRESS_STOP</b> due to the user stopping the operation,<b>MoveFileWithProgress</b> will return zero and<see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
    </returns>
  </member>
  <member name="Windows.MoveFileWithProgressW">
    <summary>
      <para>Moves a file or directory, including its children. You can provide a callback function that receives progress notifications.</para>
      <para>To perform this operation as a transacted operation, use the<see cref="MoveFileTransacted" /> function.</para>
    </summary>
    <param name="lpExistingFileName">
      <para>The name of the existing file or directory on the local computer.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the file cannot exist on a remote share because delayed operations are performed before the network is available.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpNewFileName">
      <para>The new name of the file or directory on the local computer.</para>
      <para>When moving a file, <i>lpNewFileName</i> can be on a different file system or volume. If<i>lpNewFileName</i> is on another drive, you must set the<b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>.</para>
      <para>When moving a directory, <i>lpExistingFileName</i> and<i>lpNewFileName</i> must be on the same drive.</para>
      <para>If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and<i>lpNewFileName</i> is <b>NULL</b>,<b>MoveFileWithProgress</b> registers<i>lpExistingFileName</i> to be deleted when the system restarts. The function fails if it cannot access the registry to store the information about the delete operation. If<i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart only if the directory is empty.</para>
      <para>By default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a>.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
    </param>
    <param name="lpProgressRoutine">A pointer to a <a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function that is called each time another portion of the file has been moved. The callback function can be useful if you provide a user interface that displays the progress of the operation. This parameter can be<b>NULL</b>.</param>
    <param name="lpData">An argument to be passed to the<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This parameter can be <b>NULL</b>.</param>
    <param name="dwFlags">
      <para>The move options. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_COPY_ALLOWED</b>
                </term>
              </listheader>
              <listheader>
                <term>2 (0x2)</term>
              </listheader>
            </list>
          </description>
          <description>If the file is to be moved to a different volume, the function simulates the move by using the <see cref="CopyFile" /> and <see cref="DeleteFile" /> functions.<para>If the file is successfully copied to a different volume and the original file is unable to be deleted, the function succeeds leaving the source file intact.</para><para>This value cannot be used with <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_CREATE_HARDLINK</b>
                </term>
              </listheader>
              <listheader>
                <term>16 (0x10)</term>
              </listheader>
            </list>
          </description>
          <description>Reserved for future use.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
                </term>
              </listheader>
              <listheader>
                <term>4 (0x4)</term>
              </listheader>
            </list>
          </description>
          <description>The system does not move the file until the operating system is restarted. The system moves the file immediately after AUTOCHK is executed, but before creating any paging files. Consequently, this parameter enables the function to delete paging files from previous startups.<para>This value can only be used if the process is in the context of a user who belongs to the administrators group or the LocalSystem account.</para><para>This value cannot be used with <b>MOVEFILE_COPY_ALLOWED</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>32 (0x20)</term>
              </listheader>
            </list>
          </description>
          <description>The function fails if the source file is a link source, but the file cannot be tracked after the move. This situation can occur if the destination is a volume formatted with the FAT file system.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_REPLACE_EXISTING</b>
                </term>
              </listheader>
              <listheader>
                <term>1 (0x1)</term>
              </listheader>
            </list>
          </description>
          <description>If a file named <i>lpNewFileName</i> exists, the function replaces its contents with the contents of the <i>lpExistingFileName</i> file.<para>This value cannot be used if <i>lpNewFileName</i> or<i>lpExistingFileName</i> names a directory.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MOVEFILE_WRITE_THROUGH</b>
                </term>
              </listheader>
              <listheader>
                <term>8 (0x8)</term>
              </listheader>
            </list>
          </description>
          <description>The function does not return until the file has actually been moved on the disk.<para>Setting this value guarantees that a move performed as a copy and delete operation is flushed to disk before the function returns. The flush occurs at the end of the copy operation.</para><para>This value has no effect if <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> is set.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns<b>PROGRESS_CANCEL</b> due to the user canceling the operation,<b>MoveFileWithProgress</b> will return zero and<see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
      <para>When moving a file across volumes, if <i>lpProgressRoutine</i> returns<b>PROGRESS_STOP</b> due to the user stopping the operation,<b>MoveFileWithProgress</b> will return zero and<see cref="GetLastError" /> will return<b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.</para>
    </returns>
  </member>
  <member name="Windows.MulDiv">
    <summary>Multiplies two 32-bit values and then divides the 64-bit result by a third 32-bit value. The final result is rounded to the nearest integer.</summary>
    <param name="nNumber">The multiplicand.</param>
    <param name="nNumerator">The multiplier.</param>
    <param name="nDenominator">The number by which the result of the multiplication operation is to be divided.</param>
    <returns>
      <para>If the function succeeds, the return value is the result of the multiplication and division, rounded to the nearest integer. If the result is a positive half integer (ends in .5), it is rounded up. If the result is a negative half integer, it is rounded down.</para>
      <para>If either an overflow occurred or <i>nDenominator</i> was 0, the return value is -1.</para>
    </returns>
  </member>
  <member name="Windows.NotifyChangeEventLog">
    <summary>Enables an application to receive notification when an event is written to the specified event log. When the event is written to the log, the specified event object is set to the signaled state.</summary>
    <param name="hEventLog">A handle to an event log. The<see cref="OpenEventLog" /> function returns this handle.</param>
    <param name="hEvent">A handle to a manual-reset or auto-reset event object. Use the<see cref="CreateEvent" /> function to create the event object.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ObjectCloseAuditAlarm">
    <summary>The <b>ObjectCloseAuditAlarm</b> function generates an audit message in the security event log when a handle to a private object is deleted. Alarms are not currently supported.</summary>
    <param name="SubsystemName">A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">A unique value representing the client's handle to the object. This should be the same value that was passed to the<see cref="AccessCheckAndAuditAlarm" /> or <see cref="ObjectOpenAuditAlarm" /> function.</param>
    <param name="GenerateOnClose">Specifies a flag set by a call to the <see cref="AccessCheckAndAuditAlarm" /> or <b>ObjectCloseAuditAlarm</b> function when the object handle is created. If this flag is <b>TRUE</b>, the function generates an audit message. If it is <b>FALSE</b>, the function does not generate an audit message.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ObjectCloseAuditAlarmA">
    <summary>The <b>ObjectCloseAuditAlarm</b> function generates an audit message in the security event log when a handle to a private object is deleted. Alarms are not currently supported.</summary>
    <param name="SubsystemName">A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">A unique value representing the client's handle to the object. This should be the same value that was passed to the<see cref="AccessCheckAndAuditAlarm" /> or <see cref="ObjectOpenAuditAlarm" /> function.</param>
    <param name="GenerateOnClose">Specifies a flag set by a call to the <see cref="AccessCheckAndAuditAlarm" /> or <b>ObjectCloseAuditAlarm</b> function when the object handle is created. If this flag is <b>TRUE</b>, the function generates an audit message. If it is <b>FALSE</b>, the function does not generate an audit message.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ObjectCloseAuditAlarmW">
    <summary>The <b>ObjectCloseAuditAlarm</b> function generates an audit message in the security event log when a handle to a private object is deleted. Alarms are not currently supported.</summary>
    <param name="SubsystemName">A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">A unique value representing the client's handle to the object. This should be the same value that was passed to the<see cref="AccessCheckAndAuditAlarm" /> or <see cref="ObjectOpenAuditAlarm" /> function.</param>
    <param name="GenerateOnClose">Specifies a flag set by a call to the <see cref="AccessCheckAndAuditAlarm" /> or <b>ObjectCloseAuditAlarm</b> function when the object handle is created. If this flag is <b>TRUE</b>, the function generates an audit message. If it is <b>FALSE</b>, the function does not generate an audit message.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ObjectDeleteAuditAlarm">
    <summary>The <b>ObjectDeleteAuditAlarm</b> function generates audit messages when an object is deleted. Alarms are not currently supported.</summary>
    <param name="SubsystemName">A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">Specifies a unique value representing the client's handle to the object. This must be the same value that was passed to the<see cref="AccessCheckAndAuditAlarm" /> or<see cref="ObjectOpenAuditAlarm" /> function.</param>
    <param name="GenerateOnClose">Specifies a flag set by a call to the<see cref="AccessCheckAndAuditAlarm" /> or<see cref="ObjectOpenAuditAlarm" /> function when the object handle is created.</param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ObjectDeleteAuditAlarmA">
    <summary>The <b>ObjectDeleteAuditAlarm</b> function generates audit messages when an object is deleted. Alarms are not currently supported.</summary>
    <param name="SubsystemName">A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">Specifies a unique value representing the client's handle to the object. This must be the same value that was passed to the<see cref="AccessCheckAndAuditAlarm" /> or<see cref="ObjectOpenAuditAlarm" /> function.</param>
    <param name="GenerateOnClose">Specifies a flag set by a call to the<see cref="AccessCheckAndAuditAlarm" /> or<see cref="ObjectOpenAuditAlarm" /> function when the object handle is created.</param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ObjectDeleteAuditAlarmW">
    <summary>The <b>ObjectDeleteAuditAlarm</b> function generates audit messages when an object is deleted. Alarms are not currently supported.</summary>
    <param name="SubsystemName">A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">Specifies a unique value representing the client's handle to the object. This must be the same value that was passed to the<see cref="AccessCheckAndAuditAlarm" /> or<see cref="ObjectOpenAuditAlarm" /> function.</param>
    <param name="GenerateOnClose">Specifies a flag set by a call to the<see cref="AccessCheckAndAuditAlarm" /> or<see cref="ObjectOpenAuditAlarm" /> function when the object handle is created.</param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ObjectOpenAuditAlarm">
    <summary>The <b>ObjectOpenAuditAlarm</b> function generates audit messages when a client application attempts to gain access to an object or to create a new one. Alarms are not currently supported.</summary>
    <param name="SubsystemName">A pointer to a <b>null</b>-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">
      <para>A pointer to a unique value representing the client's handle to the object. If the access is denied, this parameter is ignored.</para>
      <para>For cross-platform compatibility, the value addressed by this pointer must be sizeof(LPVOID) bytes long.</para>
    </param>
    <param name="ObjectTypeName">A pointer to a <b>null</b>-terminated string specifying the type of object to which the client is requesting access. This string appears in any audit message that the function generates.</param>
    <param name="ObjectName">A pointer to a <b>null</b>-terminated string specifying the name of the object to which the client is requesting access. This string appears in any audit message that the function generates.</param>
    <param name="pSecurityDescriptor">A pointer to the<see cref="SECURITY_DESCRIPTOR" /> structure for the object being accessed.</param>
    <param name="ClientToken">Identifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> representing the client requesting the operation. This handle must be obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access.</param>
    <param name="DesiredAccess">Specifies the desired <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a>. This mask must have been previously mapped by the <see cref="MapGenericMask" /> function to contain no generic access rights.</param>
    <param name="GrantedAccess">Specifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> indicating which access rights are granted. This access mask is intended to be the same value set by one of the access-checking functions in its <i>GrantedAccess</i> parameter. Examples of access-checking functions include <see cref="AccessCheckAndAuditAlarm" /> and <see cref="AccessCheck" />.</param>
    <param name="Privileges">A pointer to a<see cref="PRIVILEGE_SET" /> structure that specifies the set of <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a> required for the access attempt. This parameter can be <b>NULL</b>.</param>
    <param name="ObjectCreation">Specifies a flag that determines whether the application creates a new object when access is granted. When this value is <b>TRUE</b>, the application creates a new object; when it is <b>FALSE</b>, the application opens an existing object.</param>
    <param name="AccessGranted">Specifies a flag indicating whether access was granted or denied in a previous call to an access-checking function, such as <see cref="AccessCheck" />. If access was granted, this value is <b>TRUE</b>. If not, it is <b>FALSE</b>.</param>
    <param name="GenerateOnClose">A pointer to a flag set by the audit-generation routine when the function returns. This value must be passed to the<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ObjectOpenAuditAlarmA">
    <summary>The <b>ObjectOpenAuditAlarm</b> function generates audit messages when a client application attempts to gain access to an object or to create a new one. Alarms are not currently supported.</summary>
    <param name="SubsystemName">A pointer to a <b>null</b>-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">
      <para>A pointer to a unique value representing the client's handle to the object. If the access is denied, this parameter is ignored.</para>
      <para>For cross-platform compatibility, the value addressed by this pointer must be sizeof(LPVOID) bytes long.</para>
    </param>
    <param name="ObjectTypeName">A pointer to a <b>null</b>-terminated string specifying the type of object to which the client is requesting access. This string appears in any audit message that the function generates.</param>
    <param name="ObjectName">A pointer to a <b>null</b>-terminated string specifying the name of the object to which the client is requesting access. This string appears in any audit message that the function generates.</param>
    <param name="pSecurityDescriptor">A pointer to the<see cref="SECURITY_DESCRIPTOR" /> structure for the object being accessed.</param>
    <param name="ClientToken">Identifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> representing the client requesting the operation. This handle must be obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access.</param>
    <param name="DesiredAccess">Specifies the desired <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a>. This mask must have been previously mapped by the <see cref="MapGenericMask" /> function to contain no generic access rights.</param>
    <param name="GrantedAccess">Specifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> indicating which access rights are granted. This access mask is intended to be the same value set by one of the access-checking functions in its <i>GrantedAccess</i> parameter. Examples of access-checking functions include <see cref="AccessCheckAndAuditAlarm" /> and <see cref="AccessCheck" />.</param>
    <param name="Privileges">A pointer to a<see cref="PRIVILEGE_SET" /> structure that specifies the set of <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a> required for the access attempt. This parameter can be <b>NULL</b>.</param>
    <param name="ObjectCreation">Specifies a flag that determines whether the application creates a new object when access is granted. When this value is <b>TRUE</b>, the application creates a new object; when it is <b>FALSE</b>, the application opens an existing object.</param>
    <param name="AccessGranted">Specifies a flag indicating whether access was granted or denied in a previous call to an access-checking function, such as <see cref="AccessCheck" />. If access was granted, this value is <b>TRUE</b>. If not, it is <b>FALSE</b>.</param>
    <param name="GenerateOnClose">A pointer to a flag set by the audit-generation routine when the function returns. This value must be passed to the<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ObjectOpenAuditAlarmW">
    <summary>The <b>ObjectOpenAuditAlarm</b> function generates audit messages when a client application attempts to gain access to an object or to create a new one. Alarms are not currently supported.</summary>
    <param name="SubsystemName">A pointer to a <b>null</b>-terminated string specifying the name of the subsystem calling the function. This string appears in any audit message that the function generates.</param>
    <param name="HandleId">
      <para>A pointer to a unique value representing the client's handle to the object. If the access is denied, this parameter is ignored.</para>
      <para>For cross-platform compatibility, the value addressed by this pointer must be sizeof(LPVOID) bytes long.</para>
    </param>
    <param name="ObjectTypeName">A pointer to a <b>null</b>-terminated string specifying the type of object to which the client is requesting access. This string appears in any audit message that the function generates.</param>
    <param name="ObjectName">A pointer to a <b>null</b>-terminated string specifying the name of the object to which the client is requesting access. This string appears in any audit message that the function generates.</param>
    <param name="pSecurityDescriptor">A pointer to the<see cref="SECURITY_DESCRIPTOR" /> structure for the object being accessed.</param>
    <param name="ClientToken">Identifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> representing the client requesting the operation. This handle must be obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access.</param>
    <param name="DesiredAccess">Specifies the desired <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a>. This mask must have been previously mapped by the <see cref="MapGenericMask" /> function to contain no generic access rights.</param>
    <param name="GrantedAccess">Specifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> indicating which access rights are granted. This access mask is intended to be the same value set by one of the access-checking functions in its <i>GrantedAccess</i> parameter. Examples of access-checking functions include <see cref="AccessCheckAndAuditAlarm" /> and <see cref="AccessCheck" />.</param>
    <param name="Privileges">A pointer to a<see cref="PRIVILEGE_SET" /> structure that specifies the set of <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a> required for the access attempt. This parameter can be <b>NULL</b>.</param>
    <param name="ObjectCreation">Specifies a flag that determines whether the application creates a new object when access is granted. When this value is <b>TRUE</b>, the application creates a new object; when it is <b>FALSE</b>, the application opens an existing object.</param>
    <param name="AccessGranted">Specifies a flag indicating whether access was granted or denied in a previous call to an access-checking function, such as <see cref="AccessCheck" />. If access was granted, this value is <b>TRUE</b>. If not, it is <b>FALSE</b>.</param>
    <param name="GenerateOnClose">A pointer to a flag set by the audit-generation routine when the function returns. This value must be passed to the<see cref="ObjectCloseAuditAlarm" /> function when the object handle is closed.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ObjectPrivilegeAuditAlarm">
    <summary>The <b>ObjectPrivilegeAuditAlarm</b> function generates an audit message in the security event log. A protected server can use this function to log attempts by a client to use a specified set of <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a> with an open handle to a private object. Alarms are not currently supported.</summary>
    <param name="SubsystemName">A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in the audit message.</param>
    <param name="HandleId">A pointer to a unique value representing the client's handle to the object.</param>
    <param name="ClientToken">Identifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> representing the client that requested the operation. This handle must have been obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access. The function uses this token to get the identity of the client for the audit message.</param>
    <param name="DesiredAccess">Specifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> indicating the privileged access types being used or whose use is being attempted. The access mask can be mapped by the<see cref="MapGenericMask" /> function so it does not contain any generic access types.</param>
    <param name="Privileges">A pointer to a<see cref="PRIVILEGE_SET" /> structure containing the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a> that the client attempted to use. The names of the privileges appear in the audit message.</param>
    <param name="AccessGranted">Indicates whether the client's attempt to use the privileges was successful. If this value is <b>TRUE</b>, the audit message indicates success. If this value is <b>FALSE</b>, the audit message indicates failure.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ObjectPrivilegeAuditAlarmA">
    <summary>The <b>ObjectPrivilegeAuditAlarm</b> function generates an audit message in the security event log. A protected server can use this function to log attempts by a client to use a specified set of <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a> with an open handle to a private object. Alarms are not currently supported.</summary>
    <param name="SubsystemName">A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in the audit message.</param>
    <param name="HandleId">A pointer to a unique value representing the client's handle to the object.</param>
    <param name="ClientToken">Identifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> representing the client that requested the operation. This handle must have been obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access. The function uses this token to get the identity of the client for the audit message.</param>
    <param name="DesiredAccess">Specifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> indicating the privileged access types being used or whose use is being attempted. The access mask can be mapped by the<see cref="MapGenericMask" /> function so it does not contain any generic access types.</param>
    <param name="Privileges">A pointer to a<see cref="PRIVILEGE_SET" /> structure containing the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a> that the client attempted to use. The names of the privileges appear in the audit message.</param>
    <param name="AccessGranted">Indicates whether the client's attempt to use the privileges was successful. If this value is <b>TRUE</b>, the audit message indicates success. If this value is <b>FALSE</b>, the audit message indicates failure.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ObjectPrivilegeAuditAlarmW">
    <summary>The <b>ObjectPrivilegeAuditAlarm</b> function generates an audit message in the security event log. A protected server can use this function to log attempts by a client to use a specified set of <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a> with an open handle to a private object. Alarms are not currently supported.</summary>
    <param name="SubsystemName">A pointer to a null-terminated string specifying the name of the subsystem calling the function. This string appears in the audit message.</param>
    <param name="HandleId">A pointer to a unique value representing the client's handle to the object.</param>
    <param name="ClientToken">Identifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> representing the client that requested the operation. This handle must have been obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access. The function uses this token to get the identity of the client for the audit message.</param>
    <param name="DesiredAccess">Specifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access mask</a> indicating the privileged access types being used or whose use is being attempted. The access mask can be mapped by the<see cref="MapGenericMask" /> function so it does not contain any generic access types.</param>
    <param name="Privileges">A pointer to a<see cref="PRIVILEGE_SET" /> structure containing the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a> that the client attempted to use. The names of the privileges appear in the audit message.</param>
    <param name="AccessGranted">Indicates whether the client's attempt to use the privileges was successful. If this value is <b>TRUE</b>, the audit message indicates success. If this value is <b>FALSE</b>, the audit message indicates failure.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenBackupEventLog">
    <summary>Opens a handle to a backup event log created by the <see cref="BackupEventLog" /> function.</summary>
    <param name="lpUNCServerName">The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</param>
    <param name="lpFileName">The full path of the backup file.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the backup event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenBackupEventLogA">
    <summary>Opens a handle to a backup event log created by the <see cref="BackupEventLog" /> function.</summary>
    <param name="lpUNCServerName">The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</param>
    <param name="lpFileName">The full path of the backup file.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the backup event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenBackupEventLogW">
    <summary>Opens a handle to a backup event log created by the <see cref="BackupEventLog" /> function.</summary>
    <param name="lpUNCServerName">The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</param>
    <param name="lpFileName">The full path of the backup file.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the backup event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenBackupEventLog">
    <summary>Opens a handle to a backup event log created by the <see cref="BackupEventLog" /> function.</summary>
    <param name="lpUNCServerName">The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</param>
    <param name="lpFileName">The full path of the backup file.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the backup event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenBackupEventLogA">
    <summary>Opens a handle to a backup event log created by the <see cref="BackupEventLog" /> function.</summary>
    <param name="lpUNCServerName">The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</param>
    <param name="lpFileName">The full path of the backup file.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the backup event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenBackupEventLogW">
    <summary>Opens a handle to a backup event log created by the <see cref="BackupEventLog" /> function.</summary>
    <param name="lpUNCServerName">The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</param>
    <param name="lpFileName">The full path of the backup file.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the backup event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenEncryptedFileRaw">
    <summary>Opens an encrypted file in order to backup (export) or restore (import) the file. This is one of a group of Encrypted File System (EFS) functions that is intended to implement backup and restore functionality, while maintaining files in their encrypted state.</summary>
    <param name="lpFileName">The name of the file to be opened. The string must consist of characters from the Windows character set.</param>
    <param name="ulFlags">
      <para>The operation to be performed. This parameter may be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>Open the file for export (backup).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_FOR_IMPORT</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>The file is being opened for import (restore).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_FOR_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>Import (restore) a directory containing encrypted files. This must be combined with one of the previous two flags to indicate the operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OVERWRITE_HIDDEN</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>Overwrite a hidden file on import.</description>
        </listheader>
      </list>
    </param>
    <param name="pvContext">The address of a context block that must be presented in subsequent calls to<see cref="ReadEncryptedFileRaw" />, <see cref="WriteEncryptedFileRaw" />, or<see cref="CloseEncryptedFileRaw" />. Do not modify it.</param>
    <returns>
      <para>If the function succeeds, it returns <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, it returns a nonzero error code defined in WinError.h. You can use <see cref="FormatMessage" /> with the<b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of the error.</para>
    </returns>
  </member>
  <member name="Windows.OpenEncryptedFileRawA">
    <summary>Opens an encrypted file in order to backup (export) or restore (import) the file. This is one of a group of Encrypted File System (EFS) functions that is intended to implement backup and restore functionality, while maintaining files in their encrypted state.</summary>
    <param name="lpFileName">The name of the file to be opened. The string must consist of characters from the Windows character set.</param>
    <param name="ulFlags">
      <para>The operation to be performed. This parameter may be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>Open the file for export (backup).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_FOR_IMPORT</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>The file is being opened for import (restore).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_FOR_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>Import (restore) a directory containing encrypted files. This must be combined with one of the previous two flags to indicate the operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OVERWRITE_HIDDEN</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>Overwrite a hidden file on import.</description>
        </listheader>
      </list>
    </param>
    <param name="pvContext">The address of a context block that must be presented in subsequent calls to<see cref="ReadEncryptedFileRaw" />, <see cref="WriteEncryptedFileRaw" />, or<see cref="CloseEncryptedFileRaw" />. Do not modify it.</param>
    <returns>
      <para>If the function succeeds, it returns <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, it returns a nonzero error code defined in WinError.h. You can use <see cref="FormatMessage" /> with the<b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of the error.</para>
    </returns>
  </member>
  <member name="Windows.OpenEncryptedFileRawW">
    <summary>Opens an encrypted file in order to backup (export) or restore (import) the file. This is one of a group of Encrypted File System (EFS) functions that is intended to implement backup and restore functionality, while maintaining files in their encrypted state.</summary>
    <param name="lpFileName">The name of the file to be opened. The string must consist of characters from the Windows character set.</param>
    <param name="ulFlags">
      <para>The operation to be performed. This parameter may be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>Open the file for export (backup).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_FOR_IMPORT</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>The file is being opened for import (restore).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_FOR_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>Import (restore) a directory containing encrypted files. This must be combined with one of the previous two flags to indicate the operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OVERWRITE_HIDDEN</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>Overwrite a hidden file on import.</description>
        </listheader>
      </list>
    </param>
    <param name="pvContext">The address of a context block that must be presented in subsequent calls to<see cref="ReadEncryptedFileRaw" />, <see cref="WriteEncryptedFileRaw" />, or<see cref="CloseEncryptedFileRaw" />. Do not modify it.</param>
    <returns>
      <para>If the function succeeds, it returns <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, it returns a nonzero error code defined in WinError.h. You can use <see cref="FormatMessage" /> with the<b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of the error.</para>
    </returns>
  </member>
  <member name="Windows.OpenEncryptedFileRaw">
    <summary>Opens an encrypted file in order to backup (export) or restore (import) the file. This is one of a group of Encrypted File System (EFS) functions that is intended to implement backup and restore functionality, while maintaining files in their encrypted state.</summary>
    <param name="lpFileName">The name of the file to be opened. The string must consist of characters from the Windows character set.</param>
    <param name="ulFlags">
      <para>The operation to be performed. This parameter may be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>Open the file for export (backup).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_FOR_IMPORT</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>The file is being opened for import (restore).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_FOR_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>Import (restore) a directory containing encrypted files. This must be combined with one of the previous two flags to indicate the operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OVERWRITE_HIDDEN</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>Overwrite a hidden file on import.</description>
        </listheader>
      </list>
    </param>
    <param name="pvContext">The address of a context block that must be presented in subsequent calls to<see cref="ReadEncryptedFileRaw" />, <see cref="WriteEncryptedFileRaw" />, or<see cref="CloseEncryptedFileRaw" />. Do not modify it.</param>
    <returns>
      <para>If the function succeeds, it returns <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, it returns a nonzero error code defined in WinError.h. You can use <see cref="FormatMessage" /> with the<b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of the error.</para>
    </returns>
  </member>
  <member name="Windows.OpenEncryptedFileRawA">
    <summary>Opens an encrypted file in order to backup (export) or restore (import) the file. This is one of a group of Encrypted File System (EFS) functions that is intended to implement backup and restore functionality, while maintaining files in their encrypted state.</summary>
    <param name="lpFileName">The name of the file to be opened. The string must consist of characters from the Windows character set.</param>
    <param name="ulFlags">
      <para>The operation to be performed. This parameter may be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>Open the file for export (backup).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_FOR_IMPORT</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>The file is being opened for import (restore).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_FOR_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>Import (restore) a directory containing encrypted files. This must be combined with one of the previous two flags to indicate the operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OVERWRITE_HIDDEN</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>Overwrite a hidden file on import.</description>
        </listheader>
      </list>
    </param>
    <param name="pvContext">The address of a context block that must be presented in subsequent calls to<see cref="ReadEncryptedFileRaw" />, <see cref="WriteEncryptedFileRaw" />, or<see cref="CloseEncryptedFileRaw" />. Do not modify it.</param>
    <returns>
      <para>If the function succeeds, it returns <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, it returns a nonzero error code defined in WinError.h. You can use <see cref="FormatMessage" /> with the<b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of the error.</para>
    </returns>
  </member>
  <member name="Windows.OpenEncryptedFileRawW">
    <summary>Opens an encrypted file in order to backup (export) or restore (import) the file. This is one of a group of Encrypted File System (EFS) functions that is intended to implement backup and restore functionality, while maintaining files in their encrypted state.</summary>
    <param name="lpFileName">The name of the file to be opened. The string must consist of characters from the Windows character set.</param>
    <param name="ulFlags">
      <para>The operation to be performed. This parameter may be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>Open the file for export (backup).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_FOR_IMPORT</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>The file is being opened for import (restore).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CREATE_FOR_DIR</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>Import (restore) a directory containing encrypted files. This must be combined with one of the previous two flags to indicate the operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OVERWRITE_HIDDEN</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>Overwrite a hidden file on import.</description>
        </listheader>
      </list>
    </param>
    <param name="pvContext">The address of a context block that must be presented in subsequent calls to<see cref="ReadEncryptedFileRaw" />, <see cref="WriteEncryptedFileRaw" />, or<see cref="CloseEncryptedFileRaw" />. Do not modify it.</param>
    <returns>
      <para>If the function succeeds, it returns <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, it returns a nonzero error code defined in WinError.h. You can use <see cref="FormatMessage" /> with the<b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of the error.</para>
    </returns>
  </member>
  <member name="Windows.OpenEventLog">
    <summary>Opens a handle to the specified event log.</summary>
    <param name="lpUNCServerName">The Universal Naming Convention (UNC) name of the remote server on which the event log is to be opened. If this parameter is <b>NULL</b>, the local computer is used.</param>
    <param name="lpSourceName">
      <para>The name of the log.</para>
      <para>If you specify a custom log and it cannot be found, the event logging service opens the <b>Application</b> log; however, there will be no associated message or category string file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to an event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenEventLogA">
    <summary>Opens a handle to the specified event log.</summary>
    <param name="lpUNCServerName">The Universal Naming Convention (UNC) name of the remote server on which the event log is to be opened. If this parameter is <b>NULL</b>, the local computer is used.</param>
    <param name="lpSourceName">
      <para>The name of the log.</para>
      <para>If you specify a custom log and it cannot be found, the event logging service opens the <b>Application</b> log; however, there will be no associated message or category string file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to an event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenEventLogW">
    <summary>Opens a handle to the specified event log.</summary>
    <param name="lpUNCServerName">The Universal Naming Convention (UNC) name of the remote server on which the event log is to be opened. If this parameter is <b>NULL</b>, the local computer is used.</param>
    <param name="lpSourceName">
      <para>The name of the log.</para>
      <para>If you specify a custom log and it cannot be found, the event logging service opens the <b>Application</b> log; however, there will be no associated message or category string file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to an event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenEventLog">
    <summary>Opens a handle to the specified event log.</summary>
    <param name="lpUNCServerName">The Universal Naming Convention (UNC) name of the remote server on which the event log is to be opened. If this parameter is <b>NULL</b>, the local computer is used.</param>
    <param name="lpSourceName">
      <para>The name of the log.</para>
      <para>If you specify a custom log and it cannot be found, the event logging service opens the <b>Application</b> log; however, there will be no associated message or category string file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to an event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenEventLogA">
    <summary>Opens a handle to the specified event log.</summary>
    <param name="lpUNCServerName">The Universal Naming Convention (UNC) name of the remote server on which the event log is to be opened. If this parameter is <b>NULL</b>, the local computer is used.</param>
    <param name="lpSourceName">
      <para>The name of the log.</para>
      <para>If you specify a custom log and it cannot be found, the event logging service opens the <b>Application</b> log; however, there will be no associated message or category string file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to an event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenEventLogW">
    <summary>Opens a handle to the specified event log.</summary>
    <param name="lpUNCServerName">The Universal Naming Convention (UNC) name of the remote server on which the event log is to be opened. If this parameter is <b>NULL</b>, the local computer is used.</param>
    <param name="lpSourceName">
      <para>The name of the log.</para>
      <para>If you specify a custom log and it cannot be found, the event logging service opens the <b>Application</b> log; however, there will be no associated message or category string file.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the handle to an event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenFile">
    <summary>
      <para>Creates, opens, reopens, or deletes a file.</para>
      <div>
        <b>Note</b>  This function has limited capabilities and is not recommended. For new application development, use the <see cref="CreateFile" /> function.</div>
    </summary>
    <param name="lpFileName">
      <para>The name of the file.</para>
      <para>The string must consist of characters from the 8-bit Windows character set. The<b>OpenFile</b> function does not support Unicode file names or opening named pipes.</para>
    </param>
    <param name="lpReOpenBuff">
      <para>A pointer to the <see cref="OFSTRUCT" /> structure that receives information about a file when it is first opened.</para>
      <para>The structure can be used in subsequent calls to the<b>OpenFile</b> function to see an open file.</para>
      <para>The <see cref="OFSTRUCT" /> structure contains a path string member with a length that is limited to <b>OFS_MAXPATHNAME</b> characters, which is 128 characters. Because of this, you cannot use the <b>OpenFile</b>function to open a file with a path length that exceeds 128 characters. The<see cref="CreateFile" /> function does not have this path length limitation.</para>
    </param>
    <param name="uStyle">
      <para>The action to be taken.</para>
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OF_CANCEL</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000800</term>
              </listheader>
            </list>
          </description>
          <description>Ignored.<para>To produce a dialog box containing a <b>Cancel</b> button, use<b>OF_PROMPT</b>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OF_CREATE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00001000</term>
              </listheader>
            </list>
          </description>
          <description>Creates a new file.<para>If the file exists, it is truncated to zero (0) length.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OF_DELETE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000200</term>
              </listheader>
            </list>
          </description>
          <description>Deletes a file.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OF_EXIST</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00004000</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file and then closes it.<para>Use this to test for the existence of a file.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OF_PARSE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000100</term>
              </listheader>
            </list>
          </description>
          <description>Fills the <see cref="OFSTRUCT" /> structure, but does not do anything else.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OF_PROMPT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00002000</term>
              </listheader>
            </list>
          </description>
          <description>Displays a dialog box if a requested file does not exist.<para>A dialog box informs a user that the system cannot find a file, and it contains<b>Retry</b> and <b>Cancel</b> buttons. The<b>Cancel</b> button directs <b>OpenFile</b>to return a file-not-found error message.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OF_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000000</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file for reading only.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OF_READWRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file with read/write permissions.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OF_REOPEN</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00008000</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file by using information in the reopen buffer.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OF_SHARE_COMPAT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000000</term>
              </listheader>
            </list>
          </description>
          <description>For MS-DOS–based file systems, opens a file with compatibility mode, allows any process on a specified computer to open the file any number of times.<para>Other efforts to open a file with other sharing modes fail. This flag is mapped to the<b>FILE_SHARE_READ</b>|<b>FILE_SHARE_WRITE</b> flags of the<see cref="CreateFile" /> function.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OF_SHARE_DENY_NONE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000040</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file without denying read or write access to other processes.<para>On MS-DOS-based file systems, if the file has been opened in compatibility mode by any other process, the function fails.</para><para>This flag is mapped to the<b>FILE_SHARE_READ</b>|<b>FILE_SHARE_WRITE</b> flags of the<see cref="CreateFile" /> function.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OF_SHARE_DENY_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000030</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file and denies read access to other processes.<para>On MS-DOS-based file systems, if the file has been opened in compatibility mode, or for read access by any other process, the function fails.</para><para>This flag is mapped to the <b>FILE_SHARE_WRITE</b> flag of the<see cref="CreateFile" /> function.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OF_SHARE_DENY_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000020</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file and denies write access to other processes.<para>On MS-DOS-based file systems, if a file has been opened in compatibility mode, or for write access by any other process, the function fails.</para><para>This flag is mapped to the <b>FILE_SHARE_READ</b> flag of the<see cref="CreateFile" /> function.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OF_SHARE_EXCLUSIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000010</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file with exclusive mode, and denies both read/write access to other processes. If a file has been opened in any other mode for read/write access, even by the current process, the function fails.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OF_VERIFY</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Verifies that the date and time of a file are the same as when it was opened previously.<para>This is useful as an extra check for read-only files.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>OF_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Opens a file for write access only.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value specifies a file handle to use when performing file I/O. To close the file, call the <see cref="CloseHandle" /> function using this handle.</para>
      <para>If the function fails, the return value is <b>HFILE_ERROR</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenFileById">
    <summary>Opens the file that matches the specified identifier.</summary>
    <param name="hVolumeHint">A handle to any file on a volume or share on which the file to be opened is stored.</param>
    <param name="lpFileId">A pointer to a <see cref="FILE_ID_DESCRIPTOR" /> that identifies the file to open.</param>
    <param name="dwDesiredAccess">
      <para>The access to the object. Access can be read, write, or both.</para>
      <para>For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access
Rights</a>. You cannot request an access mode that conflicts with the sharing mode that is specified in an open request that has an open handle.</para>
      <para>If this parameter is zero (0), the application can query file and device attributes without accessing a device. This is useful for an application to determine the size of a floppy disk drive and the formats it supports without requiring a floppy in a drive. It can also be used to test for the existence of a file or directory without opening them for read or write access.</para>
    </param>
    <param name="dwShareMode">
      <para>The sharing mode of an object, which can be read, write, both, or none.</para>
      <para>You cannot request a sharing mode that conflicts with the access mode that is specified in an open request that has an open handle, because that would result in the following sharing violation: (<b>ERROR_SHARING_VIOLATION</b>). For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</para>
      <para>If this parameter is zero (0) and <b>OpenFileById</b>succeeds, the object cannot be shared and cannot be opened again until the handle is closed. For more information, see the Remarks section of this topic.</para>
      <para>The sharing options remain in effect until you close the handle to an object.</para>
      <para>To enable a processes to share an object while another process has the object open, use a combination of one or more of the following values to specify the access mode they can request to open the object.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SHARE_DELETE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>Enables subsequent open operations on an object to request delete access.<para>Otherwise, other processes cannot open the object if they request delete access.</para><para>If this flag is not specified, but the object has been opened for delete access, the function fails.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SHARE_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Enables subsequent open operations on an object to request read access.<para>Otherwise, other processes cannot open the object if they request read access.</para><para>If this flag is not specified, but the object has been opened for read access, the function fails.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SHARE_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Enables subsequent open operations on an object to request write access.<para>Otherwise, other processes cannot open the object if they request write access.</para><para>If this flag is not specified, but the object has been opened for write access or has a file mapping with write access, the function fails.</para></description>
        </listheader>
      </list>
    </param>
    <param name="lpSecurityAttributes">Reserved.</param>
    <param name="dwFlagsAndAttributes">
      <para>The file flags.</para>
      <para>When <b>OpenFileById</b> opens a file, it combines the file flags with existing file attributes, and ignores any supplied file attributes. This parameter can include any combination of the following flags.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_FLAG_BACKUP_SEMANTICS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x02000000</term>
              </listheader>
            </list>
          </description>
          <description>A file is being opened for a backup or restore operation. The system ensures that the calling process overrides file security checks when the process has <b>SE_BACKUP_NAME</b> and <b>SE_RESTORE_NAME</b> privileges. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/changing-privileges-in-a-token">Changing Privileges in a Token</a>.<para>You must set this flag to obtain a handle to a directory. A directory handle can be passed to some functions instead of a file handle. For more information, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/obtaining-a-handle-to-a-directory">Directory Handles</a>.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_FLAG_NO_BUFFERING</b>
                </term>
              </listheader>
              <listheader>
                <term>0x20000000</term>
              </listheader>
            </list>
          </description>
          <description>The system opens a file with no system caching. This flag does not affect hard disk caching. When combined with <b>FILE_FLAG_OVERLAPPED</b>, the flag gives maximum asynchronous performance, because the I/O does not rely on the synchronous operations of the memory manager. However, some I/O operations take more time, because data is not being held in the cache. Also, the file metadata may still be cached. To flush the metadata to disk, use the <see cref="FlushFileBuffers" /> function.<para>An application must meet certain requirements when working with files that are opened with<b>FILE_FLAG_NO_BUFFERING</b>:</para><list type="bullet"><item><description>File access must begin at byte offsets within a file that are integer multiples of the volume sector size.</description></item><item><description>File access must be for numbers of bytes that are integer multiples of the volume sector size. For example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1024, 1536, or 2048 bytes, but not of 335, 981, or 7171 bytes.</description></item><item><description>Buffer addresses for read and write operations should be sector aligned, which means aligned on addresses in memory that are integer multiples of the volume sector size. Depending on the disk, this requirement may not be enforced.</description></item></list>One way to align buffers on integer multiples of the volume sector size is to use <see cref="VirtualAlloc" /> to allocate the buffers. It allocates memory that is aligned on addresses that are integer multiples of the operating system's memory page size. Because both memory page and volume sector sizes are powers of 2, this memory is also aligned on addresses that are integer multiples of a volume sector size. Memory pages are 4-8 KB in size; sectors are 512 bytes (hard disks) or 2048 bytes (CD), and therefore, volume sectors can never be larger than memory pages.<para>An application can determine a volume sector size by calling the<see cref="GetDiskFreeSpace" /> function.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_FLAG_OPEN_NO_RECALL</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00100000</term>
              </listheader>
            </list>
          </description>
          <description>The file data is requested, but it should continue to be located in remote storage. It should not be transported back to local storage. This flag is for use by remote storage systems.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_FLAG_OPEN_REPARSE_POINT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00200000</term>
              </listheader>
            </list>
          </description>
          <description>When this flag is used, normal <a href="https://docs.microsoft.com//windows/desktop/FileIO/reparse-points">reparse point</a> processing does not occur, and <b>OpenFileById</b> attempts to open the reparse point. When a file is opened, a file handle is returned, whether or not the filter that controls the reparse point is operational. This flag cannot be used with the <b>CREATE_ALWAYS</b> flag. If the file is not a reparse point, then this flag is ignored.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_FLAG_OVERLAPPED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x40000000</term>
              </listheader>
            </list>
          </description>
          <description>The file is being opened or created for asynchronous I/O. When the operation is complete, the event specified to the call in the <see cref="OVERLAPPED" /> structure is set to the signaled state. Operations that take a significant amount of time to process return <b>ERROR_IO_PENDING</b>.<para>If this flag is specified, the file can be used for simultaneous read and write operations. The system does not maintain the file pointer, therefore you must pass the file position to the read and write functions in the <see cref="OVERLAPPED" /> structure or update the file pointer.</para><para>If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write functions specify an <see cref="OVERLAPPED" /> structure.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_FLAG_RANDOM_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x10000000</term>
              </listheader>
            </list>
          </description>
          <description>A file is accessed randomly. The system can use this as a hint to optimize file caching.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_FLAG_SEQUENTIAL_SCAN</b>
                </term>
              </listheader>
              <listheader>
                <term>0x08000000</term>
              </listheader>
            </list>
          </description>
          <description>A file is accessed sequentially from beginning to end. The system can use this as a hint to optimize file caching. If an application moves the file pointer for random access, optimum caching may not occur. However, correct operation is still guaranteed.<para>Specifying this flag can increase performance for applications that read large files using sequential access. Performance gains can be even more noticeable for applications that read large files mostly sequentially, but occasionally skip over small ranges of bytes.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_FLAG_WRITE_THROUGH</b>
                </term>
              </listheader>
              <listheader>
                <term>0x80000000</term>
              </listheader>
            </list>
          </description>
          <description>The system writes through any intermediate cache and goes directly to disk.<para>If <b>FILE_FLAG_NO_BUFFERING</b> is not also specified, so that system caching is in effect, then the data is written to the system cache, but is flushed to disk without delay.</para><para>If <b>FILE_FLAG_NO_BUFFERING</b> is also specified, so that system caching is not in effect, then the data is immediately flushed to disk without going through the system cache. The operating system also requests a write-through the hard disk cache to persistent media. However, not all hardware supports this write-through capability.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to a specified file.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenFileMapping">
    <summary>Opens a named file mapping object.</summary>
    <param name="dwDesiredAccess">The access to the file mapping object. This access is checked against any security descriptor on the target file mapping object. For a list of values, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this parameter is <b>TRUE</b>, a process created by the<see cref="CreateProcess" /> function can inherit the handle; otherwise, the handle cannot be inherited.</param>
    <param name="lpName">The name of the file mapping object to be opened. If there is an open handle to a file mapping object by this name and the security descriptor on the mapping object does not conflict with the<i>dwDesiredAccess</i> parameter, the open operation succeeds. The name can have a "Global\" or "Local\" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified file mapping object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenFileMappingA">
    <summary>Opens a named file mapping object.</summary>
    <param name="dwDesiredAccess">The access to the file mapping object. This access is checked against any security descriptor on the target file mapping object. For a list of values, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this parameter is <b>TRUE</b>, a process created by the<see cref="CreateProcess" /> function can inherit the handle; otherwise, the handle cannot be inherited.</param>
    <param name="lpName">The name of the file mapping object to be opened. If there is an open handle to a file mapping object by this name and the security descriptor on the mapping object does not conflict with the<i>dwDesiredAccess</i> parameter, the open operation succeeds. The name can have a "Global\" or "Local\" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified file mapping object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenFileMappingW">
    <summary>Opens a named file mapping object.</summary>
    <param name="dwDesiredAccess">The access to the file mapping object. This access is checked against any security descriptor on the target file mapping object. For a list of values, see<a href="https://docs.microsoft.com//windows/desktop/Memory/file-mapping-security-and-access-rights">File Mapping Security and Access Rights</a>.</param>
    <param name="bInheritHandle">If this parameter is <b>TRUE</b>, a process created by the<see cref="CreateProcess" /> function can inherit the handle; otherwise, the handle cannot be inherited.</param>
    <param name="lpName">The name of the file mapping object to be opened. If there is an open handle to a file mapping object by this name and the security descriptor on the mapping object does not conflict with the<i>dwDesiredAccess</i> parameter, the open operation succeeds. The name can have a "Global\" or "Local\" prefix to explicitly open an object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>. Fast user switching is implemented using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified file mapping object.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.OpenJobObject">
    <summary>Opens an existing job object.</summary>
    <param name="dwDesiredAccess">The access to the job object. This parameter can be one or more of the<a href="https://docs.microsoft.com//windows/desktop/ProcThread/job-object-security-and-access-rights">job object access rights</a>. This access right is checked against any security descriptor for the object.</param>
    <param name="bInheritHandle">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
    <param name="lpName">
      <para>The name of the job to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the job. The handle provides the requested access to the job.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>An error of ERROR_FILE_NOT_FOUND indicates that the job specified in <i>lpName</i> does not exist.</para>
    </returns>
  </member>
  <member name="Windows.OpenJobObjectA">
    <summary>Opens an existing job object.</summary>
    <param name="dwDesiredAccess">The access to the job object. This parameter can be one or more of the<a href="https://docs.microsoft.com//windows/desktop/ProcThread/job-object-security-and-access-rights">job object access rights</a>. This access right is checked against any security descriptor for the object.</param>
    <param name="bInheritHandle">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
    <param name="lpName">
      <para>The name of the job to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the job. The handle provides the requested access to the job.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>An error of ERROR_FILE_NOT_FOUND indicates that the job specified in <i>lpName</i> does not exist.</para>
    </returns>
  </member>
  <member name="Windows.OpenJobObjectW">
    <summary>Opens an existing job object.</summary>
    <param name="dwDesiredAccess">The access to the job object. This parameter can be one or more of the<a href="https://docs.microsoft.com//windows/desktop/ProcThread/job-object-security-and-access-rights">job object access rights</a>. This access right is checked against any security descriptor for the object.</param>
    <param name="bInheritHandle">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
    <param name="lpName">
      <para>The name of the job to be opened. Name comparisons are case sensitive.</para>
      <para>This function can open objects in a private namespace. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/object-namespaces">Object Namespaces</a>.</para>
      <para>
        <b>Terminal Services:  </b>The name can have a "Global" or "Local" prefix to explicitly open the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see<a href="https://docs.microsoft.com//windows/desktop/TermServ/kernel-object-namespaces">Kernel Object Namespaces</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the job. The handle provides the requested access to the job.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>An error of ERROR_FILE_NOT_FOUND indicates that the job specified in <i>lpName</i> does not exist.</para>
    </returns>
  </member>
  <member name="Windows.OpenPrivateNamespace">
    <summary>Opens a private namespace.</summary>
    <param name="lpBoundaryDescriptor">A descriptor that defines how the namespace is to be isolated. The <see cref="CreateBoundaryDescriptor" /> function creates a boundary descriptor.</param>
    <param name="lpAliasPrefix">The prefix for the namespace. To create an object in this namespace, specify the object name as <i>prefix</i>\<i>objectname</i>.</param>
    <returns>The function returns the handle to the existing namespace.</returns>
  </member>
  <member name="Windows.OpenPrivateNamespaceA">
    <summary>Opens a private namespace.</summary>
    <param name="lpBoundaryDescriptor">A descriptor that defines how the namespace is to be isolated. The <see cref="CreateBoundaryDescriptor" /> function creates a boundary descriptor.</param>
    <param name="lpAliasPrefix">The prefix for the namespace. To create an object in this namespace, specify the object name as <i>prefix</i>\<i>objectname</i>.</param>
    <returns>The function returns the handle to the existing namespace.</returns>
  </member>
  <member name="Windows.OpenPrivateNamespaceW">
    <summary>Opens a private namespace.</summary>
    <param name="lpBoundaryDescriptor">A descriptor that defines how the namespace is to be isolated. The <see cref="CreateBoundaryDescriptor" /> function creates a boundary descriptor.</param>
    <param name="lpAliasPrefix">The prefix for the namespace. To create an object in this namespace, specify the object name as <i>prefix</i>\<i>objectname</i>.</param>
    <returns>The function returns the handle to the existing namespace.</returns>
  </member>
  <member name="Windows.OperationEnd">
    <summary>
      <para>Notifies the system that the application is about to end an operation</para>
      <para>Every call to <see cref="OperationStart" /> must be followed by a call to <b>OperationEnd</b>, otherwise the operation's record of file access patterns is discarded after 10 seconds.</para>
    </summary>
    <param name="OperationEndParams">An <see cref="_OPERATION_END_PARAMETERS" /> structure that specifies <b>VERSION</b>, <b>OPERATION_ID</b> and <b>FLAGS</b>.</param>
    <returns>
      <b>TRUE</b> for all valid parameters and <b>FALSE</b> otherwise. To get extended error information, call <b>GetLastError</b>.</returns>
  </member>
  <member name="Windows.OperationStart">
    <summary>
      <para>Notifies the system that the application is about to start an operation.</para>
      <para>If an application calls <b>OperationStart</b> with a valid <a href="https://docs.microsoft.com//previous-versions/windows/desktop/oprec/operation-id">OPERATION_ID</a> value, the system records the specified operation’s file access patterns until <see cref="OperationEnd" /> is called for the same operation ID. This record is stored in a <i>filename.pf</i> prefetch file. Every call to <b>OperationStart</b> must be followed by a call to <b>OperationEnd</b>, otherwise the operation's record is discarded after 10 seconds.</para>
      <para>If an application calls <b>OperationStart</b> for an operation ID for which a prefetch file exists, the system loads the operation's files into memory prior to running the operation. The recording process remains the same and the system updates the appropriate <i>filename.pf</i> prefetch file.</para>
    </summary>
    <param name="OperationStartParams">An <see cref="_OPERATION_START_PARAMETERS" /> structure that specifies <b>VERSION</b>, <b>OPERATION_ID</b> and <b>FLAGS</b>.</param>
    <returns>
      <b>TRUE</b> for all valid parameters and <b>FALSE</b> otherwise. To get extended error information, call <b>GetLastError</b>.</returns>
  </member>
  <member name="Windows.PowerClearRequest">
    <summary>Decrements the count of power requests of the specified type for a power request object.</summary>
    <param name="PowerRequest">A handle to a power request object.</param>
    <param name="RequestType">
      <para>The power request type to be decremented. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PowerRequestDisplayRequired</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The display remains on even if there is no user input for an extended period of time.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PowerRequestSystemRequired</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The system continues to run instead of entering sleep after a period of user inactivity.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PowerRequestAwayModeRequired</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The system enters away mode instead of sleep. In away mode, the system continues to run but turns off audio and video to give the appearance of sleep.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PowerRequestExecutionRequired</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The calling process continues to run instead of being suspended or terminated by process lifetime management mechanisms. When and how long the process is allowed to run depends on the operating system and power policy settings. <para>When a <b>PowerRequestExecutionRequired</b> request is active, it implies <b>PowerRequestSystemRequired</b>.</para><para>The <b>PowerRequestExecutionRequired</b> request type can be used only by applications. Services cannot use this request type.</para><para><b>Windows 7 and Windows Server 2008 R2:  </b>This request type is supported starting with Windows 8 and Windows Server 2012.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.PowerCreateRequest">
    <summary>Creates a new power request object.</summary>
    <param name="Context">Points to a <see cref="REASON_CONTEXT" /> structure that contains information about the power request.</param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the power request object.</para>
      <para>If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.PowerSetRequest">
    <summary>Increments the count of power requests of the specified type for a power request object.</summary>
    <param name="PowerRequest">A handle to a power request object.</param>
    <param name="RequestType">
      <para>The power request type to be incremented. This parameter can be one of the following values.</para>
      <para>| Value | Description | |--------|-------------| | PowerRequestDisplayRequired | The display remains on even if there is no user input for an extended period of time.<br /><br /><div><b>Note:</b>A <b>PowerRequestSystemRequired</b> must be taken in addition to a <b>PowerRequestDisplayRequired</b> to ensure the display stays on and the system does not enter sleep for the duration of the request.</div> | | PowerRequestSystemRequired | The system continues to run instead of entering sleep after a period of user inactivity. | | PowerRequestAwayModeRequired | The system enters away mode instead of sleep in response to explicit action by the user. In away mode, the system continues to run but turns off audio and video to give the appearance of sleep. <b>PowerRequestAwayModeRequired</b> is only applicable on Traditional Sleep (S3) systems. | | PowerRequestExecutionRequired | The calling process continues to run instead of being suspended or terminated by process lifetime management mechanisms. When and how long the process is allowed to run depends on the operating system and power policy settings.<br /><br />On Traditional Sleep (S3) systems, an active <b>PowerRequestExecutionRequired</b> request implies <b>PowerRequestSystemRequired</b>. |</para>
    </param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, it returns zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.PrepareTape">
    <summary>The<b>PrepareTape</b> function prepares the tape to be accessed or removed.</summary>
    <param name="hDevice">Handle to the device preparing the tape. This handle is created by using the<see cref="CreateFile" /> function.</param>
    <param name="dwOperation">
      <para>Tape device preparation. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_FORMAT</b>
                </term>
              </listheader>
              <listheader>
                <term>5L</term>
              </listheader>
            </list>
          </description>
          <description>Performs a low-level format of the tape. Currently, only the QIC117 device supports this feature.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_LOAD</b>
                </term>
              </listheader>
              <listheader>
                <term>0L</term>
              </listheader>
            </list>
          </description>
          <description>Loads the tape and moves the tape to the beginning.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_LOCK</b>
                </term>
              </listheader>
              <listheader>
                <term>3L</term>
              </listheader>
            </list>
          </description>
          <description>Locks the tape ejection mechanism so that the tape is not ejected accidentally.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_TENSION</b>
                </term>
              </listheader>
              <listheader>
                <term>2L</term>
              </listheader>
            </list>
          </description>
          <description>Adjusts the tension by moving the tape to the end of the tape and back to the beginning. This option is not supported by all devices. This value is ignored if it is not supported.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_UNLOAD</b>
                </term>
              </listheader>
              <listheader>
                <term>1L</term>
              </listheader>
            </list>
          </description>
          <description>Moves the tape to the beginning for removal from the device. After a successful unload operation, the device returns errors to applications that attempt to access the tape, until the tape is loaded again.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_UNLOCK</b>
                </term>
              </listheader>
              <listheader>
                <term>4L</term>
              </listheader>
            </list>
          </description>
          <description>Unlocks the tape ejection mechanism.</description>
        </listheader>
      </list>
    </param>
    <param name="bImmediate">If this parameter is <b>TRUE</b>, the function returns immediately. If it is <b>FALSE</b>, the function does not return until the operation has been completed.</param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, it can return one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BEGINNING_OF_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1102L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to access data before the beginning-of-medium marker failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BUS_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>1111L</term>
              </listheader>
            </list>
          </description>
          <description>A reset condition was detected on the bus.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_DEVICE_NOT_PARTITIONED</b>
                </term>
              </listheader>
              <listheader>
                <term>1107L</term>
              </listheader>
            </list>
          </description>
          <description>The partition information could not be found when a tape was being loaded.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_END_OF_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1100L</term>
              </listheader>
            </list>
          </description>
          <description>The end-of-tape marker was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_FILEMARK_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1101L</term>
              </listheader>
            </list>
          </description>
          <description>A filemark was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_BLOCK_LENGTH</b>
                </term>
              </listheader>
              <listheader>
                <term>1106L</term>
              </listheader>
            </list>
          </description>
          <description>The block size is incorrect on a new tape in a multivolume partition.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_MEDIA_CHANGED</b>
                </term>
              </listheader>
              <listheader>
                <term>1110L</term>
              </listheader>
            </list>
          </description>
          <description>The tape that was in the drive has been replaced or removed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NO_DATA_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1104L</term>
              </listheader>
            </list>
          </description>
          <description>The end-of-data marker was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NO_MEDIA_IN_DRIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>1112L</term>
              </listheader>
            </list>
          </description>
          <description>There is no media in the drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_SUPPORTED</b>
                </term>
              </listheader>
              <listheader>
                <term>50L</term>
              </listheader>
            </list>
          </description>
          <description>The tape driver does not support a requested function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PARTITION_FAILURE</b>
                </term>
              </listheader>
              <listheader>
                <term>1105L</term>
              </listheader>
            </list>
          </description>
          <description>The tape could not be partitioned.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_SETMARK_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1103L</term>
              </listheader>
            </list>
          </description>
          <description>A setmark was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_UNABLE_TO_LOCK_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1108L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to lock the ejection mechanism failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1109L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to unload the tape failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_WRITE_PROTECT</b>
                </term>
              </listheader>
              <listheader>
                <term>19L</term>
              </listheader>
            </list>
          </description>
          <description>The media is write protected.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.PrivilegedServiceAuditAlarm">
    <summary>
      <para>The <b>PrivilegedServiceAuditAlarm</b> function generates an audit message in the security event log. A protected server can use this function to log attempts by a client to use a specified set of <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a>.</para>
      <para>Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">A pointer to a null-terminated string specifying the name of the subsystem calling the function. This information appears in the security event log record.</param>
    <param name="ServiceName">A pointer to a null-terminated string specifying the name of the privileged subsystem service. This information appears in the security event log record.</param>
    <param name="ClientToken">Identifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> representing the client that requested the operation. This handle must have been obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access. The function uses this token to get the identity of the client for the security event log record.</param>
    <param name="Privileges">A pointer to a<see cref="PRIVILEGE_SET" /> structure containing the privileges that the client attempted to use. The names of the privileges appear in the security event log record.</param>
    <param name="AccessGranted">Indicates whether the client's attempt to use the privileges was successful. If this value is <b>TRUE</b>, the security event log record indicates success. If this value is <b>FALSE</b>, the security event log record indicates failure.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.PrivilegedServiceAuditAlarmA">
    <summary>
      <para>The <b>PrivilegedServiceAuditAlarm</b> function generates an audit message in the security event log. A protected server can use this function to log attempts by a client to use a specified set of <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a>.</para>
      <para>Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">A pointer to a null-terminated string specifying the name of the subsystem calling the function. This information appears in the security event log record.</param>
    <param name="ServiceName">A pointer to a null-terminated string specifying the name of the privileged subsystem service. This information appears in the security event log record.</param>
    <param name="ClientToken">Identifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> representing the client that requested the operation. This handle must have been obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access. The function uses this token to get the identity of the client for the security event log record.</param>
    <param name="Privileges">A pointer to a<see cref="PRIVILEGE_SET" /> structure containing the privileges that the client attempted to use. The names of the privileges appear in the security event log record.</param>
    <param name="AccessGranted">Indicates whether the client's attempt to use the privileges was successful. If this value is <b>TRUE</b>, the security event log record indicates success. If this value is <b>FALSE</b>, the security event log record indicates failure.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.PrivilegedServiceAuditAlarmW">
    <summary>
      <para>The <b>PrivilegedServiceAuditAlarm</b> function generates an audit message in the security event log. A protected server can use this function to log attempts by a client to use a specified set of <a href="https://docs.microsoft.com//windows/desktop/SecGloss/p-gly">privileges</a>.</para>
      <para>Alarms are not currently supported.</para>
    </summary>
    <param name="SubsystemName">A pointer to a null-terminated string specifying the name of the subsystem calling the function. This information appears in the security event log record.</param>
    <param name="ServiceName">A pointer to a null-terminated string specifying the name of the privileged subsystem service. This information appears in the security event log record.</param>
    <param name="ClientToken">Identifies an <a href="https://docs.microsoft.com//windows/desktop/SecGloss/a-gly">access token</a> representing the client that requested the operation. This handle must have been obtained by opening the token of a thread impersonating the client. The token must be open for TOKEN_QUERY access. The function uses this token to get the identity of the client for the security event log record.</param>
    <param name="Privileges">A pointer to a<see cref="PRIVILEGE_SET" /> structure containing the privileges that the client attempted to use. The names of the privileges appear in the security event log record.</param>
    <param name="AccessGranted">Indicates whether the client's attempt to use the privileges was successful. If this value is <b>TRUE</b>, the security event log record indicates success. If this value is <b>FALSE</b>, the security event log record indicates failure.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.PulseEvent">
    <summary>
      <para>Sets the specified event object to the signaled state and then resets it to the nonsignaled state after releasing the appropriate number of waiting threads.</para>
      <div>
        <b>Note</b>  This function is unreliable and should not be used. It exists mainly for backward compatibility. For more information, see Remarks.</div>
    </summary>
    <param name="hEvent">
      <para>A handle to the event object. The<see cref="CreateEvent" /> or<see cref="OpenEvent" /> function returns this handle.</para>
      <para>The handle must have the EVENT_MODIFY_STATE access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/Sync/synchronization-object-security-and-access-rights">Synchronization Object Security and Access Rights</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.PurgeComm">
    <summary>Discards all characters from the output or input buffer of a specified communications resource. It can also terminate pending read or write operations on the resource.</summary>
    <param name="hFile">A handle to the communications resource. The<see cref="CreateFile" /> function returns this handle.</param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PURGE_RXABORT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0002</term>
              </listheader>
            </list>
          </description>
          <description>Terminates all outstanding overlapped read operations and returns immediately, even if the read operations have not been completed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PURGE_RXCLEAR</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0008</term>
              </listheader>
            </list>
          </description>
          <description>Clears the input buffer (if the device driver has one).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PURGE_TXABORT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0001</term>
              </listheader>
            </list>
          </description>
          <description>Terminates all outstanding overlapped write operations and returns immediately, even if the write operations have not been completed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PURGE_TXCLEAR</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0004</term>
              </listheader>
            </list>
          </description>
          <description>Clears the output buffer (if the device driver has one).</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.QueryActCtxSettingsW">
    <summary>The <b>QueryActCtxSettingsW</b> function specifies the activation context, and the namespace and name of the attribute that is to be queried.</summary>
    <param name="dwFlags">This value must be 0.</param>
    <param name="hActCtx">A handle to the activation context that is being queried.</param>
    <param name="settingsNameSpace">
      <para>A pointer to a string that contains the value <b>"http://schemas.microsoft.com/SMI/2005/WindowsSettings"</b> or <b>NULL</b>. These values are equivalent.</para>
      <para>
        <b>Windows 8 and Windows Server 2012:  </b>A pointer to a string that contains the value <b>"http://schemas.microsoft.com/SMI/2011/WindowsSettings"</b> is also a valid parameter. A <b>NULL</b> is still equivalent to the previous value.</para>
    </param>
    <param name="settingName">The name of the attribute to be queried.</param>
    <param name="pvBuffer">A pointer to the buffer that receives the query result.</param>
    <param name="dwBuffer">The size of the buffer in characters that receives the query result.</param>
    <param name="pdwWrittenOrRequired">A pointer to a value which is the number of characters written to the buffer specified by <i>pvBuffer</i> or that is required to hold the query result.</param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling<see cref="GetLastError" />. For an example, see<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
  </member>
  <member name="Windows.QueryActCtxW">
    <summary>The<b>QueryActCtxW</b> function queries the activation context.</summary>
    <param name="dwFlags">
      <para>This parameter should be set to one of the following flag bits.</para>
      <list type="table">
        <listheader>
          <description>Flag</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>
            <b>QueryActCtxW</b> queries the activation context active on the thread instead of the context specified by <i>hActCtx</i>. This is usually the last activation context passed to <see cref="ActivateActCtx" />. If <b>ActivateActCtx</b> has not been called, the active activation context can be the activation context used by the executable of the current process. In other cases, the operating system determines the active activation context. For example, when the callback function to a new thread is called, the active activation context may be the context that was active when you created the thread by calling <see cref="CreateThread" />.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>
            <b>QueryActCtxW</b> interprets <i>hActCtx</i> as an <b>HMODULE</b> data type and queries an activation context that is associated with a DLL or EXE. <para>When a DLL or EXE is loaded, the loader checks for a manifest stored in a resource. If the loader finds an RT_MANIFEST resource with a resource identifier set to ISOLATIONAWARE_MANIFEST_ RESOURCE_ID, the loader associates the resulting activation context with the DLL or EXE. This is the activation context that<b>QueryActCtxW</b> queries when the QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE flag has been set.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>
            <b>QueryActCtxW</b> interprets <i>hActCtx</i> as an address within a DLL or EXE and queries an activation context that has been associated with the DLL or EXE. This can be any address within the DLL or EXE. For example, the address of any function within a DLL or EXE or the address of any static data, such as a constant string. <para>When a DLL or EXE is loaded, the loader checks for a manifest stored in a resource in the same way as QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE.</para></description>
        </listheader>
      </list>
    </param>
    <param name="hActCtx">Handle to the activation context that is being queried.</param>
    <param name="pvSubInstance">
      <para>Index of the assembly, or assembly and file combination, in the activation context. The meaning of the <i>pvSubInstance</i> depends on the option specified by the value of the <i>ulInfoClass</i> parameter.</para>
      <para>This parameter may be null.</para>
      <list type="table">
        <listheader>
          <description>ulInfoClass Option</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>AssemblyDetailedInformationInActivationContext</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Pointer to a <b>DWORD</b> that specifies the index of the assembly within the activation context. This is the activation context that <b>QueryActCtxW</b> queries.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FileInformationInAssemblyOfAssemblyInActivationContext</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Pointer to an <see cref="ACTIVATION_CONTEXT_QUERY_INDEX" /> structure. If <b>QueryActCtxW</b> is called with this option and the function succeeds, the returned buffer contains information for a file in the assembly. This information is in the form of the <see cref="ASSEMBLY_FILE_DETAILED_INFORMATION" /> structure.</description>
        </listheader>
      </list>
    </param>
    <param name="ulInfoClass">
      <para>This parameter can have only the values shown in the following table.</para>
      <list type="table">
        <listheader>
          <description>Option</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ActivationContextBasicInformation</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>Not available.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ActivationContextDetailedInformation</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>If <b>QueryActCtxW</b> is called with this option and the function succeeds, the returned buffer contains detailed information about the activation context. This information is in the form of the <see cref="ACTIVATION_CONTEXT_DETAILED_INFORMATION" /> structure.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>AssemblyDetailedInformationInActivationContext</b>
                </term>
              </listheader>
              <listheader>
                <term>3</term>
              </listheader>
            </list>
          </description>
          <description>If <b>QueryActCtxW</b> is called with this option and the function succeeds, the buffer contains information about the assembly that has the index specified in <i>pvSubInstance</i>. This information is in the form of the <see cref="ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION" /> structure.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FileInformationInAssemblyOfAssemblyInActivationContext</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>Information about a file in one of the assemblies in Activation Context. The <i>pvSubInstance</i> parameter must point to an <see cref="ACTIVATION_CONTEXT_QUERY_INDEX" /> structure. If <b>QueryActCtxW</b> is called with this option and the function succeeds, the returned buffer contains information for a file in the assembly. This information is in the form of the <see cref="ASSEMBLY_FILE_DETAILED_INFORMATION" /> structure.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>RunlevelInformationInActivationContext</b>
                </term>
              </listheader>
              <listheader>
                <term>5</term>
              </listheader>
            </list>
          </description>
          <description>If <b>QueryActCtxW</b> is called with this option and the function succeeds, the buffer contains information about requested run level of the activation context. This information is in the form of the <see cref="ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION" /> structure.<para><b>Windows Server 2003 and Windows XP:  </b>This value is not available.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>CompatibilityInformationInActivationContext</b>
                </term>
              </listheader>
              <listheader>
                <term>6</term>
              </listheader>
            </list>
          </description>
          <description>If <b>QueryActCtxW</b> is called with this option and the function succeeds, the buffer contains information about requested compatibility context. This information is in the form of the <see cref="ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION" /> structure.<para><b>Windows Server 2008 and earlier, and Windows Vista and earlier:  </b>This value is not available. This option is available beginning with Windows Server 2008 R2 and Windows 7.</para></description>
        </listheader>
      </list>
    </param>
    <param name="pvBuffer">Pointer to a buffer that holds the returned information. This parameter is optional. If <i>pvBuffer</i> is <b>null</b>, then <i>cbBuffer</i> must be zero. If the size of the buffer pointed to by <i>pvBuffer</i> is too small,<b>QueryActCtxW</b> returns ERROR_INSUFFICIENT_BUFFER and no data is written into the buffer. See the Remarks section for the method you can use to determine the required size of the buffer.</param>
    <param name="cbBuffer">Size of the buffer in bytes pointed to by <i>pvBuffer</i>. This parameter is optional.</param>
    <param name="pcbWrittenOrRequired">Number of bytes written or required. The parameter <i>pcbWrittenOrRequired</i> can only be <b>NULL</b> when <i>pvBuffer</i> is <b>NULL</b>. If <i>pcbWrittenOrRequired</i> is non-<b>NULL</b>, it is filled with the number of bytes required to store the returned buffer.</param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling<see cref="GetLastError" />. For an example, see<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
  </member>
  <member name="Windows.QueryDosDevice">
    <summary>
      <para>Retrieves information about MS-DOS device names. The function can obtain the current mapping for a particular MS-DOS device name. The function can also obtain a list of all existing MS-DOS device names.</para>
      <para>MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path into a corresponding path uses these junctions to map MS-DOS devices and drive letters. The<b>QueryDosDevice</b> function enables an application to query the names of the junctions used to implement the MS-DOS device namespace as well as the value of each specific junction.</para>
    </summary>
    <param name="lpDeviceName">
      <para>An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing backslash; for example, use "C:", not "C:\".</para>
      <para>This parameter can be <b>NULL</b>. In that case, the<b>QueryDosDevice</b> function will store a list of all existing MS-DOS device names into the buffer pointed to by <i>lpTargetPath</i>.</para>
    </param>
    <param name="lpTargetPath">
      <para>A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or more null-terminated strings. The final null-terminated string is followed by an additional<b>NULL</b>.</para>
      <para>If <i>lpDeviceName</i> is non-<b>NULL</b>, the function retrieves information about the particular MS-DOS device specified by <i>lpDeviceName</i>. The first null-terminated string stored into the buffer is the current mapping for the device. The other null-terminated strings represent undeleted prior mappings for the device.</para>
      <para>If <i>lpDeviceName</i> is <b>NULL</b>, the function retrieves a list of all existing MS-DOS device names. Each null-terminated string stored into the buffer is the name of an existing MS-DOS device, for example, \Device\HarddiskVolume1 or \Device\Floppy0.</para>
    </param>
    <param name="ucchMax">The maximum number of <b>TCHARs</b> that can be stored into the buffer pointed to by<i>lpTargetPath</i>.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of <b>TCHARs</b> stored into the buffer pointed to by <i>lpTargetPath</i>.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the buffer is too small, the function fails and the last error code is<b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
    </returns>
  </member>
  <member name="Windows.QueryDosDeviceA">
    <summary>
      <para>Retrieves information about MS-DOS device names. The function can obtain the current mapping for a particular MS-DOS device name. The function can also obtain a list of all existing MS-DOS device names.</para>
      <para>MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path into a corresponding path uses these junctions to map MS-DOS devices and drive letters. The<b>QueryDosDevice</b> function enables an application to query the names of the junctions used to implement the MS-DOS device namespace as well as the value of each specific junction.</para>
    </summary>
    <param name="lpDeviceName">
      <para>An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing backslash; for example, use "C:", not "C:\".</para>
      <para>This parameter can be <b>NULL</b>. In that case, the<b>QueryDosDevice</b> function will store a list of all existing MS-DOS device names into the buffer pointed to by <i>lpTargetPath</i>.</para>
    </param>
    <param name="lpTargetPath">
      <para>A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or more null-terminated strings. The final null-terminated string is followed by an additional<b>NULL</b>.</para>
      <para>If <i>lpDeviceName</i> is non-<b>NULL</b>, the function retrieves information about the particular MS-DOS device specified by <i>lpDeviceName</i>. The first null-terminated string stored into the buffer is the current mapping for the device. The other null-terminated strings represent undeleted prior mappings for the device.</para>
      <para>If <i>lpDeviceName</i> is <b>NULL</b>, the function retrieves a list of all existing MS-DOS device names. Each null-terminated string stored into the buffer is the name of an existing MS-DOS device, for example, \Device\HarddiskVolume1 or \Device\Floppy0.</para>
    </param>
    <param name="ucchMax">The maximum number of <b>TCHARs</b> that can be stored into the buffer pointed to by<i>lpTargetPath</i>.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of <b>TCHARs</b> stored into the buffer pointed to by <i>lpTargetPath</i>.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the buffer is too small, the function fails and the last error code is<b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
    </returns>
  </member>
  <member name="Windows.QueryDosDeviceW">
    <summary>
      <para>Retrieves information about MS-DOS device names. The function can obtain the current mapping for a particular MS-DOS device name. The function can also obtain a list of all existing MS-DOS device names.</para>
      <para>MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path into a corresponding path uses these junctions to map MS-DOS devices and drive letters. The<b>QueryDosDevice</b> function enables an application to query the names of the junctions used to implement the MS-DOS device namespace as well as the value of each specific junction.</para>
    </summary>
    <param name="lpDeviceName">
      <para>An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing backslash; for example, use "C:", not "C:\".</para>
      <para>This parameter can be <b>NULL</b>. In that case, the<b>QueryDosDevice</b> function will store a list of all existing MS-DOS device names into the buffer pointed to by <i>lpTargetPath</i>.</para>
    </param>
    <param name="lpTargetPath">
      <para>A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or more null-terminated strings. The final null-terminated string is followed by an additional<b>NULL</b>.</para>
      <para>If <i>lpDeviceName</i> is non-<b>NULL</b>, the function retrieves information about the particular MS-DOS device specified by <i>lpDeviceName</i>. The first null-terminated string stored into the buffer is the current mapping for the device. The other null-terminated strings represent undeleted prior mappings for the device.</para>
      <para>If <i>lpDeviceName</i> is <b>NULL</b>, the function retrieves a list of all existing MS-DOS device names. Each null-terminated string stored into the buffer is the name of an existing MS-DOS device, for example, \Device\HarddiskVolume1 or \Device\Floppy0.</para>
    </param>
    <param name="ucchMax">The maximum number of <b>TCHARs</b> that can be stored into the buffer pointed to by<i>lpTargetPath</i>.</param>
    <returns>
      <para>If the function succeeds, the return value is the number of <b>TCHARs</b> stored into the buffer pointed to by <i>lpTargetPath</i>.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the buffer is too small, the function fails and the last error code is<b>ERROR_INSUFFICIENT_BUFFER</b>.</para>
    </returns>
  </member>
  <member name="Windows.QueryFullProcessImageName">
    <summary>Retrieves the full name of the executable image for the specified process.</summary>
    <param name="hProcess">A handle to the process. This handle must be created with the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
    <param name="dwFlags">
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The name should use the Win32 path format.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PROCESS_NAME_NATIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The name should use the native system path format.</description>
        </listheader>
      </list>
    </param>
    <param name="lpExeName">The path to the executable image. If the function succeeds, this string is null-terminated.</param>
    <param name="lpdwSize">On input, specifies the size of the <i>lpExeName</i> buffer, in characters. On success, receives the number of characters written to the buffer, not including the null-terminating character.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.QueryFullProcessImageNameA">
    <summary>Retrieves the full name of the executable image for the specified process.</summary>
    <param name="hProcess">A handle to the process. This handle must be created with the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
    <param name="dwFlags">
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The name should use the Win32 path format.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PROCESS_NAME_NATIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The name should use the native system path format.</description>
        </listheader>
      </list>
    </param>
    <param name="lpExeName">The path to the executable image. If the function succeeds, this string is null-terminated.</param>
    <param name="lpdwSize">On input, specifies the size of the <i>lpExeName</i> buffer, in characters. On success, receives the number of characters written to the buffer, not including the null-terminating character.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.QueryFullProcessImageNameW">
    <summary>Retrieves the full name of the executable image for the specified process.</summary>
    <param name="hProcess">A handle to the process. This handle must be created with the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
    <param name="dwFlags">
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The name should use the Win32 path format.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PROCESS_NAME_NATIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The name should use the native system path format.</description>
        </listheader>
      </list>
    </param>
    <param name="lpExeName">The path to the executable image. If the function succeeds, this string is null-terminated.</param>
    <param name="lpdwSize">On input, specifies the size of the <i>lpExeName</i> buffer, in characters. On success, receives the number of characters written to the buffer, not including the null-terminating character.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.QueryFullProcessImageName">
    <summary>Retrieves the full name of the executable image for the specified process.</summary>
    <param name="hProcess">A handle to the process. This handle must be created with the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
    <param name="dwFlags">
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The name should use the Win32 path format.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PROCESS_NAME_NATIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The name should use the native system path format.</description>
        </listheader>
      </list>
    </param>
    <param name="lpExeName">The path to the executable image. If the function succeeds, this string is null-terminated.</param>
    <param name="lpdwSize">On input, specifies the size of the <i>lpExeName</i> buffer, in characters. On success, receives the number of characters written to the buffer, not including the null-terminating character.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.QueryFullProcessImageNameA">
    <summary>Retrieves the full name of the executable image for the specified process.</summary>
    <param name="hProcess">A handle to the process. This handle must be created with the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
    <param name="dwFlags">
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The name should use the Win32 path format.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PROCESS_NAME_NATIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The name should use the native system path format.</description>
        </listheader>
      </list>
    </param>
    <param name="lpExeName">The path to the executable image. If the function succeeds, this string is null-terminated.</param>
    <param name="lpdwSize">On input, specifies the size of the <i>lpExeName</i> buffer, in characters. On success, receives the number of characters written to the buffer, not including the null-terminating character.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.QueryFullProcessImageNameW">
    <summary>Retrieves the full name of the executable image for the specified process.</summary>
    <param name="hProcess">A handle to the process. This handle must be created with the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
    <param name="dwFlags">
      <para>This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The name should use the Win32 path format.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PROCESS_NAME_NATIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The name should use the native system path format.</description>
        </listheader>
      </list>
    </param>
    <param name="lpExeName">The path to the executable image. If the function succeeds, this string is null-terminated.</param>
    <param name="lpdwSize">On input, specifies the size of the <i>lpExeName</i> buffer, in characters. On success, receives the number of characters written to the buffer, not including the null-terminating character.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.QueryThreadProfiling">
    <summary>Determines whether thread profiling is enabled for the specified thread.</summary>
    <param name="ThreadHandle">The handle to the thread of interest.</param>
    <param name="Enabled">Is <b>TRUE</b> if thread profiling is enabled for the specified thread; otherwise, <b>FALSE</b>.</param>
    <returns>Returns ERROR_SUCCESS if the call is successful; otherwise, a system error code (see Winerror.h).</returns>
  </member>
  <member name="Windows.QueryUmsThreadInformation">
    <summary>
      <para>Retrieves information about the specified user-mode scheduling (UMS) worker thread.</para>
      <blockquote>[!WARNING] As of Windows 11, user-mode scheduling is not supported. All calls fail with the error <code>ERROR_NOT_SUPPORTED</code>.</blockquote>
    </summary>
    <param name="UmsThread">A pointer to a UMS thread context.</param>
    <param name="UmsThreadInfoClass">A UMS_THREAD_INFO_CLASS value that specifies the kind of information to retrieve.</param>
    <param name="UmsThreadInformation">
      <para>A pointer to a buffer to receive the specified information. The required size of this buffer depends on the specified information class.</para>
      <para>If the information class is <b>UmsThreadContext</b> or <b>UmsThreadTeb</b>, the buffer must be <code>sizeof(PVOID)</code>.</para>
      <para>If the information class is <b>UmsThreadIsSuspended</b> or <b>UmsThreadIsTerminated</b>, the buffer must be <code>sizeof(BOOLEAN)</code>.</para>
    </param>
    <param name="UmsThreadInformationLength">The size of the <i>UmsThreadInformation</i> buffer, in bytes.</param>
    <param name="ReturnLength">A pointer to a ULONG variable. On output, this parameter receives the number of bytes written to the <i>UmsThreadInformation</i> buffer.</param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. Possible error values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INFO_LENGTH_MISMATCH</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The buffer is too small for the requested information.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_INFO_CLASS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified information class is not supported.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_SUPPORTED</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>UMS is not supported.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.ReadDirectoryChangesExW">
    <summary>
      <para>Retrieves information that describes the changes within the specified directory, which can include extended information if that information type is specified. The function does not report changes to the specified directory itself.</para>
      <para>To track changes on a volume, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/change-journals">change journals</a>.</para>
    </summary>
    <param name="hDirectory">A handle to the directory to be monitored. This directory must be opened with the<b>FILE_LIST_DIRECTORY</b> access right, or an access right such as <b>GENERIC_READ</b> that includes the <b>FILE_LIST_DIRECTORY</b> access right.</param>
    <param name="lpBuffer">
      <para>A pointer to the <b>DWORD</b>-aligned formatted buffer in which <b>ReadDirectoryChangesExW</b> should return the read results. The structure of this buffer is defined by the<see cref="FILE_NOTIFY_EXTENDED_INFORMATION" /> structure if the value of the <i>ReadDirectoryNotifyInformationClass</i> parameter is <b>ReadDirectoryNotifyExtendedInformation</b>, or by the <see cref="FILE_NOTIFY_INFORMATION" /> structure if <i>ReadDirectoryNotifyInformationClass</i> is <b>ReadDirectoryNotifyInformation</b>.</para>
      <para>This buffer is filled either synchronously or asynchronously, depending on how the directory is opened and what value is given to the <i>lpOverlapped</i> parameter. For more information, see the Remarks section.</para>
    </param>
    <param name="nBufferLength">The size of the buffer to which the <i>lpBuffer</i> parameter points, in bytes.</param>
    <param name="bWatchSubtree">If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory. If this parameter is <b>FALSE</b>, the function monitors only the directory specified by the <i>hDirectory</i> parameter.</param>
    <param name="dwNotifyFilter">
      <para>The filter criteria that the function checks to determine if the wait operation has completed. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_FILE_NAME</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Any file name change in the watched directory or subtree causes a change notification wait operation to return. Changes include renaming, creating, or deleting a file.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_DIR_NAME</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Any directory-name change in the watched directory or subtree causes a change notification wait operation to return. Changes include creating or deleting a directory.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_ATTRIBUTES</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>Any attribute change in the watched directory or subtree causes a change notification wait operation to return.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_SIZE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>Any file-size change in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change in file size only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_LAST_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000010</term>
              </listheader>
            </list>
          </description>
          <description>Any change to the last write-time of files in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change to the last write-time only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_LAST_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000020</term>
              </listheader>
            </list>
          </description>
          <description>Any change to the last access time of files in the watched directory or subtree causes a change notification wait operation to return.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_CREATION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000040</term>
              </listheader>
            </list>
          </description>
          <description>Any change to the creation time of files in the watched directory or subtree causes a change notification wait operation to return.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_SECURITY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000100</term>
              </listheader>
            </list>
          </description>
          <description>Any security-descriptor change in the watched directory or subtree causes a change notification wait operation to return.</description>
        </listheader>
      </list>
    </param>
    <param name="lpBytesReturned">For synchronous calls, this parameter receives the number of bytes transferred into the<i>lpBuffer</i> parameter. For asynchronous calls, this parameter is undefined. You must use an asynchronous notification technique to retrieve the number of bytes transferred.</param>
    <param name="lpOverlapped">A pointer to an <see cref="OVERLAPPED" /> structure that supplies data to be used during asynchronous operation. Otherwise, this value is <b>NULL</b>. The<b>Offset</b> and <b>OffsetHigh</b> members of this structure are not used.</param>
    <param name="lpCompletionRoutine">A pointer to a completion routine to be called when the operation has been completed or canceled and the calling thread is in an alertable wait state. For more information about this completion routine, see<a href="https://docs.microsoft.com//windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</a>.</param>
    <param name="ReadDirectoryNotifyInformationClass">The type of information that<b>ReadDirectoryChangesExW</b> should write to the buffer to which the <i>lpBuffer</i> parameter points. Specify <b>ReadDirectoryNotifyInformation</b> to indicate that the information should consist of <see cref="FILE_NOTIFY_INFORMATION" /> structures, or <b>ReadDirectoryNotifyExtendedInformation</b> to indicate that the information should consist of <see cref="FILE_NOTIFY_EXTENDED_INFORMATION" /> structures.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero. For synchronous calls, this means that the operation succeeded. For asynchronous calls, this indicates that the operation was successfully queued.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the network redirector or the target file system does not support this operation, the function fails with<b>ERROR_INVALID_FUNCTION</b>.</para>
    </returns>
  </member>
  <member name="Windows.ReadDirectoryChangesW">
    <summary>
      <para>Retrieves information that describes the changes within the specified directory. The function does not report changes to the specified directory itself.</para>
      <para>To track changes on a volume, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/change-journals">change journals</a>.</para>
    </summary>
    <param name="hDirectory">A handle to the directory to be monitored. This directory must be opened with the<b>FILE_LIST_DIRECTORY</b> access right, or an access right such as <b>GENERIC_READ</b> that includes the <b>FILE_LIST_DIRECTORY</b> access right.</param>
    <param name="lpBuffer">A pointer to the <b>DWORD</b>-aligned formatted buffer in which the read results are to be returned. The structure of this buffer is defined by the<see cref="FILE_NOTIFY_INFORMATION" /> structure. This buffer is filled either synchronously or asynchronously, depending on how the directory is opened and what value is given to the <i>lpOverlapped</i> parameter. For more information, see the Remarks section.</param>
    <param name="nBufferLength">The size of the buffer that is pointed to by the <i>lpBuffer</i> parameter, in bytes.</param>
    <param name="bWatchSubtree">If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory. If this parameter is <b>FALSE</b>, the function monitors only the directory specified by the <i>hDirectory</i> parameter.</param>
    <param name="dwNotifyFilter">
      <para>The filter criteria that the function checks to determine if the wait operation has completed. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_FILE_NAME</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Any file name change in the watched directory or subtree causes a change notification wait operation to return. Changes include renaming, creating, or deleting a file.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_DIR_NAME</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Any directory-name change in the watched directory or subtree causes a change notification wait operation to return. Changes include creating or deleting a directory.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_ATTRIBUTES</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>Any attribute change in the watched directory or subtree causes a change notification wait operation to return.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_SIZE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>Any file-size change in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change in file size only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_LAST_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000010</term>
              </listheader>
            </list>
          </description>
          <description>Any change to the last write-time of files in the watched directory or subtree causes a change notification wait operation to return. The operating system detects a change to the last write-time only when the file is written to the disk. For operating systems that use extensive caching, detection occurs only when the cache is sufficiently flushed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_LAST_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000020</term>
              </listheader>
            </list>
          </description>
          <description>Any change to the last access time of files in the watched directory or subtree causes a change notification wait operation to return.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_CREATION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000040</term>
              </listheader>
            </list>
          </description>
          <description>Any change to the creation time of files in the watched directory or subtree causes a change notification wait operation to return.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_NOTIFY_CHANGE_SECURITY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000100</term>
              </listheader>
            </list>
          </description>
          <description>Any security-descriptor change in the watched directory or subtree causes a change notification wait operation to return.</description>
        </listheader>
      </list>
    </param>
    <param name="lpBytesReturned">For synchronous calls, this parameter receives the number of bytes transferred into the<i>lpBuffer</i> parameter. For asynchronous calls, this parameter is undefined. You must use an asynchronous notification technique to retrieve the number of bytes transferred.</param>
    <param name="lpOverlapped">A pointer to an <see cref="OVERLAPPED" /> structure that supplies data to be used during asynchronous operation. Otherwise, this value is <b>NULL</b>. The<b>Offset</b> and <b>OffsetHigh</b> members of this structure are not used.</param>
    <param name="lpCompletionRoutine">A pointer to a completion routine to be called when the operation has been completed or canceled and the calling thread is in an alertable wait state. For more information about this completion routine, see<a href="https://docs.microsoft.com//windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero. For synchronous calls, this means that the operation succeeded. For asynchronous calls, this indicates that the operation was successfully queued.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the network redirector or the target file system does not support this operation, the function fails with<b>ERROR_INVALID_FUNCTION</b>.</para>
    </returns>
  </member>
  <member name="Windows.ReadEncryptedFileRaw">
    <summary>Backs up (export) encrypted files. This is one of a group of Encrypted File System (EFS) functions that is intended to implement backup and restore functionality, while maintaining files in their encrypted state.</summary>
    <param name="pfExportCallback">A pointer to the export callback function. The system calls the callback function multiple times, each time passing a block of the file's data to the callback function until the entire file has been read. For more information, see <a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-pfe_export_func">ExportCallback</a>.</param>
    <param name="pvCallbackContext">A pointer to an application-defined and allocated context block. The system passes this pointer to the callback function as a parameter so that the callback function can have access to application-specific data. This can be a structure and can contain any data the application needs, such as the handle to the file that will contain the backup copy of the encrypted file.</param>
    <param name="pvContext">A pointer to a system-defined context block. The context block is returned by the<see cref="OpenEncryptedFileRaw" /> function. Do not modify it.</param>
    <returns>
      <para>If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, it returns a nonzero error code defined in WinError.h. You can use<see cref="FormatMessage" /> with the<b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of the error.</para>
    </returns>
  </member>
  <member name="Windows.ReadEventLog">
    <summary>Reads the specified number of entries from the specified event log. The function can be used to read log entries in chronological or reverse chronological order.</summary>
    <param name="hEventLog">A handle to the event log to be read. The<see cref="OpenEventLog" /> function returns this handle.</param>
    <param name="dwReadFlags">
      <para>Use the following flag values to indicate how to read the log file. This parameter must include one of the following values (the flags are mutually exclusive).</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_SEEK_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0002</term>
              </listheader>
            </list>
          </description>
          <description>Begin reading from the record specified in the <i>dwRecordOffset</i> parameter. <para>This option may not work with large log files if the function cannot determine the log file's size. For details, see Knowledge Base article, 177199.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_SEQUENTIAL_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0001</term>
              </listheader>
            </list>
          </description>
          <description>Read the records sequentially. <para>If this is the first read operation, the EVENTLOG_FORWARDS_READ EVENTLOG_BACKWARDS_READ flags determines which record is read first.</para></description>
        </listheader>
      </list> <para>You must specify one of the following flags to indicate the direction for successive read operations (the flags are mutually exclusive).</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>EVENTLOG_FORWARDS_READ</b></term></listheader><listheader><term>0x0004</term></listheader></list></description><description>The log is read in chronological order (oldest to newest). <para>The default.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>EVENTLOG_BACKWARDS_READ</b></term></listheader><listheader><term>0x0008</term></listheader></list></description><description>The log is read in reverse chronological order (newest to oldest).</description></listheader></list></param>
    <param name="dwRecordOffset">The record number of the log-entry at which the read operation should start. This parameter is ignored unless <i>dwReadFlags</i> includes the <b>EVENTLOG_SEEK_READ</b> flag.</param>
    <param name="lpBuffer">
      <para>An application-allocated buffer that will receive one or more <see cref="EVENTLOGRECORD" /> structures. This parameter cannot be <b>NULL</b>, even if the <i>nNumberOfBytesToRead</i> parameter is zero.</para>
      <para>The maximum size of this buffer is 0x7ffff bytes.</para>
    </param>
    <param name="nNumberOfBytesToRead">The size of the <i>lpBuffer</i> buffer, in bytes. This function will read as many log entries as will fit in the buffer; the function will not return partial entries.</param>
    <param name="pnBytesRead">A pointer to a variable that receives the number of bytes read by the function.</param>
    <param name="pnMinNumberOfBytesNeeded">A pointer to a variable that receives the required size of the <i>lpBuffer</i> buffer. This value is valid only if this function returns zero and<see cref="GetLastError" /> returns <b>ERROR_INSUFFICIENT_BUFFER</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ReadEventLogA">
    <summary>Reads the specified number of entries from the specified event log. The function can be used to read log entries in chronological or reverse chronological order.</summary>
    <param name="hEventLog">A handle to the event log to be read. The<see cref="OpenEventLog" /> function returns this handle.</param>
    <param name="dwReadFlags">
      <para>Use the following flag values to indicate how to read the log file. This parameter must include one of the following values (the flags are mutually exclusive).</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_SEEK_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0002</term>
              </listheader>
            </list>
          </description>
          <description>Begin reading from the record specified in the <i>dwRecordOffset</i> parameter. <para>This option may not work with large log files if the function cannot determine the log file's size. For details, see Knowledge Base article, 177199.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_SEQUENTIAL_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0001</term>
              </listheader>
            </list>
          </description>
          <description>Read the records sequentially. <para>If this is the first read operation, the EVENTLOG_FORWARDS_READ EVENTLOG_BACKWARDS_READ flags determines which record is read first.</para></description>
        </listheader>
      </list> <para>You must specify one of the following flags to indicate the direction for successive read operations (the flags are mutually exclusive).</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>EVENTLOG_FORWARDS_READ</b></term></listheader><listheader><term>0x0004</term></listheader></list></description><description>The log is read in chronological order (oldest to newest). <para>The default.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>EVENTLOG_BACKWARDS_READ</b></term></listheader><listheader><term>0x0008</term></listheader></list></description><description>The log is read in reverse chronological order (newest to oldest).</description></listheader></list></param>
    <param name="dwRecordOffset">The record number of the log-entry at which the read operation should start. This parameter is ignored unless <i>dwReadFlags</i> includes the <b>EVENTLOG_SEEK_READ</b> flag.</param>
    <param name="lpBuffer">
      <para>An application-allocated buffer that will receive one or more <see cref="EVENTLOGRECORD" /> structures. This parameter cannot be <b>NULL</b>, even if the <i>nNumberOfBytesToRead</i> parameter is zero.</para>
      <para>The maximum size of this buffer is 0x7ffff bytes.</para>
    </param>
    <param name="nNumberOfBytesToRead">The size of the <i>lpBuffer</i> buffer, in bytes. This function will read as many log entries as will fit in the buffer; the function will not return partial entries.</param>
    <param name="pnBytesRead">A pointer to a variable that receives the number of bytes read by the function.</param>
    <param name="pnMinNumberOfBytesNeeded">A pointer to a variable that receives the required size of the <i>lpBuffer</i> buffer. This value is valid only if this function returns zero and<see cref="GetLastError" /> returns <b>ERROR_INSUFFICIENT_BUFFER</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ReadEventLogW">
    <summary>Reads the specified number of entries from the specified event log. The function can be used to read log entries in chronological or reverse chronological order.</summary>
    <param name="hEventLog">A handle to the event log to be read. The<see cref="OpenEventLog" /> function returns this handle.</param>
    <param name="dwReadFlags">
      <para>Use the following flag values to indicate how to read the log file. This parameter must include one of the following values (the flags are mutually exclusive).</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_SEEK_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0002</term>
              </listheader>
            </list>
          </description>
          <description>Begin reading from the record specified in the <i>dwRecordOffset</i> parameter. <para>This option may not work with large log files if the function cannot determine the log file's size. For details, see Knowledge Base article, 177199.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_SEQUENTIAL_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0001</term>
              </listheader>
            </list>
          </description>
          <description>Read the records sequentially. <para>If this is the first read operation, the EVENTLOG_FORWARDS_READ EVENTLOG_BACKWARDS_READ flags determines which record is read first.</para></description>
        </listheader>
      </list> <para>You must specify one of the following flags to indicate the direction for successive read operations (the flags are mutually exclusive).</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>EVENTLOG_FORWARDS_READ</b></term></listheader><listheader><term>0x0004</term></listheader></list></description><description>The log is read in chronological order (oldest to newest). <para>The default.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>EVENTLOG_BACKWARDS_READ</b></term></listheader><listheader><term>0x0008</term></listheader></list></description><description>The log is read in reverse chronological order (newest to oldest).</description></listheader></list></param>
    <param name="dwRecordOffset">The record number of the log-entry at which the read operation should start. This parameter is ignored unless <i>dwReadFlags</i> includes the <b>EVENTLOG_SEEK_READ</b> flag.</param>
    <param name="lpBuffer">
      <para>An application-allocated buffer that will receive one or more <see cref="EVENTLOGRECORD" /> structures. This parameter cannot be <b>NULL</b>, even if the <i>nNumberOfBytesToRead</i> parameter is zero.</para>
      <para>The maximum size of this buffer is 0x7ffff bytes.</para>
    </param>
    <param name="nNumberOfBytesToRead">The size of the <i>lpBuffer</i> buffer, in bytes. This function will read as many log entries as will fit in the buffer; the function will not return partial entries.</param>
    <param name="pnBytesRead">A pointer to a variable that receives the number of bytes read by the function.</param>
    <param name="pnMinNumberOfBytesNeeded">A pointer to a variable that receives the required size of the <i>lpBuffer</i> buffer. This value is valid only if this function returns zero and<see cref="GetLastError" /> returns <b>ERROR_INSUFFICIENT_BUFFER</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ReadEventLog">
    <summary>Reads the specified number of entries from the specified event log. The function can be used to read log entries in chronological or reverse chronological order.</summary>
    <param name="hEventLog">A handle to the event log to be read. The<see cref="OpenEventLog" /> function returns this handle.</param>
    <param name="dwReadFlags">
      <para>Use the following flag values to indicate how to read the log file. This parameter must include one of the following values (the flags are mutually exclusive).</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_SEEK_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0002</term>
              </listheader>
            </list>
          </description>
          <description>Begin reading from the record specified in the <i>dwRecordOffset</i> parameter. <para>This option may not work with large log files if the function cannot determine the log file's size. For details, see Knowledge Base article, 177199.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_SEQUENTIAL_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0001</term>
              </listheader>
            </list>
          </description>
          <description>Read the records sequentially. <para>If this is the first read operation, the EVENTLOG_FORWARDS_READ EVENTLOG_BACKWARDS_READ flags determines which record is read first.</para></description>
        </listheader>
      </list> <para>You must specify one of the following flags to indicate the direction for successive read operations (the flags are mutually exclusive).</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>EVENTLOG_FORWARDS_READ</b></term></listheader><listheader><term>0x0004</term></listheader></list></description><description>The log is read in chronological order (oldest to newest). <para>The default.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>EVENTLOG_BACKWARDS_READ</b></term></listheader><listheader><term>0x0008</term></listheader></list></description><description>The log is read in reverse chronological order (newest to oldest).</description></listheader></list></param>
    <param name="dwRecordOffset">The record number of the log-entry at which the read operation should start. This parameter is ignored unless <i>dwReadFlags</i> includes the <b>EVENTLOG_SEEK_READ</b> flag.</param>
    <param name="lpBuffer">
      <para>An application-allocated buffer that will receive one or more <see cref="EVENTLOGRECORD" /> structures. This parameter cannot be <b>NULL</b>, even if the <i>nNumberOfBytesToRead</i> parameter is zero.</para>
      <para>The maximum size of this buffer is 0x7ffff bytes.</para>
    </param>
    <param name="nNumberOfBytesToRead">The size of the <i>lpBuffer</i> buffer, in bytes. This function will read as many log entries as will fit in the buffer; the function will not return partial entries.</param>
    <param name="pnBytesRead">A pointer to a variable that receives the number of bytes read by the function.</param>
    <param name="pnMinNumberOfBytesNeeded">A pointer to a variable that receives the required size of the <i>lpBuffer</i> buffer. This value is valid only this function returns zero and<see cref="GetLastError" /> returns <b>ERROR_INSUFFICIENT_BUFFER</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ReadEventLogA">
    <summary>Reads the specified number of entries from the specified event log. The function can be used to read log entries in chronological or reverse chronological order.</summary>
    <param name="hEventLog">A handle to the event log to be read. The<see cref="OpenEventLog" /> function returns this handle.</param>
    <param name="dwReadFlags">
      <para>Use the following flag values to indicate how to read the log file. This parameter must include one of the following values (the flags are mutually exclusive).</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_SEEK_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0002</term>
              </listheader>
            </list>
          </description>
          <description>Begin reading from the record specified in the <i>dwRecordOffset</i> parameter. <para>This option may not work with large log files if the function cannot determine the log file's size. For details, see Knowledge Base article, 177199.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_SEQUENTIAL_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0001</term>
              </listheader>
            </list>
          </description>
          <description>Read the records sequentially. <para>If this is the first read operation, the EVENTLOG_FORWARDS_READ EVENTLOG_BACKWARDS_READ flags determines which record is read first.</para></description>
        </listheader>
      </list> <para>You must specify one of the following flags to indicate the direction for successive read operations (the flags are mutually exclusive).</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>EVENTLOG_FORWARDS_READ</b></term></listheader><listheader><term>0x0004</term></listheader></list></description><description>The log is read in chronological order (oldest to newest). <para>The default.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>EVENTLOG_BACKWARDS_READ</b></term></listheader><listheader><term>0x0008</term></listheader></list></description><description>The log is read in reverse chronological order (newest to oldest).</description></listheader></list></param>
    <param name="dwRecordOffset">The record number of the log-entry at which the read operation should start. This parameter is ignored unless <i>dwReadFlags</i> includes the <b>EVENTLOG_SEEK_READ</b> flag.</param>
    <param name="lpBuffer">
      <para>An application-allocated buffer that will receive one or more <see cref="EVENTLOGRECORD" /> structures. This parameter cannot be <b>NULL</b>, even if the <i>nNumberOfBytesToRead</i> parameter is zero.</para>
      <para>The maximum size of this buffer is 0x7ffff bytes.</para>
    </param>
    <param name="nNumberOfBytesToRead">The size of the <i>lpBuffer</i> buffer, in bytes. This function will read as many log entries as will fit in the buffer; the function will not return partial entries.</param>
    <param name="pnBytesRead">A pointer to a variable that receives the number of bytes read by the function.</param>
    <param name="pnMinNumberOfBytesNeeded">A pointer to a variable that receives the required size of the <i>lpBuffer</i> buffer. This value is valid only this function returns zero and<see cref="GetLastError" /> returns <b>ERROR_INSUFFICIENT_BUFFER</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ReadEventLogW">
    <summary>Reads the specified number of entries from the specified event log. The function can be used to read log entries in chronological or reverse chronological order.</summary>
    <param name="hEventLog">A handle to the event log to be read. The<see cref="OpenEventLog" /> function returns this handle.</param>
    <param name="dwReadFlags">
      <para>Use the following flag values to indicate how to read the log file. This parameter must include one of the following values (the flags are mutually exclusive).</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_SEEK_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0002</term>
              </listheader>
            </list>
          </description>
          <description>Begin reading from the record specified in the <i>dwRecordOffset</i> parameter. <para>This option may not work with large log files if the function cannot determine the log file's size. For details, see Knowledge Base article, 177199.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_SEQUENTIAL_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0001</term>
              </listheader>
            </list>
          </description>
          <description>Read the records sequentially. <para>If this is the first read operation, the EVENTLOG_FORWARDS_READ EVENTLOG_BACKWARDS_READ flags determines which record is read first.</para></description>
        </listheader>
      </list> <para>You must specify one of the following flags to indicate the direction for successive read operations (the flags are mutually exclusive).</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>EVENTLOG_FORWARDS_READ</b></term></listheader><listheader><term>0x0004</term></listheader></list></description><description>The log is read in chronological order (oldest to newest). <para>The default.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>EVENTLOG_BACKWARDS_READ</b></term></listheader><listheader><term>0x0008</term></listheader></list></description><description>The log is read in reverse chronological order (newest to oldest).</description></listheader></list></param>
    <param name="dwRecordOffset">The record number of the log-entry at which the read operation should start. This parameter is ignored unless <i>dwReadFlags</i> includes the <b>EVENTLOG_SEEK_READ</b> flag.</param>
    <param name="lpBuffer">
      <para>An application-allocated buffer that will receive one or more <see cref="EVENTLOGRECORD" /> structures. This parameter cannot be <b>NULL</b>, even if the <i>nNumberOfBytesToRead</i> parameter is zero.</para>
      <para>The maximum size of this buffer is 0x7ffff bytes.</para>
    </param>
    <param name="nNumberOfBytesToRead">The size of the <i>lpBuffer</i> buffer, in bytes. This function will read as many log entries as will fit in the buffer; the function will not return partial entries.</param>
    <param name="pnBytesRead">A pointer to a variable that receives the number of bytes read by the function.</param>
    <param name="pnMinNumberOfBytesNeeded">A pointer to a variable that receives the required size of the <i>lpBuffer</i> buffer. This value is valid only this function returns zero and<see cref="GetLastError" /> returns <b>ERROR_INSUFFICIENT_BUFFER</b>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ReadThreadProfilingData">
    <summary>Reads the specified profiling data associated with the thread.</summary>
    <param name="PerformanceDataHandle">The handle that the <see cref="EnableThreadProfiling" /> function returned.</param>
    <param name="Flags">
      <para>One or more of the following flags that specify the counter data to read. The flags must have been set when you called the <see cref="EnableThreadProfiling" /> function.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>READ_THREAD_PROFILING_FLAG_DISPATCHING</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Get the thread profiling data.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>READ_THREAD_PROFILING_FLAG_HARDWARE_COUNTERS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Get the hardware performance counters data.</description>
        </listheader>
      </list>
    </param>
    <param name="PerformanceData">A <see cref="PERFORMANCE_DATA" /> structure that contains the thread profiling and hardware counter data.</param>
    <returns>Returns ERROR_SUCCESS if the call is successful; otherwise, a system error code (see Winerror.h).</returns>
  </member>
  <member name="Windows.RegisterApplicationRecoveryCallback">
    <summary>Registers the active instance of an application for recovery.</summary>
    <param name="pRecoveyCallback">A pointer to the recovery callback function. For more information, see <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/aa373202(v=vs.85)">ApplicationRecoveryCallback</a>.</param>
    <param name="pvParameter">A pointer to a variable to be passed to the callback function. Can be <b>NULL</b>.</param>
    <param name="dwPingInterval">
      <para>The recovery ping interval, in milliseconds. By default, the interval is 5 seconds (RECOVERY_DEFAULT_PING_INTERVAL). The maximum interval is 5 minutes. If you specify zero, the default interval is used.</para>
      <para>You must call the <see cref="ApplicationRecoveryInProgress" /> function within the specified interval to indicate to ARR that you are still actively recovering; otherwise, WER terminates recovery. Typically, you perform recovery in a loop with each iteration lasting no longer than the ping interval. Each iteration performs a block of recovery work followed by a call to <b>ApplicationRecoveryInProgress</b>. Since you also use <b>ApplicationRecoveryInProgress</b> to determine if the user wants to cancel recovery, you should consider a smaller interval, so you do not perform a lot of work unnecessarily.</para>
    </param>
    <param name="dwFlags">Reserved for future use. Set to zero.</param>
    <returns>
      <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>E_FAIL</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Internal error; the registration failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>E_INVALIDARG</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The ping interval cannot be more than five minutes.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.RegisterApplicationRestart">
    <summary>Registers the active instance of an application for restart.</summary>
    <param name="pwzCommandline">
      <para>A pointer to a Unicode string that specifies the command-line arguments for the application when it is restarted. The maximum size of the command line that you can specify is RESTART_MAX_CMD_LINE characters. Do not include the name of the executable in the command line; this function adds it for you.</para>
      <para>If this parameter is <b>NULL</b> or an empty string, the previously registered command line is removed. If the argument contains spaces, use quotes around the argument.</para>
    </param>
    <param name="dwFlags">
      <para>This parameter can be 0 or one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>RESTART_NO_CRASH</b>
                </term>
              </listheader>
              <listheader>
                <term>1</term>
              </listheader>
            </list>
          </description>
          <description>Do not restart the process if it terminates due to an unhandled exception.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>RESTART_NO_HANG</b>
                </term>
              </listheader>
              <listheader>
                <term>2</term>
              </listheader>
            </list>
          </description>
          <description>Do not restart the process if it terminates due to the application not responding.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>RESTART_NO_PATCH</b>
                </term>
              </listheader>
              <listheader>
                <term>4</term>
              </listheader>
            </list>
          </description>
          <description>Do not restart the process if it terminates due to the installation of an update.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>RESTART_NO_REBOOT</b>
                </term>
              </listheader>
              <listheader>
                <term>8</term>
              </listheader>
            </list>
          </description>
          <description>Do not restart the process if the computer is restarted as the result of an update.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>E_FAIL</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Internal error.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>E_INVALIDARG</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified command line is too long.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.RegisterEventSource">
    <summary>Retrieves a registered handle to the specified event log.</summary>
    <param name="lpUNCServerName">The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</param>
    <param name="lpSourceName">
      <para>The name of the <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-sources">event source</a> whose handle is to be retrieved. The source name must be a subkey of a log under the <b>Eventlog</b> registry key. Note that the <b>Security</b> log is for system use only.</para>
      <div>
        <b>Note</b>  This string must not contain characters prohibited in XML Attributes, with the exception of XML Escape sequences such as <b>&amp;lt &amp;gl</b>.</div>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The function returns <b>ERROR_ACCESS_DENIED</b> if <i>lpSourceName</i> specifies the <b>Security</b> event log.</para>
    </returns>
  </member>
  <member name="Windows.RegisterEventSourceA">
    <summary>Retrieves a registered handle to the specified event log.</summary>
    <param name="lpUNCServerName">The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</param>
    <param name="lpSourceName">
      <para>The name of the <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-sources">event source</a> whose handle is to be retrieved. The source name must be a subkey of a log under the <b>Eventlog</b> registry key. Note that the <b>Security</b> log is for system use only.</para>
      <div>
        <b>Note</b>  This string must not contain characters prohibited in XML Attributes, with the exception of XML Escape sequences such as <b>&amp;lt &amp;gl</b>.</div>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The function returns <b>ERROR_ACCESS_DENIED</b> if <i>lpSourceName</i> specifies the <b>Security</b> event log.</para>
    </returns>
  </member>
  <member name="Windows.RegisterEventSourceW">
    <summary>Retrieves a registered handle to the specified event log.</summary>
    <param name="lpUNCServerName">The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</param>
    <param name="lpSourceName">
      <para>The name of the <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-sources">event source</a> whose handle is to be retrieved. The source name must be a subkey of a log under the <b>Eventlog</b> registry key. Note that the <b>Security</b> log is for system use only.</para>
      <div>
        <b>Note</b>  This string must not contain characters prohibited in XML Attributes, with the exception of XML Escape sequences such as <b>&amp;lt &amp;gl</b>.</div>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The function returns <b>ERROR_ACCESS_DENIED</b> if <i>lpSourceName</i> specifies the <b>Security</b> event log.</para>
    </returns>
  </member>
  <member name="Windows.RegisterEventSource">
    <summary>Retrieves a registered handle to the specified event log.</summary>
    <param name="lpUNCServerName">The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</param>
    <param name="lpSourceName">
      <para>The name of the <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-sources">event source</a> whose handle is to be retrieved. The source name must be a subkey of a log under the <b>Eventlog</b> registry key. Note that the <b>Security</b> log is for system use only.</para>
      <div>
        <b>Note</b>  This string must not contain characters prohibited in XML Attributes, with the exception of XML Escape sequences such as <b>&lt;</b> or <b>&gt;</b>.</div>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The function returns <b>ERROR_ACCESS_DENIED</b> if <i>lpSourceName</i> specifies the <b>Security</b> event log.</para>
    </returns>
  </member>
  <member name="Windows.RegisterEventSourceA">
    <summary>Retrieves a registered handle to the specified event log.</summary>
    <param name="lpUNCServerName">The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</param>
    <param name="lpSourceName">
      <para>The name of the <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-sources">event source</a> whose handle is to be retrieved. The source name must be a subkey of a log under the <b>Eventlog</b> registry key. Note that the <b>Security</b> log is for system use only.</para>
      <div>
        <b>Note</b>  This string must not contain characters prohibited in XML Attributes, with the exception of XML Escape sequences such as <b>&lt;</b> or <b>&gt;</b>.</div>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The function returns <b>ERROR_ACCESS_DENIED</b> if <i>lpSourceName</i> specifies the <b>Security</b> event log.</para>
    </returns>
  </member>
  <member name="Windows.RegisterEventSourceW">
    <summary>Retrieves a registered handle to the specified event log.</summary>
    <param name="lpUNCServerName">The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If this parameter is <b>NULL</b>, the local computer is used.</param>
    <param name="lpSourceName">
      <para>The name of the <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-sources">event source</a> whose handle is to be retrieved. The source name must be a subkey of a log under the <b>Eventlog</b> registry key. Note that the <b>Security</b> log is for system use only.</para>
      <div>
        <b>Note</b>  This string must not contain characters prohibited in XML Attributes, with the exception of XML Escape sequences such as <b>&lt;</b> or <b>&gt;</b>.</div>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a handle to the event log.</para>
      <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>The function returns <b>ERROR_ACCESS_DENIED</b> if <i>lpSourceName</i> specifies the <b>Security</b> event log.</para>
    </returns>
  </member>
  <member name="Windows.RegisterWaitForSingleObject">
    <summary>
      <para>Directs a wait thread in the <a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-pooling">thread pool</a> to wait on the object. The wait thread queues the specified callback function to the thread pool when one of the following occurs:</para>
      <list type="bullet">
        <item>
          <description>The specified object is in the signaled state.</description>
        </item>
        <item>
          <description>The time-out interval elapses.</description>
        </item>
      </list>
    </summary>
    <param name="phNewWaitObject">A pointer to a variable that receives a wait handle on return. Note that a wait handle cannot be used in functions that require an object handle, such as<see cref="CloseHandle" />.</param>
    <param name="hObject">
      <para>A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section.</para>
      <para>If this handle is closed while the wait is still pending, the function's behavior is undefined.</para>
      <para>The handles must have the <b>SYNCHRONIZE</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.</para>
    </param>
    <param name="Callback">A pointer to the application-defined function of type <b>WAITORTIMERCALLBACK</b> to be executed when <i>hObject</i> is in the signaled state, or <i>dwMilliseconds</i> elapses. For more information, see<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms687066(v=vs.85)">WaitOrTimerCallback</a>.</param>
    <param name="Context">A single value that is passed to the callback function.</param>
    <param name="dwMilliseconds">The time-out interval, in milliseconds. The function returns if the interval elapses, even if the object's state is nonsignaled. If <i>dwMilliseconds</i> is zero, the function tests the object's state and returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function's time-out interval never elapses.</param>
    <param name="dwFlags">
      <para>This parameter can be one or more of the following values.</para>
      <para>For information about using these values with objects that remain signaled, see the Remarks section.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WT_EXECUTEDEFAULT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000000</term>
              </listheader>
            </list>
          </description>
          <description>By default, the callback function is queued to a non-I/O worker thread.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WT_EXECUTEINIOTHREAD</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>This flag is not used.<para><b>Windows Server 2003 and Windows XP:  </b>The callback function is queued to an I/O worker thread. This flag should be used if the function should be executed in a thread that waits in an alertable state.</para><para>I/O worker threads were removed starting with Windows Vista and Windows Server 2008.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WT_EXECUTEINPERSISTENTTHREAD</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000080</term>
              </listheader>
            </list>
          </description>
          <description>The callback function is queued to a thread that never terminates. It does not guarantee that the same thread is used each time. This flag should be used only for short tasks or it could affect other wait operations. <para>This flag must be set if the thread calls functions that use APCs. For more information, see <a href="https://docs.microsoft.com//windows/desktop/Sync/asynchronous-procedure-calls">Asynchronous Procedure Calls</a>.</para><para>Note that currently no worker thread is truly persistent, although no worker thread will terminate if there are any pending I/O requests.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WT_EXECUTEINWAITTHREAD</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>The callback function is invoked by the wait thread itself. This flag should be used only for short tasks or it could affect other wait operations. <para>Deadlocks can occur if some other thread acquires an exclusive lock and calls the<see cref="UnregisterWait" /> or<a href="https://docs.microsoft.com//windows/desktop/Sync/unregisterwaitex">UnregisterWaitEx</a> function while the callback function is trying to acquire the same lock.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WT_EXECUTELONGFUNCTION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000010</term>
              </listheader>
            </list>
          </description>
          <description>The callback function can perform a long wait. This flag helps the system to decide if it should create a new thread.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WT_EXECUTEONLYONCE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>The thread will no longer wait on the handle after the callback function has been called once. Otherwise, the timer is reset every time the wait operation completes until the wait operation is canceled.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>WT_TRANSFER_IMPERSONATION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000100</term>
              </listheader>
            </list>
          </description>
          <description>Callback functions will use the current access token, whether it is a process or impersonation token. If this flag is not specified, callback functions execute only with the process token.<para><b>Windows XP:  </b>This flag is not supported until Windows XP with SP2 and Windows Server 2003.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<br /><see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ReleaseActCtx">
    <summary>The<b>ReleaseActCtx</b> function decrements the reference count of the specified activation context.</summary>
    <param name="hActCtx">Handle to the<see cref="ACTCTX" /> structure that contains information on the activation context for which the reference count is to be decremented.</param>
    <returns>This function does not return a value. On successful completion, the activation context reference count is decremented. The recipient of the reference-counted object must decrement the reference count when the object is no longer required.</returns>
  </member>
  <member name="Windows.RemoveSecureMemoryCacheCallback">
    <summary>Unregisters a callback function that was previously registered with the <see cref="AddSecureMemoryCacheCallback" /> function.</summary>
    <param name="pfnCallBack">A pointer to the application-defined <a href="https://docs.microsoft.com//windows/desktop/api/winnt/nc-winnt-psecure_memory_cache_callback">SecureMemoryCacheCallback</a> function to remove.</param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>.</para>
      <para>If the function fails, it returns <b>FALSE</b>.</para>
    </returns>
  </member>
  <member name="Windows.ReOpenFile">
    <summary>Reopens the specified file system object with different access rights, sharing mode, and flags.</summary>
    <param name="hOriginalFile">A handle to the object to be reopened. The object must have been created by the<see cref="CreateFile" /> function.</param>
    <param name="dwDesiredAccess">
      <para>The required access to the object. For a list of values, see<a href="https://docs.microsoft.com//windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>. You cannot request an access mode that conflicts with the sharing mode specified in a previous open request whose handle is still open.</para>
      <para>If this parameter is zero (0), the application can query device attributes without accessing the device. This is useful if an application wants to determine the size of a floppy disk drive and the formats it supports without requiring a floppy in the drive.</para>
    </param>
    <param name="dwShareMode">
      <para>The sharing mode of the object. You cannot request a sharing mode that conflicts with the access mode specified in a previous open request whose handle is still open.</para>
      <para>If this parameter is zero (0) and <see cref="CreateFile" /> succeeds, the object cannot be shared and cannot be opened again until the handle is closed.</para>
      <para>To enable other processes to share the object while your process has it open, use a combination of one or more of the following values to specify the type of access they can request when they open the object. These sharing options remain in effect until you close the handle to the object.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SHARE_DELETE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>Enables subsequent open operations on the object to request delete access. Otherwise, other processes cannot open the object if they request delete access.<para>If the object has already been opened with delete access, the sharing mode must include this flag.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SHARE_READ</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Enables subsequent open operations on the object to request read access. Otherwise, other processes cannot open the object if they request read access.<para>If the object has already been opened with read access, the sharing mode must include this flag.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SHARE_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Enables subsequent open operations on the object to request write access. Otherwise, other processes cannot open the object if they request write access.<para>If the object has already been opened with write access, the sharing mode must include this flag.</para></description>
        </listheader>
      </list>
    </param>
    <param name="dwFlagsAndAttributes">
      <para>The file flags. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_FLAG_BACKUP_SEMANTICS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x02000000</term>
              </listheader>
            </list>
          </description>
          <description>Indicates that the file is being opened or created for a backup or restore operation. The system ensures that the calling process overrides file security checks, provided it has the <b>SE_BACKUP_NAME</b> and <b>SE_RESTORE_NAME</b> privileges. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SecBP/changing-privileges-in-a-token">Changing Privileges in a Token</a>.<para>You can also set this flag to obtain a handle to a directory. Where indicated, a directory handle can be passed to some functions in place of a file handle.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_FLAG_DELETE_ON_CLOSE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x04000000</term>
              </listheader>
            </list>
          </description>
          <description>Indicates that the operating system is to delete the file immediately after all of its handles have been closed, not just the specified handle but also any other open or duplicated handles.<para>Subsequent open requests for the file fail, unless <b>FILE_SHARE_DELETE</b> is used.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_FLAG_NO_BUFFERING</b>
                </term>
              </listheader>
              <listheader>
                <term>0x20000000</term>
              </listheader>
            </list>
          </description>
          <description>Instructs the system to open the file with no intermediate buffering or caching. When combined with <b>FILE_FLAG_OVERLAPPED</b>, the flag gives maximum asynchronous performance, because the I/O does not rely on the synchronous operations of the memory manager. However, some I/O operations take longer, because data is not being held in the cache.<para>An application must meet specific requirements when working with files opened with<b>FILE_FLAG_NO_BUFFERING</b>:</para><list type="bullet"><item><description>File access must begin at byte offsets within the file that are integer multiples of the volume sector size.</description></item><item><description>File access must be for numbers of bytes that are integer multiples of the volume sector size. For example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1024, 1536, or 2048 bytes, but not of 335, 981, or 7171 bytes.</description></item><item><description>Buffer addresses for read and write operations should be sector aligned (aligned on addresses in memory that are integer multiples of the volume sector size). Depending on the disk, this requirement may not be enforced.</description></item></list>One way to align buffers on integer multiples of the volume sector size is to use <see cref="VirtualAlloc" /> to allocate the buffers. It allocates memory that is aligned on addresses that are integer multiples of the operating system memory page size. Because both memory page and volume sector sizes are powers of 2, this memory is also aligned on addresses that are integer multiples of a volume sector size. Memory pages are 4-8 KB in size; sectors are 512 bytes (hard disks) or 2048 bytes (CD), and therefore, volume sectors can never be larger than memory pages.<para>An application can determine a volume sector size by calling the<see cref="GetDiskFreeSpace" /> function.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_FLAG_OPEN_NO_RECALL</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00100000</term>
              </listheader>
            </list>
          </description>
          <description>Indicates that the file data is requested, but it should continue to reside in remote storage. It should not be transported back to local storage. This flag is intended for use by remote storage systems.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_FLAG_OPEN_REPARSE_POINT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00200000</term>
              </listheader>
            </list>
          </description>
          <description>When this flag is used, normal <a href="https://docs.microsoft.com//windows/desktop/FileIO/reparse-points">reparse point</a> processing does not occur, and <b>ReOpenFile</b> attempts to open the reparse point. When a file is opened, a file handle is returned, whether or not the filter that controls the reparse point is operational. This flag cannot be used with the <b>CREATE_ALWAYS</b> flag. If the file is not a reparse point, then this flag is ignored.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_FLAG_OVERLAPPED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x40000000</term>
              </listheader>
            </list>
          </description>
          <description>Instructs the system to initialize the object, so that operations that take a significant amount of time to process return <b>ERROR_IO_PENDING</b>. When the operation is finished, the specified event is set to the signaled state.<para>When you specify <b>FILE_FLAG_OVERLAPPED</b>, the file read and write functions<b>must</b> specify an<see cref="OVERLAPPED" /> structure. That is, when<b>FILE_FLAG_OVERLAPPED</b> is specified, an application <b>must</b>perform overlapped reading and writing.</para><para>When <b>FILE_FLAG_OVERLAPPED</b> is specified, the system does not maintain the file pointer. The file position must be passed as part of the <i>lpOverlapped</i> parameter (pointing to an <see cref="OVERLAPPED" /> structure) to the file read and write functions.</para><para>This flag also enables more than one operation to be performed simultaneously with the handle (a simultaneous read and write operation, for example).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_FLAG_POSIX_SEMANTICS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x01000000</term>
              </listheader>
            </list>
          </description>
          <description>Indicates that the file is to be accessed according to POSIX rules. This includes allowing multiple files with names, differing only in case, for file systems that support such naming. Use care when using this option because files created with this flag may not be accessible by applications written for MS-DOS or 16-bit Windows.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_FLAG_RANDOM_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x10000000</term>
              </listheader>
            </list>
          </description>
          <description>Indicates that the file is accessed randomly. The system can use this as a hint to optimize file caching.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_FLAG_SEQUENTIAL_SCAN</b>
                </term>
              </listheader>
              <listheader>
                <term>0x08000000</term>
              </listheader>
            </list>
          </description>
          <description>Indicates that the file is to be accessed sequentially from beginning to end. The system can use this as a hint to optimize file caching. If an application moves the file pointer for random access, optimum caching may not occur; however, correct operation is still guaranteed.<para>Specifying this flag can increase performance for applications that read large files using sequential access. Performance gains can be even more noticeable for applications that read large files mostly sequentially, but occasionally skip over small ranges of bytes.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_FLAG_WRITE_THROUGH</b>
                </term>
              </listheader>
              <listheader>
                <term>0x80000000</term>
              </listheader>
            </list>
          </description>
          <description>Instructs the system to write through any intermediate cache and go directly to disk. The system can still cache write operations, but cannot lazily flush them.</description>
        </listheader>
      </list> <para>If the handle represents the client side of a named pipe, the <i>dwFlags</i> parameter can also contain Security Quality of Service information. For more information, see<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/impersonation-levels">Impersonation Levels</a>. When the calling application specifies the <b>SECURITY_SQOS_PRESENT</b> flag, the<i>dwFlags</i> parameter can contain one or more of the following values.</para><list type="table"><listheader><description>Value</description><description>Meaning</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_ANONYMOUS</b></term></listheader></list></description><description>Impersonate the client at the Anonymous impersonation level.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_CONTEXT_TRACKING</b></term></listheader></list></description><description>The security tracking mode is dynamic. If this flag is not specified, the security tracking mode is static.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_DELEGATION</b></term></listheader></list></description><description>Impersonate the client at the Delegation impersonation level.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_EFFECTIVE_ONLY</b></term></listheader></list></description><description>Only the enabled aspects of the client security context are available to the server. If you do not specify this flag, all aspects of the client security context are available.<para>This allows the client to limit the groups and privileges that a server can use while impersonating the client.</para></description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_IDENTIFICATION</b></term></listheader></list></description><description>Impersonate the client at the Identification impersonation level.</description></listheader><listheader><description><list type="bullet"><listheader><term><b>SECURITY_IMPERSONATION</b></term></listheader></list></description><description>Impersonate the client at the Impersonation impersonation level.</description></listheader></list></param>
    <returns>
      <para>If the function succeeds, the return value is an open handle to the specified file.</para>
      <para>If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.ReportEvent">
    <summary>Writes an entry at the end of the specified event log.</summary>
    <param name="hEventLog">
      <para>A handle to the event log. The<see cref="RegisterEventSource" /> function returns this handle.</para>
      <para>As of Windows XP with SP2, this parameter cannot be a handle to the <b>Security</b> log. To write an event to the <b>Security</b> log, use the <see cref="AuthzReportSecurityEvent" /> function.</para>
    </param>
    <param name="wType">
      <para>The type of event to be logged. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_SUCCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0000</term>
              </listheader>
            </list>
          </description>
          <description>Information event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_AUDIT_FAILURE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0010</term>
              </listheader>
            </list>
          </description>
          <description>Failure Audit event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_AUDIT_SUCCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0008</term>
              </listheader>
            </list>
          </description>
          <description>Success Audit event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_ERROR_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0001</term>
              </listheader>
            </list>
          </description>
          <description>Error event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_INFORMATION_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0004</term>
              </listheader>
            </list>
          </description>
          <description>Information event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_WARNING_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0002</term>
              </listheader>
            </list>
          </description>
          <description>Warning event</description>
        </listheader>
      </list> <para>For more information about event types, see<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-types">Event Types</a>.</para></param>
    <param name="wCategory">The event category. This is source-specific information; the category can have any value. For more information, see<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-categories">Event Categories</a>.</param>
    <param name="dwEventID">The event identifier. The event identifier specifies the entry in the message file associated with the event source. For more information, see <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-identifiers">Event Identifiers</a>.</param>
    <param name="lpUserSid">A pointer to the current user's security identifier. This parameter can be <b>NULL</b> if the security identifier is not required.</param>
    <param name="wNumStrings">The number of insert strings in the array pointed to by the <i>lpStrings</i> parameter. A value of zero indicates that no strings are present.</param>
    <param name="dwDataSize">The number of bytes of event-specific raw (binary) data to write to the log. If this parameter is zero, no event-specific data is present.</param>
    <param name="lpStrings">
      <para>A pointer to a buffer containing an array of null-terminated strings that are merged into the message before Event Viewer displays the string to the user. This parameter must be a valid pointer (or <b>NULL</b>), even if <i>wNumStrings</i> is zero. Each string is limited to 31,839 characters.</para>
      <para>
        <b>Prior to Windows Vista:  </b>Each string is limited to 32K characters.</para>
    </param>
    <param name="lpRawData">A pointer to the buffer containing the binary data. This parameter must be a valid pointer (or <b>NULL</b>), even if the <i>dwDataSize</i> parameter is zero.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero, indicating that the entry was written to the log.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />, which returns one of the following extended error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_PARAMETER</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One of the parameters is not valid.<para>This error is returned on Windows Server 2003 if the message data to be logged is too large. This error is returned by the RPC server on Windows Server 2003 if the <i>dwDataSize</i> parameter is larger than 261,991 (0x3ff67).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_ENOUGH_MEMORY</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Insufficient memory resources are available to complete the operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>RPC_S_INVALID_BOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The array bounds are invalid. <para>This error is returned if the message data to be logged is too large. On Windows Vista and later, this error is returned if the <i>dwDataSize</i> parameter is larger than 61,440 (0xf000).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>RPC_X_BAD_STUB_DATA</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The stub received bad data.<para>This error is returned on Windows XP if the message data to be logged is too large. This error is returned by the RPC server on Windows XP, if the <i>dwDataSize</i> parameter is larger than 262,143 (0x3ffff).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>Other</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use <see cref="FormatMessage" /> to obtain the message string for the returned error.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.ReportEventA">
    <summary>Writes an entry at the end of the specified event log.</summary>
    <param name="hEventLog">
      <para>A handle to the event log. The<see cref="RegisterEventSource" /> function returns this handle.</para>
      <para>As of Windows XP with SP2, this parameter cannot be a handle to the <b>Security</b> log. To write an event to the <b>Security</b> log, use the <see cref="AuthzReportSecurityEvent" /> function.</para>
    </param>
    <param name="wType">
      <para>The type of event to be logged. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_SUCCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0000</term>
              </listheader>
            </list>
          </description>
          <description>Information event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_AUDIT_FAILURE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0010</term>
              </listheader>
            </list>
          </description>
          <description>Failure Audit event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_AUDIT_SUCCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0008</term>
              </listheader>
            </list>
          </description>
          <description>Success Audit event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_ERROR_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0001</term>
              </listheader>
            </list>
          </description>
          <description>Error event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_INFORMATION_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0004</term>
              </listheader>
            </list>
          </description>
          <description>Information event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_WARNING_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0002</term>
              </listheader>
            </list>
          </description>
          <description>Warning event</description>
        </listheader>
      </list> <para>For more information about event types, see<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-types">Event Types</a>.</para></param>
    <param name="wCategory">The event category. This is source-specific information; the category can have any value. For more information, see<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-categories">Event Categories</a>.</param>
    <param name="dwEventID">The event identifier. The event identifier specifies the entry in the message file associated with the event source. For more information, see <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-identifiers">Event Identifiers</a>.</param>
    <param name="lpUserSid">A pointer to the current user's security identifier. This parameter can be <b>NULL</b> if the security identifier is not required.</param>
    <param name="wNumStrings">The number of insert strings in the array pointed to by the <i>lpStrings</i> parameter. A value of zero indicates that no strings are present.</param>
    <param name="dwDataSize">The number of bytes of event-specific raw (binary) data to write to the log. If this parameter is zero, no event-specific data is present.</param>
    <param name="lpStrings">
      <para>A pointer to a buffer containing an array of null-terminated strings that are merged into the message before Event Viewer displays the string to the user. This parameter must be a valid pointer (or <b>NULL</b>), even if <i>wNumStrings</i> is zero. Each string is limited to 31,839 characters.</para>
      <para>
        <b>Prior to Windows Vista:  </b>Each string is limited to 32K characters.</para>
    </param>
    <param name="lpRawData">A pointer to the buffer containing the binary data. This parameter must be a valid pointer (or <b>NULL</b>), even if the <i>dwDataSize</i> parameter is zero.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero, indicating that the entry was written to the log.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />, which returns one of the following extended error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_PARAMETER</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One of the parameters is not valid.<para>This error is returned on Windows Server 2003 if the message data to be logged is too large. This error is returned by the RPC server on Windows Server 2003 if the <i>dwDataSize</i> parameter is larger than 261,991 (0x3ff67).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_ENOUGH_MEMORY</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Insufficient memory resources are available to complete the operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>RPC_S_INVALID_BOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The array bounds are invalid. <para>This error is returned if the message data to be logged is too large. On Windows Vista and later, this error is returned if the <i>dwDataSize</i> parameter is larger than 61,440 (0xf000).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>RPC_X_BAD_STUB_DATA</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The stub received bad data.<para>This error is returned on Windows XP if the message data to be logged is too large. This error is returned by the RPC server on Windows XP, if the <i>dwDataSize</i> parameter is larger than 262,143 (0x3ffff).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>Other</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use <see cref="FormatMessage" /> to obtain the message string for the returned error.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.ReportEventW">
    <summary>Writes an entry at the end of the specified event log.</summary>
    <param name="hEventLog">
      <para>A handle to the event log. The<see cref="RegisterEventSource" /> function returns this handle.</para>
      <para>As of Windows XP with SP2, this parameter cannot be a handle to the <b>Security</b> log. To write an event to the <b>Security</b> log, use the <see cref="AuthzReportSecurityEvent" /> function.</para>
    </param>
    <param name="wType">
      <para>The type of event to be logged. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_SUCCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0000</term>
              </listheader>
            </list>
          </description>
          <description>Information event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_AUDIT_FAILURE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0010</term>
              </listheader>
            </list>
          </description>
          <description>Failure Audit event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_AUDIT_SUCCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0008</term>
              </listheader>
            </list>
          </description>
          <description>Success Audit event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_ERROR_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0001</term>
              </listheader>
            </list>
          </description>
          <description>Error event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_INFORMATION_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0004</term>
              </listheader>
            </list>
          </description>
          <description>Information event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_WARNING_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0002</term>
              </listheader>
            </list>
          </description>
          <description>Warning event</description>
        </listheader>
      </list> <para>For more information about event types, see<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-types">Event Types</a>.</para></param>
    <param name="wCategory">The event category. This is source-specific information; the category can have any value. For more information, see<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-categories">Event Categories</a>.</param>
    <param name="dwEventID">The event identifier. The event identifier specifies the entry in the message file associated with the event source. For more information, see <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-identifiers">Event Identifiers</a>.</param>
    <param name="lpUserSid">A pointer to the current user's security identifier. This parameter can be <b>NULL</b> if the security identifier is not required.</param>
    <param name="wNumStrings">The number of insert strings in the array pointed to by the <i>lpStrings</i> parameter. A value of zero indicates that no strings are present.</param>
    <param name="dwDataSize">The number of bytes of event-specific raw (binary) data to write to the log. If this parameter is zero, no event-specific data is present.</param>
    <param name="lpStrings">
      <para>A pointer to a buffer containing an array of null-terminated strings that are merged into the message before Event Viewer displays the string to the user. This parameter must be a valid pointer (or <b>NULL</b>), even if <i>wNumStrings</i> is zero. Each string is limited to 31,839 characters.</para>
      <para>
        <b>Prior to Windows Vista:  </b>Each string is limited to 32K characters.</para>
    </param>
    <param name="lpRawData">A pointer to the buffer containing the binary data. This parameter must be a valid pointer (or <b>NULL</b>), even if the <i>dwDataSize</i> parameter is zero.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero, indicating that the entry was written to the log.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />, which returns one of the following extended error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_PARAMETER</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One of the parameters is not valid.<para>This error is returned on Windows Server 2003 if the message data to be logged is too large. This error is returned by the RPC server on Windows Server 2003 if the <i>dwDataSize</i> parameter is larger than 261,991 (0x3ff67).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_ENOUGH_MEMORY</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Insufficient memory resources are available to complete the operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>RPC_S_INVALID_BOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The array bounds are invalid. <para>This error is returned if the message data to be logged is too large. On Windows Vista and later, this error is returned if the <i>dwDataSize</i> parameter is larger than 61,440 (0xf000).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>RPC_X_BAD_STUB_DATA</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The stub received bad data.<para>This error is returned on Windows XP if the message data to be logged is too large. This error is returned by the RPC server on Windows XP, if the <i>dwDataSize</i> parameter is larger than 262,143 (0x3ffff).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>Other</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use <see cref="FormatMessage" /> to obtain the message string for the returned error.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.ReportEvent">
    <summary>Writes an entry at the end of the specified event log.</summary>
    <param name="hEventLog">
      <para>A handle to the event log. The<see cref="RegisterEventSource" /> function returns this handle.</para>
      <para>As of Windows XP with SP2, this parameter cannot be a handle to the <b>Security</b> log. To write an event to the <b>Security</b> log, use the <see cref="AuthzReportSecurityEvent" /> function.</para>
    </param>
    <param name="wType">
      <para>The type of event to be logged. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_SUCCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0000</term>
              </listheader>
            </list>
          </description>
          <description>Information event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_AUDIT_FAILURE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0010</term>
              </listheader>
            </list>
          </description>
          <description>Failure Audit event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_AUDIT_SUCCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0008</term>
              </listheader>
            </list>
          </description>
          <description>Success Audit event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_ERROR_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0001</term>
              </listheader>
            </list>
          </description>
          <description>Error event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_INFORMATION_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0004</term>
              </listheader>
            </list>
          </description>
          <description>Information event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_WARNING_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0002</term>
              </listheader>
            </list>
          </description>
          <description>Warning event</description>
        </listheader>
      </list> <para>For more information about event types, see<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-types">Event Types</a>.</para></param>
    <param name="wCategory">The event category. This is source-specific information; the category can have any value. For more information, see<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-categories">Event Categories</a>.</param>
    <param name="dwEventID">The event identifier. The event identifier specifies the entry in the message file associated with the event source. For more information, see <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-identifiers">Event Identifiers</a>.</param>
    <param name="lpUserSid">A pointer to the current user's security identifier. This parameter can be <b>NULL</b> if the security identifier is not required.</param>
    <param name="wNumStrings">The number of insert strings in the array pointed to by the <i>lpStrings</i> parameter. A value of zero indicates that no strings are present.</param>
    <param name="dwDataSize">The number of bytes of event-specific raw (binary) data to write to the log. If this parameter is zero, no event-specific data is present.</param>
    <param name="lpStrings">
      <para>A pointer to a buffer containing an array of null-terminated strings that are merged into the message before Event Viewer displays the string to the user. This parameter must be a valid pointer (or <b>NULL</b>), even if <i>wNumStrings</i> is zero. Each string is limited to 31,839 characters.</para>
      <para>
        <b>Prior to Windows Vista:  </b>Each string is limited to 32K characters.</para>
    </param>
    <param name="lpRawData">A pointer to the buffer containing the binary data. This parameter must be a valid pointer (or <b>NULL</b>), even if the <i>dwDataSize</i> parameter is zero.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero, indicating that the entry was written to the log.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />, which returns one of the following extended error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_PARAMETER</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One of the parameters is not valid.<para>This error is returned on Windows Server 2003 if the message data to be logged is too large. This error is returned by the RPC server on Windows Server 2003 if the <i>dwDataSize</i> parameter is larger than 261,991 (0x3ff67).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_ENOUGH_MEMORY</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Insufficient memory resources are available to complete the operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>RPC_S_INVALID_BOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The array bounds are invalid. <para>This error is returned if the message data to be logged is too large. On Windows Vista and later, this error is returned if the <i>dwDataSize</i> parameter is larger than 61,440 (0xf000).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>RPC_X_BAD_STUB_DATA</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The stub received bad data.<para>This error is returned on Windows XP if the message data to be logged is too large. This error is returned by the RPC server on Windows XP, if the <i>dwDataSize</i> parameter is larger than 262,143 (0x3ffff).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>Other</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use <see cref="FormatMessage" /> to obtain the message string for the returned error.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.ReportEventA">
    <summary>Writes an entry at the end of the specified event log.</summary>
    <param name="hEventLog">
      <para>A handle to the event log. The<see cref="RegisterEventSource" /> function returns this handle.</para>
      <para>As of Windows XP with SP2, this parameter cannot be a handle to the <b>Security</b> log. To write an event to the <b>Security</b> log, use the <see cref="AuthzReportSecurityEvent" /> function.</para>
    </param>
    <param name="wType">
      <para>The type of event to be logged. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_SUCCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0000</term>
              </listheader>
            </list>
          </description>
          <description>Information event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_AUDIT_FAILURE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0010</term>
              </listheader>
            </list>
          </description>
          <description>Failure Audit event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_AUDIT_SUCCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0008</term>
              </listheader>
            </list>
          </description>
          <description>Success Audit event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_ERROR_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0001</term>
              </listheader>
            </list>
          </description>
          <description>Error event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_INFORMATION_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0004</term>
              </listheader>
            </list>
          </description>
          <description>Information event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_WARNING_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0002</term>
              </listheader>
            </list>
          </description>
          <description>Warning event</description>
        </listheader>
      </list> <para>For more information about event types, see<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-types">Event Types</a>.</para></param>
    <param name="wCategory">The event category. This is source-specific information; the category can have any value. For more information, see<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-categories">Event Categories</a>.</param>
    <param name="dwEventID">The event identifier. The event identifier specifies the entry in the message file associated with the event source. For more information, see <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-identifiers">Event Identifiers</a>.</param>
    <param name="lpUserSid">A pointer to the current user's security identifier. This parameter can be <b>NULL</b> if the security identifier is not required.</param>
    <param name="wNumStrings">The number of insert strings in the array pointed to by the <i>lpStrings</i> parameter. A value of zero indicates that no strings are present.</param>
    <param name="dwDataSize">The number of bytes of event-specific raw (binary) data to write to the log. If this parameter is zero, no event-specific data is present.</param>
    <param name="lpStrings">
      <para>A pointer to a buffer containing an array of null-terminated strings that are merged into the message before Event Viewer displays the string to the user. This parameter must be a valid pointer (or <b>NULL</b>), even if <i>wNumStrings</i> is zero. Each string is limited to 31,839 characters.</para>
      <para>
        <b>Prior to Windows Vista:  </b>Each string is limited to 32K characters.</para>
    </param>
    <param name="lpRawData">A pointer to the buffer containing the binary data. This parameter must be a valid pointer (or <b>NULL</b>), even if the <i>dwDataSize</i> parameter is zero.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero, indicating that the entry was written to the log.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />, which returns one of the following extended error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_PARAMETER</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One of the parameters is not valid.<para>This error is returned on Windows Server 2003 if the message data to be logged is too large. This error is returned by the RPC server on Windows Server 2003 if the <i>dwDataSize</i> parameter is larger than 261,991 (0x3ff67).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_ENOUGH_MEMORY</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Insufficient memory resources are available to complete the operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>RPC_S_INVALID_BOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The array bounds are invalid. <para>This error is returned if the message data to be logged is too large. On Windows Vista and later, this error is returned if the <i>dwDataSize</i> parameter is larger than 61,440 (0xf000).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>RPC_X_BAD_STUB_DATA</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The stub received bad data.<para>This error is returned on Windows XP if the message data to be logged is too large. This error is returned by the RPC server on Windows XP, if the <i>dwDataSize</i> parameter is larger than 262,143 (0x3ffff).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>Other</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use <see cref="FormatMessage" /> to obtain the message string for the returned error.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.ReportEventW">
    <summary>Writes an entry at the end of the specified event log.</summary>
    <param name="hEventLog">
      <para>A handle to the event log. The<see cref="RegisterEventSource" /> function returns this handle.</para>
      <para>As of Windows XP with SP2, this parameter cannot be a handle to the <b>Security</b> log. To write an event to the <b>Security</b> log, use the <see cref="AuthzReportSecurityEvent" /> function.</para>
    </param>
    <param name="wType">
      <para>The type of event to be logged. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_SUCCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0000</term>
              </listheader>
            </list>
          </description>
          <description>Information event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_AUDIT_FAILURE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0010</term>
              </listheader>
            </list>
          </description>
          <description>Failure Audit event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_AUDIT_SUCCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0008</term>
              </listheader>
            </list>
          </description>
          <description>Success Audit event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_ERROR_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0001</term>
              </listheader>
            </list>
          </description>
          <description>Error event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_INFORMATION_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0004</term>
              </listheader>
            </list>
          </description>
          <description>Information event</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EVENTLOG_WARNING_TYPE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0002</term>
              </listheader>
            </list>
          </description>
          <description>Warning event</description>
        </listheader>
      </list> <para>For more information about event types, see<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-types">Event Types</a>.</para></param>
    <param name="wCategory">The event category. This is source-specific information; the category can have any value. For more information, see<a href="https://docs.microsoft.com//windows/desktop/EventLog/event-categories">Event Categories</a>.</param>
    <param name="dwEventID">The event identifier. The event identifier specifies the entry in the message file associated with the event source. For more information, see <a href="https://docs.microsoft.com//windows/desktop/EventLog/event-identifiers">Event Identifiers</a>.</param>
    <param name="lpUserSid">A pointer to the current user's security identifier. This parameter can be <b>NULL</b> if the security identifier is not required.</param>
    <param name="wNumStrings">The number of insert strings in the array pointed to by the <i>lpStrings</i> parameter. A value of zero indicates that no strings are present.</param>
    <param name="dwDataSize">The number of bytes of event-specific raw (binary) data to write to the log. If this parameter is zero, no event-specific data is present.</param>
    <param name="lpStrings">
      <para>A pointer to a buffer containing an array of null-terminated strings that are merged into the message before Event Viewer displays the string to the user. This parameter must be a valid pointer (or <b>NULL</b>), even if <i>wNumStrings</i> is zero. Each string is limited to 31,839 characters.</para>
      <para>
        <b>Prior to Windows Vista:  </b>Each string is limited to 32K characters.</para>
    </param>
    <param name="lpRawData">A pointer to the buffer containing the binary data. This parameter must be a valid pointer (or <b>NULL</b>), even if the <i>dwDataSize</i> parameter is zero.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero, indicating that the entry was written to the log.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />, which returns one of the following extended error codes.</para>
      <list type="table">
        <listheader>
          <description>Error code</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_PARAMETER</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>One of the parameters is not valid.<para>This error is returned on Windows Server 2003 if the message data to be logged is too large. This error is returned by the RPC server on Windows Server 2003 if the <i>dwDataSize</i> parameter is larger than 261,991 (0x3ff67).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_ENOUGH_MEMORY</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Insufficient memory resources are available to complete the operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>RPC_S_INVALID_BOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The array bounds are invalid. <para>This error is returned if the message data to be logged is too large. On Windows Vista and later, this error is returned if the <i>dwDataSize</i> parameter is larger than 61,440 (0xf000).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>RPC_X_BAD_STUB_DATA</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The stub received bad data.<para>This error is returned on Windows XP if the message data to be logged is too large. This error is returned by the RPC server on Windows XP, if the <i>dwDataSize</i> parameter is larger than 262,143 (0x3ffff).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>Other</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Use <see cref="FormatMessage" /> to obtain the message string for the returned error.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.SetCommBreak">
    <summary>Suspends character transmission for a specified communications device and places the transmission line in a break state until the<see cref="ClearCommBreak" /> function is called.</summary>
    <param name="hFile">A handle to the communications device. The<see cref="CreateFile" /> function returns this handle.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetCommConfig">
    <summary>Sets the current configuration of a communications device.</summary>
    <param name="hCommDev">A handle to the open communications device. The<see cref="CreateFile" /> function returns this handle.</param>
    <param name="lpCC">A pointer to a<see cref="COMMCONFIG" /> structure.</param>
    <param name="dwSize">The size of the structure pointed to by <i>lpCC</i>, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetCommMask">
    <summary>Specifies a set of events to be monitored for a communications device.</summary>
    <param name="hFile">A handle to the communications device. The<see cref="CreateFile" /> function returns this handle.</param>
    <param name="dwEvtMask">
      <para>The events to be enabled. A value of zero disables all events. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_BREAK</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0040</term>
              </listheader>
            </list>
          </description>
          <description>A break was detected on input.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_CTS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0008</term>
              </listheader>
            </list>
          </description>
          <description>The CTS (clear-to-send) signal changed state.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_DSR</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0010</term>
              </listheader>
            </list>
          </description>
          <description>The DSR (data-set-ready) signal changed state.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_ERR</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0080</term>
              </listheader>
            </list>
          </description>
          <description>A line-status error occurred. Line-status errors are <b>CE_FRAME</b>, <b>CE_OVERRUN</b>, and <b>CE_RXPARITY</b>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_RING</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0100</term>
              </listheader>
            </list>
          </description>
          <description>A ring indicator was detected.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_RLSD</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0020</term>
              </listheader>
            </list>
          </description>
          <description>The RLSD (receive-line-signal-detect) signal changed state.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_RXCHAR</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0001</term>
              </listheader>
            </list>
          </description>
          <description>A character was received and placed in the input buffer.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_RXFLAG</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0002</term>
              </listheader>
            </list>
          </description>
          <description>The event character was received and placed in the input buffer. The event character is specified in the device's <see cref="DCB" /> structure, which is applied to a serial port by using the <see cref="SetCommState" /> function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_TXEMPTY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0004</term>
              </listheader>
            </list>
          </description>
          <description>The last character in the output buffer was sent.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetCommState">
    <summary>Configures a communications device according to the specifications in a device-control block (a<see cref="DCB" /> structure). The function reinitializes all hardware and control settings, but it does not empty output or input queues.</summary>
    <param name="hFile">A handle to the communications device. The<see cref="CreateFile" /> function returns this handle.</param>
    <param name="lpDCB">A pointer to a<see cref="DCB" /> structure that contains the configuration information for the specified communications device.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetCommTimeouts">
    <summary>Sets the time-out parameters for all read and write operations on a specified communications device.</summary>
    <param name="hFile">A handle to the communications device. The<see cref="CreateFile" /> function returns this handle.</param>
    <param name="lpCommTimeouts">A pointer to a<see cref="COMMTIMEOUTS" /> structure that contains the new time-out values.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetCurrentDirectory">
    <summary>Changes the current directory for the current process.</summary>
    <param name="lpPathName">
      <para>The path to the new current directory. This parameter may specify a relative path or a full path. In either case, the full path of the specified directory is calculated and stored as the current directory.</para>
      <para>For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>By default, the name is limited to MAX_PATH characters.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>The final character before the null character must be a backslash ('\'). If you do not specify the backslash, it will be added for you; therefore, specify <b>MAX_PATH</b>-2 characters for the path unless you include the trailing backslash, in which case, specify <b>MAX_PATH</b>-1 characters for the path.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetCurrentDirectoryA">
    <summary>Changes the current directory for the current process.</summary>
    <param name="lpPathName">
      <para>The path to the new current directory. This parameter may specify a relative path or a full path. In either case, the full path of the specified directory is calculated and stored as the current directory.</para>
      <para>For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>By default, the name is limited to MAX_PATH characters.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>The final character before the null character must be a backslash ('\'). If you do not specify the backslash, it will be added for you; therefore, specify <b>MAX_PATH</b>-2 characters for the path unless you include the trailing backslash, in which case, specify <b>MAX_PATH</b>-1 characters for the path.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetCurrentDirectoryW">
    <summary>Changes the current directory for the current process.</summary>
    <param name="lpPathName">
      <para>The path to the new current directory. This parameter may specify a relative path or a full path. In either case, the full path of the specified directory is calculated and stored as the current directory.</para>
      <para>For more information, see <a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</para>
      <para>By default, the name is limited to MAX_PATH characters.</para>
      <blockquote>[!TIP] Starting with Windows 10, Version 1607, you can opt-in to remove the MAX_PATH limitation. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com//windows/win32/fileio/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</blockquote>
      <para>The final character before the null character must be a backslash ('\'). If you do not specify the backslash, it will be added for you; therefore, specify <b>MAX_PATH</b>-2 characters for the path unless you include the trailing backslash, in which case, specify <b>MAX_PATH</b>-1 characters for the path.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetDefaultCommConfig">
    <summary>Sets the default configuration for a communications device.</summary>
    <param name="lpszName">The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
    <param name="lpCC">A pointer to a<see cref="COMMCONFIG" /> structure.</param>
    <param name="dwSize">The size of the structure pointed to by <i>lpCC</i>, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetDefaultCommConfigA">
    <summary>Sets the default configuration for a communications device.</summary>
    <param name="lpszName">The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
    <param name="lpCC">A pointer to a<see cref="COMMCONFIG" /> structure.</param>
    <param name="dwSize">The size of the structure pointed to by <i>lpCC</i>, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetDefaultCommConfigW">
    <summary>Sets the default configuration for a communications device.</summary>
    <param name="lpszName">The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
    <param name="lpCC">A pointer to a<see cref="COMMCONFIG" /> structure.</param>
    <param name="dwSize">The size of the structure pointed to by <i>lpCC</i>, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetDefaultCommConfig">
    <summary>Sets the default configuration for a communications device.</summary>
    <param name="lpszName">The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
    <param name="lpCC">A pointer to a<see cref="COMMCONFIG" /> structure.</param>
    <param name="dwSize">The size of the structure pointed to by <i>lpCC</i>, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetDefaultCommConfigA">
    <summary>Sets the default configuration for a communications device.</summary>
    <param name="lpszName">The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
    <param name="lpCC">A pointer to a<see cref="COMMCONFIG" /> structure.</param>
    <param name="dwSize">The size of the structure pointed to by <i>lpCC</i>, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetDefaultCommConfigW">
    <summary>Sets the default configuration for a communications device.</summary>
    <param name="lpszName">The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.</param>
    <param name="lpCC">A pointer to a<see cref="COMMCONFIG" /> structure.</param>
    <param name="dwSize">The size of the structure pointed to by <i>lpCC</i>, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetDllDirectory">
    <summary>Adds a directory to the search path used to locate DLLs for the application.</summary>
    <param name="lpPathName">The directory to be added to the search path. If this parameter is an empty string (""), the call removes the current directory from the default DLL search order. If this parameter is NULL, the function restores the default search order.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetDllDirectoryA">
    <summary>Adds a directory to the search path used to locate DLLs for the application.</summary>
    <param name="lpPathName">The directory to be added to the search path. If this parameter is an empty string (""), the call removes the current directory from the default DLL search order. If this parameter is NULL, the function restores the default search order.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetDllDirectoryW">
    <summary>Adds a directory to the search path used to locate DLLs for the application.</summary>
    <param name="lpPathName">The directory to be added to the search path. If this parameter is an empty string (""), the call removes the current directory from the default DLL search order. If this parameter is NULL, the function restores the default search order.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetDllDirectory">
    <summary>Adds a directory to the search path used to locate DLLs for the application.</summary>
    <param name="lpPathName">The directory to be added to the search path. If this parameter is an empty string (""), the call removes the current directory from the default DLL search order. If this parameter is NULL, the function restores the default search order.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetDllDirectoryA">
    <summary>Adds a directory to the search path used to locate DLLs for the application.</summary>
    <param name="lpPathName">The directory to be added to the search path. If this parameter is an empty string (""), the call removes the current directory from the default DLL search order. If this parameter is NULL, the function restores the default search order.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetDllDirectoryW">
    <summary>Adds a directory to the search path used to locate DLLs for the application.</summary>
    <param name="lpPathName">The directory to be added to the search path. If this parameter is an empty string (""), the call removes the current directory from the default DLL search order. If this parameter is NULL, the function restores the default search order.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetEnvironmentVariable">
    <summary>Sets the contents of the specified environment variable for the current process.</summary>
    <param name="lpName">The name of the environment variable. The operating system creates the environment variable if it does not exist and <i>lpValue</i> is not NULL.</param>
    <param name="lpValue">
      <para>The contents of the environment variable. The maximum size of a user-defined environment variable is 32,767 characters. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/environment-variables">Environment Variables</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The total size of the environment block for a process may not exceed 32,767 characters.</para>
      <para>If this parameter is NULL, the variable is deleted from the current process's environment.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetEnvironmentVariableA">
    <summary>Sets the contents of the specified environment variable for the current process.</summary>
    <param name="lpName">The name of the environment variable. The operating system creates the environment variable if it does not exist and <i>lpValue</i> is not NULL.</param>
    <param name="lpValue">
      <para>The contents of the environment variable. The maximum size of a user-defined environment variable is 32,767 characters. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/environment-variables">Environment Variables</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The total size of the environment block for a process may not exceed 32,767 characters.</para>
      <para>If this parameter is NULL, the variable is deleted from the current process's environment.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetEnvironmentVariableW">
    <summary>Sets the contents of the specified environment variable for the current process.</summary>
    <param name="lpName">The name of the environment variable. The operating system creates the environment variable if it does not exist and <i>lpValue</i> is not NULL.</param>
    <param name="lpValue">
      <para>The contents of the environment variable. The maximum size of a user-defined environment variable is 32,767 characters. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/environment-variables">Environment Variables</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The total size of the environment block for a process may not exceed 32,767 characters.</para>
      <para>If this parameter is NULL, the variable is deleted from the current process's environment.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetFileBandwidthReservation">
    <summary>Requests that bandwidth for the specified file stream be reserved. The reservation is specified as a number of bytes in a period of milliseconds for I/O requests on the specified file handle.</summary>
    <param name="hFile">A handle to the file.</param>
    <param name="nPeriodMilliseconds">The period of the reservation, in milliseconds. The period is the time from which the I/O is issued to the kernel until the time the I/O should be completed. The minimum supported value for the file stream can be determined by looking at the value returned through the<i>lpPeriodMilliseconds</i> parameter to the<see cref="GetFileBandwidthReservation" /> function, on a handle that has not had a bandwidth reservation set.</param>
    <param name="nBytesPerPeriod">The bandwidth to reserve, in bytes per period. The maximum supported value for the file stream can be determined by looking at the value returned through the<i>lpBytesPerPeriod</i> parameter to the<see cref="GetFileBandwidthReservation" /> function, on a handle that has not had a bandwidth reservation set.</param>
    <param name="bDiscardable">Indicates whether I/O should be completed with an error if a driver is unable to satisfy an I/O operation before the period expires. If one of the drivers for the specified file stream does not support this functionality, this function may return success and ignore the flag. To verify whether the setting will be honored, call the<see cref="GetFileBandwidthReservation" /> function using the same <i>hFile</i> handle and examine the <i>*pDiscardable</i>return value.</param>
    <param name="lpTransferSize">A pointer to a variable that receives the minimum size of any individual I/O request that may be issued by the application. All I/O requests should be multiples of <i>TransferSize</i>.</param>
    <param name="lpNumOutstandingRequests">A pointer to a variable that receives the number of <i>TransferSize</i> chunks the application should allow to be outstanding with the operating system. This allows the storage stack to keep the device busy and allows maximum throughput.</param>
    <returns>
      <para>Returns nonzero if successful or zero otherwise.</para>
      <para>A reservation can fail if there is not enough bandwidth available on the volume because of existing reservations; in this case <b>ERROR_NO_SYSTEM_RESOURCES</b> is returned.</para>
      <para>To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetFileCompletionNotificationModes">
    <summary>Sets the notification modes for a file handle, allowing you to specify how completion notifications work for the specified file.</summary>
    <param name="FileHandle">A handle to the file.</param>
    <param name="Flags">
      <para>The modes to be set. One or more modes can be set at the same time; however, after a mode has been set for a file handle, it cannot be removed.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SKIP_COMPLETION_PORT_ON_SUCCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x1</term>
              </listheader>
            </list>
          </description>
          <description>If the following three conditions are true, the I/O Manager does not queue a completion entry to the port, when it would ordinarily do so. The conditions are: <list type="bullet"><item><description>A completion port is associated with the file handle.</description></item><item><description>The file is opened for asynchronous I/O.</description></item><item><description>A request returns success immediately without returning <b>ERROR_PENDING</b>.</description></item></list><para>When the <i>FileHandle</i> parameter is a socket, this mode is only compatible with Layered Service Providers (LSP) that return Installable File Systems (IFS) handles. To detect whether a non-IFS LSP is installed, use the<see cref="WSAEnumProtocols" /> function and examine the<b>dwServiceFlag1</b> member in each returned<see cref="WSAPROTOCOL_INFO" /> structure. If the<b>XP1_IFS_HANDLES</b> (0x20000) bit is cleared then the specified LSP is not an IFS LSP. Vendors that have non-IFS LSPs are encouraged to migrate to the<a href="https://docs.microsoft.com//windows/desktop/FWP/windows-filtering-platform-start-page">Windows Filtering Platform</a>(WFP).</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>FILE_SKIP_SET_EVENT_ON_HANDLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x2</term>
              </listheader>
            </list>
          </description>
          <description>The I/O Manager does not set the event for the file object if a request returns with a success code, or the error returned is <b>ERROR_PENDING</b> and the function that is called is not a synchronous function.<para>If an explicit event is provided for the request, it is still signaled.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>Returns nonzero if successful or zero otherwise.</para>
      <para>To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetFileSecurity">
    <summary>
      <para>The <b>SetFileSecurity</b> function sets the security of a file or directory object.</para>
      <para>This function is obsolete. Use the <see cref="SetNamedSecurityInfo" /> function instead.</para>
    </summary>
    <param name="lpFileName">A pointer to a null-terminated string that specifies the file or directory for which security is set. Note that security applied to a directory is not inherited by its children.</param>
    <param name="SecurityInformation">Specifies a<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</a> structure that identifies the contents of the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> pointed to by the <i>pSecurityDescriptor</i> parameter.</param>
    <param name="pSecurityDescriptor">A pointer to a<see cref="SECURITY_DESCRIPTOR" /> structure.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetFileSecurityA">
    <summary>
      <para>The <b>SetFileSecurity</b> function sets the security of a file or directory object.</para>
      <para>This function is obsolete. Use the <see cref="SetNamedSecurityInfo" /> function instead.</para>
    </summary>
    <param name="lpFileName">A pointer to a null-terminated string that specifies the file or directory for which security is set. Note that security applied to a directory is not inherited by its children.</param>
    <param name="SecurityInformation">Specifies a<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</a> structure that identifies the contents of the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> pointed to by the <i>pSecurityDescriptor</i> parameter.</param>
    <param name="pSecurityDescriptor">A pointer to a<see cref="SECURITY_DESCRIPTOR" /> structure.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetFileSecurityW">
    <summary>
      <para>The <b>SetFileSecurity</b> function sets the security of a file or directory object.</para>
      <para>This function is obsolete. Use the <see cref="SetNamedSecurityInfo" /> function instead.</para>
    </summary>
    <param name="lpFileName">A pointer to a null-terminated string that specifies the file or directory for which security is set. Note that security applied to a directory is not inherited by its children.</param>
    <param name="SecurityInformation">Specifies a<a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/security-information">SECURITY_INFORMATION</a> structure that identifies the contents of the <a href="https://docs.microsoft.com//windows/desktop/SecGloss/s-gly">security descriptor</a> pointed to by the <i>pSecurityDescriptor</i> parameter.</param>
    <param name="pSecurityDescriptor">A pointer to a<see cref="SECURITY_DESCRIPTOR" /> structure.</param>
    <returns>
      <para>If the function succeeds, the function returns nonzero.</para>
      <para>If the function fails, it returns zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetFileShortName">
    <summary>Sets the short name for the specified file. The file must be on an NTFS file system volume.</summary>
    <param name="hFile">A handle to the file. The file must be opened with either the <b>GENERIC_ALL</b> access right or <b>GENERIC_WRITE</b>|<b>DELETE</b>, and with the<b>FILE_FLAG_BACKUP_SEMANTICS</b> file attribute.</param>
    <param name="lpShortName">
      <para>A pointer to a string that specifies the short name for the file.</para>
      <para>Specifying an empty (zero-length) string will remove the short file name, if it exists for the file specified by the <i>hFile</i> parameter. If a short file name does not exist, the function will do nothing and return success.</para>
      <para>
        <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This behavior is not supported. The parameter must contain a valid string of one or more characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.<b>GetLastError</b> may return one of the following error codes that are specific to this function.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified short name is not unique.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_PARAMETER</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Either the specified file has been opened in case-sensitive mode or the specified short name is invalid.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.SetFileShortNameA">
    <summary>Sets the short name for the specified file. The file must be on an NTFS file system volume.</summary>
    <param name="hFile">A handle to the file. The file must be opened with either the <b>GENERIC_ALL</b> access right or <b>GENERIC_WRITE</b>|<b>DELETE</b>, and with the<b>FILE_FLAG_BACKUP_SEMANTICS</b> file attribute.</param>
    <param name="lpShortName">
      <para>A pointer to a string that specifies the short name for the file.</para>
      <para>Specifying an empty (zero-length) string will remove the short file name, if it exists for the file specified by the <i>hFile</i> parameter. If a short file name does not exist, the function will do nothing and return success.</para>
      <para>
        <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This behavior is not supported. The parameter must contain a valid string of one or more characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.<b>GetLastError</b> may return one of the following error codes that are specific to this function.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified short name is not unique.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_PARAMETER</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Either the specified file has been opened in case-sensitive mode or the specified short name is invalid.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.SetFileShortNameW">
    <summary>Sets the short name for the specified file. The file must be on an NTFS file system volume.</summary>
    <param name="hFile">A handle to the file. The file must be opened with either the <b>GENERIC_ALL</b> access right or <b>GENERIC_WRITE</b>|<b>DELETE</b>, and with the<b>FILE_FLAG_BACKUP_SEMANTICS</b> file attribute.</param>
    <param name="lpShortName">
      <para>A pointer to a string that specifies the short name for the file.</para>
      <para>Specifying an empty (zero-length) string will remove the short file name, if it exists for the file specified by the <i>hFile</i> parameter. If a short file name does not exist, the function will do nothing and return success.</para>
      <para>
        <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This behavior is not supported. The parameter must contain a valid string of one or more characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.<b>GetLastError</b> may return one of the following error codes that are specific to this function.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified short name is not unique.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_PARAMETER</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Either the specified file has been opened in case-sensitive mode or the specified short name is invalid.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.SetFileShortName">
    <summary>Sets the short name for the specified file. The file must be on an NTFS file system volume.</summary>
    <param name="hFile">A handle to the file. The file must be opened with either the <b>GENERIC_ALL</b> access right or <b>GENERIC_WRITE</b>|<b>DELETE</b>, and with the<b>FILE_FLAG_BACKUP_SEMANTICS</b> file attribute.</param>
    <param name="lpShortName">
      <para>A pointer to a string that specifies the short name for the file.</para>
      <para>Specifying an empty (zero-length) string will remove the short file name, if it exists for the file specified by the <i>hFile</i> parameter. If a short file name does not exist, the function will do nothing and return success.</para>
      <para>
        <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This behavior is not supported. The parameter must contain a valid string of one or more characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.<b>GetLastError</b> may return one of the following error codes that are specific to this function.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified short name is not unique.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_PARAMETER</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Either the specified file has been opened in case-sensitive mode or the specified short name is invalid.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.SetFileShortNameA">
    <summary>Sets the short name for the specified file. The file must be on an NTFS file system volume.</summary>
    <param name="hFile">A handle to the file. The file must be opened with either the <b>GENERIC_ALL</b> access right or <b>GENERIC_WRITE</b>|<b>DELETE</b>, and with the<b>FILE_FLAG_BACKUP_SEMANTICS</b> file attribute.</param>
    <param name="lpShortName">
      <para>A pointer to a string that specifies the short name for the file.</para>
      <para>Specifying an empty (zero-length) string will remove the short file name, if it exists for the file specified by the <i>hFile</i> parameter. If a short file name does not exist, the function will do nothing and return success.</para>
      <para>
        <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This behavior is not supported. The parameter must contain a valid string of one or more characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.<b>GetLastError</b> may return one of the following error codes that are specific to this function.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified short name is not unique.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_PARAMETER</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Either the specified file has been opened in case-sensitive mode or the specified short name is invalid.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.SetFileShortNameW">
    <summary>Sets the short name for the specified file. The file must be on an NTFS file system volume.</summary>
    <param name="hFile">A handle to the file. The file must be opened with either the <b>GENERIC_ALL</b> access right or <b>GENERIC_WRITE</b>|<b>DELETE</b>, and with the<b>FILE_FLAG_BACKUP_SEMANTICS</b> file attribute.</param>
    <param name="lpShortName">
      <para>A pointer to a string that specifies the short name for the file.</para>
      <para>Specifying an empty (zero-length) string will remove the short file name, if it exists for the file specified by the <i>hFile</i> parameter. If a short file name does not exist, the function will do nothing and return success.</para>
      <para>
        <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This behavior is not supported. The parameter must contain a valid string of one or more characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.<b>GetLastError</b> may return one of the following error codes that are specific to this function.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_ALREADY_EXISTS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified short name is not unique.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_PARAMETER</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Either the specified file has been opened in case-sensitive mode or the specified short name is invalid.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariable">
    <summary>Sets the value of the specified firmware environment variable.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored.</param>
    <param name="pValue">A pointer to the new value for the firmware environment variable.</param>
    <param name="nSize">The size of the <i>pBuffer</i> buffer, in bytes. If this parameter is zero, the firmware environment variable is deleted.</param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariableA">
    <summary>Sets the value of the specified firmware environment variable.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored.</param>
    <param name="pValue">A pointer to the new value for the firmware environment variable.</param>
    <param name="nSize">The size of the <i>pBuffer</i> buffer, in bytes. If this parameter is zero, the firmware environment variable is deleted.</param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariableW">
    <summary>Sets the value of the specified firmware environment variable.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored.</param>
    <param name="pValue">A pointer to the new value for the firmware environment variable.</param>
    <param name="nSize">The size of the <i>pBuffer</i> buffer, in bytes. If this parameter is zero, the firmware environment variable is deleted.</param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariableEx">
    <summary>Sets the value of the specified firmware environment variable as the attributes that indicate how this variable is stored and maintained.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored. The pointer must not be <b>NULL</b>.</param>
    <param name="pValue">A pointer to the new value for the firmware environment variable.</param>
    <param name="nSize">The size of the <i>pValue</i> buffer, in bytes. Unless the VARIABLE_ATTRIBUTE_APPEND_WRITE, VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS, or VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS variable attribute is set via <i>dwAttributes</i>, setting this value to zero will result in the deletion of this variable.</param>
    <param name="dwAttributes">
      <para>Bitmask to set UEFI variable attributes associated with the variable. See also <a href="https://www.uefi.org/specifications">UEFI Spec 2.3.1, Section 7.2</a>.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_NON_VOLATILE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The firmware environment variable is stored in non-volatile memory (e.g. NVRAM).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The firmware environment variable can be accessed during boot service.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>The firmware environment variable can be accessed at runtime.<div><b>Note</b>  Variables with this attribute set, must also have<b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b> set.</div></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_HARDWARE_ERROR_RECORD</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>Indicates hardware related errors encountered at runtime.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000010</term>
              </listheader>
            </list>
          </description>
          <description>Indicates an authentication requirement that must be met before writing to this firmware environment variable. For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000020</term>
              </listheader>
            </list>
          </description>
          <description>Indicates authentication and time stamp requirements that must be met before writing to this firmware environment variable. When this attribute is set, the buffer, represented by <i>pValue</i>, will begin with an instance of a complete (and serialized) EFI_VARIABLE_AUTHENTICATION_2 descriptor. For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_APPEND_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000040</term>
              </listheader>
            </list>
          </description>
          <description> Append an existing environment variable with the value of <i>pValue</i>. If the firmware does not support the operation, then <b>SetFirmwareEnvironmentVariableEx</b> will return ERROR_INVALID_FUNCTION.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariableExA">
    <summary>Sets the value of the specified firmware environment variable as the attributes that indicate how this variable is stored and maintained.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored. The pointer must not be <b>NULL</b>.</param>
    <param name="pValue">A pointer to the new value for the firmware environment variable.</param>
    <param name="nSize">The size of the <i>pValue</i> buffer, in bytes. Unless the VARIABLE_ATTRIBUTE_APPEND_WRITE, VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS, or VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS variable attribute is set via <i>dwAttributes</i>, setting this value to zero will result in the deletion of this variable.</param>
    <param name="dwAttributes">
      <para>Bitmask to set UEFI variable attributes associated with the variable. See also <a href="https://www.uefi.org/specifications">UEFI Spec 2.3.1, Section 7.2</a>.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_NON_VOLATILE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The firmware environment variable is stored in non-volatile memory (e.g. NVRAM).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The firmware environment variable can be accessed during boot service.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>The firmware environment variable can be accessed at runtime.<div><b>Note</b>  Variables with this attribute set, must also have<b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b> set.</div></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_HARDWARE_ERROR_RECORD</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>Indicates hardware related errors encountered at runtime.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000010</term>
              </listheader>
            </list>
          </description>
          <description>Indicates an authentication requirement that must be met before writing to this firmware environment variable. For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000020</term>
              </listheader>
            </list>
          </description>
          <description>Indicates authentication and time stamp requirements that must be met before writing to this firmware environment variable. When this attribute is set, the buffer, represented by <i>pValue</i>, will begin with an instance of a complete (and serialized) EFI_VARIABLE_AUTHENTICATION_2 descriptor. For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_APPEND_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000040</term>
              </listheader>
            </list>
          </description>
          <description> Append an existing environment variable with the value of <i>pValue</i>. If the firmware does not support the operation, then <b>SetFirmwareEnvironmentVariableEx</b> will return ERROR_INVALID_FUNCTION.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariableExW">
    <summary>Sets the value of the specified firmware environment variable as the attributes that indicate how this variable is stored and maintained.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored. The pointer must not be <b>NULL</b>.</param>
    <param name="pValue">A pointer to the new value for the firmware environment variable.</param>
    <param name="nSize">The size of the <i>pValue</i> buffer, in bytes. Unless the VARIABLE_ATTRIBUTE_APPEND_WRITE, VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS, or VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS variable attribute is set via <i>dwAttributes</i>, setting this value to zero will result in the deletion of this variable.</param>
    <param name="dwAttributes">
      <para>Bitmask to set UEFI variable attributes associated with the variable. See also <a href="https://www.uefi.org/specifications">UEFI Spec 2.3.1, Section 7.2</a>.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_NON_VOLATILE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The firmware environment variable is stored in non-volatile memory (e.g. NVRAM).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The firmware environment variable can be accessed during boot service.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>The firmware environment variable can be accessed at runtime.<div><b>Note</b>  Variables with this attribute set, must also have<b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b> set.</div></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_HARDWARE_ERROR_RECORD</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>Indicates hardware related errors encountered at runtime.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000010</term>
              </listheader>
            </list>
          </description>
          <description>Indicates an authentication requirement that must be met before writing to this firmware environment variable. For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000020</term>
              </listheader>
            </list>
          </description>
          <description>Indicates authentication and time stamp requirements that must be met before writing to this firmware environment variable. When this attribute is set, the buffer, represented by <i>pValue</i>, will begin with an instance of a complete (and serialized) EFI_VARIABLE_AUTHENTICATION_2 descriptor. For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_APPEND_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000040</term>
              </listheader>
            </list>
          </description>
          <description> Append an existing environment variable with the value of <i>pValue</i>. If the firmware does not support the operation, then <b>SetFirmwareEnvironmentVariableEx</b> will return ERROR_INVALID_FUNCTION.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariableEx">
    <summary>Sets the value of the specified firmware environment variable and the attributes that indicate how this variable is stored and maintained.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored. The pointer must not be <b>NULL</b>.</param>
    <param name="pValue">A pointer to the new value for the firmware environment variable.</param>
    <param name="nSize">The size of the <i>pValue</i> buffer, in bytes. Unless the VARIABLE_ATTRIBUTE_APPEND_WRITE, VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS, or VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS variable attribute is set via <i>dwAttributes</i>, setting this value to zero will result in the deletion of this variable.</param>
    <param name="dwAttributes">
      <para>Bitmask to set UEFI variable attributes associated with the variable. See also <a href="https://www.uefi.org/specifications">UEFI Spec 2.3.1, Section 7.2</a>.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_NON_VOLATILE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The firmware environment variable is stored in non-volatile memory (e.g. NVRAM).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The firmware environment variable can be accessed during boot service.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>The firmware environment variable can be accessed at runtime.<div><b>Note</b>  Variables with this attribute set, must also have<b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b> set.</div></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_HARDWARE_ERROR_RECORD</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>Indicates hardware related errors encountered at runtime.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000010</term>
              </listheader>
            </list>
          </description>
          <description>Indicates an authentication requirement that must be met before writing to this firmware environment variable. For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000020</term>
              </listheader>
            </list>
          </description>
          <description>Indicates authentication and time stamp requirements that must be met before writing to this firmware environment variable. When this attribute is set, the buffer, represented by <i>pValue</i>, will begin with an instance of a complete (and serialized) EFI_VARIABLE_AUTHENTICATION_2 descriptor. For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_APPEND_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000040</term>
              </listheader>
            </list>
          </description>
          <description> Append an existing environment variable with the value of <i>pValue</i>. If the firmware does not support the operation, then <b>SetFirmwareEnvironmentVariableEx</b> will return ERROR_INVALID_FUNCTION.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariableExA">
    <summary>Sets the value of the specified firmware environment variable and the attributes that indicate how this variable is stored and maintained.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored. The pointer must not be <b>NULL</b>.</param>
    <param name="pValue">A pointer to the new value for the firmware environment variable.</param>
    <param name="nSize">The size of the <i>pValue</i> buffer, in bytes. Unless the VARIABLE_ATTRIBUTE_APPEND_WRITE, VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS, or VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS variable attribute is set via <i>dwAttributes</i>, setting this value to zero will result in the deletion of this variable.</param>
    <param name="dwAttributes">
      <para>Bitmask to set UEFI variable attributes associated with the variable. See also <a href="https://www.uefi.org/specifications">UEFI Spec 2.3.1, Section 7.2</a>.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_NON_VOLATILE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The firmware environment variable is stored in non-volatile memory (e.g. NVRAM).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The firmware environment variable can be accessed during boot service.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>The firmware environment variable can be accessed at runtime.<div><b>Note</b>  Variables with this attribute set, must also have<b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b> set.</div></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_HARDWARE_ERROR_RECORD</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>Indicates hardware related errors encountered at runtime.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000010</term>
              </listheader>
            </list>
          </description>
          <description>Indicates an authentication requirement that must be met before writing to this firmware environment variable. For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000020</term>
              </listheader>
            </list>
          </description>
          <description>Indicates authentication and time stamp requirements that must be met before writing to this firmware environment variable. When this attribute is set, the buffer, represented by <i>pValue</i>, will begin with an instance of a complete (and serialized) EFI_VARIABLE_AUTHENTICATION_2 descriptor. For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_APPEND_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000040</term>
              </listheader>
            </list>
          </description>
          <description> Append an existing environment variable with the value of <i>pValue</i>. If the firmware does not support the operation, then <b>SetFirmwareEnvironmentVariableEx</b> will return ERROR_INVALID_FUNCTION.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariableExW">
    <summary>Sets the value of the specified firmware environment variable and the attributes that indicate how this variable is stored and maintained.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored. The pointer must not be <b>NULL</b>.</param>
    <param name="pValue">A pointer to the new value for the firmware environment variable.</param>
    <param name="nSize">The size of the <i>pValue</i> buffer, in bytes. Unless the VARIABLE_ATTRIBUTE_APPEND_WRITE, VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS, or VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS variable attribute is set via <i>dwAttributes</i>, setting this value to zero will result in the deletion of this variable.</param>
    <param name="dwAttributes">
      <para>Bitmask to set UEFI variable attributes associated with the variable. See also <a href="https://www.uefi.org/specifications">UEFI Spec 2.3.1, Section 7.2</a>.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_NON_VOLATILE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>The firmware environment variable is stored in non-volatile memory (e.g. NVRAM).</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>The firmware environment variable can be accessed during boot service.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_RUNTIME_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>The firmware environment variable can be accessed at runtime.<div><b>Note</b>  Variables with this attribute set, must also have<b>VARIABLE_ATTRIBUTE_BOOTSERVICE_ACCESS</b> set.</div></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_HARDWARE_ERROR_RECORD</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000008</term>
              </listheader>
            </list>
          </description>
          <description>Indicates hardware related errors encountered at runtime.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_AUTHENTICATED_WRITE_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000010</term>
              </listheader>
            </list>
          </description>
          <description>Indicates an authentication requirement that must be met before writing to this firmware environment variable. For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000020</term>
              </listheader>
            </list>
          </description>
          <description>Indicates authentication and time stamp requirements that must be met before writing to this firmware environment variable. When this attribute is set, the buffer, represented by <i>pValue</i>, will begin with an instance of a complete (and serialized) EFI_VARIABLE_AUTHENTICATION_2 descriptor. For more information see, <a href="https://www.uefi.org/specifications">UEFI spec 2.3.1</a>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>VARIABLE_ATTRIBUTE_APPEND_WRITE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000040</term>
              </listheader>
            </list>
          </description>
          <description> Append an existing environment variable with the value of <i>pValue</i>. If the firmware does not support the operation, then <b>SetFirmwareEnvironmentVariableEx</b> will return ERROR_INVALID_FUNCTION.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariable">
    <summary>Sets the value of the specified firmware environment variable.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored.</param>
    <param name="pValue">A pointer to the new value for the firmware environment variable.</param>
    <param name="nSize">The size of the <i>pBuffer</i> buffer, in bytes. If this parameter is zero, the firmware environment variable is deleted.</param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariableA">
    <summary>Sets the value of the specified firmware environment variable.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored.</param>
    <param name="pValue">A pointer to the new value for the firmware environment variable.</param>
    <param name="nSize">The size of the <i>pBuffer</i> buffer, in bytes. If this parameter is zero, the firmware environment variable is deleted.</param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.SetFirmwareEnvironmentVariableW">
    <summary>Sets the value of the specified firmware environment variable.</summary>
    <param name="lpName">The name of the firmware environment variable. The pointer must not be <b>NULL</b>.</param>
    <param name="lpGuid">The GUID that represents the namespace of the firmware environment variable. The GUID must be a string in the format "{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}". If the system does not support GUID-based namespaces, this parameter is ignored.</param>
    <param name="pValue">A pointer to the new value for the firmware environment variable.</param>
    <param name="nSize">The size of the <i>pBuffer</i> buffer, in bytes. If this parameter is zero, the firmware environment variable is deleted.</param>
    <returns>
      <para>If the function succeeds, the return value is a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />. Possible error codes include ERROR_INVALID_FUNCTION.</para>
    </returns>
  </member>
  <member name="Windows.SetHandleCount">
    <summary>Changes the number of file handles available to a process. For DOS-based Win32, the default maximum number of file handles available to a process is 20. For Windows Win32 systems, this API has no effect.</summary>
    <param name="uNumber">The requested number of available file handles.</param>
    <returns>The number of available file handles.</returns>
  </member>
  <member name="Windows.SetMailslotInfo">
    <summary>Sets the time-out value used by the specified mailslot for a read operation.</summary>
    <param name="hMailslot">A handle to a mailslot. The<see cref="CreateMailslot" /> function must create this handle.</param>
    <param name="lReadTimeout">
      <para>The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in milliseconds. The following values have special meanings.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>Returns immediately if no message is present. (The system does not treat an immediate return as an error.)</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>MAILSLOT_WAIT_FOREVER</b>
                </term>
              </listheader>
              <listheader>
                <term>((DWORD)-1)</term>
              </listheader>
            </list>
          </description>
          <description>Waits forever for a message.</description>
        </listheader>
      </list> <para>This time-out value applies to all subsequent read operations and to all inherited mailslot handles.</para></param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetProcessAffinityMask">
    <summary>Sets a processor affinity mask for the threads of the specified process.</summary>
    <param name="hProcess">A handle to the process whose affinity mask is to be set. This handle must have the <b>PROCESS_SET_INFORMATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.</param>
    <param name="dwProcessAffinityMask">
      <para>The affinity mask for the threads of the process.</para>
      <para>On a system with more than 64 processors, the affinity mask must specify processors in a single <a href="https://docs.microsoft.com//windows/desktop/ProcThread/processor-groups">processor group</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the process affinity mask requests a processor that is not configured in the system, the last error code is <b>ERROR_INVALID_PARAMETER</b>.</para>
      <para>On a system with more than 64 processors, if the calling process contains threads in more than one processor group, the last error code is <b>ERROR_INVALID_PARAMETER</b>.</para>
    </returns>
  </member>
  <member name="Windows.SetProcessDEPPolicy">
    <summary>Changes data execution prevention (DEP) and DEP-ATL thunk emulation settings for a 32-bit process.</summary>
    <param name="dwFlags">
      <para>A <b>DWORD</b> that can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>If the DEP system policy is OptIn or OptOut and DEP is enabled for the process, setting <i>dwFlags</i> to 0 disables DEP for the process.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PROCESS_DEP_ENABLE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Enables DEP permanently on the current process. After DEP has been enabled for the process by setting <b>PROCESS_DEP_ENABLE</b>, it cannot be disabled for the life of the process.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Disables DEP-ATL thunk emulation for the current process, which prevents the system from intercepting NX faults that originate from the Active Template Library (ATL) thunk layer. For more information, see the Remarks section. This flag can be specified only with <b>PROCESS_DEP_ENABLE</b>.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>.</para>
      <para>If the function fails, it returns <b>FALSE</b>. To retrieve error values defined for this function, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetSearchPathMode">
    <summary>Sets the per-process mode that the <see cref="SearchPath" />function uses when locating files.</summary>
    <param name="Flags">
      <para>The search mode to use.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Enable safe process search mode for the process.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00010000</term>
              </listheader>
            </list>
          </description>
          <description>Disable safe process search mode for the process.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>BASE_SEARCH_PATH_PERMANENT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00008000</term>
              </listheader>
            </list>
          </description>
          <description>Optional flag to use in combination with <b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b> to make this mode permanent for this process. This is done by bitwise <b>OR</b> operation:<para><code>(BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE | BASE_SEARCH_PATH_PERMANENT)</code></para><para>This flag cannot be combined with the <b>BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE</b>flag.</para></description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the operation completes successfully, the<b>SetSearchPathMode</b> function returns a nonzero value.</para>
      <para>If the operation fails, the <b>SetSearchPathMode</b>function returns zero. To get extended error information, call the<see cref="GetLastError" /> function.</para>
      <para>If the <b>SetSearchPathMode</b> function fails because a parameter value is not valid, the value returned by the<see cref="GetLastError" /> function will be<b>ERROR_INVALID_PARAMETER</b>.</para>
      <para>If the <b>SetSearchPathMode</b> function fails because the combination of current state and parameter value is not valid, the value returned by the<see cref="GetLastError" /> function will be<b>ERROR_ACCESS_DENIED</b>. For more information, see the Remarks section.</para>
    </returns>
  </member>
  <member name="Windows.SetTapeParameters">
    <summary>The<b>SetTapeParameters</b> function either specifies the block size of a tape or configures the tape device.</summary>
    <param name="hDevice">Handle to the device for which to set configuration information. This handle is created by using the<see cref="CreateFile" /> function.</param>
    <param name="dwOperation">
      <para>Type of information to set. This parameter must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SET_TAPE_DRIVE_INFORMATION</b>
                </term>
              </listheader>
              <listheader>
                <term>1L</term>
              </listheader>
            </list>
          </description>
          <description>Sets the device-specific information specified by <i>lpTapeInformation</i>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>SET_TAPE_MEDIA_INFORMATION</b>
                </term>
              </listheader>
              <listheader>
                <term>0L</term>
              </listheader>
            </list>
          </description>
          <description>Sets the tape-specific information specified by the <i>lpTapeInformation</i> parameter.</description>
        </listheader>
      </list>
    </param>
    <param name="lpTapeInformation">
      <para>Pointer to a structure that contains the information to set. If the <i>dwOperation</i> parameter is SET_TAPE_MEDIA_INFORMATION, <i>lpTapeInformation</i> points to a<see cref="TAPE_SET_MEDIA_PARAMETERS" /> structure.</para>
      <para>If <i>dwOperation</i> is SET_TAPE_DRIVE_INFORMATION, <i>lpTapeInformation</i> points to a<see cref="TAPE_SET_DRIVE_PARAMETERS" /> structure.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, it can return one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BEGINNING_OF_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1102L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to access data before the beginning-of-medium marker failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BUS_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>1111L</term>
              </listheader>
            </list>
          </description>
          <description>A reset condition was detected on the bus.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_DEVICE_NOT_PARTITIONED</b>
                </term>
              </listheader>
              <listheader>
                <term>1107L</term>
              </listheader>
            </list>
          </description>
          <description>The partition information could not be found when a tape was being loaded.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_END_OF_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1100L</term>
              </listheader>
            </list>
          </description>
          <description>The end-of-tape marker was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_FILEMARK_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1101L</term>
              </listheader>
            </list>
          </description>
          <description>A filemark was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_BLOCK_LENGTH</b>
                </term>
              </listheader>
              <listheader>
                <term>1106L</term>
              </listheader>
            </list>
          </description>
          <description>The block size is incorrect on a new tape in a multivolume partition.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_MEDIA_CHANGED</b>
                </term>
              </listheader>
              <listheader>
                <term>1110L</term>
              </listheader>
            </list>
          </description>
          <description>The tape that was in the drive has been replaced or removed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NO_DATA_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1104L</term>
              </listheader>
            </list>
          </description>
          <description>The end-of-data marker was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NO_MEDIA_IN_DRIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>1112L</term>
              </listheader>
            </list>
          </description>
          <description>There is no media in the drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_SUPPORTED</b>
                </term>
              </listheader>
              <listheader>
                <term>50L</term>
              </listheader>
            </list>
          </description>
          <description>The tape driver does not support a requested function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PARTITION_FAILURE</b>
                </term>
              </listheader>
              <listheader>
                <term>1105L</term>
              </listheader>
            </list>
          </description>
          <description>The tape could not be partitioned.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_SETMARK_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1103L</term>
              </listheader>
            </list>
          </description>
          <description>A setmark was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_UNABLE_TO_LOCK_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1108L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to lock the ejection mechanism failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1109L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to unload the tape failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_WRITE_PROTECT</b>
                </term>
              </listheader>
              <listheader>
                <term>19L</term>
              </listheader>
            </list>
          </description>
          <description>The media is write protected.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.SetTapePosition">
    <summary>The<b>SetTapePosition</b> function sets the tape position on the specified device.</summary>
    <param name="hDevice">Handle to the device on which to set the tape position. This handle is created by using the<see cref="CreateFile" /> function.</param>
    <param name="dwPositionMethod">
      <para>Type of positioning to perform. This parameter must be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_ABSOLUTE_BLOCK</b>
                </term>
              </listheader>
              <listheader>
                <term>1L</term>
              </listheader>
            </list>
          </description>
          <description>Moves the tape to the device-specific block address specified by the <i>dwOffsetLow</i> and <i>dwOffsetHigh</i> parameters. The <i>dwPartition</i> parameter is ignored.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_LOGICAL_BLOCK</b>
                </term>
              </listheader>
              <listheader>
                <term>2L</term>
              </listheader>
            </list>
          </description>
          <description>Moves the tape to the block address specified by <i>dwOffsetLow</i> and <i>dwOffsetHigh</i> in the partition specified by <i>dwPartition</i>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_REWIND</b>
                </term>
              </listheader>
              <listheader>
                <term>0L</term>
              </listheader>
            </list>
          </description>
          <description>Moves the tape to the beginning of the current partition. The <i>dwPartition</i>, <i>dwOffsetLow</i>, and <i>dwOffsetHigh</i> parameters are ignored.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_SPACE_END_OF_DATA</b>
                </term>
              </listheader>
              <listheader>
                <term>4L</term>
              </listheader>
            </list>
          </description>
          <description>Moves the tape to the end of the data on the partition specified by <i>dwPartition</i>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_SPACE_FILEMARKS</b>
                </term>
              </listheader>
              <listheader>
                <term>6L</term>
              </listheader>
            </list>
          </description>
          <description>Moves the tape forward (or backward) the number of filemarks specified by <i>dwOffsetLow</i> and <i>dwOffsetHigh</i> in the current partition. The <i>dwPartition</i> parameter is ignored.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_SPACE_RELATIVE_BLOCKS</b>
                </term>
              </listheader>
              <listheader>
                <term>5L</term>
              </listheader>
            </list>
          </description>
          <description>Moves the tape forward (or backward) the number of blocks specified by <i>dwOffsetLow</i> and <i>dwOffsetHigh</i> in the current partition. The <i>dwPartition</i> parameter is ignored.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_SPACE_SEQUENTIAL_FMKS</b>
                </term>
              </listheader>
              <listheader>
                <term>7L</term>
              </listheader>
            </list>
          </description>
          <description>Moves the tape forward (or backward) to the first occurrence of n filemarks in the current partition, where n is the number specified by <i>dwOffsetLow</i> and <i>dwOffsetHigh</i>. The <i>dwPartition</i> parameter is ignored.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_SPACE_SEQUENTIAL_SMKS</b>
                </term>
              </listheader>
              <listheader>
                <term>9L</term>
              </listheader>
            </list>
          </description>
          <description>Moves the tape forward (or backward) to the first occurrence of n setmarks in the current partition, where n is the number specified by <i>dwOffsetLow</i> and <i>dwOffsetHigh</i>. The <i>dwPartition</i> parameter is ignored.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_SPACE_SETMARKS</b>
                </term>
              </listheader>
              <listheader>
                <term>8L</term>
              </listheader>
            </list>
          </description>
          <description>Moves the tape forward (or backward) the number of setmarks specified by <i>dwOffsetLow</i> and <i>dwOffsetHigh</i> in the current partition. The <i>dwPartition</i> parameter is ignored.</description>
        </listheader>
      </list>
    </param>
    <param name="dwPartition">Partition to position within. If <i>dwPartition</i> is zero, the current partition is used. Partitions are numbered logically from 1 through n, where 1 is the first partition on the tape and n is the last.</param>
    <param name="dwOffsetLow">Low-order bits of the block address or count for the position operation specified by the <i>dwPositionMethod</i> parameter.</param>
    <param name="dwOffsetHigh">High-order bits of the block address or count for the position operation specified by the <i>dwPositionMethod</i> parameter. If the high-order bits are not required, this parameter should be zero.</param>
    <param name="bImmediate">Indicates whether to return as soon as the move operation begins. If this parameter is <b>TRUE</b>, the function returns immediately; if <b>FALSE</b>, the function does not return until the move operation has been completed.</param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, it can return one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BEGINNING_OF_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1102L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to access data before the beginning-of-medium marker failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BUS_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>1111L</term>
              </listheader>
            </list>
          </description>
          <description>A reset condition was detected on the bus.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_DEVICE_NOT_PARTITIONED</b>
                </term>
              </listheader>
              <listheader>
                <term>1107L</term>
              </listheader>
            </list>
          </description>
          <description>The partition information could not be found when a tape was being loaded.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_END_OF_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1100L</term>
              </listheader>
            </list>
          </description>
          <description>The end-of-tape marker was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_FILEMARK_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1101L</term>
              </listheader>
            </list>
          </description>
          <description>A filemark was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_BLOCK_LENGTH</b>
                </term>
              </listheader>
              <listheader>
                <term>1106L</term>
              </listheader>
            </list>
          </description>
          <description>The block size is incorrect on a new tape in a multivolume partition.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_MEDIA_CHANGED</b>
                </term>
              </listheader>
              <listheader>
                <term>1110L</term>
              </listheader>
            </list>
          </description>
          <description>The tape that was in the drive has been replaced or removed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NO_DATA_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1104L</term>
              </listheader>
            </list>
          </description>
          <description>The end-of-data marker was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NO_MEDIA_IN_DRIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>1112L</term>
              </listheader>
            </list>
          </description>
          <description>There is no media in the drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_SUPPORTED</b>
                </term>
              </listheader>
              <listheader>
                <term>50L</term>
              </listheader>
            </list>
          </description>
          <description>The tape driver does not support a requested function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PARTITION_FAILURE</b>
                </term>
              </listheader>
              <listheader>
                <term>1105L</term>
              </listheader>
            </list>
          </description>
          <description>The tape could not be partitioned.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_SETMARK_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1103L</term>
              </listheader>
            </list>
          </description>
          <description>A setmark was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_UNABLE_TO_LOCK_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1108L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to lock the ejection mechanism failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1109L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to unload the tape failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_WRITE_PROTECT</b>
                </term>
              </listheader>
              <listheader>
                <term>19L</term>
              </listheader>
            </list>
          </description>
          <description>The media is write protected.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.SetThreadAffinityMask">
    <summary>Sets a processor affinity mask for the specified thread.</summary>
    <param name="hThread">
      <para>A handle to the thread whose affinity mask is to be set.</para>
      <para>This handle must have the <b>THREAD_SET_INFORMATION</b> or <b>THREAD_SET_LIMITED_INFORMATION</b> access right and the <b>THREAD_QUERY_INFORMATION</b> or <b>THREAD_QUERY_LIMITED_INFORMATION</b> access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
      <para>
        <b>Windows Server 2003 and Windows XP:  </b>The handle must have the <b>THREAD_SET_INFORMATION</b> and <b>THREAD_QUERY_INFORMATION</b> access rights.</para>
    </param>
    <param name="dwThreadAffinityMask">
      <para>The affinity mask for the thread.</para>
      <para>On a system with more than 64 processors, the affinity mask must specify processors in the thread's current <a href="https://docs.microsoft.com//windows/desktop/ProcThread/processor-groups">processor group</a>.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the thread's previous affinity mask.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the thread affinity mask requests a processor that is not selected for the process affinity mask, the last error code is <b>ERROR_INVALID_PARAMETER</b>.</para>
    </returns>
  </member>
  <member name="Windows.SetThreadExecutionState">
    <summary>Enables an application to inform the system that it is in use, thereby preventing the system from entering sleep or turning off the display while the application is running.</summary>
    <param name="esFlags">
      <para>The thread's execution requirements. This parameter can be one or more of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ES_AWAYMODE_REQUIRED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000040</term>
              </listheader>
            </list>
          </description>
          <description>Enables away mode. This value must be specified with <b>ES_CONTINUOUS</b>.<para>Away mode should be used only by media-recording and media-distribution applications that must perform critical background processing on desktop computers while the computer appears to be sleeping. See Remarks.</para></description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ES_CONTINUOUS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x80000000</term>
              </listheader>
            </list>
          </description>
          <description>Informs the system that the state being set should remain in effect until the next call that uses <b>ES_CONTINUOUS</b> and one of the other state flags is cleared.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ES_DISPLAY_REQUIRED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000002</term>
              </listheader>
            </list>
          </description>
          <description>Forces the display to be on by resetting the display idle timer.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ES_SYSTEM_REQUIRED</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000001</term>
              </listheader>
            </list>
          </description>
          <description>Forces the system to be in the working state by resetting the system idle timer.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ES_USER_PRESENT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000004</term>
              </listheader>
            </list>
          </description>
          <description>This value is not supported. If <b>ES_USER_PRESENT</b> is combined with other <i>esFlags</i> values, the call will fail and none of the specified states will be set.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If the function succeeds, the return value is the previous thread execution state.</para>
      <para>If the function fails, the return value is <b>NULL</b>.</para>
    </returns>
  </member>
  <member name="Windows.SetThreadpoolCallbackCleanupGroup">
    <summary>Associates the specified cleanup group with the specified callback environment.</summary>
    <param name="pcbe">A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="InitializeThreadpoolEnvironment" /> function returns this structure.</param>
    <param name="ptpcg">A <b>TP_CLEANUP_GROUP</b> structure that defines the cleanup group. The <see cref="CreateThreadpoolCleanupGroup" /> function returns this structure.</param>
    <param name="pfng">The cleanup callback to be called if the cleanup group is canceled before the associated object is released. The function is called when you call <see cref="CloseThreadpoolCleanupGroupMembers" />.</param>
  </member>
  <member name="Windows.SetThreadpoolCallbackLibrary">
    <summary>Ensures that the specified DLL remains loaded as long as there are outstanding callbacks.</summary>
    <param name="pcbe">A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="InitializeThreadpoolEnvironment" /> function returns this structure.</param>
    <param name="mod">A handle to the DLL.</param>
  </member>
  <member name="Windows.SetThreadpoolCallbackPersistent">
    <summary>Specifies that the callback should run on a persistent thread.</summary>
    <param name="pcbe">A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="InitializeThreadpoolEnvironment" /> function returns this structure.</param>
  </member>
  <member name="Windows.SetThreadpoolCallbackPool">
    <summary>Sets the thread pool to be used when generating callbacks.</summary>
    <param name="pcbe">A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="InitializeThreadpoolEnvironment" /> function returns this structure.</param>
    <param name="ptpp">A <b>TP_POOL</b> structure that defines the thread pool. The <see cref="CreateThreadpool" /> function returns this structure.</param>
  </member>
  <member name="Windows.SetThreadpoolCallbackPriority">
    <summary>Specifies the priority of a callback function relative to other work items in the same thread pool.</summary>
    <param name="pcbe">A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="InitializeThreadpoolEnvironment" /> function returns this structure.</param>
    <param name="Priority">
      <para>The priority for the callback relative to other callbacks in the same thread pool. This parameter can be one of the following <b>TP_CALLBACK_PRIORITY</b> enumeration values:</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TP_CALLBACK_PRIORITY_HIGH</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The callback should run at high priority.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TP_CALLBACK_PRIORITY_LOW</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The callback should run at low priority.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TP_CALLBACK_PRIORITY_NORMAL</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The callback should run at normal priority.</description>
        </listheader>
      </list>
    </param>
  </member>
  <member name="Windows.SetThreadpoolCallbackRunsLong">
    <summary>Indicates that callbacks associated with this callback environment may not return quickly.</summary>
    <param name="pcbe">A <b>TP_CALLBACK_ENVIRON</b> structure that defines the callback environment. The <see cref="InitializeThreadpoolEnvironment" /> function returns this structure.</param>
  </member>
  <member name="Windows.SetUmsThreadInformation">
    <summary>
      <para>Sets application-specific context information for the specified user-mode scheduling (UMS) worker thread.</para>
      <blockquote>[!WARNING] As of Windows 11, user-mode scheduling is not supported. All calls fail with the error <code>ERROR_NOT_SUPPORTED</code>.</blockquote>
    </summary>
    <param name="UmsThread">A pointer to a UMS thread context.</param>
    <param name="UmsThreadInfoClass">A <see cref="UMS_THREAD_INFO_CLASS" /> value that specifies the kind of information to set. This parameter must be <b>UmsThreadUserContext</b>.</param>
    <param name="UmsThreadInformation">A pointer to a buffer that contains the information to set.</param>
    <param name="UmsThreadInformationLength">The size of the <i>UmsThreadInformation</i> buffer, in bytes.</param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />. Possible error values include the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INFO_LENGTH_MISMATCH</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The buffer size does not match the required size for the specified information class.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_INFO_CLASS</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The <i>UmsThreadInfoClass</i> parameter specifies an information class that is not supported.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_SUPPORTED</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>UMS is not supported.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.SetupComm">
    <summary>Initializes the communications parameters for a specified communications device.</summary>
    <param name="hFile">A handle to the communications device. The<see cref="CreateFile" /> function returns this handle.</param>
    <param name="dwInQueue">The recommended size of the device's internal input buffer, in bytes.</param>
    <param name="dwOutQueue">The recommended size of the device's internal output buffer, in bytes.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetVolumeLabel">
    <summary>Sets the label of a file system volume.</summary>
    <param name="lpRootPathName">A pointer to a string that contains the volume's drive letter (for example, X:) or the path of a mounted folder that is associated with the volume (for example, Y:\MountX). The string must end with a trailing backslash (''). If this parameter is <b>NULL</b>, the root of the current directory is used.</param>
    <param name="lpVolumeName">A pointer to a string that contains the new label for the volume. If this parameter is<b>NULL</b>, the function deletes any existing label from the specified volume and does not assign a new label.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetVolumeLabelA">
    <summary>Sets the label of a file system volume.</summary>
    <param name="lpRootPathName">A pointer to a string that contains the volume's drive letter (for example, X:) or the path of a mounted folder that is associated with the volume (for example, Y:\MountX). The string must end with a trailing backslash (''). If this parameter is <b>NULL</b>, the root of the current directory is used.</param>
    <param name="lpVolumeName">A pointer to a string that contains the new label for the volume. If this parameter is<b>NULL</b>, the function deletes any existing label from the specified volume and does not assign a new label.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetVolumeLabelW">
    <summary>Sets the label of a file system volume.</summary>
    <param name="lpRootPathName">A pointer to a string that contains the volume's drive letter (for example, X:) or the path of a mounted folder that is associated with the volume (for example, Y:\MountX). The string must end with a trailing backslash (''). If this parameter is <b>NULL</b>, the root of the current directory is used.</param>
    <param name="lpVolumeName">A pointer to a string that contains the new label for the volume. If this parameter is<b>NULL</b>, the function deletes any existing label from the specified volume and does not assign a new label.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetVolumeLabel">
    <summary>Sets the label of a file system volume.</summary>
    <param name="lpRootPathName">A pointer to a string that contains the volume's drive letter (for example, X:) or the path of a mounted folder that is associated with the volume (for example, Y:\MountX). The string must end with a trailing backslash (''). If this parameter is <b>NULL</b>, the root of the current directory is used.</param>
    <param name="lpVolumeName">A pointer to a string that contains the new label for the volume. If this parameter is<b>NULL</b>, the function deletes any existing label from the specified volume and does not assign a new label.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetVolumeLabelA">
    <summary>Sets the label of a file system volume.</summary>
    <param name="lpRootPathName">A pointer to a string that contains the volume's drive letter (for example, X:) or the path of a mounted folder that is associated with the volume (for example, Y:\MountX). The string must end with a trailing backslash (''). If this parameter is <b>NULL</b>, the root of the current directory is used.</param>
    <param name="lpVolumeName">A pointer to a string that contains the new label for the volume. If this parameter is<b>NULL</b>, the function deletes any existing label from the specified volume and does not assign a new label.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetVolumeLabelW">
    <summary>Sets the label of a file system volume.</summary>
    <param name="lpRootPathName">A pointer to a string that contains the volume's drive letter (for example, X:) or the path of a mounted folder that is associated with the volume (for example, Y:\MountX). The string must end with a trailing backslash (''). If this parameter is <b>NULL</b>, the root of the current directory is used.</param>
    <param name="lpVolumeName">A pointer to a string that contains the new label for the volume. If this parameter is<b>NULL</b>, the function deletes any existing label from the specified volume and does not assign a new label.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.SetVolumeMountPoint">
    <summary>Associates a volume with a drive letter or a directory on another volume.</summary>
    <param name="lpszVolumeMountPoint">The user-mode path to be associated with the volume. This may be a drive letter (for example, "X:\") or a directory on another volume (for example, "Y:\MountX"). The string must end with a trailing backslash ('').</param>
    <param name="lpszVolumeName">A volume <b>GUID</b> path for the volume. This string must be of the form "\\?\Volume{<i>GUID</i>}" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. The "\\?" turns off path parsing and is ignored as part of the path, as discussed in<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the <i>lpszVolumeMountPoint</i> parameter contains a path to a mounted folder, <see cref="GetLastError" /> returns <b>ERROR_DIR_NOT_EMPTY</b>, even if the directory is empty.</para>
    </returns>
  </member>
  <member name="Windows.SetVolumeMountPointA">
    <summary>Associates a volume with a drive letter or a directory on another volume.</summary>
    <param name="lpszVolumeMountPoint">The user-mode path to be associated with the volume. This may be a drive letter (for example, "X:\") or a directory on another volume (for example, "Y:\MountX"). The string must end with a trailing backslash ('').</param>
    <param name="lpszVolumeName">A volume <b>GUID</b> path for the volume. This string must be of the form "\\?\Volume{<i>GUID</i>}" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. The "\\?" turns off path parsing and is ignored as part of the path, as discussed in<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the <i>lpszVolumeMountPoint</i> parameter contains a path to a mounted folder, <see cref="GetLastError" /> returns <b>ERROR_DIR_NOT_EMPTY</b>, even if the directory is empty.</para>
    </returns>
  </member>
  <member name="Windows.SetVolumeMountPointW">
    <summary>Associates a volume with a drive letter or a directory on another volume.</summary>
    <param name="lpszVolumeMountPoint">The user-mode path to be associated with the volume. This may be a drive letter (for example, "X:\") or a directory on another volume (for example, "Y:\MountX"). The string must end with a trailing backslash ('').</param>
    <param name="lpszVolumeName">A volume <b>GUID</b> path for the volume. This string must be of the form "\\?\Volume{<i>GUID</i>}" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. The "\\?" turns off path parsing and is ignored as part of the path, as discussed in<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the <i>lpszVolumeMountPoint</i> parameter contains a path to a mounted folder, <see cref="GetLastError" /> returns <b>ERROR_DIR_NOT_EMPTY</b>, even if the directory is empty.</para>
    </returns>
  </member>
  <member name="Windows.SetVolumeMountPoint">
    <summary>Associates a volume with a drive letter or a directory on another volume.</summary>
    <param name="lpszVolumeMountPoint">The user-mode path to be associated with the volume. This may be a drive letter (for example, "X:\") or a directory on another volume (for example, "Y:\MountX"). The string must end with a trailing backslash ('').</param>
    <param name="lpszVolumeName">A volume <b>GUID</b> path for the volume. This string must be of the form "\\?\Volume{<i>GUID</i>}\" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. The "\\?\" turns off path parsing and is ignored as part of the path, as discussed in<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the <i>lpszVolumeMountPoint</i> parameter contains a path to a mounted folder, <see cref="GetLastError" /> returns <b>ERROR_DIR_NOT_EMPTY</b>, even if the directory is empty.</para>
    </returns>
  </member>
  <member name="Windows.SetVolumeMountPointA">
    <summary>Associates a volume with a drive letter or a directory on another volume.</summary>
    <param name="lpszVolumeMountPoint">The user-mode path to be associated with the volume. This may be a drive letter (for example, "X:\") or a directory on another volume (for example, "Y:\MountX"). The string must end with a trailing backslash ('').</param>
    <param name="lpszVolumeName">A volume <b>GUID</b> path for the volume. This string must be of the form "\\?\Volume{<i>GUID</i>}\" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. The "\\?\" turns off path parsing and is ignored as part of the path, as discussed in<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the <i>lpszVolumeMountPoint</i> parameter contains a path to a mounted folder, <see cref="GetLastError" /> returns <b>ERROR_DIR_NOT_EMPTY</b>, even if the directory is empty.</para>
    </returns>
  </member>
  <member name="Windows.SetVolumeMountPointW">
    <summary>Associates a volume with a drive letter or a directory on another volume.</summary>
    <param name="lpszVolumeMountPoint">The user-mode path to be associated with the volume. This may be a drive letter (for example, "X:\") or a directory on another volume (for example, "Y:\MountX"). The string must end with a trailing backslash ('').</param>
    <param name="lpszVolumeName">A volume <b>GUID</b> path for the volume. This string must be of the form "\\?\Volume{<i>GUID</i>}\" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. The "\\?\" turns off path parsing and is ignored as part of the path, as discussed in<a href="https://docs.microsoft.com//windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
      <para>If the <i>lpszVolumeMountPoint</i> parameter contains a path to a mounted folder, <see cref="GetLastError" /> returns <b>ERROR_DIR_NOT_EMPTY</b>, even if the directory is empty.</para>
    </returns>
  </member>
  <member name="Windows.SetXStateFeaturesMask">
    <summary>Sets the mask of XState features set within a<see cref="CONTEXT" /> structure.</summary>
    <param name="Context">A pointer to a <see cref="CONTEXT" /> structure that has been initialized with <see cref="InitializeContext" />.</param>
    <param name="FeatureMask">A mask of XState features to set in the specified<see cref="CONTEXT" /> structure.</param>
    <returns>This function returns <b>TRUE</b> if successful, otherwise<b>FALSE</b>.</returns>
  </member>
  <member name="Windows.SwitchToFiber">
    <summary>Schedules a fiber. The function must be called on a fiber.</summary>
    <param name="lpFiber">The address of the fiber to be scheduled.</param>
  </member>
  <member name="Windows.TransmitCommChar">
    <summary>Transmits a specified character ahead of any pending data in the output buffer of the specified communications device.</summary>
    <param name="hFile">A handle to the communications device. The<see cref="CreateFile" /> function returns this handle.</param>
    <param name="cChar">The character to be transmitted.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.UmsThreadYield">
    <summary>
      <para>Yields control to the user-mode scheduling (UMS) scheduler thread on which the calling UMS worker thread is running.</para>
      <blockquote>[!WARNING] As of Windows 11, user-mode scheduling is not supported. All calls fail with the error <code>ERROR_NOT_SUPPORTED</code>.</blockquote>
    </summary>
    <param name="SchedulerParam">A parameter to pass to the scheduler thread's <a href="https://docs.microsoft.com//windows/desktop/api/winnt/nc-winnt-rtl_ums_scheduler_entry_point">UmsSchedulerProc</a> function.</param>
    <returns>
      <para>If the function succeeds, it returns a nonzero value.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.UnregisterApplicationRecoveryCallback">
    <summary>Removes the active instance of an application from the recovery list.</summary>
    <returns>
      <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>E_FAIL</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Internal error.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.UnregisterApplicationRestart">
    <summary>Removes the active instance of an application from the restart list.</summary>
    <returns>
      <para>This function returns <b>S_OK</b> on success or one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>E_FAIL</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>Internal error.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.UnregisterWait">
    <summary>
      <para>Cancels a registered wait operation issued by the<see cref="RegisterWaitForSingleObject" /> function.</para>
      <para>To use a completion event, call the<a href="https://docs.microsoft.com//windows/desktop/Sync/unregisterwaitex">UnregisterWaitEx</a> function.</para>
    </summary>
    <param name="WaitHandle">The wait handle. This handle is returned by the<see cref="RegisterWaitForSingleObject" /> function.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.UpdateResource">
    <summary>Adds, deletes, or replaces a resource in a portable executable (PE) file. There are some restrictions on resource updates in files that contain Resource Configuration (RC Config) data: <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral</a> (LN) files and language-specific resource (.mui) files.</summary>
    <param name="hUpdate">A module handle returned by the <see cref="BeginUpdateResource" /> function, referencing the file to be updated.</param>
    <param name="lpType">
      <para>The resource type to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/win32/menurc/resource-types">Resource Types</a>.</para>
    </param>
    <param name="lpName">The name of the resource to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is a resource ID. When creating a new resource do not use a string that begins with a '#' character for this parameter.</param>
    <param name="wLanguage">The <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">language identifier</a> of the resource to be updated. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the <see cref="MAKELANGID" /> macro.</param>
    <param name="lpData">
      <para>The resource data to be inserted into the file indicated by <i>hUpdate</i>. If the resource is one of the predefined types, the data must be valid and properly aligned. Note that this is the raw binary data to be stored in the file indicated by <i>hUpdate</i>, not the data provided by <see cref="LoadIcon" />, <see cref="LoadString" />, or other resource-specific load functions. All data containing strings or text must be in Unicode format. <i>lpData</i> must not point to ANSI data.</para>
      <para>If <i>lpData</i> is <b>NULL</b> and <i>cbData</i> is 0, the specified resource is deleted from the file indicated by <i>hUpdate</i>.</para>
    </param>
    <param name="cb">The size, in bytes, of the resource data at <i>lpData</i>.</param>
    <returns>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.UpdateResourceA">
    <summary>Adds, deletes, or replaces a resource in a portable executable (PE) file. There are some restrictions on resource updates in files that contain Resource Configuration (RC Config) data: <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral</a> (LN) files and language-specific resource (.mui) files.</summary>
    <param name="hUpdate">A module handle returned by the <see cref="BeginUpdateResource" /> function, referencing the file to be updated.</param>
    <param name="lpType">
      <para>The resource type to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/win32/menurc/resource-types">Resource Types</a>.</para>
    </param>
    <param name="lpName">The name of the resource to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is a resource ID. When creating a new resource do not use a string that begins with a '#' character for this parameter.</param>
    <param name="wLanguage">The <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">language identifier</a> of the resource to be updated. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the <see cref="MAKELANGID" /> macro.</param>
    <param name="lpData">
      <para>The resource data to be inserted into the file indicated by <i>hUpdate</i>. If the resource is one of the predefined types, the data must be valid and properly aligned. Note that this is the raw binary data to be stored in the file indicated by <i>hUpdate</i>, not the data provided by <see cref="LoadIcon" />, <see cref="LoadString" />, or other resource-specific load functions. All data containing strings or text must be in Unicode format. <i>lpData</i> must not point to ANSI data.</para>
      <para>If <i>lpData</i> is <b>NULL</b> and <i>cbData</i> is 0, the specified resource is deleted from the file indicated by <i>hUpdate</i>.</para>
    </param>
    <param name="cb">The size, in bytes, of the resource data at <i>lpData</i>.</param>
    <returns>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.UpdateResourceW">
    <summary>Adds, deletes, or replaces a resource in a portable executable (PE) file. There are some restrictions on resource updates in files that contain Resource Configuration (RC Config) data: <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral</a> (LN) files and language-specific resource (.mui) files.</summary>
    <param name="hUpdate">A module handle returned by the <see cref="BeginUpdateResource" /> function, referencing the file to be updated.</param>
    <param name="lpType">
      <para>The resource type to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/win32/menurc/resource-types">Resource Types</a>.</para>
    </param>
    <param name="lpName">The name of the resource to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is a resource ID. When creating a new resource do not use a string that begins with a '#' character for this parameter.</param>
    <param name="wLanguage">The <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">language identifier</a> of the resource to be updated. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the <see cref="MAKELANGID" /> macro.</param>
    <param name="lpData">
      <para>The resource data to be inserted into the file indicated by <i>hUpdate</i>. If the resource is one of the predefined types, the data must be valid and properly aligned. Note that this is the raw binary data to be stored in the file indicated by <i>hUpdate</i>, not the data provided by <see cref="LoadIcon" />, <see cref="LoadString" />, or other resource-specific load functions. All data containing strings or text must be in Unicode format. <i>lpData</i> must not point to ANSI data.</para>
      <para>If <i>lpData</i> is <b>NULL</b> and <i>cbData</i> is 0, the specified resource is deleted from the file indicated by <i>hUpdate</i>.</para>
    </param>
    <param name="cb">The size, in bytes, of the resource data at <i>lpData</i>.</param>
    <returns>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.UpdateResource">
    <summary>Adds, deletes, or replaces a resource in a portable executable (PE) file. There are some restrictions on resource updates in files that contain Resource Configuration (RC Config) data: <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral</a> (LN) files and language-specific resource (.mui) files.</summary>
    <param name="hUpdate">A module handle returned by the <see cref="BeginUpdateResource" /> function, referencing the file to be updated.</param>
    <param name="lpType">
      <para>The resource type to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/win32/menurc/resource-types">Resource Types</a>.</para>
    </param>
    <param name="lpName">The name of the resource to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is a resource ID. When creating a new resource do not use a string that begins with a '#' character for this parameter.</param>
    <param name="wLanguage">The <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">language identifier</a> of the resource to be updated. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the <see cref="MAKELANGID" /> macro.</param>
    <param name="lpData">
      <para>The resource data to be inserted into the file indicated by <i>hUpdate</i>. If the resource is one of the predefined types, the data must be valid and properly aligned. Note that this is the raw binary data to be stored in the file indicated by <i>hUpdate</i>, not the data provided by <see cref="LoadIcon" />, <see cref="LoadString" />, or other resource-specific load functions. All data containing strings or text must be in Unicode format. <i>lpData</i> must not point to ANSI data.</para>
      <para>If <i>lpData</i> is <b>NULL</b> and <i>cbData</i> is 0, the specified resource is deleted from the file indicated by <i>hUpdate</i>.</para>
    </param>
    <param name="cb">The size, in bytes, of the resource data at <i>lpData</i>.</param>
    <returns>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.UpdateResourceA">
    <summary>Adds, deletes, or replaces a resource in a portable executable (PE) file. There are some restrictions on resource updates in files that contain Resource Configuration (RC Config) data: <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral</a> (LN) files and language-specific resource (.mui) files.</summary>
    <param name="hUpdate">A module handle returned by the <see cref="BeginUpdateResource" /> function, referencing the file to be updated.</param>
    <param name="lpType">
      <para>The resource type to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/win32/menurc/resource-types">Resource Types</a>.</para>
    </param>
    <param name="lpName">The name of the resource to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is a resource ID. When creating a new resource do not use a string that begins with a '#' character for this parameter.</param>
    <param name="wLanguage">The <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">language identifier</a> of the resource to be updated. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the <see cref="MAKELANGID" /> macro.</param>
    <param name="lpData">
      <para>The resource data to be inserted into the file indicated by <i>hUpdate</i>. If the resource is one of the predefined types, the data must be valid and properly aligned. Note that this is the raw binary data to be stored in the file indicated by <i>hUpdate</i>, not the data provided by <see cref="LoadIcon" />, <see cref="LoadString" />, or other resource-specific load functions. All data containing strings or text must be in Unicode format. <i>lpData</i> must not point to ANSI data.</para>
      <para>If <i>lpData</i> is <b>NULL</b> and <i>cbData</i> is 0, the specified resource is deleted from the file indicated by <i>hUpdate</i>.</para>
    </param>
    <param name="cb">The size, in bytes, of the resource data at <i>lpData</i>.</param>
    <returns>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.UpdateResourceW">
    <summary>Adds, deletes, or replaces a resource in a portable executable (PE) file. There are some restrictions on resource updates in files that contain Resource Configuration (RC Config) data: <a href="https://docs.microsoft.com//windows/desktop/Intl/mui-resource-management">language-neutral</a> (LN) files and language-specific resource (.mui) files.</summary>
    <param name="hUpdate">A module handle returned by the <see cref="BeginUpdateResource" /> function, referencing the file to be updated.</param>
    <param name="lpType">
      <para>The resource type to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is an integer value representing a predefined resource type. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource type. For example, the string "#258" represents the identifier 258.</para>
      <para>For a list of predefined resource types, see <a href="https://docs.microsoft.com//windows/win32/menurc/resource-types">Resource Types</a>.</para>
    </param>
    <param name="lpName">The name of the resource to be updated. Alternatively, rather than a pointer, this parameter can be <see cref="MAKEINTRESOURCE" />(ID), where ID is a resource ID. When creating a new resource do not use a string that begins with a '#' character for this parameter.</param>
    <param name="wLanguage">The <a href="https://docs.microsoft.com//windows/desktop/Intl/language-identifiers">language identifier</a> of the resource to be updated. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the <see cref="MAKELANGID" /> macro.</param>
    <param name="lpData">
      <para>The resource data to be inserted into the file indicated by <i>hUpdate</i>. If the resource is one of the predefined types, the data must be valid and properly aligned. Note that this is the raw binary data to be stored in the file indicated by <i>hUpdate</i>, not the data provided by <see cref="LoadIcon" />, <see cref="LoadString" />, or other resource-specific load functions. All data containing strings or text must be in Unicode format. <i>lpData</i> must not point to ANSI data.</para>
      <para>If <i>lpData</i> is <b>NULL</b> and <i>cbData</i> is 0, the specified resource is deleted from the file indicated by <i>hUpdate</i>.</para>
    </param>
    <param name="cb">The size, in bytes, of the resource data at <i>lpData</i>.</param>
    <returns>Returns <b>TRUE</b> if successful or <b>FALSE</b> otherwise. To get extended error information, call <see cref="GetLastError" />.</returns>
  </member>
  <member name="Windows.WaitCommEvent">
    <summary>Waits for an event to occur for a specified communications device. The set of events that are monitored by this function is contained in the event mask associated with the device handle.</summary>
    <param name="hFile">A handle to the communications device. The<see cref="CreateFile" /> function returns this handle.</param>
    <param name="lpEvtMask">
      <para>A pointer to a variable that receives a mask indicating the type of event that occurred. If an error occurs, the value is zero; otherwise, it is one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_BREAK</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0040</term>
              </listheader>
            </list>
          </description>
          <description>A break was detected on input.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_CTS</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0008</term>
              </listheader>
            </list>
          </description>
          <description>The CTS (clear-to-send) signal changed state.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_DSR</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0010</term>
              </listheader>
            </list>
          </description>
          <description>The DSR (data-set-ready) signal changed state.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_ERR</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0080</term>
              </listheader>
            </list>
          </description>
          <description>A line-status error occurred. Line-status errors are <b>CE_FRAME</b>, <b>CE_OVERRUN</b>, and <b>CE_RXPARITY</b>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_RING</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0100</term>
              </listheader>
            </list>
          </description>
          <description>A ring indicator was detected.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_RLSD</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0020</term>
              </listheader>
            </list>
          </description>
          <description>The RLSD (receive-line-signal-detect) signal changed state.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_RXCHAR</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0001</term>
              </listheader>
            </list>
          </description>
          <description>A character was received and placed in the input buffer.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_RXFLAG</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0002</term>
              </listheader>
            </list>
          </description>
          <description>The event character was received and placed in the input buffer. The event character is specified in the device's <see cref="DCB" /> structure, which is applied to a serial port by using the <see cref="SetCommState" /> function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>EV_TXEMPTY</b>
                </term>
              </listheader>
              <listheader>
                <term>0x0004</term>
              </listheader>
            </list>
          </description>
          <description>The last character in the output buffer was sent.</description>
        </listheader>
      </list>
    </param>
    <param name="lpOverlapped">
      <para>A pointer to an<see cref="OVERLAPPED" /> structure. This structure is required if <i>hFile</i> was opened with <b>FILE_FLAG_OVERLAPPED</b>.</para>
      <para>If <i>hFile</i> was opened with <b>FILE_FLAG_OVERLAPPED</b>, the <i>lpOverlapped</i> parameter must not be <b>NULL</b>. It must point to a valid <see cref="OVERLAPPED" /> structure. If <i>hFile</i> was opened with <b>FILE_FLAG_OVERLAPPED</b> and <i>lpOverlapped</i> is <b>NULL</b>, the function can incorrectly report that the operation is complete.</para>
      <para>If <i>hFile</i> was opened with <b>FILE_FLAG_OVERLAPPED</b> and <i>lpOverlapped</i> is not <b>NULL</b>,<b>WaitCommEvent</b> is performed as an overlapped operation. In this case, the <see cref="OVERLAPPED" /> structure must contain a handle to a manual-reset event object (created by using the<see cref="CreateEvent" /> function).</para>
      <para>If <i>hFile</i> was not opened with <b>FILE_FLAG_OVERLAPPED</b>,<b>WaitCommEvent</b> does not return until one of the specified events or an error occurs.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WaitNamedPipe">
    <summary>Waits until either a time-out interval elapses or an instance of the specified named pipe is available for connection (that is, the pipe's server process has a pending<see cref="ConnectNamedPipe" /> operation on the pipe).</summary>
    <param name="lpNamedPipeName">
      <para>The name of the named pipe. The string must include the name of the computer on which the server process is executing. A period may be used for the <i>servername</i> if the pipe is local. The following pipe name format is used:</para>
      <para>\\<i>servername</i>\pipe\<i>pipename</i></para>
    </param>
    <param name="nTimeOut">
      <para>The number of milliseconds that the function will wait for an instance of the named pipe to be available. You can used one of the following values instead of specifying a number of milliseconds.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NMPWAIT_USE_DEFAULT_WAIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000000</term>
              </listheader>
            </list>
          </description>
          <description>The time-out interval is the default value specified by the server process in the <see cref="CreateNamedPipe" /> function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NMPWAIT_WAIT_FOREVER</b>
                </term>
              </listheader>
              <listheader>
                <term>0xffffffff</term>
              </listheader>
            </list>
          </description>
          <description>The function does not return until an instance of the named pipe is available.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If an instance of the pipe is available before the time-out interval elapses, the return value is nonzero.</para>
      <para>If an instance of the pipe is not available before the time-out interval elapses, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WaitNamedPipeA">
    <summary>Waits until either a time-out interval elapses or an instance of the specified named pipe is available for connection (that is, the pipe's server process has a pending<see cref="ConnectNamedPipe" /> operation on the pipe).</summary>
    <param name="lpNamedPipeName">
      <para>The name of the named pipe. The string must include the name of the computer on which the server process is executing. A period may be used for the <i>servername</i> if the pipe is local. The following pipe name format is used:</para>
      <para>\\<i>servername</i>\pipe\<i>pipename</i></para>
    </param>
    <param name="nTimeOut">
      <para>The number of milliseconds that the function will wait for an instance of the named pipe to be available. You can used one of the following values instead of specifying a number of milliseconds.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NMPWAIT_USE_DEFAULT_WAIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000000</term>
              </listheader>
            </list>
          </description>
          <description>The time-out interval is the default value specified by the server process in the <see cref="CreateNamedPipe" /> function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NMPWAIT_WAIT_FOREVER</b>
                </term>
              </listheader>
              <listheader>
                <term>0xffffffff</term>
              </listheader>
            </list>
          </description>
          <description>The function does not return until an instance of the named pipe is available.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If an instance of the pipe is available before the time-out interval elapses, the return value is nonzero.</para>
      <para>If an instance of the pipe is not available before the time-out interval elapses, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WaitNamedPipeW">
    <summary>Waits until either a time-out interval elapses or an instance of the specified named pipe is available for connection (that is, the pipe's server process has a pending<see cref="ConnectNamedPipe" /> operation on the pipe).</summary>
    <param name="lpNamedPipeName">
      <para>The name of the named pipe. The string must include the name of the computer on which the server process is executing. A period may be used for the <i>servername</i> if the pipe is local. The following pipe name format is used:</para>
      <para>\\<i>servername</i>\pipe\<i>pipename</i></para>
    </param>
    <param name="nTimeOut">
      <para>The number of milliseconds that the function will wait for an instance of the named pipe to be available. You can used one of the following values instead of specifying a number of milliseconds.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NMPWAIT_USE_DEFAULT_WAIT</b>
                </term>
              </listheader>
              <listheader>
                <term>0x00000000</term>
              </listheader>
            </list>
          </description>
          <description>The time-out interval is the default value specified by the server process in the <see cref="CreateNamedPipe" /> function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>NMPWAIT_WAIT_FOREVER</b>
                </term>
              </listheader>
              <listheader>
                <term>0xffffffff</term>
              </listheader>
            </list>
          </description>
          <description>The function does not return until an instance of the named pipe is available.</description>
        </listheader>
      </list>
    </param>
    <returns>
      <para>If an instance of the pipe is available before the time-out interval elapses, the return value is nonzero.</para>
      <para>If an instance of the pipe is not available before the time-out interval elapses, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WinExec">
    <summary>
      <para>Runs the specified application.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit Windows. Applications should use the <see cref="CreateProcess" /> function.</div>
    </summary>
    <param name="lpCmdLine">
      <para>The command line (file name plus optional parameters) for the application to be executed. If the name of the executable file in the <i>lpCmdLine</i> parameter does not contain a directory path, the system searches for the executable file in this sequence:</para>
      <list type="number">
        <item>
          <description>The directory from which the application loaded.</description>
        </item>
        <item>
          <description>The current directory.</description>
        </item>
        <item>
          <description>The Windows system directory. The <see cref="GetSystemDirectory" /> function retrieves the path of this directory.</description>
        </item>
        <item>
          <description>The Windows directory. The <see cref="GetWindowsDirectory" /> function retrieves the path of this directory.</description>
        </item>
        <item>
          <description>The directories listed in the PATH environment variable.</description>
        </item>
      </list>
    </param>
    <param name="uCmdShow">The display options. For a list of the acceptable values, see the description of the <i>nCmdShow</i> parameter of the<see cref="ShowWindow" /> function.</param>
    <returns>
      <para>If the function succeeds, the return value is greater than 31.</para>
      <para>If the function fails, the return value is one of the following error values.</para>
      <list type="table">
        <listheader>
          <description>Return code/value</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>0</term>
              </listheader>
            </list>
          </description>
          <description>The system is out of memory or resources.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BAD_FORMAT</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The .exe file is invalid.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_FILE_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified file was not found.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PATH_NOT_FOUND</b>
                </term>
              </listheader>
            </list>
          </description>
          <description>The specified path was not found.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.WinMain">
    <summary>
      <para>The user-provided entry point for a graphical Windows-based application.</para>
      <para>
        <b>WinMain</b> is the conventional name used for the application entry point. For more information, see Remarks.</para>
    </summary>
    <param name="hInstance">A handle to the current instance of the application.</param>
    <param name="hPrevInstance">A handle to the previous instance of the application. This parameter is always <b>NULL</b>. If you need to detect whether another instance already exists, create a uniquely named mutex using the <see cref="CreateMutex" /> function. <b>CreateMutex</b> will succeed even if the mutex already exists, but the function will return <b>ERROR_ALREADY_EXISTS</b>. This indicates that another instance of your application exists, because it created the mutex first. However, a malicious user can create this mutex before you do and prevent your application from starting. To prevent this situation, create a randomly named mutex and store the name so that it can only be obtained by an authorized user. Alternatively, you can use a file for this purpose. To limit your application to one instance per user, create a locked file in the user's profile directory.</param>
    <param name="lpCmdLine">The command line for the application, excluding the program name. To retrieve the entire command line, use the <see cref="GetCommandLine" /> function.</param>
    <param name="nShowCmd">Controls how the window is to be shown. This parameter can be any of the values that can be specified in the <i>nCmdShow</i> parameter for the <see cref="ShowWindow" /> function.</param>
    <returns>If the function succeeds, terminating when it receives a <a href="https://docs.microsoft.com//windows/desktop/winmsg/wm-quit">WM_QUIT</a> message, it should return the exit value contained in that message's <i>wParam</i> parameter. If the function terminates before entering the message loop, it should return zero.</returns>
  </member>
  <member name="Windows.Wow64GetThreadContext">
    <summary>Retrieves the context of the specified WOW64 thread.</summary>
    <param name="hThread">A handle to the thread whose context is to be retrieved. The handle must have<b>THREAD_GET_CONTEXT</b> access to the thread. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</param>
    <param name="lpContext">A <see cref="WOW64_CONTEXT" /> structure. The caller must initialize the <b>ContextFlags</b> member of this structure.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.Wow64GetThreadSelectorEntry">
    <summary>Retrieves a descriptor table entry for the specified selector and WOW64 thread.</summary>
    <param name="hThread">A handle to the thread containing the specified selector. The handle must have been created with THREAD_QUERY_INFORMATION access to the thread. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</param>
    <param name="dwSelector">The global or local selector value to look up in the thread's descriptor tables.</param>
    <param name="lpSelectorEntry">A pointer to a<see cref="WOW64_LDT_ENTRY" /> structure that receives a copy of the descriptor table entry if the specified selector has an entry in the specified thread's descriptor table. This information can be used to convert a segment-relative address to a linear virtual address.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero. In that case, the structure pointed to by the <i>lpSelectorEntry</i> parameter receives a copy of the specified descriptor table entry.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.Wow64SetThreadContext">
    <summary>Sets the context of the specified WOW64 thread.</summary>
    <param name="hThread">A handle to the thread whose context is to be set.</param>
    <param name="lpContext">A <see cref="WOW64_CONTEXT" /> structure. The caller must initialize the <b>ContextFlags</b> member of this structure.</param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.Wow64SuspendThread">
    <summary>Suspends the specified WOW64 thread.</summary>
    <param name="hThread">
      <para>A handle to the thread that is to be suspended.</para>
      <para>The handle must have the THREAD_SUSPEND_RESUME access right. For more information, see<a href="https://docs.microsoft.com//windows/desktop/ProcThread/thread-security-and-access-rights">Thread Security and Access Rights</a>.</para>
    </param>
    <returns>If the function succeeds, the return value is the thread's previous suspend count; otherwise, it is (DWORD) -1. To get extended error information, use the<see cref="GetLastError" /> function.</returns>
  </member>
  <member name="Windows.WriteEncryptedFileRaw">
    <summary>Restores (import) encrypted files. This is one of a group of Encrypted File System (EFS) functions that is intended to implement backup and restore functionality, while maintaining files in their encrypted state.</summary>
    <param name="pfImportCallback">A pointer to the import callback function. The system calls the callback function multiple times, each time passing a buffer that will be filled by the callback function with a portion of backed-up file's data. When the callback function signals that the entire file has been processed, it tells the system that the restore operation is finished. For more information, see<a href="https://docs.microsoft.com//windows/desktop/api/winbase/nc-winbase-pfe_import_func">ImportCallback</a>.</param>
    <param name="pvCallbackContext">A pointer to an application-defined and allocated context block. The system passes this pointer to the callback function as a parameter so that the callback function can have access to application-specific data. This can be a structure and can contain any data the application needs, such as the handle to the file that will contain the backup copy of the encrypted file.</param>
    <param name="pvContext">A pointer to a system-defined context block. The context block is returned by the<see cref="OpenEncryptedFileRaw" /> function. Do not modify it.</param>
    <returns>
      <para>If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.</para>
      <para>If the function fails, it returns a nonzero error code defined in WinError.h. You can use<see cref="FormatMessage" /> with the<b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of the error.</para>
    </returns>
  </member>
  <member name="Windows.WritePrivateProfileSection">
    <summary>
      <para>Replaces the keys and values for the specified section in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in which data is written. This section name is typically the name of the calling application.</param>
    <param name="lpString">The new key names and associated values that are to be written to the named section. This string is limited to 65,535 bytes.</param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path for the file, the function searches the Windows directory for the file. If the file does not exist and <i>lpFileName</i> does not contain a full path, the function creates the file in the Windows directory.</para>
      <para>If the file exists and was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function creates a file using ANSI characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WritePrivateProfileSectionA">
    <summary>
      <para>Replaces the keys and values for the specified section in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in which data is written. This section name is typically the name of the calling application.</param>
    <param name="lpString">The new key names and associated values that are to be written to the named section. This string is limited to 65,535 bytes.</param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path for the file, the function searches the Windows directory for the file. If the file does not exist and <i>lpFileName</i> does not contain a full path, the function creates the file in the Windows directory.</para>
      <para>If the file exists and was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function creates a file using ANSI characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WritePrivateProfileSectionW">
    <summary>
      <para>Replaces the keys and values for the specified section in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in which data is written. This section name is typically the name of the calling application.</param>
    <param name="lpString">The new key names and associated values that are to be written to the named section. This string is limited to 65,535 bytes.</param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path for the file, the function searches the Windows directory for the file. If the file does not exist and <i>lpFileName</i> does not contain a full path, the function creates the file in the Windows directory.</para>
      <para>If the file exists and was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function creates a file using ANSI characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WritePrivateProfileSection">
    <summary>
      <para>Replaces the keys and values for the specified section in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in which data is written. This section name is typically the name of the calling application.</param>
    <param name="lpString">The new key names and associated values that are to be written to the named section. This string is limited to 65,535 bytes.</param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path for the file, the function searches the Windows directory for the file. If the file does not exist and <i>lpFileName</i> does not contain a full path, the function creates the file in the Windows directory.</para>
      <para>If the file exists and was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function creates a file using ANSI characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WritePrivateProfileSectionA">
    <summary>
      <para>Replaces the keys and values for the specified section in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in which data is written. This section name is typically the name of the calling application.</param>
    <param name="lpString">The new key names and associated values that are to be written to the named section. This string is limited to 65,535 bytes.</param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path for the file, the function searches the Windows directory for the file. If the file does not exist and <i>lpFileName</i> does not contain a full path, the function creates the file in the Windows directory.</para>
      <para>If the file exists and was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function creates a file using ANSI characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WritePrivateProfileSectionW">
    <summary>
      <para>Replaces the keys and values for the specified section in an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section in which data is written. This section name is typically the name of the calling application.</param>
    <param name="lpString">The new key names and associated values that are to be written to the named section. This string is limited to 65,535 bytes.</param>
    <param name="lpFileName">
      <para>The name of the initialization file. If this parameter does not contain a full path for the file, the function searches the Windows directory for the file. If the file does not exist and <i>lpFileName</i> does not contain a full path, the function creates the file in the Windows directory.</para>
      <para>If the file exists and was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function creates a file using ANSI characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WritePrivateProfileString">
    <summary>
      <para>Copies a string into the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section to which the string will be copied. If the section does not exist, it is created. The name of the section is case-independent; the string can be any combination of uppercase and lowercase letters.</param>
    <param name="lpKeyName">The name of the key to be associated with a string. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all entries within the section, is deleted.</param>
    <param name="lpString">A <b>null</b>-terminated string to be written to the file. If this parameter is <b>NULL</b>, the key pointed to by the <i>lpKeyName</i> parameter is deleted.</param>
    <param name="lpFileName">
      <para>The name of the initialization file.</para>
      <para>If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
    </param>
    <returns>
      <para>If the function successfully copies the string to the initialization file, the return value is nonzero.</para>
      <para>If the function fails, or if it flushes the cached version of the most recently accessed initialization file, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WritePrivateProfileStringA">
    <summary>
      <para>Copies a string into the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section to which the string will be copied. If the section does not exist, it is created. The name of the section is case-independent; the string can be any combination of uppercase and lowercase letters.</param>
    <param name="lpKeyName">The name of the key to be associated with a string. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all entries within the section, is deleted.</param>
    <param name="lpString">A <b>null</b>-terminated string to be written to the file. If this parameter is <b>NULL</b>, the key pointed to by the <i>lpKeyName</i> parameter is deleted.</param>
    <param name="lpFileName">
      <para>The name of the initialization file.</para>
      <para>If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
    </param>
    <returns>
      <para>If the function successfully copies the string to the initialization file, the return value is nonzero.</para>
      <para>If the function fails, or if it flushes the cached version of the most recently accessed initialization file, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WritePrivateProfileStringW">
    <summary>
      <para>Copies a string into the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section to which the string will be copied. If the section does not exist, it is created. The name of the section is case-independent; the string can be any combination of uppercase and lowercase letters.</param>
    <param name="lpKeyName">The name of the key to be associated with a string. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all entries within the section, is deleted.</param>
    <param name="lpString">A <b>null</b>-terminated string to be written to the file. If this parameter is <b>NULL</b>, the key pointed to by the <i>lpKeyName</i> parameter is deleted.</param>
    <param name="lpFileName">
      <para>The name of the initialization file.</para>
      <para>If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
    </param>
    <returns>
      <para>If the function successfully copies the string to the initialization file, the return value is nonzero.</para>
      <para>If the function fails, or if it flushes the cached version of the most recently accessed initialization file, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WritePrivateProfileString">
    <summary>
      <para>Copies a string into the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section to which the string will be copied. If the section does not exist, it is created. The name of the section is case-independent; the string can be any combination of uppercase and lowercase letters.</param>
    <param name="lpKeyName">The name of the key to be associated with a string. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all entries within the section, is deleted.</param>
    <param name="lpString">A <b>null</b>-terminated string to be written to the file. If this parameter is <b>NULL</b>, the key pointed to by the <i>lpKeyName</i> parameter is deleted.</param>
    <param name="lpFileName">
      <para>The name of the initialization file.</para>
      <para>If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
    </param>
    <returns>
      <para>If the function successfully copies the string to the initialization file, the return value is nonzero.</para>
      <para>If the function fails, or if it flushes the cached version of the most recently accessed initialization file, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WritePrivateProfileStringA">
    <summary>
      <para>Copies a string into the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section to which the string will be copied. If the section does not exist, it is created. The name of the section is case-independent; the string can be any combination of uppercase and lowercase letters.</param>
    <param name="lpKeyName">The name of the key to be associated with a string. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all entries within the section, is deleted.</param>
    <param name="lpString">A <b>null</b>-terminated string to be written to the file. If this parameter is <b>NULL</b>, the key pointed to by the <i>lpKeyName</i> parameter is deleted.</param>
    <param name="lpFileName">
      <para>The name of the initialization file.</para>
      <para>If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
    </param>
    <returns>
      <para>If the function successfully copies the string to the initialization file, the return value is nonzero.</para>
      <para>If the function fails, or if it flushes the cached version of the most recently accessed initialization file, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WritePrivateProfileStringW">
    <summary>
      <para>Copies a string into the specified section of an initialization file.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section to which the string will be copied. If the section does not exist, it is created. The name of the section is case-independent; the string can be any combination of uppercase and lowercase letters.</param>
    <param name="lpKeyName">The name of the key to be associated with a string. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all entries within the section, is deleted.</param>
    <param name="lpString">A <b>null</b>-terminated string to be written to the file. If this parameter is <b>NULL</b>, the key pointed to by the <i>lpKeyName</i> parameter is deleted.</param>
    <param name="lpFileName">
      <para>The name of the initialization file.</para>
      <para>If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
    </param>
    <returns>
      <para>If the function successfully copies the string to the initialization file, the return value is nonzero.</para>
      <para>If the function fails, or if it flushes the cached version of the most recently accessed initialization file, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WritePrivateProfileStruct">
    <summary>
      <para>Copies data into a key in the specified section of an initialization file. As it copies the data, the function calculates a checksum and appends it to the end of the data. The<see cref="GetPrivateProfileStruct" /> function uses the checksum to ensure the integrity of the data.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszSection">The name of the section to which the string will be copied. If the section does not exist, it is created. The name of the section is case independent, the string can be any combination of uppercase and lowercase letters.</param>
    <param name="lpszKey">The name of the key to be associated with a string. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all keys and entries within the section, is deleted.</param>
    <param name="lpStruct">The data to be copied. If this parameter is <b>NULL</b>, the key is deleted.</param>
    <param name="uSizeStruct">The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</param>
    <param name="szFile">
      <para>The name of the initialization file. If this parameter is <b>NULL</b>, the information is copied into the Win.ini file.</para>
      <para>If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
    </param>
    <returns>
      <para>If the function successfully copies the string to the initialization file, the return value is nonzero.</para>
      <para>If the function fails, or if it flushes the cached version of the most recently accessed initialization file, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WritePrivateProfileStructA">
    <summary>
      <para>Copies data into a key in the specified section of an initialization file. As it copies the data, the function calculates a checksum and appends it to the end of the data. The<see cref="GetPrivateProfileStruct" /> function uses the checksum to ensure the integrity of the data.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszSection">The name of the section to which the string will be copied. If the section does not exist, it is created. The name of the section is case independent, the string can be any combination of uppercase and lowercase letters.</param>
    <param name="lpszKey">The name of the key to be associated with a string. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all keys and entries within the section, is deleted.</param>
    <param name="lpStruct">The data to be copied. If this parameter is <b>NULL</b>, the key is deleted.</param>
    <param name="uSizeStruct">The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</param>
    <param name="szFile">
      <para>The name of the initialization file. If this parameter is <b>NULL</b>, the information is copied into the Win.ini file.</para>
      <para>If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
    </param>
    <returns>
      <para>If the function successfully copies the string to the initialization file, the return value is nonzero.</para>
      <para>If the function fails, or if it flushes the cached version of the most recently accessed initialization file, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WritePrivateProfileStructW">
    <summary>
      <para>Copies data into a key in the specified section of an initialization file. As it copies the data, the function calculates a checksum and appends it to the end of the data. The<see cref="GetPrivateProfileStruct" /> function uses the checksum to ensure the integrity of the data.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszSection">The name of the section to which the string will be copied. If the section does not exist, it is created. The name of the section is case independent, the string can be any combination of uppercase and lowercase letters.</param>
    <param name="lpszKey">The name of the key to be associated with a string. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all keys and entries within the section, is deleted.</param>
    <param name="lpStruct">The data to be copied. If this parameter is <b>NULL</b>, the key is deleted.</param>
    <param name="uSizeStruct">The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</param>
    <param name="szFile">
      <para>The name of the initialization file. If this parameter is <b>NULL</b>, the information is copied into the Win.ini file.</para>
      <para>If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
    </param>
    <returns>
      <para>If the function successfully copies the string to the initialization file, the return value is nonzero.</para>
      <para>If the function fails, or if it flushes the cached version of the most recently accessed initialization file, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WritePrivateProfileStruct">
    <summary>
      <para>Copies data into a key in the specified section of an initialization file. As it copies the data, the function calculates a checksum and appends it to the end of the data. The<see cref="GetPrivateProfileStruct" /> function uses the checksum to ensure the integrity of the data.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszSection">The name of the section to which the struct data will be copied. If the section does not exist, it is created. The name of the section is case independent.</param>
    <param name="lpszKey">The name of the key to be associated with a struct. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all keys and entries within the section, is deleted.</param>
    <param name="lpStruct">The data to be copied. If this parameter is <b>NULL</b>, the key is deleted.</param>
    <param name="uSizeStruct">The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</param>
    <param name="szFile">
      <para>The name of the initialization file. If this parameter is <b>NULL</b>, the information is copied into the Win.ini file.</para>
      <para>If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
    </param>
    <returns>
      <para>If the function successfully copies the struct to the initialization file, the return value is nonzero.</para>
      <para>If the function fails, or if it flushes the cached version of the most recently accessed initialization file, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WritePrivateProfileStructA">
    <summary>
      <para>Copies data into a key in the specified section of an initialization file. As it copies the data, the function calculates a checksum and appends it to the end of the data. The<see cref="GetPrivateProfileStruct" /> function uses the checksum to ensure the integrity of the data.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszSection">The name of the section to which the struct data will be copied. If the section does not exist, it is created. The name of the section is case independent.</param>
    <param name="lpszKey">The name of the key to be associated with a struct. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all keys and entries within the section, is deleted.</param>
    <param name="lpStruct">The data to be copied. If this parameter is <b>NULL</b>, the key is deleted.</param>
    <param name="uSizeStruct">The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</param>
    <param name="szFile">
      <para>The name of the initialization file. If this parameter is <b>NULL</b>, the information is copied into the Win.ini file.</para>
      <para>If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
    </param>
    <returns>
      <para>If the function successfully copies the struct to the initialization file, the return value is nonzero.</para>
      <para>If the function fails, or if it flushes the cached version of the most recently accessed initialization file, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WritePrivateProfileStructW">
    <summary>
      <para>Copies data into a key in the specified section of an initialization file. As it copies the data, the function calculates a checksum and appends it to the end of the data. The<see cref="GetPrivateProfileStruct" /> function uses the checksum to ensure the integrity of the data.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpszSection">The name of the section to which the struct data will be copied. If the section does not exist, it is created. The name of the section is case independent.</param>
    <param name="lpszKey">The name of the key to be associated with a struct. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all keys and entries within the section, is deleted.</param>
    <param name="lpStruct">The data to be copied. If this parameter is <b>NULL</b>, the key is deleted.</param>
    <param name="uSizeStruct">The size of the buffer pointed to by the <i>lpStruct</i> parameter, in bytes.</param>
    <param name="szFile">
      <para>The name of the initialization file. If this parameter is <b>NULL</b>, the information is copied into the Win.ini file.</para>
      <para>If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
    </param>
    <returns>
      <para>If the function successfully copies the struct to the initialization file, the return value is nonzero.</para>
      <para>If the function fails, or if it flushes the cached version of the most recently accessed initialization file, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WriteProfileSection">
    <summary>
      <para>Replaces the contents of the specified section in the Win.ini file with specified keys and values. If Win.ini uses Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section. This section name is typically the name of the calling application.</param>
    <param name="lpString">
      <para>The new key names and associated values that are to be written to the named section. This string is limited to 65,535 bytes.</para>
      <para>If the file exists and was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function creates a file using ANSI characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WriteProfileSectionA">
    <summary>
      <para>Replaces the contents of the specified section in the Win.ini file with specified keys and values. If Win.ini uses Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section. This section name is typically the name of the calling application.</param>
    <param name="lpString">
      <para>The new key names and associated values that are to be written to the named section. This string is limited to 65,535 bytes.</para>
      <para>If the file exists and was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function creates a file using ANSI characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WriteProfileSectionW">
    <summary>
      <para>Replaces the contents of the specified section in the Win.ini file with specified keys and values. If Win.ini uses Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section. This section name is typically the name of the calling application.</param>
    <param name="lpString">
      <para>The new key names and associated values that are to be written to the named section. This string is limited to 65,535 bytes.</para>
      <para>If the file exists and was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function creates a file using ANSI characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WriteProfileSection">
    <summary>
      <para>Replaces the contents of the specified section in the Win.ini file with specified keys and values. If Win.ini uses Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section. This section name is typically the name of the calling application.</param>
    <param name="lpString">
      <para>The new key names and associated values that are to be written to the named section. This string is limited to 65,535 bytes.</para>
      <para>If the file exists and was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function creates a file using ANSI characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WriteProfileSectionA">
    <summary>
      <para>Replaces the contents of the specified section in the Win.ini file with specified keys and values. If Win.ini uses Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section. This section name is typically the name of the calling application.</param>
    <param name="lpString">
      <para>The new key names and associated values that are to be written to the named section. This string is limited to 65,535 bytes.</para>
      <para>If the file exists and was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function creates a file using ANSI characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WriteProfileSectionW">
    <summary>
      <para>Replaces the contents of the specified section in the Win.ini file with specified keys and values. If Win.ini uses Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The name of the section. This section name is typically the name of the calling application.</param>
    <param name="lpString">
      <para>The new key names and associated values that are to be written to the named section. This string is limited to 65,535 bytes.</para>
      <para>If the file exists and was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function creates a file using ANSI characters.</para>
    </param>
    <returns>
      <para>If the function succeeds, the return value is nonzero.</para>
      <para>If the function fails, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WriteProfileString">
    <summary>
      <para>Copies a string into the specified section of the Win.ini file. If Win.ini uses Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The section to which the string is to be copied. If the section does not exist, it is created. The name of the section is not case-sensitive; the string can be any combination of uppercase and lowercase letters.</param>
    <param name="lpKeyName">The key to be associated with the string. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all entries in the section, is deleted.</param>
    <param name="lpString">A <b>null</b>-terminated string to be written to the file. If this parameter is <b>NULL</b>, the key pointed to by the <i>lpKeyName</i> parameter is deleted.</param>
    <returns>
      <para>If the function successfully copies the string to the Win.ini file, the return value is nonzero.</para>
      <para>If the function fails, or if it flushes the cached version of Win.ini, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WriteProfileStringA">
    <summary>
      <para>Copies a string into the specified section of the Win.ini file. If Win.ini uses Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The section to which the string is to be copied. If the section does not exist, it is created. The name of the section is not case-sensitive; the string can be any combination of uppercase and lowercase letters.</param>
    <param name="lpKeyName">The key to be associated with the string. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all entries in the section, is deleted.</param>
    <param name="lpString">A <b>null</b>-terminated string to be written to the file. If this parameter is <b>NULL</b>, the key pointed to by the <i>lpKeyName</i> parameter is deleted.</param>
    <returns>
      <para>If the function successfully copies the string to the Win.ini file, the return value is nonzero.</para>
      <para>If the function fails, or if it flushes the cached version of Win.ini, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WriteProfileStringW">
    <summary>
      <para>Copies a string into the specified section of the Win.ini file. If Win.ini uses Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The section to which the string is to be copied. If the section does not exist, it is created. The name of the section is not case-sensitive; the string can be any combination of uppercase and lowercase letters.</param>
    <param name="lpKeyName">The key to be associated with the string. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all entries in the section, is deleted.</param>
    <param name="lpString">A <b>null</b>-terminated string to be written to the file. If this parameter is <b>NULL</b>, the key pointed to by the <i>lpKeyName</i> parameter is deleted.</param>
    <returns>
      <para>If the function successfully copies the string to the Win.ini file, the return value is nonzero.</para>
      <para>If the function fails, or if it flushes the cached version of Win.ini, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WriteProfileString">
    <summary>
      <para>Copies a string into the specified section of the Win.ini file. If Win.ini uses Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The section to which the string is to be copied. If the section does not exist, it is created. The name of the section is not case-sensitive; the string can be any combination of uppercase and lowercase letters.</param>
    <param name="lpKeyName">The key to be associated with the string. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all entries in the section, is deleted.</param>
    <param name="lpString">A <b>null</b>-terminated string to be written to the file. If this parameter is <b>NULL</b>, the key pointed to by the <i>lpKeyName</i> parameter is deleted.</param>
    <returns>
      <para>If the function successfully copies the string to the Win.ini file, the return value is nonzero.</para>
      <para>If the function fails, or if it flushes the cached version of Win.ini, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WriteProfileStringA">
    <summary>
      <para>Copies a string into the specified section of the Win.ini file. If Win.ini uses Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The section to which the string is to be copied. If the section does not exist, it is created. The name of the section is not case-sensitive; the string can be any combination of uppercase and lowercase letters.</param>
    <param name="lpKeyName">The key to be associated with the string. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all entries in the section, is deleted.</param>
    <param name="lpString">A <b>null</b>-terminated string to be written to the file. If this parameter is <b>NULL</b>, the key pointed to by the <i>lpKeyName</i> parameter is deleted.</param>
    <returns>
      <para>If the function successfully copies the string to the Win.ini file, the return value is nonzero.</para>
      <para>If the function fails, or if it flushes the cached version of Win.ini, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WriteProfileStringW">
    <summary>
      <para>Copies a string into the specified section of the Win.ini file. If Win.ini uses Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</para>
      <div>
        <b>Note</b>  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.</div>
    </summary>
    <param name="lpAppName">The section to which the string is to be copied. If the section does not exist, it is created. The name of the section is not case-sensitive; the string can be any combination of uppercase and lowercase letters.</param>
    <param name="lpKeyName">The key to be associated with the string. If the key does not exist in the specified section, it is created. If this parameter is <b>NULL</b>, the entire section, including all entries in the section, is deleted.</param>
    <param name="lpString">A <b>null</b>-terminated string to be written to the file. If this parameter is <b>NULL</b>, the key pointed to by the <i>lpKeyName</i> parameter is deleted.</param>
    <returns>
      <para>If the function successfully copies the string to the Win.ini file, the return value is nonzero.</para>
      <para>If the function fails, or if it flushes the cached version of Win.ini, the return value is zero. To get extended error information, call<see cref="GetLastError" />.</para>
    </returns>
  </member>
  <member name="Windows.WriteTapemark">
    <summary>The<b>WriteTapemark</b> function writes a specified number of filemarks, setmarks, short filemarks, or long filemarks to a tape device. These tapemarks divide a tape partition into smaller areas.</summary>
    <param name="hDevice">Handle to the device on which to write tapemarks. This handle is created by using the<see cref="CreateFile" /> function.</param>
    <param name="dwTapemarkType">
      <para>Type of tapemarks to write. This parameter can be one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Value</description>
          <description>Meaning</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_FILEMARKS</b>
                </term>
              </listheader>
              <listheader>
                <term>1L</term>
              </listheader>
            </list>
          </description>
          <description>Writes the number of filemarks specified by the <i>dwTapemarkCount</i> parameter.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_LONG_FILEMARKS</b>
                </term>
              </listheader>
              <listheader>
                <term>3L</term>
              </listheader>
            </list>
          </description>
          <description>Writes the number of long filemarks specified by <i>dwTapemarkCount</i>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_SETMARKS</b>
                </term>
              </listheader>
              <listheader>
                <term>0L</term>
              </listheader>
            </list>
          </description>
          <description>Writes the number of setmarks specified by <i>dwTapemarkCount</i>.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>TAPE_SHORT_FILEMARKS</b>
                </term>
              </listheader>
              <listheader>
                <term>2L</term>
              </listheader>
            </list>
          </description>
          <description>Writes the number of short filemarks specified by <i>dwTapemarkCount</i>.</description>
        </listheader>
      </list>
    </param>
    <param name="dwTapemarkCount">Number of tapemarks to write.</param>
    <param name="bImmediate">If this parameter is <b>TRUE</b>, the function returns immediately; if it is <b>FALSE</b>, the function does not return until the operation has been completed.</param>
    <returns>
      <para>If the function succeeds, the return value is NO_ERROR.</para>
      <para>If the function fails, it can return one of the following error codes.</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Description</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BEGINNING_OF_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1102L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to access data before the beginning-of-medium marker failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_BUS_RESET</b>
                </term>
              </listheader>
              <listheader>
                <term>1111L</term>
              </listheader>
            </list>
          </description>
          <description>A reset condition was detected on the bus.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_DEVICE_NOT_PARTITIONED</b>
                </term>
              </listheader>
              <listheader>
                <term>1107L</term>
              </listheader>
            </list>
          </description>
          <description>The partition information could not be found when a tape was being loaded.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_END_OF_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1100L</term>
              </listheader>
            </list>
          </description>
          <description>The end-of-tape marker was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_FILEMARK_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1101L</term>
              </listheader>
            </list>
          </description>
          <description>A filemark was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_INVALID_BLOCK_LENGTH</b>
                </term>
              </listheader>
              <listheader>
                <term>1106L</term>
              </listheader>
            </list>
          </description>
          <description>The block size is incorrect on a new tape in a multivolume partition.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_MEDIA_CHANGED</b>
                </term>
              </listheader>
              <listheader>
                <term>1110L</term>
              </listheader>
            </list>
          </description>
          <description>The tape that was in the drive has been replaced or removed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NO_DATA_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1104L</term>
              </listheader>
            </list>
          </description>
          <description>The end-of-data marker was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NO_MEDIA_IN_DRIVE</b>
                </term>
              </listheader>
              <listheader>
                <term>1112L</term>
              </listheader>
            </list>
          </description>
          <description>There is no media in the drive.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_NOT_SUPPORTED</b>
                </term>
              </listheader>
              <listheader>
                <term>50L</term>
              </listheader>
            </list>
          </description>
          <description>The tape driver does not support a requested function.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_PARTITION_FAILURE</b>
                </term>
              </listheader>
              <listheader>
                <term>1105L</term>
              </listheader>
            </list>
          </description>
          <description>The tape could not be partitioned.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_SETMARK_DETECTED</b>
                </term>
              </listheader>
              <listheader>
                <term>1103L</term>
              </listheader>
            </list>
          </description>
          <description>A setmark was reached during an operation.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_UNABLE_TO_LOCK_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1108L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to lock the ejection mechanism failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b>
                </term>
              </listheader>
              <listheader>
                <term>1109L</term>
              </listheader>
            </list>
          </description>
          <description>An attempt to unload the tape failed.</description>
        </listheader>
        <listheader>
          <description>
            <list type="bullet">
              <listheader>
                <term>
                  <b>ERROR_WRITE_PROTECT</b>
                </term>
              </listheader>
              <listheader>
                <term>19L</term>
              </listheader>
            </list>
          </description>
          <description>The media is write protected.</description>
        </listheader>
      </list>
    </returns>
  </member>
  <member name="Windows.WTSGetActiveConsoleSessionId">
    <summary>Retrieves the session identifier of the console session. The console session is the session that is currently attached to the physical console. Note that it is not necessary that Remote Desktop Services be running for this function to succeed.</summary>
    <returns>The session identifier of the session that is attached to the physical console. If there is no session attached to the physical console, (for example, if the physical console session is in the process of being attached or detached), this function returns 0xFFFFFFFF.</returns>
  </member>
  <member name="Windows.ZombifyActCtx">
    <summary>The<b>ZombifyActCtx</b> function deactivates the specified activation context, but does not deallocate it.</summary>
    <param name="hActCtx">Handle to the activation context that is to be deactivated.</param>
    <returns>
      <para>If the function succeeds, it returns <b>TRUE</b>. If a <b>null</b> handle is passed in the <i>hActCtx</i> parameter, NULL_INVALID_PARAMETER will be returned. Otherwise, it returns <b>FALSE</b>.</para>
      <para>This function sets errors that can be retrieved by calling<see cref="GetLastError" />. For an example, see<a href="https://docs.microsoft.com//windows/desktop/Debug/retrieving-the-last-error-code">Retrieving the Last-Error Code</a>. For a complete list of error codes, see<a href="https://docs.microsoft.com//windows/desktop/Debug/system-error-codes">System Error Codes</a>.</para>
    </returns>
  </member>
  <member name="Windows._lclose">
    <summary>The _lclose function closes the specified file so that it is no longer available for reading or writing. This function is provided for compatibility with 16-bit versions of Windows. Win32-based applications should use the CloseHandle function.</summary>
    <param name="hFile">Identifies the file to be closed. This handle is returned by the function that created or last opened the file.</param>
    <returns>Handle to file to close.</returns>
  </member>
  <member name="Windows._lopen">
    <summary>The _lopen function opens an existing file and sets the file pointer to the beginning of the file. This function is provided for compatibility with 16-bit versions of Windows. Win32-based applications should use the CreateFile function.</summary>
    <param name="lpPathName">Pointer to a null-terminated string that names the file to open. The string must consist of characters from the Windows ANSI character set.</param>
    <param name="iReadWrite">
      <para>Specifies the modes in which to open the file. This parameter consists of one access mode and an optional share mode. The access mode must be one of the following values: OF_READ, OF_READWRITE, OF_WRITE</para>
      <para>The share mode can be one of the following values: OF_SHARE_COMPAT, OF_SHARE_DENY_NONE, OF_SHARE_DENY_READ, OF_SHARE_DENY_WRITE, OF_SHARE_EXCLUSIVE</para>
    </param>
    <returns>If the function succeeds, the return value is a file handle.</returns>
  </member>
  <member name="Windows._lread">
    <summary>The _lread function reads data from the specified file. This function is provided for compatibility with 16-bit versions of Windows. Win32-based applications should use the ReadFile function.</summary>
    <param name="hFile">Identifies the specified file.</param>
    <param name="lpBuffer">Pointer to a buffer that contains the data read from the file.</param>
    <param name="uBytes">Specifies the number of bytes to be read from the file.</param>
    <returns>The return value indicates the number of bytes actually read from the file. If the number of bytes read is less than uBytes, the function has reached the end of file (EOF) before reading the specified number of bytes.</returns>
  </member>
</doc>