<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright © Tanner Gooding and Contributors. Licensed under the MIT License (MIT). See License.md in the repository root for more information. -->
<!-- Ported from https://github.com/MicrosoftDocs/sdk-api/ -->
<doc>
  <member name="Windows.AssocCreate">
    <summary>
      <para>Returns a pointer to an <see cref="IQueryAssociations" /> object.</para>
    </summary>
    <param name="clsid">
      <para>Type: <b>CLSID</b></para>
      <para>The CLSID of the object that exposes the interface. This parameter must be set to CLSID_QueryAssociations, which is defined in Shlguid.h.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>Reference to the IID IID_IQueryAssociations, which is defined in Shlguid.h.</para>
    </param>
    <param name="ppv">
      <para>Type: <b>void*</b></para>
      <para>When this method returns, contains the <see cref="IQueryAssociations" /> interface pointer requested in <i>riid</i>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>As of Windows Vista, <see cref="AssocCreateForClasses" /> is preferred to <b>AssocCreate</b>.</para>
    </remarks>
  </member>
  <member name="Windows.AssocGetPerceivedType">
    <summary>
      <para>Retrieves a file's perceived type based on its extension.</para>
    </summary>
    <param name="pszExt">
      <para>Type: <b>PCWSTR</b></para>
      <para>A pointer to a buffer that contains the file's extension. This should include the leading period, for example ".txt".</para>
    </param>
    <param name="ptype">
      <para>Type: <b><see cref="PERCEIVED" />*</b></para>
      <para>A pointer to a <see cref="PERCEIVED" /> value that indicates the perceived type.</para>
    </param>
    <param name="pflag">
      <para>Type: <b>PERCEIVEDFLAG*</b></para>
      <para>A pointer to a value that indicates the source of the perceived type information. One or more of the following values.</para>
      <h4>PERCEIVEDFLAG_UNDEFINED (0x0000)</h4>
      <para>No perceived type was found (<see cref="PERCEIVED_TYPE_UNSPECIFIED" />).</para>
      <h4>PERCEIVEDFLAG_SOFTCODED (0x0001)</h4>
      <para>The perceived type was determined through an association in the registry.</para>
      <h4>PERCEIVEDFLAG_HARDCODED (0x0002)</h4>
      <para>The perceived type is inherently known to Windows.</para>
      <h4>PERCEIVEDFLAG_NATIVESUPPORT (0x0004)</h4>
      <para>The perceived type was determined through a codec provided with Windows.</para>
      <h4>PERCEIVEDFLAG_GDIPLUS (0x0010)</h4>
      <para>The perceived type is supported by the GDI+ library.</para>
      <h4>PERCEIVEDFLAG_WMSDK (0x0020)</h4>
      <para>The perceived type is supported by the Windows Media SDK.</para>
      <h4>PERCEIVEDFLAG_ZIPFOLDER (0x0040)</h4>
      <para>The perceived type is supported by Windows compressed folders.</para>
    </param>
    <param name="ppszType">
      <para>Type: <b>PWSTR*</b></para>
      <para>If the function returns a success code, this contains the address of a pointer to a buffer that receives the perceived type string, for instance "text" or "video". This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This function first compares the extension against a hard-coded set of extensions known to Windows. If that search fails to reveal a match, the registered associations under HKEY_CLASSES_ROOT are searched for a key that matches the extension and contains a PerceivedType value. If that value is found, the extension set is again searched for a match. If again no match is found, the perceived type is determined to be PERCEIVED_TYPE_CUSTOM. If either a key that matches the extension or a PerceivedType value is not found, the perceived type is reported as PERCEIVED_TYPE_UNSPECIFIED.</para>
    </remarks>
  </member>
  <member name="Windows.AssocIsDangerous">
    <summary>
      <para>Determines whether a file type is considered a potential security risk.</para>
    </summary>
    <param name="pszAssoc">
      <para>Type: <b>PCWSTR</b></para>
      <para>A pointer to a string that contains the type of file in question. This may be either an extension such as ".exe" or a progid such as "exefile".</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the file type is considered dangerous; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>Files that are determined to be potentially dangerous, such as .exe files, should be handled with more care than other files. For example, Windows Internet Explorer version 6.01 or later uses <b>AssocIsDangerous</b> to determine whether it should issue stronger warning language in its download dialog box. <see cref="ShellExecuteEx" /> uses <b>AssocIsDangerous</b> to trigger zone checking using the methods of the <a href="https://docs.microsoft.com//previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms537130(v=vs.85)">IInternetSecurityManager</a> interface in conjunction with the <a href="https://docs.microsoft.com//previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms537178(v=vs.85)">URLACTION_SHELL_SHELLEXECUTE</a> flag.</para>
      <para>The determination of a file's potential risk is made by checking its type against several sources, including a list of known dangerous types and the presence of the FTA_AlwaysUnsafe flag in the registry. On systems running Windows XPService Pack 1 (SP1) or later or Windows Server 2003, it also uses the <see cref="SaferiIsExecutableFileType" /> function to determine whether a file type is executable.</para>
      <para>Applications that can take advantage of <b>AssocIsDangerous</b> include email programs, browsers, chat clients capable of downloading files, and any application that moves files or data from one zone of trust to another.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/fa-file-types">File Types</seealso>
    <seealso cref="SaferiIsExecutableFileType" />
  </member>
  <member name="Windows.AssocQueryKey">
    <summary>
      <para>Searches for and retrieves a key related to a file or protocol association from the registry.</para>
    </summary>
    <param name="flags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a></b></para>
      <para>The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.</para>
    </param>
    <param name="key">
      <para>Type: <b><see cref="ASSOCKEY" /></b></para>
      <para>The <see cref="ASSOCKEY" /> value that specifies the type of key that is to be returned.</para>
    </param>
    <param name="pszAssoc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that is used to determine the root key. Four types of strings can be used.</para>
      <h4>File name extension</h4>
      <para>A file name extension, such as .txt.</para>
      <h4>CLSID</h4>
      <para>A CLSID GUID in the standard "{GUID}" format.</para>
      <h4>ProgID</h4>
      <para>An application's ProgID, such as <b>Word.Document.8</b>.</para>
      <h4>Executable name</h4>
      <para>The name of an application's .exe file. The <see cref="ASSOCF_OPEN_BYEXENAME" /> flag must be set in <i>flags</i>.</para>
    </param>
    <param name="pszExtra">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.</para>
    </param>
    <param name="phkeyOut">
      <para>Type: <b>HKEY*</b></para>
      <para>A pointer to the key's HKEY value.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or a COM error value otherwise.</para>
    </returns>
    <remarks>
      <para>This function is a wrapper for the <see cref="IQueryAssociations" /> interface. It is intended to simplify the process of using the interface. For further discussion of how the file and protocol association functions work, see <b>IQueryAssociations</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines AssocQueryKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.AssocQueryKeyA">
    <summary>
      <para>Searches for and retrieves a key related to a file or protocol association from the registry.</para>
    </summary>
    <param name="flags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a></b></para>
      <para>The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.</para>
    </param>
    <param name="key">
      <para>Type: <b><see cref="ASSOCKEY" /></b></para>
      <para>The <see cref="ASSOCKEY" /> value that specifies the type of key that is to be returned.</para>
    </param>
    <param name="pszAssoc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that is used to determine the root key. Four types of strings can be used.</para>
      <h4>File name extension</h4>
      <para>A file name extension, such as .txt.</para>
      <h4>CLSID</h4>
      <para>A CLSID GUID in the standard "{GUID}" format.</para>
      <h4>ProgID</h4>
      <para>An application's ProgID, such as <b>Word.Document.8</b>.</para>
      <h4>Executable name</h4>
      <para>The name of an application's .exe file. The <see cref="ASSOCF_OPEN_BYEXENAME" /> flag must be set in <i>flags</i>.</para>
    </param>
    <param name="pszExtra">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.</para>
    </param>
    <param name="phkeyOut">
      <para>Type: <b>HKEY*</b></para>
      <para>A pointer to the key's HKEY value.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or a COM error value otherwise.</para>
    </returns>
    <remarks>
      <para>This function is a wrapper for the <see cref="IQueryAssociations" /> interface. It is intended to simplify the process of using the interface. For further discussion of how the file and protocol association functions work, see <b>IQueryAssociations</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines AssocQueryKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.AssocQueryKeyW">
    <summary>
      <para>Searches for and retrieves a key related to a file or protocol association from the registry.</para>
    </summary>
    <param name="flags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a></b></para>
      <para>The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.</para>
    </param>
    <param name="key">
      <para>Type: <b><see cref="ASSOCKEY" /></b></para>
      <para>The <see cref="ASSOCKEY" /> value that specifies the type of key that is to be returned.</para>
    </param>
    <param name="pszAssoc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that is used to determine the root key. Four types of strings can be used.</para>
      <h4>File name extension</h4>
      <para>A file name extension, such as .txt.</para>
      <h4>CLSID</h4>
      <para>A CLSID GUID in the standard "{GUID}" format.</para>
      <h4>ProgID</h4>
      <para>An application's ProgID, such as <b>Word.Document.8</b>.</para>
      <h4>Executable name</h4>
      <para>The name of an application's .exe file. The <see cref="ASSOCF_OPEN_BYEXENAME" /> flag must be set in <i>flags</i>.</para>
    </param>
    <param name="pszExtra">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.</para>
    </param>
    <param name="phkeyOut">
      <para>Type: <b>HKEY*</b></para>
      <para>A pointer to the key's HKEY value.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or a COM error value otherwise.</para>
    </returns>
    <remarks>
      <para>This function is a wrapper for the <see cref="IQueryAssociations" /> interface. It is intended to simplify the process of using the interface. For further discussion of how the file and protocol association functions work, see <b>IQueryAssociations</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines AssocQueryKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.AssocQueryKey">
    <summary>
      <para>Searches for and retrieves a key related to a file or protocol association from the registry.</para>
    </summary>
    <param name="flags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a></b></para>
      <para>The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.</para>
    </param>
    <param name="key">
      <para>Type: <b><see cref="ASSOCKEY" /></b></para>
      <para>The <see cref="ASSOCKEY" /> value that specifies the type of key that is to be returned.</para>
    </param>
    <param name="pszAssoc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that is used to determine the root key. Four types of strings can be used.</para>
      <h4>File name extension</h4>
      <para>A file name extension, such as .txt.</para>
      <h4>CLSID</h4>
      <para>A CLSID GUID in the standard "{GUID}" format.</para>
      <h4>ProgID</h4>
      <para>An application's ProgID, such as <b>Word.Document.8</b>.</para>
      <h4>Executable name</h4>
      <para>The name of an application's .exe file. The <see cref="ASSOCF_OPEN_BYEXENAME" /> flag must be set in <i>flags</i>.</para>
    </param>
    <param name="pszExtra">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.</para>
    </param>
    <param name="phkeyOut">
      <para>Type: <b>HKEY*</b></para>
      <para>A pointer to the key's HKEY value.</para>
      <h5>- pszAssoc.CLSID</h5>
      <para>A CLSID GUID in the standard "{GUID}" format.</para>
      <h5>- pszAssoc.Executable name</h5>
      <para>The name of an application's .exe file. The <see cref="ASSOCF_OPEN_BYEXENAME" /> flag must be set in <i>flags</i>.</para>
      <h5>- pszAssoc.File name extension</h5>
      <para>A file name extension, such as .txt.</para>
      <h5>- pszAssoc.ProgID</h5>
      <para>An application's ProgID, such as <b>Word.Document.8</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or a COM error value otherwise.</para>
    </returns>
    <remarks>
      <para>This function is a wrapper for the <see cref="IQueryAssociations" /> interface. It is intended to simplify the process of using the interface. For further discussion of how the file and protocol association functions work, see <b>IQueryAssociations</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines AssocQueryKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.AssocQueryKeyA">
    <summary>
      <para>Searches for and retrieves a key related to a file or protocol association from the registry.</para>
    </summary>
    <param name="flags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a></b></para>
      <para>The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.</para>
    </param>
    <param name="key">
      <para>Type: <b><see cref="ASSOCKEY" /></b></para>
      <para>The <see cref="ASSOCKEY" /> value that specifies the type of key that is to be returned.</para>
    </param>
    <param name="pszAssoc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that is used to determine the root key. Four types of strings can be used.</para>
      <h4>File name extension</h4>
      <para>A file name extension, such as .txt.</para>
      <h4>CLSID</h4>
      <para>A CLSID GUID in the standard "{GUID}" format.</para>
      <h4>ProgID</h4>
      <para>An application's ProgID, such as <b>Word.Document.8</b>.</para>
      <h4>Executable name</h4>
      <para>The name of an application's .exe file. The <see cref="ASSOCF_OPEN_BYEXENAME" /> flag must be set in <i>flags</i>.</para>
    </param>
    <param name="pszExtra">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.</para>
    </param>
    <param name="phkeyOut">
      <para>Type: <b>HKEY*</b></para>
      <para>A pointer to the key's HKEY value.</para>
      <h5>- pszAssoc.CLSID</h5>
      <para>A CLSID GUID in the standard "{GUID}" format.</para>
      <h5>- pszAssoc.Executable name</h5>
      <para>The name of an application's .exe file. The <see cref="ASSOCF_OPEN_BYEXENAME" /> flag must be set in <i>flags</i>.</para>
      <h5>- pszAssoc.File name extension</h5>
      <para>A file name extension, such as .txt.</para>
      <h5>- pszAssoc.ProgID</h5>
      <para>An application's ProgID, such as <b>Word.Document.8</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or a COM error value otherwise.</para>
    </returns>
    <remarks>
      <para>This function is a wrapper for the <see cref="IQueryAssociations" /> interface. It is intended to simplify the process of using the interface. For further discussion of how the file and protocol association functions work, see <b>IQueryAssociations</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines AssocQueryKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.AssocQueryKeyW">
    <summary>
      <para>Searches for and retrieves a key related to a file or protocol association from the registry.</para>
    </summary>
    <param name="flags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a></b></para>
      <para>The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.</para>
    </param>
    <param name="key">
      <para>Type: <b><see cref="ASSOCKEY" /></b></para>
      <para>The <see cref="ASSOCKEY" /> value that specifies the type of key that is to be returned.</para>
    </param>
    <param name="pszAssoc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that is used to determine the root key. Four types of strings can be used.</para>
      <h4>File name extension</h4>
      <para>A file name extension, such as .txt.</para>
      <h4>CLSID</h4>
      <para>A CLSID GUID in the standard "{GUID}" format.</para>
      <h4>ProgID</h4>
      <para>An application's ProgID, such as <b>Word.Document.8</b>.</para>
      <h4>Executable name</h4>
      <para>The name of an application's .exe file. The <see cref="ASSOCF_OPEN_BYEXENAME" /> flag must be set in <i>flags</i>.</para>
    </param>
    <param name="pszExtra">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.</para>
    </param>
    <param name="phkeyOut">
      <para>Type: <b>HKEY*</b></para>
      <para>A pointer to the key's HKEY value.</para>
      <h5>- pszAssoc.CLSID</h5>
      <para>A CLSID GUID in the standard "{GUID}" format.</para>
      <h5>- pszAssoc.Executable name</h5>
      <para>The name of an application's .exe file. The <see cref="ASSOCF_OPEN_BYEXENAME" /> flag must be set in <i>flags</i>.</para>
      <h5>- pszAssoc.File name extension</h5>
      <para>A file name extension, such as .txt.</para>
      <h5>- pszAssoc.ProgID</h5>
      <para>An application's ProgID, such as <b>Word.Document.8</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or a COM error value otherwise.</para>
    </returns>
    <remarks>
      <para>This function is a wrapper for the <see cref="IQueryAssociations" /> interface. It is intended to simplify the process of using the interface. For further discussion of how the file and protocol association functions work, see <b>IQueryAssociations</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines AssocQueryKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.AssocQueryString">
    <summary>
      <para>Searches for and retrieves a file or protocol association-related string from the registry.</para>
    </summary>
    <param name="flags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a></b></para>
      <para>The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.</para>
    </param>
    <param name="str">
      <para>Type: <b><see cref="ASSOCSTR" /></b></para>
      <para>The <see cref="ASSOCSTR" /> value that specifies the type of string that is to be returned.</para>
    </param>
    <param name="pszAssoc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that is used to determine the root key. The following four types of strings can be used.</para>
      <h4>File name extension</h4>
      <para>A file name extension, such as .txt.</para>
      <h4>CLSID</h4>
      <para>A CLSID GUID in the standard "{GUID}" format.</para>
      <h4>ProgID</h4>
      <para>An application's ProgID, such as <b>Word.Document.8</b>.</para>
      <h4>Executable name</h4>
      <para>The name of an application's .exe file. The <see cref="ASSOCF_OPEN_BYEXENAME" /> flag must be set in <i>flags</i>.</para>
    </param>
    <param name="pszExtra">
      <para>Type: <b>LPCTSTR</b></para>
      <para>An optional null-terminated string with additional information about the location of the string. It is typically set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a null-terminated string that, when this function returns successfully, receives the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, when calling the function, is set to the number of characters in the <i>pszOut</i> buffer. When the function returns successfully, the value is set to the number of characters actually placed in the buffer.</para>
      <para>If the <see cref="ASSOCF_NOTRUNCATE" /> flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the buffer.</para>
      <para>If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size, in characters, of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns a standard COM error value, including the following:</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>S_OK</description>
          <description>Success.</description>
        </item>
        <item>
          <description>E_POINTER</description>
          <description>The <i>pszOut</i> buffer is too small to hold the entire string.</description>
        </item>
        <item>
          <description>S_FALSE</description>
          <description>
            <i>pszOut</i> is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function is a wrapper for the <see cref="IQueryAssociations" /> interface. The <b>AssocQueryString</b> function is intended to simplify the process of using <b>IQueryAssociations</b> interface.</para>
      <para>Once an item is selected, the host must decide which (if any) preview handler is available for that item. Preview handlers are typically registered on file name extensions or ProgID, but some preview handlers are only instantiated for items within particular shell folders (the MAPI preview handler is associated with any items that came from the MAPI Shell folder, for example). Thus, the host must use <see cref="IQueryAssociations" /> to determine which preview handler to use. For further discussion of how the file and protocol association functions work, see <see cref="IQueryAssociations" />.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines AssocQueryString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.AssocQueryStringA">
    <summary>
      <para>Searches for and retrieves a file or protocol association-related string from the registry.</para>
    </summary>
    <param name="flags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a></b></para>
      <para>The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.</para>
    </param>
    <param name="str">
      <para>Type: <b><see cref="ASSOCSTR" /></b></para>
      <para>The <see cref="ASSOCSTR" /> value that specifies the type of string that is to be returned.</para>
    </param>
    <param name="pszAssoc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that is used to determine the root key. The following four types of strings can be used.</para>
      <h4>File name extension</h4>
      <para>A file name extension, such as .txt.</para>
      <h4>CLSID</h4>
      <para>A CLSID GUID in the standard "{GUID}" format.</para>
      <h4>ProgID</h4>
      <para>An application's ProgID, such as <b>Word.Document.8</b>.</para>
      <h4>Executable name</h4>
      <para>The name of an application's .exe file. The <see cref="ASSOCF_OPEN_BYEXENAME" /> flag must be set in <i>flags</i>.</para>
    </param>
    <param name="pszExtra">
      <para>Type: <b>LPCTSTR</b></para>
      <para>An optional null-terminated string with additional information about the location of the string. It is typically set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a null-terminated string that, when this function returns successfully, receives the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, when calling the function, is set to the number of characters in the <i>pszOut</i> buffer. When the function returns successfully, the value is set to the number of characters actually placed in the buffer.</para>
      <para>If the <see cref="ASSOCF_NOTRUNCATE" /> flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the buffer.</para>
      <para>If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size, in characters, of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns a standard COM error value, including the following:</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>S_OK</description>
          <description>Success.</description>
        </item>
        <item>
          <description>E_POINTER</description>
          <description>The <i>pszOut</i> buffer is too small to hold the entire string.</description>
        </item>
        <item>
          <description>S_FALSE</description>
          <description>
            <i>pszOut</i> is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function is a wrapper for the <see cref="IQueryAssociations" /> interface. The <b>AssocQueryString</b> function is intended to simplify the process of using <b>IQueryAssociations</b> interface.</para>
      <para>Once an item is selected, the host must decide which (if any) preview handler is available for that item. Preview handlers are typically registered on file name extensions or ProgID, but some preview handlers are only instantiated for items within particular shell folders (the MAPI preview handler is associated with any items that came from the MAPI Shell folder, for example). Thus, the host must use <see cref="IQueryAssociations" /> to determine which preview handler to use. For further discussion of how the file and protocol association functions work, see <see cref="IQueryAssociations" />.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines AssocQueryString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.AssocQueryStringW">
    <summary>
      <para>Searches for and retrieves a file or protocol association-related string from the registry.</para>
    </summary>
    <param name="flags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a></b></para>
      <para>The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.</para>
    </param>
    <param name="str">
      <para>Type: <b><see cref="ASSOCSTR" /></b></para>
      <para>The <see cref="ASSOCSTR" /> value that specifies the type of string that is to be returned.</para>
    </param>
    <param name="pszAssoc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that is used to determine the root key. The following four types of strings can be used.</para>
      <h4>File name extension</h4>
      <para>A file name extension, such as .txt.</para>
      <h4>CLSID</h4>
      <para>A CLSID GUID in the standard "{GUID}" format.</para>
      <h4>ProgID</h4>
      <para>An application's ProgID, such as <b>Word.Document.8</b>.</para>
      <h4>Executable name</h4>
      <para>The name of an application's .exe file. The <see cref="ASSOCF_OPEN_BYEXENAME" /> flag must be set in <i>flags</i>.</para>
    </param>
    <param name="pszExtra">
      <para>Type: <b>LPCTSTR</b></para>
      <para>An optional null-terminated string with additional information about the location of the string. It is typically set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a null-terminated string that, when this function returns successfully, receives the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, when calling the function, is set to the number of characters in the <i>pszOut</i> buffer. When the function returns successfully, the value is set to the number of characters actually placed in the buffer.</para>
      <para>If the <see cref="ASSOCF_NOTRUNCATE" /> flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the buffer.</para>
      <para>If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size, in characters, of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns a standard COM error value, including the following:</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>S_OK</description>
          <description>Success.</description>
        </item>
        <item>
          <description>E_POINTER</description>
          <description>The <i>pszOut</i> buffer is too small to hold the entire string.</description>
        </item>
        <item>
          <description>S_FALSE</description>
          <description>
            <i>pszOut</i> is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function is a wrapper for the <see cref="IQueryAssociations" /> interface. The <b>AssocQueryString</b> function is intended to simplify the process of using <b>IQueryAssociations</b> interface.</para>
      <para>Once an item is selected, the host must decide which (if any) preview handler is available for that item. Preview handlers are typically registered on file name extensions or ProgID, but some preview handlers are only instantiated for items within particular shell folders (the MAPI preview handler is associated with any items that came from the MAPI Shell folder, for example). Thus, the host must use <see cref="IQueryAssociations" /> to determine which preview handler to use. For further discussion of how the file and protocol association functions work, see <see cref="IQueryAssociations" />.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines AssocQueryString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.AssocQueryStringByKey">
    <summary>
      <para>Searches for and retrieves a file association-related string from the registry starting from a specified key.</para>
    </summary>
    <param name="flags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a></b></para>
      <para>The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.</para>
    </param>
    <param name="str">
      <para>Type: <b><see cref="ASSOCSTR" /></b></para>
      <para>The <see cref="ASSOCSTR" /> value that specifies the type of string that is to be returned.</para>
    </param>
    <param name="hkAssoc">
      <para>Type: <b>HKEY</b></para>
      <para>The HKEY value of the key that will be used as a root key. The search looks only below this key.</para>
    </param>
    <param name="pszExtra">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string used to return the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, specifies the number of characters in the <i>pszOut</i> buffer. When the function returns, it points to the number of characters placed in the buffer.</para>
      <para>If the <see cref="ASSOCF_NOTRUNCATE" /> flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the buffer.</para>
      <para>If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns a standard COM error value, including the following:</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>S_OK</description>
          <description>Success.</description>
        </item>
        <item>
          <description>E_POINTER</description>
          <description>The <i>pszOut</i> buffer is too small to hold the entire string.</description>
        </item>
        <item>
          <description>S_FALSE</description>
          <description>
            <i>pszOut</i> is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function is a wrapper for the <see cref="IQueryAssociations" /> interface. It is intended to simplify the process of using this interface. For further discussion of how the file association functions work, see <b>IQueryAssociations</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines AssocQueryStringByKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.AssocQueryStringByKeyA">
    <summary>
      <para>Searches for and retrieves a file association-related string from the registry starting from a specified key.</para>
    </summary>
    <param name="flags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a></b></para>
      <para>The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.</para>
    </param>
    <param name="str">
      <para>Type: <b><see cref="ASSOCSTR" /></b></para>
      <para>The <see cref="ASSOCSTR" /> value that specifies the type of string that is to be returned.</para>
    </param>
    <param name="hkAssoc">
      <para>Type: <b>HKEY</b></para>
      <para>The HKEY value of the key that will be used as a root key. The search looks only below this key.</para>
    </param>
    <param name="pszExtra">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string used to return the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, specifies the number of characters in the <i>pszOut</i> buffer. When the function returns, it points to the number of characters placed in the buffer.</para>
      <para>If the <see cref="ASSOCF_NOTRUNCATE" /> flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the buffer.</para>
      <para>If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns a standard COM error value, including the following:</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>S_OK</description>
          <description>Success.</description>
        </item>
        <item>
          <description>E_POINTER</description>
          <description>The <i>pszOut</i> buffer is too small to hold the entire string.</description>
        </item>
        <item>
          <description>S_FALSE</description>
          <description>
            <i>pszOut</i> is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function is a wrapper for the <see cref="IQueryAssociations" /> interface. It is intended to simplify the process of using this interface. For further discussion of how the file association functions work, see <b>IQueryAssociations</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines AssocQueryStringByKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.AssocQueryStringByKeyW">
    <summary>
      <para>Searches for and retrieves a file association-related string from the registry starting from a specified key.</para>
    </summary>
    <param name="flags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a></b></para>
      <para>The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.</para>
    </param>
    <param name="str">
      <para>Type: <b><see cref="ASSOCSTR" /></b></para>
      <para>The <see cref="ASSOCSTR" /> value that specifies the type of string that is to be returned.</para>
    </param>
    <param name="hkAssoc">
      <para>Type: <b>HKEY</b></para>
      <para>The HKEY value of the key that will be used as a root key. The search looks only below this key.</para>
    </param>
    <param name="pszExtra">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string used to return the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, specifies the number of characters in the <i>pszOut</i> buffer. When the function returns, it points to the number of characters placed in the buffer.</para>
      <para>If the <see cref="ASSOCF_NOTRUNCATE" /> flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the buffer.</para>
      <para>If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns a standard COM error value, including the following:</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>S_OK</description>
          <description>Success.</description>
        </item>
        <item>
          <description>E_POINTER</description>
          <description>The <i>pszOut</i> buffer is too small to hold the entire string.</description>
        </item>
        <item>
          <description>S_FALSE</description>
          <description>
            <i>pszOut</i> is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function is a wrapper for the <see cref="IQueryAssociations" /> interface. It is intended to simplify the process of using this interface. For further discussion of how the file association functions work, see <b>IQueryAssociations</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines AssocQueryStringByKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.AssocQueryStringByKey">
    <summary>
      <para>Searches for and retrieves a file association-related string from the registry starting from a specified key.</para>
    </summary>
    <param name="flags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a></b></para>
      <para>The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.</para>
    </param>
    <param name="str">
      <para>Type: <b><see cref="ASSOCSTR" /></b></para>
      <para>The <see cref="ASSOCSTR" /> value that specifies the type of string that is to be returned.</para>
    </param>
    <param name="hkAssoc">
      <para>Type: <b>HKEY</b></para>
      <para>The HKEY value of the key that will be used as a root key. The search looks only below this key.</para>
    </param>
    <param name="pszExtra">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string used to return the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, specifies the number of characters in the <i>pszOut</i> buffer. When the function returns, it points to the number of characters placed in the buffer.</para>
      <para>If the <see cref="ASSOCF_NOTRUNCATE" /> flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the buffer.</para>
      <para>If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns a standard COM error value, including the following:</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>S_OK</description>
          <description>Success.</description>
        </item>
        <item>
          <description>E_POINTER</description>
          <description>The <i>pszOut</i> buffer is too small to hold the entire string.</description>
        </item>
        <item>
          <description>S_FALSE</description>
          <description>
            <i>pszOut</i> is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function is a wrapper for the <see cref="IQueryAssociations" /> interface. It is intended to simplify the process of using this interface. For further discussion of how the file association functions work, see <b>IQueryAssociations</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines AssocQueryStringByKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.AssocQueryStringByKeyA">
    <summary>
      <para>Searches for and retrieves a file association-related string from the registry starting from a specified key.</para>
    </summary>
    <param name="flags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a></b></para>
      <para>The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.</para>
    </param>
    <param name="str">
      <para>Type: <b><see cref="ASSOCSTR" /></b></para>
      <para>The <see cref="ASSOCSTR" /> value that specifies the type of string that is to be returned.</para>
    </param>
    <param name="hkAssoc">
      <para>Type: <b>HKEY</b></para>
      <para>The HKEY value of the key that will be used as a root key. The search looks only below this key.</para>
    </param>
    <param name="pszExtra">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string used to return the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, specifies the number of characters in the <i>pszOut</i> buffer. When the function returns, it points to the number of characters placed in the buffer.</para>
      <para>If the <see cref="ASSOCF_NOTRUNCATE" /> flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the buffer.</para>
      <para>If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns a standard COM error value, including the following:</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>S_OK</description>
          <description>Success.</description>
        </item>
        <item>
          <description>E_POINTER</description>
          <description>The <i>pszOut</i> buffer is too small to hold the entire string.</description>
        </item>
        <item>
          <description>S_FALSE</description>
          <description>
            <i>pszOut</i> is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function is a wrapper for the <see cref="IQueryAssociations" /> interface. It is intended to simplify the process of using this interface. For further discussion of how the file association functions work, see <b>IQueryAssociations</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines AssocQueryStringByKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.AssocQueryStringByKeyW">
    <summary>
      <para>Searches for and retrieves a file association-related string from the registry starting from a specified key.</para>
    </summary>
    <param name="flags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a></b></para>
      <para>The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.</para>
    </param>
    <param name="str">
      <para>Type: <b><see cref="ASSOCSTR" /></b></para>
      <para>The <see cref="ASSOCSTR" /> value that specifies the type of string that is to be returned.</para>
    </param>
    <param name="hkAssoc">
      <para>Type: <b>HKEY</b></para>
      <para>The HKEY value of the key that will be used as a root key. The search looks only below this key.</para>
    </param>
    <param name="pszExtra">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to an optional null-terminated string with additional information about the location of the string. It is normally set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string used to return the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, specifies the number of characters in the <i>pszOut</i> buffer. When the function returns, it points to the number of characters placed in the buffer.</para>
      <para>If the <see cref="ASSOCF_NOTRUNCATE" /> flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the buffer.</para>
      <para>If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size of the buffer.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns a standard COM error value, including the following:</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>S_OK</description>
          <description>Success.</description>
        </item>
        <item>
          <description>E_POINTER</description>
          <description>The <i>pszOut</i> buffer is too small to hold the entire string.</description>
        </item>
        <item>
          <description>S_FALSE</description>
          <description>
            <i>pszOut</i> is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function is a wrapper for the <see cref="IQueryAssociations" /> interface. It is intended to simplify the process of using this interface. For further discussion of how the file association functions work, see <b>IQueryAssociations</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines AssocQueryStringByKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.AssocQueryString">
    <summary>
      <para>Searches for and retrieves a file or protocol association-related string from the registry.</para>
    </summary>
    <param name="flags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a></b></para>
      <para>The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.</para>
    </param>
    <param name="str">
      <para>Type: <b><see cref="ASSOCSTR" /></b></para>
      <para>The <see cref="ASSOCSTR" /> value that specifies the type of string that is to be returned.</para>
    </param>
    <param name="pszAssoc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that is used to determine the root key. The following four types of strings can be used.</para>
      <h4>File name extension</h4>
      <para>A file name extension, such as .txt.</para>
      <h4>CLSID</h4>
      <para>A CLSID GUID in the standard "{GUID}" format.</para>
      <h4>ProgID</h4>
      <para>An application's ProgID, such as <b>Word.Document.8</b>.</para>
      <h4>Executable name</h4>
      <para>The name of an application's .exe file. The <see cref="ASSOCF_OPEN_BYEXENAME" /> flag must be set in <i>flags</i>.</para>
    </param>
    <param name="pszExtra">
      <para>Type: <b>LPCTSTR</b></para>
      <para>An optional null-terminated string with additional information about the location of the string. It is typically set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a null-terminated string that, when this function returns successfully, receives the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, when calling the function, is set to the number of characters in the <i>pszOut</i> buffer. When the function returns successfully, the value is set to the number of characters actually placed in the buffer.</para>
      <para>If the <see cref="ASSOCF_NOTRUNCATE" /> flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the buffer.</para>
      <para>If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size, in characters, of the buffer.</para>
      <h5>- pszAssoc.CLSID</h5>
      <para>A CLSID GUID in the standard "{GUID}" format.</para>
      <h5>- pszAssoc.Executable name</h5>
      <para>The name of an application's .exe file. The <see cref="ASSOCF_OPEN_BYEXENAME" /> flag must be set in <i>flags</i>.</para>
      <h5>- pszAssoc.File name extension</h5>
      <para>A file name extension, such as .txt.</para>
      <h5>- pszAssoc.ProgID</h5>
      <para>An application's ProgID, such as <b>Word.Document.8</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns a standard COM error value, including the following:</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>S_OK</description>
          <description>Success.</description>
        </item>
        <item>
          <description>E_POINTER</description>
          <description>The <i>pszOut</i> buffer is too small to hold the entire string.</description>
        </item>
        <item>
          <description>S_FALSE</description>
          <description>
            <i>pszOut</i> is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function is a wrapper for the <see cref="IQueryAssociations" /> interface. The <b>AssocQueryString</b> function is intended to simplify the process of using <b>IQueryAssociations</b> interface.</para>
      <para>Once an item is selected, the host must decide which (if any) preview handler is available for that item. Preview handlers are typically registered on file name extensions or ProgID, but some preview handlers are only instantiated for items within particular shell folders (the MAPI preview handler is associated with any items that came from the MAPI Shell folder, for example). Thus, the host must use <see cref="IQueryAssociations" /> to determine which preview handler to use. For further discussion of how the file and protocol association functions work, see <see cref="IQueryAssociations" />.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines AssocQueryString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.AssocQueryStringA">
    <summary>
      <para>Searches for and retrieves a file or protocol association-related string from the registry.</para>
    </summary>
    <param name="flags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a></b></para>
      <para>The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.</para>
    </param>
    <param name="str">
      <para>Type: <b><see cref="ASSOCSTR" /></b></para>
      <para>The <see cref="ASSOCSTR" /> value that specifies the type of string that is to be returned.</para>
    </param>
    <param name="pszAssoc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that is used to determine the root key. The following four types of strings can be used.</para>
      <h4>File name extension</h4>
      <para>A file name extension, such as .txt.</para>
      <h4>CLSID</h4>
      <para>A CLSID GUID in the standard "{GUID}" format.</para>
      <h4>ProgID</h4>
      <para>An application's ProgID, such as <b>Word.Document.8</b>.</para>
      <h4>Executable name</h4>
      <para>The name of an application's .exe file. The <see cref="ASSOCF_OPEN_BYEXENAME" /> flag must be set in <i>flags</i>.</para>
    </param>
    <param name="pszExtra">
      <para>Type: <b>LPCTSTR</b></para>
      <para>An optional null-terminated string with additional information about the location of the string. It is typically set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a null-terminated string that, when this function returns successfully, receives the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, when calling the function, is set to the number of characters in the <i>pszOut</i> buffer. When the function returns successfully, the value is set to the number of characters actually placed in the buffer.</para>
      <para>If the <see cref="ASSOCF_NOTRUNCATE" /> flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the buffer.</para>
      <para>If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size, in characters, of the buffer.</para>
      <h5>- pszAssoc.CLSID</h5>
      <para>A CLSID GUID in the standard "{GUID}" format.</para>
      <h5>- pszAssoc.Executable name</h5>
      <para>The name of an application's .exe file. The <see cref="ASSOCF_OPEN_BYEXENAME" /> flag must be set in <i>flags</i>.</para>
      <h5>- pszAssoc.File name extension</h5>
      <para>A file name extension, such as .txt.</para>
      <h5>- pszAssoc.ProgID</h5>
      <para>An application's ProgID, such as <b>Word.Document.8</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns a standard COM error value, including the following:</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>S_OK</description>
          <description>Success.</description>
        </item>
        <item>
          <description>E_POINTER</description>
          <description>The <i>pszOut</i> buffer is too small to hold the entire string.</description>
        </item>
        <item>
          <description>S_FALSE</description>
          <description>
            <i>pszOut</i> is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function is a wrapper for the <see cref="IQueryAssociations" /> interface. The <b>AssocQueryString</b> function is intended to simplify the process of using <b>IQueryAssociations</b> interface.</para>
      <para>Once an item is selected, the host must decide which (if any) preview handler is available for that item. Preview handlers are typically registered on file name extensions or ProgID, but some preview handlers are only instantiated for items within particular shell folders (the MAPI preview handler is associated with any items that came from the MAPI Shell folder, for example). Thus, the host must use <see cref="IQueryAssociations" /> to determine which preview handler to use. For further discussion of how the file and protocol association functions work, see <see cref="IQueryAssociations" />.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines AssocQueryString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.AssocQueryStringW">
    <summary>
      <para>Searches for and retrieves a file or protocol association-related string from the registry.</para>
    </summary>
    <param name="flags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a></b></para>
      <para>The flags that can be used to control the search. It can be any combination of <a href="https://docs.microsoft.com//windows/win32/shell/assocf_str">ASSOCF</a> values, except that only one ASSOCF_INIT value can be included.</para>
    </param>
    <param name="str">
      <para>Type: <b><see cref="ASSOCSTR" /></b></para>
      <para>The <see cref="ASSOCSTR" /> value that specifies the type of string that is to be returned.</para>
    </param>
    <param name="pszAssoc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that is used to determine the root key. The following four types of strings can be used.</para>
      <h4>File name extension</h4>
      <para>A file name extension, such as .txt.</para>
      <h4>CLSID</h4>
      <para>A CLSID GUID in the standard "{GUID}" format.</para>
      <h4>ProgID</h4>
      <para>An application's ProgID, such as <b>Word.Document.8</b>.</para>
      <h4>Executable name</h4>
      <para>The name of an application's .exe file. The <see cref="ASSOCF_OPEN_BYEXENAME" /> flag must be set in <i>flags</i>.</para>
    </param>
    <param name="pszExtra">
      <para>Type: <b>LPCTSTR</b></para>
      <para>An optional null-terminated string with additional information about the location of the string. It is typically set to a Shell verb such as <b>open</b>. Set this parameter to <b>NULL</b> if it is not used.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a null-terminated string that, when this function returns successfully, receives the requested string. Set this parameter to <b>NULL</b> to retrieve the required buffer size.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, when calling the function, is set to the number of characters in the <i>pszOut</i> buffer. When the function returns successfully, the value is set to the number of characters actually placed in the buffer.</para>
      <para>If the <see cref="ASSOCF_NOTRUNCATE" /> flag is set in <i>flags</i> and the buffer specified in <i>pszOut</i> is too small, the function returns E_POINTER and the value is set to the required size of the buffer.</para>
      <para>If <i>pszOut</i> is <b>NULL</b>, the function returns S_FALSE and <i>pcchOut</i> points to the required size, in characters, of the buffer.</para>
      <h5>- pszAssoc.CLSID</h5>
      <para>A CLSID GUID in the standard "{GUID}" format.</para>
      <h5>- pszAssoc.Executable name</h5>
      <para>The name of an application's .exe file. The <see cref="ASSOCF_OPEN_BYEXENAME" /> flag must be set in <i>flags</i>.</para>
      <h5>- pszAssoc.File name extension</h5>
      <para>A file name extension, such as .txt.</para>
      <h5>- pszAssoc.ProgID</h5>
      <para>An application's ProgID, such as <b>Word.Document.8</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns a standard COM error value, including the following:</para>
      <list type="table">
        <listheader>
          <description>Error</description>
          <description>Meaning</description>
        </listheader>
        <item>
          <description>S_OK</description>
          <description>Success.</description>
        </item>
        <item>
          <description>E_POINTER</description>
          <description>The <i>pszOut</i> buffer is too small to hold the entire string.</description>
        </item>
        <item>
          <description>S_FALSE</description>
          <description>
            <i>pszOut</i> is <b>NULL</b>. <i>pcchOut</i> contains the required buffer size.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function is a wrapper for the <see cref="IQueryAssociations" /> interface. The <b>AssocQueryString</b> function is intended to simplify the process of using <b>IQueryAssociations</b> interface.</para>
      <para>Once an item is selected, the host must decide which (if any) preview handler is available for that item. Preview handlers are typically registered on file name extensions or ProgID, but some preview handlers are only instantiated for items within particular shell folders (the MAPI preview handler is associated with any items that came from the MAPI Shell folder, for example). Thus, the host must use <see cref="IQueryAssociations" /> to determine which preview handler to use. For further discussion of how the file and protocol association functions work, see <see cref="IQueryAssociations" />.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines AssocQueryString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ChrCmpI">
    <summary>
      <para>Performs a comparison between two characters. The comparison is not case-sensitive.</para>
    </summary>
    <param name="w1">
      <para>Type: <b>TCHAR</b></para>
      <para>The first character to be compared.</para>
    </param>
    <param name="w2">
      <para>Type: <b>TCHAR</b></para>
      <para>The second character to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns zero if the two characters are the same, or nonzero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines ChrCmpI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ChrCmpIA">
    <summary>
      <para>Performs a comparison between two characters. The comparison is not case-sensitive.</para>
    </summary>
    <param name="w1">
      <para>Type: <b>TCHAR</b></para>
      <para>The first character to be compared.</para>
    </param>
    <param name="w2">
      <para>Type: <b>TCHAR</b></para>
      <para>The second character to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns zero if the two characters are the same, or nonzero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines ChrCmpI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ChrCmpIW">
    <summary>
      <para>Performs a comparison between two characters. The comparison is not case-sensitive.</para>
    </summary>
    <param name="w1">
      <para>Type: <b>TCHAR</b></para>
      <para>The first character to be compared.</para>
    </param>
    <param name="w2">
      <para>Type: <b>TCHAR</b></para>
      <para>The second character to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns zero if the two characters are the same, or nonzero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines ChrCmpI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ChrCmpI">
    <summary>
      <para>Performs a comparison between two characters. The comparison is not case-sensitive.</para>
    </summary>
    <param name="w1">
      <para>Type: <b>TCHAR</b></para>
      <para>The first character to be compared.</para>
    </param>
    <param name="w2">
      <para>Type: <b>TCHAR</b></para>
      <para>The second character to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns zero if the two characters are the same, or nonzero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines ChrCmpI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ChrCmpIA">
    <summary>
      <para>Performs a comparison between two characters. The comparison is not case-sensitive.</para>
    </summary>
    <param name="w1">
      <para>Type: <b>TCHAR</b></para>
      <para>The first character to be compared.</para>
    </param>
    <param name="w2">
      <para>Type: <b>TCHAR</b></para>
      <para>The second character to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns zero if the two characters are the same, or nonzero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines ChrCmpI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ChrCmpIW">
    <summary>
      <para>Performs a comparison between two characters. The comparison is not case-sensitive.</para>
    </summary>
    <param name="w1">
      <para>Type: <b>TCHAR</b></para>
      <para>The first character to be compared.</para>
    </param>
    <param name="w2">
      <para>Type: <b>TCHAR</b></para>
      <para>The second character to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns zero if the two characters are the same, or nonzero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines ChrCmpI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ColorAdjustLuma">
    <summary>
      <para>Changes the luminance of a RGB value. Hue and saturation are not affected.</para>
    </summary>
    <param name="clrRGB">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a></b></para>
      <para>The initial RGB value.</para>
    </param>
    <param name="n">
      <para>Type: <b>int</b></para>
      <para>The luminance in units of 0.1 percent of the total range. For example, a value of <i>n</i> = 50 corresponds to 5 percent of the maximum luminance.</para>
    </param>
    <param name="fScale">
      <para>Type: <b>BOOL</b></para>
      <para>If <i>fScale</i> is set to <b>TRUE</b>, <i>n</i> specifies how much to increment or decrement the current luminance. If <i>fScale</i> is set to <b>FALSE</b>, <i>n</i> specifies the absolute luminance.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a></b></para>
      <para>Returns the modified RGB value.</para>
    </returns>
    <remarks>
      <para>If <i>fScale</i> is set to <b>TRUE</b>, <i>n</i> can range from -1000 to +1000.</para>
      <para>If <i>fScale</i> is set to <b>FALSE</b>, <i>n</i> can range from 0 to 1000. Available luminance values range from 0 to a maximum. If the requested value is negative or exceeds the maximum, the luminance will be set to either zero or the maximum value, respectively.</para>
    </remarks>
  </member>
  <member name="Windows.ColorHLSToRGB">
    <summary>
      <para>Converts colors from hue-luminance-saturation (HLS) to RGB format.</para>
    </summary>
    <param name="wHue">
      <para>Type: <b>WORD</b></para>
      <para>The original HLS hue value.</para>
    </param>
    <param name="wLuminance">
      <para>Type: <b>WORD</b></para>
      <para>The original HLS luminance value.</para>
    </param>
    <param name="wSaturation">
      <para>Type: <b>WORD</b></para>
      <para>The original HLS saturation value.</para>
    </param>
    <returns>
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a></b></para>
      <para>Returns the RGB value.</para>
    </returns>
  </member>
  <member name="Windows.ColorRGBToHLS">
    <summary>
      <para>Converts colors from RGB to hue-luminance-saturation (HLS) format.</para>
    </summary>
    <param name="clrRGB">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/gdi/colorref">COLORREF</a></b></para>
      <para>The original RGB color.</para>
    </param>
    <param name="pwHue">
      <para>Type: <b>WORD*</b></para>
      <para>A pointer to a value that, when this method returns successfully, receives the HLS hue value.</para>
    </param>
    <param name="pwLuminance">
      <para>Type: <b>WORD*</b></para>
      <para>A pointer to a value that, when this method returns successfully, receives the HLS luminance value.</para>
    </param>
    <param name="pwSaturation">
      <para>Type: <b>WORD*</b></para>
      <para>A pointer to a value that, when this method returns successfully, receives the HLS saturation value.</para>
    </param>
  </member>
  <member name="Windows.DllInstall">
    <summary>
      <para>Handles installation and setup for a DLL.</para>
    </summary>
    <param name="bInstall">
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if the DLL is being installed; <b>FALSE</b> if it is being uninstalled.</para>
    </param>
    <param name="pszCmdLine">
      <para>Type: <b>PCWSTR</b></para>
      <para>A string passed in by <b>regsvr32</b> that indicates which setup procedure to use. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This function may be implemented and exported by name by a DLL for use during application installation or setup. It is invoked by <b>regsvr32</b> to allow the DLL to perform tasks such as adding information to the registry.</para>
      <para>
        <b>DllInstall</b> is used only for application installation and setup. It should not be called by an application. It is similar in purpose to <see cref="DllRegisterServer" /> or <see cref="DllUnregisterServer" />. Unlike these functions, <b>DllInstall</b> takes an input string which can be used to specify a variety of different actions. This allows a DLL to be installed in more than one way, based on any criteria that is appropriate.</para>
      <para>To use <b>DllInstall</b> with <b>regsvr32</b>, add a "/i" flag followed by a colon (:) and a string. The string will be passed to <b>DllInstall</b> as the <i>pszCmdLine</i> parameter. If you omit the colon and string, <i>pszCmdLine</i> will be set to <b>NULL</b>. The following example would be used to install a DLL.</para>
      <para>
        <b>regsvr32 /i:"Install_1" dllname.dll</b>
      </para>
      <para>
        <b>DllInstall</b> is invoked with <i>bInstall</i> set to <b>TRUE</b> and <i>pszCmdLine</i> set to "Install_1". To uninstall a DLL, use the following:</para>
      <para>
        <b>regsvr32 /u /i:"Install_1" dllname.dll</b>
      </para>
      <para>With both of the above examples, <see cref="DllRegisterServer" /> or <see cref="DllUnregisterServer" /> will also be called. To call <b>DllInstall</b> only, add a "/n" flag.</para>
      <para>
        <b>regsvr32 /n /i:"Install_1" dllname.dll</b>
      </para>
    </remarks>
  </member>
  <member name="Windows.GetAcceptLanguages">
    <summary>
      <para>Retrieves a string used with websites when specifying language preferences.</para>
    </summary>
    <param name="pszLanguages">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that, when this function returns successfully, receives the language preferences information. We recommend that this buffer be of size 2048 characters to ensure sufficient space to return the full string. You can also call this function with this parameter set to NULL to retrieve the size of the string that will be returned.</para>
    </param>
    <param name="pcchLanguages">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to the size, in characters, of the string at <i>pszLanguages</i>.</para>
      <para>On entry, this value is the size of <i>pszLanguages</i>, including the terminating null character.</para>
      <para>On exit, it is the actual size of <i>pszLanguages</i>, not including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>For those versions of Windows that do not include <b>GetAcceptLanguages</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>GetAcceptLanguagesA</b> is ordinal 14 and <b>GetAcceptLanguagesW</b> is ordinal 15.</para>
      <para>Some websites offer content in multiple languages. You can specify your language preferences in the Internet Options item in Control Panel. <b>GetAcceptLanguages</b> retrieves a string that represents those preferences. That string is sent in an additional language header when negotiating HTTP connections.</para>
      <para>
        <b>Note</b>  If your app or service passes language tags from this function to any <a href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support">National Language Support</a> functions, or to Microsoft .NET, it must first convert the tags through the <see cref="ResolveLocaleName" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines GetAcceptLanguages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.GetAcceptLanguagesA">
    <summary>
      <para>Retrieves a string used with websites when specifying language preferences.</para>
    </summary>
    <param name="pszLanguages">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that, when this function returns successfully, receives the language preferences information. We recommend that this buffer be of size 2048 characters to ensure sufficient space to return the full string. You can also call this function with this parameter set to NULL to retrieve the size of the string that will be returned.</para>
    </param>
    <param name="pcchLanguages">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to the size, in characters, of the string at <i>pszLanguages</i>.</para>
      <para>On entry, this value is the size of <i>pszLanguages</i>, including the terminating null character.</para>
      <para>On exit, it is the actual size of <i>pszLanguages</i>, not including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>For those versions of Windows that do not include <b>GetAcceptLanguages</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>GetAcceptLanguagesA</b> is ordinal 14 and <b>GetAcceptLanguagesW</b> is ordinal 15.</para>
      <para>Some websites offer content in multiple languages. You can specify your language preferences in the Internet Options item in Control Panel. <b>GetAcceptLanguages</b> retrieves a string that represents those preferences. That string is sent in an additional language header when negotiating HTTP connections.</para>
      <para>
        <b>Note</b>  If your app or service passes language tags from this function to any <a href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support">National Language Support</a> functions, or to Microsoft .NET, it must first convert the tags through the <see cref="ResolveLocaleName" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines GetAcceptLanguages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.GetAcceptLanguagesW">
    <summary>
      <para>Retrieves a string used with websites when specifying language preferences.</para>
    </summary>
    <param name="pszLanguages">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that, when this function returns successfully, receives the language preferences information. We recommend that this buffer be of size 2048 characters to ensure sufficient space to return the full string. You can also call this function with this parameter set to NULL to retrieve the size of the string that will be returned.</para>
    </param>
    <param name="pcchLanguages">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to the size, in characters, of the string at <i>pszLanguages</i>.</para>
      <para>On entry, this value is the size of <i>pszLanguages</i>, including the terminating null character.</para>
      <para>On exit, it is the actual size of <i>pszLanguages</i>, not including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>For those versions of Windows that do not include <b>GetAcceptLanguages</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>GetAcceptLanguagesA</b> is ordinal 14 and <b>GetAcceptLanguagesW</b> is ordinal 15.</para>
      <para>Some websites offer content in multiple languages. You can specify your language preferences in the Internet Options item in Control Panel. <b>GetAcceptLanguages</b> retrieves a string that represents those preferences. That string is sent in an additional language header when negotiating HTTP connections.</para>
      <para>
        <b>Note</b>  If your app or service passes language tags from this function to any <a href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support">National Language Support</a> functions, or to Microsoft .NET, it must first convert the tags through the <see cref="ResolveLocaleName" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines GetAcceptLanguages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.GetAcceptLanguages">
    <summary>
      <para>Retrieves a string used with websites when specifying language preferences.</para>
    </summary>
    <param name="pszLanguages">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that, when this function returns successfully, receives the language preferences information. We recommend that this buffer be of size 2048 characters to ensure sufficient space to return the full string. You can also call this function with this parameter set to NULL to retrieve the size of the string that will be returned.</para>
    </param>
    <param name="pcchLanguages">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to the size, in characters, of the string at <i>pszLanguages</i>.</para>
      <para>On entry, this value is the size of <i>pszLanguages</i>, including the terminating null character.</para>
      <para>On exit, it is the actual size of <i>pszLanguages</i>, not including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>For those versions of Windows that do not include <b>GetAcceptLanguages</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>GetAcceptLanguagesA</b> is ordinal 14 and <b>GetAcceptLanguagesW</b> is ordinal 15.</para>
      <para>Some websites offer content in multiple languages. You can specify your language preferences in the Internet Options item in Control Panel. <b>GetAcceptLanguages</b> retrieves a string that represents those preferences. That string is sent in an additional language header when negotiating HTTP connections.</para>
      <para>
        <b>Note</b>  If your app or service passes language tags from this function to any <a href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support">National Language Support</a> functions, or to Microsoft .NET, it must first convert the tags through the <see cref="ResolveLocaleName" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines GetAcceptLanguages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.GetAcceptLanguagesA">
    <summary>
      <para>Retrieves a string used with websites when specifying language preferences.</para>
    </summary>
    <param name="pszLanguages">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that, when this function returns successfully, receives the language preferences information. We recommend that this buffer be of size 2048 characters to ensure sufficient space to return the full string. You can also call this function with this parameter set to NULL to retrieve the size of the string that will be returned.</para>
    </param>
    <param name="pcchLanguages">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to the size, in characters, of the string at <i>pszLanguages</i>.</para>
      <para>On entry, this value is the size of <i>pszLanguages</i>, including the terminating null character.</para>
      <para>On exit, it is the actual size of <i>pszLanguages</i>, not including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>For those versions of Windows that do not include <b>GetAcceptLanguages</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>GetAcceptLanguagesA</b> is ordinal 14 and <b>GetAcceptLanguagesW</b> is ordinal 15.</para>
      <para>Some websites offer content in multiple languages. You can specify your language preferences in the Internet Options item in Control Panel. <b>GetAcceptLanguages</b> retrieves a string that represents those preferences. That string is sent in an additional language header when negotiating HTTP connections.</para>
      <para>
        <b>Note</b>  If your app or service passes language tags from this function to any <a href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support">National Language Support</a> functions, or to Microsoft .NET, it must first convert the tags through the <see cref="ResolveLocaleName" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines GetAcceptLanguages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.GetAcceptLanguagesW">
    <summary>
      <para>Retrieves a string used with websites when specifying language preferences.</para>
    </summary>
    <param name="pszLanguages">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that, when this function returns successfully, receives the language preferences information. We recommend that this buffer be of size 2048 characters to ensure sufficient space to return the full string. You can also call this function with this parameter set to NULL to retrieve the size of the string that will be returned.</para>
    </param>
    <param name="pcchLanguages">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to the size, in characters, of the string at <i>pszLanguages</i>.</para>
      <para>On entry, this value is the size of <i>pszLanguages</i>, including the terminating null character.</para>
      <para>On exit, it is the actual size of <i>pszLanguages</i>, not including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>For those versions of Windows that do not include <b>GetAcceptLanguages</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>GetAcceptLanguagesA</b> is ordinal 14 and <b>GetAcceptLanguagesW</b> is ordinal 15.</para>
      <para>Some websites offer content in multiple languages. You can specify your language preferences in the Internet Options item in Control Panel. <b>GetAcceptLanguages</b> retrieves a string that represents those preferences. That string is sent in an additional language header when negotiating HTTP connections.</para>
      <para>
        <b>Note</b>  If your app or service passes language tags from this function to any <a href="https://docs.microsoft.com//windows/desktop/Intl/national-language-support">National Language Support</a> functions, or to Microsoft .NET, it must first convert the tags through the <see cref="ResolveLocaleName" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines GetAcceptLanguages as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.GetProcessReference">
    <summary>
      <para>Retrieves the process-specific object supplied by <see cref="SetProcessReference" />, incrementing the reference count to keep the process alive.</para>
    </summary>
    <param name="punk">
      <para>The address of a pointer that, when this function returns successfully, points to the object supplied to the process by <see cref="SetProcessReference" />. Your application is responsible for freeing this resource when it is no longer needed.</para>
      <para>A pointer to a free-threaded <see cref="IUnknown" />. Components can use this interface (through <see cref="SHGetInstanceExplorer" />) to prevent the host process from terminating. This value can be <b>NULL</b>, in which case the process reference is no longer made available to components.</para>
    </param>
    <remarks>
      <para>There are a number of components, such as Shell extension handlers, that are implemented as DLLs and run in a host process such as Windows Explorer (Explorer.exe) or Windows Internet Explorer (Iexplore.exe). Typically, when the user closes the host process, the component is shut down immediately as well. Such an abrupt termination can create problems for some components. For example, if a component is using a background thread to download data or run user-interface functions, it might need additional time to safely shut itself down.</para>
      <para>
        <b>GetProcessReference</b> allows components that run in a host process to hold a reference on the host process. <b>GetProcessReference</b> increments the host's reference count and returns a pointer to the host's <see cref="IUnknown" /> interface. By holding that reference, a component can prevent the host process from closing prematurely. After the component has completed its necessary processing, it should call <see cref="(*punk)-&gt;Release" /> to release the host's reference and allow the process to terminate.</para>
      <para>
        <b>Note</b>  If <b>GetProcessReference</b> is successful, the component must release the host's reference when it is no longer needed. Otherwise, all resources associated with the process will remain in memory. The <see cref="IUnknown" /> interface pointed to by *<i>punk</i> can only be used to release this reference. Components cannot use <see cref="(*punk)-&gt;QueryInterface" /> to request other interface pointers.</para>
      <para>
        <b>GetProcessReference</b> succeeds only if it is called from from an application which had previously called <see cref="SetProcessReference" /> to set a process reference.</para>
    </remarks>
    <seealso cref="SHGetInstanceExplorer" />
    <seealso cref="SetProcessReference" />
    <seealso href="https://docs.microsoft.com//windows/desktop/apiindex/windows-apisets">Windows API Sets</seealso>
  </member>
  <member name="Windows.HashData">
    <summary>
      <para>Hashes an array of data.</para>
    </summary>
    <param name="pbData">
      <para>Type: <b>BYTE*</b></para>
      <para>A pointer to the data array.</para>
    </param>
    <param name="cbData">
      <para>Type: <b>DWORD</b></para>
      <para>The number of elements in the array at <i>pbData</i>.</para>
    </param>
    <param name="pbHash">
      <para>Type: <b>BYTE*</b></para>
      <para>A pointer to a value that, when this function returns successfully, receives the hashed array.</para>
    </param>
    <param name="cbHash">
      <para>Type: <b>DWORD</b></para>
      <para>The number of elements in <i>pbHash</i>. It should be no larger than 256.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
  </member>
  <member name="Windows.IntlStrEqN">
    <summary>
      <para>Performs a case-sensitive comparison of a specified number of characters from the beginning of two localized strings.</para>
    </summary>
    <param name="s1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="s2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be compared, starting from the beginning of the strings.</para>
    </param>
    <remarks>
      <para>This function retrieves the thread locale and uses <see cref="CompareString" /> to do a case-sensitive comparison of the first <i>nChar</i> characters. It is equivalent to:</para>
      <code>IntlStrEqWorker(TRUE, pszStr1, pszStr2, nChar)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines IntlStrEqN as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IntlStrEqWorker" />
  </member>
  <member name="Windows.IntlStrEqNA">
    <summary>
      <para>Performs a case-sensitive comparison of a specified number of characters from the beginning of two localized strings.</para>
    </summary>
    <param name="s1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="s2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be compared, starting from the beginning of the strings.</para>
    </param>
    <remarks>
      <para>This function retrieves the thread locale and uses <see cref="CompareString" /> to do a case-sensitive comparison of the first <i>nChar</i> characters. It is equivalent to:</para>
      <code>IntlStrEqWorker(TRUE, pszStr1, pszStr2, nChar)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines IntlStrEqN as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IntlStrEqWorker" />
  </member>
  <member name="Windows.IntlStrEqNW">
    <summary>
      <para>Performs a case-sensitive comparison of a specified number of characters from the beginning of two localized strings.</para>
    </summary>
    <param name="s1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="s2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be compared, starting from the beginning of the strings.</para>
    </param>
    <remarks>
      <para>This function retrieves the thread locale and uses <see cref="CompareString" /> to do a case-sensitive comparison of the first <i>nChar</i> characters. It is equivalent to:</para>
      <code>IntlStrEqWorker(TRUE, pszStr1, pszStr2, nChar)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines IntlStrEqN as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IntlStrEqWorker" />
  </member>
  <member name="Windows.IntlStrEqNI">
    <summary>
      <para>Performs a case-insensitive comparison of a specified number of characters from the beginning of two localized strings.</para>
    </summary>
    <param name="s1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="s2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be compared, starting from the beginning of the strings.</para>
    </param>
    <remarks>
      <para>This function retrieves the thread locale and uses <see cref="CompareString" /> to do a case-insensitive comparison of the first <i>nChar</i> characters. It is equivalent to:</para>
      <code>IntlStrEqWorker(FALSE, pszStr1, pszStr2, nChar)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines IntlStrEqNI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IntlStrEqWorker" />
  </member>
  <member name="Windows.IntlStrEqNIA">
    <summary>
      <para>Performs a case-insensitive comparison of a specified number of characters from the beginning of two localized strings.</para>
    </summary>
    <param name="s1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="s2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be compared, starting from the beginning of the strings.</para>
    </param>
    <remarks>
      <para>This function retrieves the thread locale and uses <see cref="CompareString" /> to do a case-insensitive comparison of the first <i>nChar</i> characters. It is equivalent to:</para>
      <code>IntlStrEqWorker(FALSE, pszStr1, pszStr2, nChar)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines IntlStrEqNI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IntlStrEqWorker" />
  </member>
  <member name="Windows.IntlStrEqNIW">
    <summary>
      <para>Performs a case-insensitive comparison of a specified number of characters from the beginning of two localized strings.</para>
    </summary>
    <param name="s1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="s2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be compared, starting from the beginning of the strings.</para>
    </param>
    <remarks>
      <para>This function retrieves the thread locale and uses <see cref="CompareString" /> to do a case-insensitive comparison of the first <i>nChar</i> characters. It is equivalent to:</para>
      <code>IntlStrEqWorker(FALSE, pszStr1, pszStr2, nChar)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines IntlStrEqNI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IntlStrEqWorker" />
  </member>
  <member name="Windows.IntlStrEqNI">
    <summary>
      <para>Performs a case-insensitive comparison of a specified number of characters from the beginning of two localized strings.</para>
    </summary>
    <param name="s1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="s2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be compared, starting from the beginning of the strings.</para>
    </param>
    <remarks>
      <para>This function retrieves the thread locale and uses <see cref="CompareString" /> to do a case-insensitive comparison of the first <i>nChar</i> characters. It is equivalent to:</para>
      <code>IntlStrEqWorker(FALSE, pszStr1, pszStr2, nChar)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines IntlStrEqNI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IntlStrEqWorker" />
  </member>
  <member name="Windows.IntlStrEqNIA">
    <summary>
      <para>Performs a case-insensitive comparison of a specified number of characters from the beginning of two localized strings.</para>
    </summary>
    <param name="s1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="s2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be compared, starting from the beginning of the strings.</para>
    </param>
    <remarks>
      <para>This function retrieves the thread locale and uses <see cref="CompareString" /> to do a case-insensitive comparison of the first <i>nChar</i> characters. It is equivalent to:</para>
      <code>IntlStrEqWorker(FALSE, pszStr1, pszStr2, nChar)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines IntlStrEqNI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IntlStrEqWorker" />
  </member>
  <member name="Windows.IntlStrEqNIW">
    <summary>
      <para>Performs a case-insensitive comparison of a specified number of characters from the beginning of two localized strings.</para>
    </summary>
    <param name="s1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="s2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be compared, starting from the beginning of the strings.</para>
    </param>
    <remarks>
      <para>This function retrieves the thread locale and uses <see cref="CompareString" /> to do a case-insensitive comparison of the first <i>nChar</i> characters. It is equivalent to:</para>
      <code>IntlStrEqWorker(FALSE, pszStr1, pszStr2, nChar)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines IntlStrEqNI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IntlStrEqWorker" />
  </member>
  <member name="Windows.IntlStrEqN">
    <summary>
      <para>Performs a case-sensitive comparison of a specified number of characters from the beginning of two localized strings.</para>
    </summary>
    <param name="s1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="s2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be compared, starting from the beginning of the strings.</para>
    </param>
    <remarks>
      <para>This function retrieves the thread locale and uses <see cref="CompareString" /> to do a case-sensitive comparison of the first <i>nChar</i> characters. It is equivalent to:</para>
      <code>IntlStrEqWorker(TRUE, pszStr1, pszStr2, nChar)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines IntlStrEqN as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IntlStrEqWorker" />
  </member>
  <member name="Windows.IntlStrEqNA">
    <summary>
      <para>Performs a case-sensitive comparison of a specified number of characters from the beginning of two localized strings.</para>
    </summary>
    <param name="s1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="s2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be compared, starting from the beginning of the strings.</para>
    </param>
    <remarks>
      <para>This function retrieves the thread locale and uses <see cref="CompareString" /> to do a case-sensitive comparison of the first <i>nChar</i> characters. It is equivalent to:</para>
      <code>IntlStrEqWorker(TRUE, pszStr1, pszStr2, nChar)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines IntlStrEqN as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IntlStrEqWorker" />
  </member>
  <member name="Windows.IntlStrEqNW">
    <summary>
      <para>Performs a case-sensitive comparison of a specified number of characters from the beginning of two localized strings.</para>
    </summary>
    <param name="s1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="s2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be compared, starting from the beginning of the strings.</para>
    </param>
    <remarks>
      <para>This function retrieves the thread locale and uses <see cref="CompareString" /> to do a case-sensitive comparison of the first <i>nChar</i> characters. It is equivalent to:</para>
      <code>IntlStrEqWorker(TRUE, pszStr1, pszStr2, nChar)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines IntlStrEqN as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="IntlStrEqWorker" />
  </member>
  <member name="Windows.IntlStrEqWorker">
    <summary>
      <para>Compares a specified number of characters from the beginning of two localized strings.</para>
    </summary>
    <param name="fCaseSens">
      <para>Type: <b>BOOL</b></para>
      <para>A value that is set to <b>TRUE</b> for a case-sensitive comparison, or to <b>FALSE</b> for a case-insensitive comparison.</para>
    </param>
    <param name="lpString1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be compared, starting from the beginning of the strings.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the first <i>nChar</i> characters are identical, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function retrieves the thread locale and uses <see cref="CompareString" /> to determine whether the first <i>nChar</i> characters are identical.</para>
    </remarks>
  </member>
  <member name="Windows.IntlStrEqWorkerA">
    <summary>
      <para>Compares a specified number of characters from the beginning of two localized strings.</para>
    </summary>
    <param name="fCaseSens">
      <para>Type: <b>BOOL</b></para>
      <para>A value that is set to <b>TRUE</b> for a case-sensitive comparison, or to <b>FALSE</b> for a case-insensitive comparison.</para>
    </param>
    <param name="lpString1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be compared, starting from the beginning of the strings.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the first <i>nChar</i> characters are identical, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function retrieves the thread locale and uses <see cref="CompareString" /> to determine whether the first <i>nChar</i> characters are identical.</para>
    </remarks>
  </member>
  <member name="Windows.IntlStrEqWorkerW">
    <summary>
      <para>Compares a specified number of characters from the beginning of two localized strings.</para>
    </summary>
    <param name="fCaseSens">
      <para>Type: <b>BOOL</b></para>
      <para>A value that is set to <b>TRUE</b> for a case-sensitive comparison, or to <b>FALSE</b> for a case-insensitive comparison.</para>
    </param>
    <param name="lpString1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be compared, starting from the beginning of the strings.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the first <i>nChar</i> characters are identical, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function retrieves the thread locale and uses <see cref="CompareString" /> to determine whether the first <i>nChar</i> characters are identical.</para>
    </remarks>
  </member>
  <member name="Windows.IntlStrEqWorker">
    <summary>
      <para>Compares a specified number of characters from the beginning of two localized strings.</para>
    </summary>
    <param name="fCaseSens">
      <para>Type: <b>BOOL</b></para>
      <para>A value that is set to <b>TRUE</b> for a case-sensitive comparison, or to <b>FALSE</b> for a case-insensitive comparison.</para>
    </param>
    <param name="lpString1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be compared, starting from the beginning of the strings.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the first <i>nChar</i> characters are identical, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function retrieves the thread locale and uses <see cref="CompareString" /> to determine whether the first <i>nChar</i> characters are identical.</para>
    </remarks>
  </member>
  <member name="Windows.IntlStrEqWorkerA">
    <summary>
      <para>Compares a specified number of characters from the beginning of two localized strings.</para>
    </summary>
    <param name="fCaseSens">
      <para>Type: <b>BOOL</b></para>
      <para>A value that is set to <b>TRUE</b> for a case-sensitive comparison, or to <b>FALSE</b> for a case-insensitive comparison.</para>
    </param>
    <param name="lpString1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be compared, starting from the beginning of the strings.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the first <i>nChar</i> characters are identical, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function retrieves the thread locale and uses <see cref="CompareString" /> to determine whether the first <i>nChar</i> characters are identical.</para>
    </remarks>
  </member>
  <member name="Windows.IntlStrEqWorkerW">
    <summary>
      <para>Compares a specified number of characters from the beginning of two localized strings.</para>
    </summary>
    <param name="fCaseSens">
      <para>Type: <b>BOOL</b></para>
      <para>A value that is set to <b>TRUE</b> for a case-sensitive comparison, or to <b>FALSE</b> for a case-insensitive comparison.</para>
    </param>
    <param name="lpString1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="lpString2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be compared, starting from the beginning of the strings.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the first <i>nChar</i> characters are identical, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function retrieves the thread locale and uses <see cref="CompareString" /> to determine whether the first <i>nChar</i> characters are identical.</para>
    </remarks>
  </member>
  <member name="Windows.IsCharSpace">
    <summary>
      <para>Determines whether a character represents a space.</para>
    </summary>
    <param name="wch">
      <para>Type: <b>TCHAR</b></para>
      <para>A single character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the character is a space; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>For those versions of Windows that do not include <b>IsCharSpace</b> in Shlwapi.h, <b>IsCharSpaceW</b> must be called directly from Shlwapi.dll (ordinal 29), using a WCHAR in the <i>wch</i> parameter. <b>IsCharSpaceA</b> is not available in versions of Windows that do not include <b>IsCharSpace</b> in Shlwapi.h.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines IsCharSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.IsCharSpaceA">
    <summary>
      <para>Determines whether a character represents a space.</para>
    </summary>
    <param name="wch">
      <para>Type: <b>TCHAR</b></para>
      <para>A single character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the character is a space; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>For those versions of Windows that do not include <b>IsCharSpace</b> in Shlwapi.h, <b>IsCharSpaceW</b> must be called directly from Shlwapi.dll (ordinal 29), using a WCHAR in the <i>wch</i> parameter. <b>IsCharSpaceA</b> is not available in versions of Windows that do not include <b>IsCharSpace</b> in Shlwapi.h.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines IsCharSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.IsCharSpaceW">
    <summary>
      <para>Determines whether a character represents a space.</para>
    </summary>
    <param name="wch">
      <para>Type: <b>TCHAR</b></para>
      <para>A single character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the character is a space; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>For those versions of Windows that do not include <b>IsCharSpace</b> in Shlwapi.h, <b>IsCharSpaceW</b> must be called directly from Shlwapi.dll (ordinal 29), using a WCHAR in the <i>wch</i> parameter. <b>IsCharSpaceA</b> is not available in versions of Windows that do not include <b>IsCharSpace</b> in Shlwapi.h.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines IsCharSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.IsCharSpace">
    <summary>
      <para>Determines whether a character represents a space.</para>
    </summary>
    <param name="wch">
      <para>Type: <b>TCHAR</b></para>
      <para>A single character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the character is a space; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>For those versions of Windows that do not include <b>IsCharSpace</b> in Shlwapi.h, <b>IsCharSpaceW</b> must be called directly from Shlwapi.dll (ordinal 29), using a WCHAR in the <i>wch</i> parameter. <b>IsCharSpaceA</b> is not available in versions of Windows that do not include <b>IsCharSpace</b> in Shlwapi.h.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines IsCharSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.IsCharSpaceA">
    <summary>
      <para>Determines whether a character represents a space.</para>
    </summary>
    <param name="wch">
      <para>Type: <b>TCHAR</b></para>
      <para>A single character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the character is a space; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>For those versions of Windows that do not include <b>IsCharSpace</b> in Shlwapi.h, <b>IsCharSpaceW</b> must be called directly from Shlwapi.dll (ordinal 29), using a WCHAR in the <i>wch</i> parameter. <b>IsCharSpaceA</b> is not available in versions of Windows that do not include <b>IsCharSpace</b> in Shlwapi.h.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines IsCharSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.IsCharSpaceW">
    <summary>
      <para>Determines whether a character represents a space.</para>
    </summary>
    <param name="wch">
      <para>Type: <b>TCHAR</b></para>
      <para>A single character.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the character is a space; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>For those versions of Windows that do not include <b>IsCharSpace</b> in Shlwapi.h, <b>IsCharSpaceW</b> must be called directly from Shlwapi.dll (ordinal 29), using a WCHAR in the <i>wch</i> parameter. <b>IsCharSpaceA</b> is not available in versions of Windows that do not include <b>IsCharSpace</b> in Shlwapi.h.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines IsCharSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.IsInternetESCEnabled">
    <summary>
      <para>Determines whether Windows Internet Explorer is in the Enhanced Security Configuration.</para>
    </summary>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if Internet Explorer is in the Enhanced Security Configuration, and <b>FALSE</b> otherwise.</para>
    </returns>
  </member>
  <member name="Windows.IsOS">
    <summary>
      <para>Checks for specified operating systems and operating system features.</para>
    </summary>
    <param name="dwOS">
      <para>Type: <b>DWORD</b></para>
      <para>A value that specifies which operating system or operating system feature to check for. One of the following values (you cannot combine values).</para>
      <list type="table">
        <listheader>
          <description>Name</description>
          <description>Value</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>OS_WINDOWS</description>
          <description>0</description>
          <description>The program is running on one of the following versions of Windows:
<list type="bullet"><item><description>Windows 95</description></item><item><description>Windows 98</description></item><item><description>Windows Me</description></item></list><para>Equivalent to <see cref="VER_PLATFORM_WIN32_WINDOWS" />. Note that none of those systems are supported at this time. <b>OS_WINDOWS</b> returns <b>FALSE</b> on all supported systems.</para></description>
        </item>
        <item>
          <description>OS_NT</description>
          <description>1</description>
          <description>Always returns <b>TRUE</b>.</description>
        </item>
        <item>
          <description>OS_WIN95ORGREATER</description>
          <description>2</description>
          <description>Always returns <b>FALSE</b>.</description>
        </item>
        <item>
          <description>OS_NT4ORGREATER</description>
          <description>3</description>
          <description>Always returns <b>FALSE</b>.</description>
        </item>
        <item>
          <description>OS_WIN98ORGREATER</description>
          <description>5</description>
          <description>Always returns <b>FALSE</b>.</description>
        </item>
        <item>
          <description>OS_WIN98_GOLD</description>
          <description>6</description>
          <description>Always returns <b>FALSE</b>.</description>
        </item>
        <item>
          <description>OS_WIN2000ORGREATER</description>
          <description>7</description>
          <description>The program is running on Windows 2000 or one of its successors.</description>
        </item>
        <item>
          <description>OS_WIN2000PRO</description>
          <description>8</description>
          <description>Do not use; use OS_PROFESSIONAL.</description>
        </item>
        <item>
          <description>OS_WIN2000SERVER</description>
          <description>9</description>
          <description>Do not use; use OS_SERVER.</description>
        </item>
        <item>
          <description>OS_WIN2000ADVSERVER</description>
          <description>10</description>
          <description>Do not use; use OS_ADVSERVER.</description>
        </item>
        <item>
          <description>OS_WIN2000DATACENTER</description>
          <description>11</description>
          <description>Do not use; use OS_DATACENTER.</description>
        </item>
        <item>
          <description>OS_WIN2000TERMINAL</description>
          <description>12</description>
          <description>The program is running on Windows 2000 Terminal Server in either Remote Administration mode or Application Server mode, or Windows Server 2003  (or one of its successors) in Terminal Server mode or Remote Desktop for Administration mode. Consider using a more specific value such as OS_TERMINALSERVER, OS_TERMINALREMOTEADMIN, or  OS_PERSONALTERMINALSERVER.</description>
        </item>
        <item>
          <description>OS_EMBEDDED</description>
          <description>13</description>
          <description>The program is running on Windows Embedded, any version. Equivalent to <see cref="VER_SUITE_EMBEDDEDNT" />.</description>
        </item>
        <item>
          <description>OS_TERMINALCLIENT</description>
          <description>14</description>
          <description>The program is running as a Terminal Server client. Equivalent to <see cref="GetSystemMetrics" />(SM_REMOTESESSION).</description>
        </item>
        <item>
          <description>OS_TERMINALREMOTEADMIN</description>
          <description>15</description>
          <description>The program is running on Windows 2000 Terminal Server in the Remote Administration mode or Windows Server 2003 (or one of its successors) in the Remote Desktop for Administration mode (these are the default installation modes). This is equivalent to <see cref="VER_SUITE_TERMINAL" /> &amp;&amp; <see cref="VER_SUITE_SINGLEUSERTS" />.</description>
        </item>
        <item>
          <description>OS_WIN95_GOLD</description>
          <description>16</description>
          <description>Always returns <b>FALSE</b>.</description>
        </item>
        <item>
          <description>OS_MEORGREATER</description>
          <description>17</description>
          <description>Always returns <b>FALSE</b>.</description>
        </item>
        <item>
          <description>OS_XPORGREATER</description>
          <description>18</description>
          <description>Always returns <b>FALSE</b>.</description>
        </item>
        <item>
          <description>OS_HOME</description>
          <description>19</description>
          <description>Always returns <b>FALSE</b>.</description>
        </item>
        <item>
          <description>OS_PROFESSIONAL</description>
          <description>20</description>
          <description>The program is running on Windows NT Workstation or Windows 2000 (or one of its successors) Professional. Equivalent to <see cref="VER_PLATFORM_WIN32_NT" /> &amp;&amp; <see cref="VER_NT_WORKSTATION" />.</description>
        </item>
        <item>
          <description>OS_DATACENTER</description>
          <description>21</description>
          <description>The program is running on Windows Datacenter Server or Windows Server Datacenter Edition, any version. Equivalent to (<see cref="VER_NT_SERVER" /> || <see cref="VER_NT_DOMAIN_CONTROLLER" />) &amp;&amp; <see cref="VER_SUITE_DATACENTER" />.</description>
        </item>
        <item>
          <description>OS_ADVSERVER</description>
          <description>22</description>
          <description>The program is running on Windows Advanced Server or Windows Server Enterprise Edition, any version. Equivalent to (<see cref="VER_NT_SERVER" /> || <see cref="VER_NT_DOMAIN_CONTROLLER" />) &amp;&amp; <see cref="VER_SUITE_ENTERPRISE" /> &amp;&amp; !<see cref="VER_SUITE_DATACENTER" />.</description>
        </item>
        <item>
          <description>OS_SERVER</description>
          <description>23</description>
          <description>The program is running on Windows Server (Standard) or Windows Server Standard Edition, any version. This value will not return <b>true</b> for <see cref="VER_SUITE_DATACENTER" />, <see cref="VER_SUITE_ENTERPRISE" />, <see cref="VER_SUITE_SMALLBUSINESS" />, or <see cref="VER_SUITE_SMALLBUSINESS_RESTRICTED" />.</description>
        </item>
        <item>
          <description>OS_TERMINALSERVER</description>
          <description>24</description>
          <description>The program is running on Windows 2000 Terminal Server in Application Server mode, or on Windows Server 2003  (or one of its successors) in Terminal Server mode. This is equivalent to <see cref="VER_SUITE_TERMINAL" /> &amp;&amp; <see cref="VER_SUITE_SINGLEUSERTS" />.</description>
        </item>
        <item>
          <description>OS_PERSONALTERMINALSERVER</description>
          <description>25</description>
          <description>The program is running on Windows XP (or one of its successors), Home Edition or Professional. This is equivalent to <see cref="VER_SUITE_SINGLEUSERTS" /> &amp;&amp; !<see cref="VER_SUITE_TERMINAL" />.</description>
        </item>
        <item>
          <description>OS_FASTUSERSWITCHING</description>
          <description>26</description>
          <description>Fast user switching is enabled.</description>
        </item>
        <item>
          <description>OS_WELCOMELOGONUI</description>
          <description>27</description>
          <description>Always returns <b>FALSE</b>.</description>
        </item>
        <item>
          <description>OS_DOMAINMEMBER</description>
          <description>28</description>
          <description>The computer is joined to a domain.</description>
        </item>
        <item>
          <description>OS_ANYSERVER</description>
          <description>29</description>
          <description>The program is running on any Windows Server product. Equivalent to <see cref="VER_NT_SERVER" /> || <see cref="VER_NT_DOMAIN_CONTROLLER" />.</description>
        </item>
        <item>
          <description>OS_WOW6432</description>
          <description>30</description>
          <description>The program is a 32-bit program running on 64-bit Windows.</description>
        </item>
        <item>
          <description>OS_WEBSERVER</description>
          <description>31</description>
          <description>Always returns <b>FALSE</b>.</description>
        </item>
        <item>
          <description>OS_SMALLBUSINESSSERVER</description>
          <description>32</description>
          <description>The program is running on Microsoft Small Business Server with restrictive client license in force. Equivalent to <see cref="VER_SUITE_SMALLBUSINESS_RESTRICTED" />.</description>
        </item>
        <item>
          <description>OS_TABLETPC</description>
          <description>33</description>
          <description>The program is running on Windows XP Tablet PC Edition, or one of its successors.</description>
        </item>
        <item>
          <description>OS_SERVERADMINUI</description>
          <description>34</description>
          <description>The user should be presented with administrator UI. It is possible to have server administrative UI on a non-server machine. This value informs the application that an administrator's profile has roamed to a non-server, and UI should be appropriate to an administrator. Otherwise, the user is shown a mix of administrator and nonadministrator settings.</description>
        </item>
        <item>
          <description>OS_MEDIACENTER</description>
          <description>35</description>
          <description>The program is running on Windows XP Media Center Edition, or one of its successors. Equivalent to <see cref="GetSystemMetrics" />(SM_MEDIACENTER).</description>
        </item>
        <item>
          <description>OS_APPLIANCE</description>
          <description>36</description>
          <description>The program is running on Windows Appliance Server.</description>
        </item>
      </list>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns a nonzero value if the specified operating system or operating system feature is detected, otherwise <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>Values are not provided for Windows Vista and Windows 7. To determine whether either of those operating systems are present, use <see cref="VerifyVersionInfo" />.</para>
      <para>In Windows versions earlier than Windows Vista, <b>IsOS</b> was not exported by name or declared in a public header file. To use it in those cases, you must use <see cref="GetProcAddress" /> and request ordinal 437 from Shlwapi.dll to obtain a function pointer. Under Windows Vista, <b>IsOS</b> is included in Shlwapi.h and this is not necessary.</para>
      <para>When referring to server products, "Windows Server" refers only to the Standard Edition server. If all server products are covered by a particular flag, it is called out explicitly in the table.</para>
    </remarks>
    <seealso cref="GetSystemMetrics" />
    <seealso cref="GetVersionEx" />
    <seealso cref="VerifyVersionInfo" />
  </member>
  <member name="Windows.IStream_Copy">
    <summary>
      <para>Copies a stream to another stream.</para>
    </summary>
    <param name="pstmFrom">
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>A pointer to the source stream.</para>
    </param>
    <param name="pstmTo">
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>A pointer to the destination stream.</para>
    </param>
    <param name="cb">
      <para>Type: <b>DWORD</b></para>
      <para>The number of bytes to copy from the source stream.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
  </member>
  <member name="Windows.IStream_Read">
    <summary>
      <para>Reads bytes from a specified stream and returns a value that indicates whether all bytes were successfully read.</para>
    </summary>
    <param name="pstm">
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>A pointer to the <see cref="IStream" /> interface of the stream from which to read.</para>
    </param>
    <param name="pv">
      <para>Type: <b>VOID*</b></para>
      <para>A pointer to a buffer to receive the stream data from <i>pstm</i>. This buffer must be at least <i>cb</i> bytes in size.</para>
    </param>
    <param name="cb">
      <para>Type: <b>ULONG</b></para>
      <para>The number of bytes of data that the function should attempt to read from the input stream.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns <b>S_OK</b> if the function successfully reads the specified number of bytes from the stream, or a COM failure code otherwise. In particular, if the read attempt was successful but fewer than <i>cb</i> bytes were read, the function returns <b>E_FAIL</b>.</para>
    </returns>
    <remarks>
      <para>This function calls the <see cref="ISequentialStream.Read" /> method to read data from the specified stream into the buffer. If the function fails for any reason, the contents of the output buffer and the position of the read pointer in the input stream are undefined.</para>
    </remarks>
    <seealso cref="ISequentialStream.Read" />
  </member>
  <member name="Windows.IStream_ReadPidl">
    <summary>
      <para>Reads a pointer to an item identifier list (PIDL) from an <see cref="IStream" /> object into a PIDLIST_RELATIVE object.</para>
    </summary>
    <param name="pstm">
      <para>Type: <b>IStream*</b></para>
      <para>A pointer to the <see cref="IStream" /> from which the PIDL is read.</para>
    </param>
    <param name="ppidlOut">
      <para>Type: <b>PIDLIST_RELATIVE*</b></para>
      <para>A pointer to the resulting PIDL.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
  </member>
  <member name="Windows.IStream_ReadStr">
    <summary>
      <para>Reads from a stream and writes into a string.</para>
    </summary>
    <param name="pstm">
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>A pointer to the stream from which to read.</para>
    </param>
    <param name="ppsz">
      <para>Type: <b>PWSTR*</b></para>
      <para>A pointer to the null-terminated, Unicode string into which the stream is written.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
  </member>
  <member name="Windows.IStream_Reset">
    <summary>
      <para>Moves the seek position in a specified stream to the beginning of the stream.</para>
    </summary>
    <param name="pstm">
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>A pointer to the <see cref="IStream" /> interface of the stream whose position is to be reset.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns <b>S_OK</b> on success or a COM failure code otherwise. See <see cref="IStream.Seek" /> for further discussion of possible error codes.</para>
    </returns>
    <remarks>
      <para>This function calls <see cref="IStream.Seek" /> to move the stream's seek position to the beginning of the stream.</para>
    </remarks>
  </member>
  <member name="Windows.IStream_Size">
    <summary>
      <para>Retrieves the size, in bytes, of a specified stream.</para>
    </summary>
    <param name="pstm">
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>A pointer to the <see cref="IStream" /> interface of the stream whose size is to be determined.</para>
    </param>
    <param name="pui">
      <para>Type: <b><see cref="ULARGE_INTEGER" />*</b></para>
      <para>A pointer to a <see cref="ULARGE_INTEGER" /> structure to receive the size of the stream.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns <b>S_OK</b> on success or a COM failure code otherwise. See <see cref="IStream.Stat" /> for further discussion of possible error codes.</para>
    </returns>
    <remarks>
      <para>This function gets the size of the stream by calling the specified stream object's <see cref="IStream.Stat" /> method. It then copies the value of the <b>cbSize</b> member of the <see cref="STATSTG" /> structure returned by <b>IStream.Stat</b> to the <see cref="ULARGE_INTEGER" /> structure pointed to by <i>pui</i>.  If the function fails, the contents of the <b>ULARGE_INTEGER</b> structure are undefined.</para>
    </remarks>
  </member>
  <member name="Windows.IStream_Write">
    <summary>
      <para>Writes data of unknown format from a buffer to a specified stream.</para>
    </summary>
    <param name="pstm">
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>An <see cref="IStream" /> pointer that specifies the target stream.</para>
    </param>
    <param name="pv">
      <para>Type: <b>const void*</b></para>
      <para>Pointer to a buffer that holds the data to send to the target stream. This buffer must be at least <i>cb</i> bytes in size.</para>
    </param>
    <param name="cb">
      <para>Type: <b>ULONG</b></para>
      <para>The number of bytes of data to write to the target stream.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if the function successfully wrote the specified number of bytes to the stream, or an error value otherwise. In particular, if less than <i>cb</i> bytes was written to the target stream, even if some data was successfully written, the function returns E_FAIL.</para>
    </returns>
  </member>
  <member name="Windows.IStream_WritePidl">
    <summary>
      <para>Writes a pointer to an item identifier list (PIDL) from a PCUIDLIST_RELATIVE object into an <see cref="IStream" /> object.</para>
    </summary>
    <param name="pstm">
      <para>Type: <b>IStream*</b></para>
      <para>A pointer to the <see cref="IStream" /> object in which to write.</para>
    </param>
    <param name="pidlWrite">
      <para>Type: <b>PCUIDLIST_RELATIVE</b></para>
      <para>The source PIDL.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
  </member>
  <member name="Windows.IStream_WriteStr">
    <summary>
      <para>Reads from a string and writes into a stream.</para>
    </summary>
    <param name="pstm">
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>A pointer to the stream in which to write.</para>
    </param>
    <param name="psz">
      <para>Type: <b>PCWSTR</b></para>
      <para>A pointer to a null-terminated, Unicode string from which to read.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
  </member>
  <member name="Windows.IUnknown_AtomicRelease">
    <summary>
      <para>Releases a Component Object Model (COM) pointer and sets it to <b>NULL</b>.</para>
    </summary>
    <param name="ppunk">
      <para>Type: <b>void**</b></para>
      <para>The address of a pointer to a COM interface.</para>
    </param>
    <remarks>
      <para>If <i>ppunk</i> points to a <b>NULL</b> pointer, no operation is performed. Otherwise, <i>ppunk</i> is assumed to be the address of a COM interface pointer, derived from <see cref="IUnknown" />. The function calls the interface's <see cref="IUnknown.Release" /> method then sets the interface pointer to <b>NULL</b>.</para>
      <h4>Examples</h4>
      <para>The following example uses <b>IUnknown_AtomicRelease</b> to release the stream, if it exists. If not, it does nothing.</para>
      <code>void sample()
{
    IStream *pstm = NULL;
    CreateStreamOnHGlobal(NULL, TRUE, &amp;amp;amp;amp;amp;amp;pstm);

    IUnknown_AtomicRelease((void**)&amp;amp;amp;amp;amp;amp;pstm);

    // At this point, pstm is NULL
}
</code>
    </remarks>
  </member>
  <member name="Windows.IUnknown_GetSite">
    <summary>
      <para>Calls the specified object's <see cref="IObjectWithSite.GetSite" /> method.</para>
    </summary>
    <param name="punk">
      <para>Type: <b><see cref="IUnknown" />*</b></para>
      <para>A pointer to the COM object whose <see cref="IObjectWithSite.GetSite" /> method is to be called.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>The IID of the interface pointer that should be returned in <i>ppvSite</i>.</para>
    </param>
    <param name="ppv">
      <para>Type: <b>VOID**</b></para>
      <para>The address of the pointer to receive the requested interface pointer. If the function call is successful, <i>ppvSite</i> will contain the requested interface pointer. If no site is available or the requested interface is not supported, <i>ppvSite</i> is set to <b>NULL</b> and the function returns a COM error code.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns <b>S_OK</b> if the site was successfully retrieved or a COM error code otherwise.</para>
    </returns>
    <remarks>
      <para>This function calls the specified object's <see cref="QueryInterface" /> method to obtain the <see cref="IObjectWithSite" /> interface.  If successful, the function calls the interface's <see cref="IObjectWithSite.GetSite" /> method to obtain the site.</para>
    </remarks>
  </member>
  <member name="Windows.IUnknown_GetWindow">
    <summary>
      <para>Attempts to retrieve a window handle from a Component Object Model (COM) object by querying for various interfaces that have a <b>GetWindow</b> method.</para>
    </summary>
    <param name="punk">
      <para>Type: <b><see cref="IUnknown" />*</b></para>
      <para>A pointer to the COM object from which this function will attempt to obtain a window handle.</para>
    </param>
    <param name="phwnd">
      <para>Type: <b>HWND*</b></para>
      <para>A pointer to a HWND that, when this function returns successfully, receives the window handle. If a window handle was not obtained, this parameter is set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if a window handle was successfully returned, or a COM error code otherwise. If no suitable interface was found, the function returns E_NOINTERFACE. Otherwise, the function returns the <b>HRESULT</b> returned by the corresponding interface's <b>GetWindow</b> method.</para>
    </returns>
    <remarks>
      <para>This function attempts to retrieve the window handle by calling <see cref="IOleWindow.GetWindow" />, <a href="https://docs.microsoft.com//previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms537095(v=vs.85)">IInternetSecurityMgrSite.GetWindow</a>, and <see cref="IShellView.GetWindow" />. It is possible that future versions of <b>IUnknown_GetWindow</b> may attempt additional interfaces.</para>
      <para>
        <b>Note</b>  The query for <see cref="IShellView" /> is theoretically unnecessary because <b>IShellView</b> derives from <see cref="IOleWindow" />. The function explicitly queries for this interface because some objects implement <see cref="QueryInterface" /> incorrectly and fail to respond to a query for the base interface.</para>
    </remarks>
  </member>
  <member name="Windows.IUnknown_QueryService">
    <summary>
      <para>Retrieves an interface for a service from a specified object.</para>
    </summary>
    <param name="punk">
      <para>Type: <b><see cref="IUnknown" />*</b></para>
      <para>A pointer to the <see cref="IUnknown" /> instance of the COM object that supports the service.</para>
    </param>
    <param name="guidService">
      <para>Type: <b>REFGUID</b></para>
      <para>The service's unique identifier (SID).</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>The IID of the desired service interface.</para>
    </param>
    <param name="ppvOut">
      <para>Type: <b>void**</b></para>
      <para>When this method returns, contains the interface pointer requested <i>riid</i>. If successful, the calling application is responsible for calling <see cref="IUnknown.Release" /> using this value when the service is no longer needed. In the case of failure, this value is <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns <b>S_OK</b> if successful. Returns <b>E_FAIL</b> if the object does not support <a href="https://docs.microsoft.com//previous-versions/windows/internet-explorer/ie-developer/platform-apis/cc678965(v=vs.85)">IServiceProvider</a>. Otherwise, the function returns the <b>HRESULT</b> returned by the object's <a href="https://docs.microsoft.com//previous-versions/windows/internet-explorer/ie-developer/platform-apis/cc678966(v=vs.85)">QueryService</a> method.</para>
    </returns>
    <remarks>
      <para>If the object passed in the <i>punk</i> parameter supports the <a href="https://docs.microsoft.com//previous-versions/windows/internet-explorer/ie-developer/platform-apis/cc678965(v=vs.85)">IServiceProvider</a> interface, then its <a href="https://docs.microsoft.com//previous-versions/windows/internet-explorer/ie-developer/platform-apis/cc678966(v=vs.85)">QueryService</a> method is invoked, passing the <i>guidService</i>, <i>riid</i>, and <i>ppvOut</i> parameters and propagating the return value. Otherwise, the function returns E_FAIL.</para>
      <para>For those versions of Windows that do not include <b>IUnknown_QueryService</b> in Shlwapi.h, this function must be called directly from Shlwapi.dll using ordinal 176.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/internet-explorer/ie-developer/platform-apis/cc678965(v=vs.85)">IServiceProvider</seealso>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/internet-explorer/ie-developer/platform-apis/cc678966(v=vs.85)">QueryService</seealso>
  </member>
  <member name="Windows.IUnknown_Set">
    <summary>
      <para>Changes the value of a Component Object Model (COM) interface pointer and releases the previous interface.</para>
    </summary>
    <param name="ppunk">
      <para>Type: <b><see cref="IUnknown" />**</b></para>
      <para>The address of a COM interface pointer to receive the pointer assigned to <i>punk</i>. If the previous value of the pointer is non-<b>NULL</b>, the function releases that interface by calling its IUnkown.Release method.</para>
    </param>
    <param name="punk">
      <para>Type: <b><see cref="IUnknown" />*</b></para>
      <para>The interface pointer to be copied to <i>ppunk</i>. If the value is non-<b>NULL</b>, the function increments the interface's reference count.</para>
    </param>
    <remarks>
      <para>This function mimics the behavior of a smart pointer. Conceptually, the function does the following:</para>
      <list type="bullet">
        <item>
          <description>Releases the original interface, if <i>ppunk</i> is non-<b>NULL</b></description>
        </item>
        <item>
          <description>Assigns <i>punk</i> to <i>ppunk</i></description>
        </item>
        <item>
          <description>Calls IUnknown.AddRef on the interface pointed to by <i>punk</i>, if <i>punk</i> is non-<b>NULL</b>.</description>
        </item>
      </list>
      <h4>Examples</h4>
      <code>
void sample()
{
  IUnknown *punk = NULL;
  IStream* pstm = NULL;

  if (SUCCEEDED(CreateStreamOnHGlobal(NULL, TRUE, &amp;amp;amp;amp;amp;amp;pstm)) {
    // since punk == NULL, this merely copies the value and AddRef()s it
    IUnknown_Set(&amp;amp;amp;amp;amp;amp;punk, pstm);
    pstm-&gt;Release();

    if (SUCCEEDED(CreateStreamOnHGlobal(NULL, TRUE, &amp;amp;amp;amp;amp;amp;pstm)) {
      // this call will release the old value of punk before copying the
      // new value and AddRef()ing it
      IUnknown_Set(&amp;amp;amp;amp;amp;amp;punk, pstm);
      pstm-&gt;Release();
    }
  }

  // This call will release whatever punk points to, if anything.
  IUnknown_AtomcRelease((void**)&amp;amp;amp;amp;amp;amp;punk);

  // at this point, punk == NULL
}
</code>
    </remarks>
  </member>
  <member name="Windows.IUnknown_SetSite">
    <summary>
      <para>Sets the specified object's site by calling its <see cref="IObjectWithSite.SetSite" /> method.</para>
    </summary>
    <param name="punk">
      <para>Type: <b><see cref="IUnknown" />*</b></para>
      <para>A pointer to the IUnknown interface of the object whose site is to be changed.</para>
    </param>
    <param name="punkSite">
      <para>Type: <b><see cref="IUnknown" />*</b></para>
      <para>A pointer to the IUnknown interface of the new site.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if the site was successfully set, or a COM error code otherwise.</para>
    </returns>
    <remarks>
      <para>This function calls the specified object's IUnknown.QueryInterface method to obtain a pointer to the object's <see cref="IObjectWithSite" /> interface.  If successful, the function calls <see cref="IObjectWithSite.SetSite" /> to set or change the site.</para>
    </remarks>
  </member>
  <member name="Windows.MAKEDLLVERULL">
    <summary>
      <para>Used to pack DLL version information into a ULONGLONG value.</para>
    </summary>
    <param name="major">
      <para>The major version number.</para>
    </param>
    <param name="minor">
      <para>The minor version number.</para>
    </param>
    <param name="build">
      <para>The build number.</para>
    </param>
    <param name="qfe">
      <para>The hotfix number that identifies the service pack.</para>
    </param>
    <remarks>
      <para>This macro is used in conjunction with <a href="https://docs.microsoft.com//windows/desktop/api/shlwapi/nc-shlwapi-dllgetversionproc">DllGetVersion</a> to pack version information into a form that can easily be compared to the <b>ullVersion</b> member of a <see cref="DLLVERSIONINFO2" /> structure. It is defined as follows.</para>
      <code>#define MAKEDLLVERULL(major, minor, build, sp) \
        (((ULONGLONG)(major) &lt;&lt; 48) | \
         ((ULONGLONG)(minor) &lt;&lt; 32) | \
         ((ULONGLONG)(build) &lt;&lt; 16) | \
         ((ULONGLONG)(   sp) &lt;&lt;  0))

</code>
      <para>For most purposes, you only need to assign values to the major and minor version numbers. The remaining two parameters can be set to zero. The following code fragment illustrates how to use <b>MAKEDLLVERULL</b> to determine whether a DLL is <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">version 4.71</a> or later. The <b>VersionInfo</b> structure is the <see cref="DLLVERSIONINFO2" /> structure returned by <a href="https://docs.microsoft.com//windows/desktop/api/shlwapi/nc-shlwapi-dllgetversionproc">DllGetVersion</a>.</para>
      <code>if(VersionInfo.ullVersion &gt;= MAKEDLLVERULL(4, 71, 0, 0))
{
    ...
}

</code>
    </remarks>
  </member>
  <member name="Windows.ParseURL">
    <summary>
      <para>Performs rudimentary parsing of a URL.</para>
    </summary>
    <param name="pcszURL">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the URL to be parsed.</para>
    </param>
    <param name="ppu">
      <para>Type: <b><see cref="PARSEDURL" />*</b></para>
      <para>A pointer to a <see cref="PARSEDURL" /> structure that receives the parsed results. The calling application must set the structure's <i>cbSize</i> member to the size of the structure before calling <b>ParseURL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns <b>S_OK</b> on success, or a COM error code otherwise. The function returns <b>URL_E_INVALID_SYNTAX</b> (defined in Intshcut.h) if the string could not be parsed as a URL.</para>
    </returns>
    <remarks>
      <para>The parsing performed by <b>ParseURL</b> is fairly rudimentary. For more sophisticated URL parsing, use <see cref="InternetCrackUrl" />.</para>
      <h4>Examples</h4>
      <para>This sample console application uses <b>ParseURL</b> to parse several simple URLs.</para>
      <code>
#include &lt;windows.h&gt;
#include &lt;shlwapi.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

void sample(LPCTSTR pcszUrl)
{
    PARSEDURL pu;
    pu.cbSize = sizeof(pu);
    HRESULT hr = ParseURL(pcszUrl, &amp;amp;amp;amp;amp;amp;pu);
    _tprintf(TEXT("ParseURL(%s) returned 0x%08x\n"), pcszUrl, hr);
    if (SUCCEEDED(hr)) {
        _tprintf(TEXT("Protocol = %.*s\n"), pu.cchProtocol, pu.pszProtocol);
        _tprintf(TEXT("Suffix   = %.*s\n"), pu.cchSuffix, pu.pszSuffix);
        _tprintf(TEXT("Scheme   = %d\n"), pu.nScheme);
        _tprintf(TEXT("\n"));
    }
}

int __cdecl main()
{
    sample(TEXT("http://msdn.microsoft.com/vstudio/"));
    sample(TEXT("mailto:someone@example.com"));
    sample(TEXT("file://C:\\AUTOEXEC.BAT"));
    sample(TEXT("C:\\AUTOEXEC.BAT"));
    return 0;
}

OUTPUT:
---------

ParseURL(http://msdn.microsoft.com/vstudio/) returned 0x00000000
Protocol = http
Suffix   = //msdn.microsoft.com/vstudio/
Scheme   = 2

ParseURL(mailto:someone@example.com) returned 0x00000000
Protocol = mailto
Suffix   = someone@example.com
Scheme   = 4

ParseURL(file://C:\AUTOEXEC.BAT) returned 0x00000000
Protocol = file
Suffix   = C:\AUTOEXEC.BAT
Scheme   = 9

ParseURL(C:\AUTOEXEC.BAT) returned 0x80041001

</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines ParseURL as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ParseURLA">
    <summary>
      <para>Performs rudimentary parsing of a URL.</para>
    </summary>
    <param name="pcszURL">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the URL to be parsed.</para>
    </param>
    <param name="ppu">
      <para>Type: <b><see cref="PARSEDURL" />*</b></para>
      <para>A pointer to a <see cref="PARSEDURL" /> structure that receives the parsed results. The calling application must set the structure's <i>cbSize</i> member to the size of the structure before calling <b>ParseURL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns <b>S_OK</b> on success, or a COM error code otherwise. The function returns <b>URL_E_INVALID_SYNTAX</b> (defined in Intshcut.h) if the string could not be parsed as a URL.</para>
    </returns>
    <remarks>
      <para>The parsing performed by <b>ParseURL</b> is fairly rudimentary. For more sophisticated URL parsing, use <see cref="InternetCrackUrl" />.</para>
      <h4>Examples</h4>
      <para>This sample console application uses <b>ParseURL</b> to parse several simple URLs.</para>
      <code>
#include &lt;windows.h&gt;
#include &lt;shlwapi.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

void sample(LPCTSTR pcszUrl)
{
    PARSEDURL pu;
    pu.cbSize = sizeof(pu);
    HRESULT hr = ParseURL(pcszUrl, &amp;amp;amp;amp;amp;amp;pu);
    _tprintf(TEXT("ParseURL(%s) returned 0x%08x\n"), pcszUrl, hr);
    if (SUCCEEDED(hr)) {
        _tprintf(TEXT("Protocol = %.*s\n"), pu.cchProtocol, pu.pszProtocol);
        _tprintf(TEXT("Suffix   = %.*s\n"), pu.cchSuffix, pu.pszSuffix);
        _tprintf(TEXT("Scheme   = %d\n"), pu.nScheme);
        _tprintf(TEXT("\n"));
    }
}

int __cdecl main()
{
    sample(TEXT("http://msdn.microsoft.com/vstudio/"));
    sample(TEXT("mailto:someone@example.com"));
    sample(TEXT("file://C:\\AUTOEXEC.BAT"));
    sample(TEXT("C:\\AUTOEXEC.BAT"));
    return 0;
}

OUTPUT:
---------

ParseURL(http://msdn.microsoft.com/vstudio/) returned 0x00000000
Protocol = http
Suffix   = //msdn.microsoft.com/vstudio/
Scheme   = 2

ParseURL(mailto:someone@example.com) returned 0x00000000
Protocol = mailto
Suffix   = someone@example.com
Scheme   = 4

ParseURL(file://C:\AUTOEXEC.BAT) returned 0x00000000
Protocol = file
Suffix   = C:\AUTOEXEC.BAT
Scheme   = 9

ParseURL(C:\AUTOEXEC.BAT) returned 0x80041001

</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines ParseURL as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ParseURLW">
    <summary>
      <para>Performs rudimentary parsing of a URL.</para>
    </summary>
    <param name="pcszURL">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the URL to be parsed.</para>
    </param>
    <param name="ppu">
      <para>Type: <b><see cref="PARSEDURL" />*</b></para>
      <para>A pointer to a <see cref="PARSEDURL" /> structure that receives the parsed results. The calling application must set the structure's <i>cbSize</i> member to the size of the structure before calling <b>ParseURL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns <b>S_OK</b> on success, or a COM error code otherwise. The function returns <b>URL_E_INVALID_SYNTAX</b> (defined in Intshcut.h) if the string could not be parsed as a URL.</para>
    </returns>
    <remarks>
      <para>The parsing performed by <b>ParseURL</b> is fairly rudimentary. For more sophisticated URL parsing, use <see cref="InternetCrackUrl" />.</para>
      <h4>Examples</h4>
      <para>This sample console application uses <b>ParseURL</b> to parse several simple URLs.</para>
      <code>
#include &lt;windows.h&gt;
#include &lt;shlwapi.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

void sample(LPCTSTR pcszUrl)
{
    PARSEDURL pu;
    pu.cbSize = sizeof(pu);
    HRESULT hr = ParseURL(pcszUrl, &amp;amp;amp;amp;amp;amp;pu);
    _tprintf(TEXT("ParseURL(%s) returned 0x%08x\n"), pcszUrl, hr);
    if (SUCCEEDED(hr)) {
        _tprintf(TEXT("Protocol = %.*s\n"), pu.cchProtocol, pu.pszProtocol);
        _tprintf(TEXT("Suffix   = %.*s\n"), pu.cchSuffix, pu.pszSuffix);
        _tprintf(TEXT("Scheme   = %d\n"), pu.nScheme);
        _tprintf(TEXT("\n"));
    }
}

int __cdecl main()
{
    sample(TEXT("http://msdn.microsoft.com/vstudio/"));
    sample(TEXT("mailto:someone@example.com"));
    sample(TEXT("file://C:\\AUTOEXEC.BAT"));
    sample(TEXT("C:\\AUTOEXEC.BAT"));
    return 0;
}

OUTPUT:
---------

ParseURL(http://msdn.microsoft.com/vstudio/) returned 0x00000000
Protocol = http
Suffix   = //msdn.microsoft.com/vstudio/
Scheme   = 2

ParseURL(mailto:someone@example.com) returned 0x00000000
Protocol = mailto
Suffix   = someone@example.com
Scheme   = 4

ParseURL(file://C:\AUTOEXEC.BAT) returned 0x00000000
Protocol = file
Suffix   = C:\AUTOEXEC.BAT
Scheme   = 9

ParseURL(C:\AUTOEXEC.BAT) returned 0x80041001

</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines ParseURL as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ParseURL">
    <summary>
      <para>Performs rudimentary parsing of a URL.</para>
    </summary>
    <param name="pcszURL">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the URL to be parsed.</para>
    </param>
    <param name="ppu">
      <para>Type: <b><see cref="PARSEDURL" />*</b></para>
      <para>A pointer to a <see cref="PARSEDURL" /> structure that receives the parsed results. The calling application must set the structure's <i>cbSize</i> member to the size of the structure before calling <b>ParseURL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns <b>S_OK</b> on success, or a COM error code otherwise. The function returns <b>URL_E_INVALID_SYNTAX</b> (defined in Intshcut.h) if the string could not be parsed as a URL.</para>
    </returns>
    <remarks>
      <para>The parsing performed by <b>ParseURL</b> is fairly rudimentary. For more sophisticated URL parsing, use <see cref="InternetCrackUrl" />.</para>
      <h4>Examples</h4>
      <para>This sample console application uses <b>ParseURL</b> to parse several simple URLs.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;shlwapi.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

void sample(LPCTSTR pcszUrl)
{
    PARSEDURL pu;
    pu.cbSize = sizeof(pu);
    HRESULT hr = ParseURL(pcszUrl, &amp;amp;amp;amp;amp;amp;pu);
    _tprintf(TEXT("ParseURL(%s) returned 0x%08x\n"), pcszUrl, hr);
    if (SUCCEEDED(hr)) {
        _tprintf(TEXT("Protocol = %.*s\n"), pu.cchProtocol, pu.pszProtocol);
        _tprintf(TEXT("Suffix   = %.*s\n"), pu.cchSuffix, pu.pszSuffix);
        _tprintf(TEXT("Scheme   = %d\n"), pu.nScheme);
        _tprintf(TEXT("\n"));
    }
}

int __cdecl main()
{
    sample(TEXT("http://msdn.microsoft.com/vstudio/"));
    sample(TEXT("mailto:someone@example.com"));
    sample(TEXT("file://C:\\AUTOEXEC.BAT"));
    sample(TEXT("C:\\AUTOEXEC.BAT"));
    return 0;
}
</code>
      <para>Output:</para>
      <code>ParseURL(http://msdn.microsoft.com/vstudio/) returned 0x00000000
Protocol = http
Suffix   = //msdn.microsoft.com/vstudio/
Scheme   = 2

ParseURL(mailto:someone@example.com) returned 0x00000000
Protocol = mailto
Suffix   = someone@example.com
Scheme   = 4

ParseURL(file://C:\AUTOEXEC.BAT) returned 0x00000000
Protocol = file
Suffix   = C:\AUTOEXEC.BAT
Scheme   = 9

ParseURL(C:\AUTOEXEC.BAT) returned 0x80041001
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines ParseURL as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ParseURLA">
    <summary>
      <para>Performs rudimentary parsing of a URL.</para>
    </summary>
    <param name="pcszURL">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the URL to be parsed.</para>
    </param>
    <param name="ppu">
      <para>Type: <b><see cref="PARSEDURL" />*</b></para>
      <para>A pointer to a <see cref="PARSEDURL" /> structure that receives the parsed results. The calling application must set the structure's <i>cbSize</i> member to the size of the structure before calling <b>ParseURL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns <b>S_OK</b> on success, or a COM error code otherwise. The function returns <b>URL_E_INVALID_SYNTAX</b> (defined in Intshcut.h) if the string could not be parsed as a URL.</para>
    </returns>
    <remarks>
      <para>The parsing performed by <b>ParseURL</b> is fairly rudimentary. For more sophisticated URL parsing, use <see cref="InternetCrackUrl" />.</para>
      <h4>Examples</h4>
      <para>This sample console application uses <b>ParseURL</b> to parse several simple URLs.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;shlwapi.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

void sample(LPCTSTR pcszUrl)
{
    PARSEDURL pu;
    pu.cbSize = sizeof(pu);
    HRESULT hr = ParseURL(pcszUrl, &amp;amp;amp;amp;amp;amp;pu);
    _tprintf(TEXT("ParseURL(%s) returned 0x%08x\n"), pcszUrl, hr);
    if (SUCCEEDED(hr)) {
        _tprintf(TEXT("Protocol = %.*s\n"), pu.cchProtocol, pu.pszProtocol);
        _tprintf(TEXT("Suffix   = %.*s\n"), pu.cchSuffix, pu.pszSuffix);
        _tprintf(TEXT("Scheme   = %d\n"), pu.nScheme);
        _tprintf(TEXT("\n"));
    }
}

int __cdecl main()
{
    sample(TEXT("http://msdn.microsoft.com/vstudio/"));
    sample(TEXT("mailto:someone@example.com"));
    sample(TEXT("file://C:\\AUTOEXEC.BAT"));
    sample(TEXT("C:\\AUTOEXEC.BAT"));
    return 0;
}
</code>
      <para>Output:</para>
      <code>ParseURL(http://msdn.microsoft.com/vstudio/) returned 0x00000000
Protocol = http
Suffix   = //msdn.microsoft.com/vstudio/
Scheme   = 2

ParseURL(mailto:someone@example.com) returned 0x00000000
Protocol = mailto
Suffix   = someone@example.com
Scheme   = 4

ParseURL(file://C:\AUTOEXEC.BAT) returned 0x00000000
Protocol = file
Suffix   = C:\AUTOEXEC.BAT
Scheme   = 9

ParseURL(C:\AUTOEXEC.BAT) returned 0x80041001
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines ParseURL as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.ParseURLW">
    <summary>
      <para>Performs rudimentary parsing of a URL.</para>
    </summary>
    <param name="pcszURL">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the URL to be parsed.</para>
    </param>
    <param name="ppu">
      <para>Type: <b><see cref="PARSEDURL" />*</b></para>
      <para>A pointer to a <see cref="PARSEDURL" /> structure that receives the parsed results. The calling application must set the structure's <i>cbSize</i> member to the size of the structure before calling <b>ParseURL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns <b>S_OK</b> on success, or a COM error code otherwise. The function returns <b>URL_E_INVALID_SYNTAX</b> (defined in Intshcut.h) if the string could not be parsed as a URL.</para>
    </returns>
    <remarks>
      <para>The parsing performed by <b>ParseURL</b> is fairly rudimentary. For more sophisticated URL parsing, use <see cref="InternetCrackUrl" />.</para>
      <h4>Examples</h4>
      <para>This sample console application uses <b>ParseURL</b> to parse several simple URLs.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;shlwapi.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

void sample(LPCTSTR pcszUrl)
{
    PARSEDURL pu;
    pu.cbSize = sizeof(pu);
    HRESULT hr = ParseURL(pcszUrl, &amp;amp;amp;amp;amp;amp;pu);
    _tprintf(TEXT("ParseURL(%s) returned 0x%08x\n"), pcszUrl, hr);
    if (SUCCEEDED(hr)) {
        _tprintf(TEXT("Protocol = %.*s\n"), pu.cchProtocol, pu.pszProtocol);
        _tprintf(TEXT("Suffix   = %.*s\n"), pu.cchSuffix, pu.pszSuffix);
        _tprintf(TEXT("Scheme   = %d\n"), pu.nScheme);
        _tprintf(TEXT("\n"));
    }
}

int __cdecl main()
{
    sample(TEXT("http://msdn.microsoft.com/vstudio/"));
    sample(TEXT("mailto:someone@example.com"));
    sample(TEXT("file://C:\\AUTOEXEC.BAT"));
    sample(TEXT("C:\\AUTOEXEC.BAT"));
    return 0;
}
</code>
      <para>Output:</para>
      <code>ParseURL(http://msdn.microsoft.com/vstudio/) returned 0x00000000
Protocol = http
Suffix   = //msdn.microsoft.com/vstudio/
Scheme   = 2

ParseURL(mailto:someone@example.com) returned 0x00000000
Protocol = mailto
Suffix   = someone@example.com
Scheme   = 4

ParseURL(file://C:\AUTOEXEC.BAT) returned 0x00000000
Protocol = file
Suffix   = C:\AUTOEXEC.BAT
Scheme   = 9

ParseURL(C:\AUTOEXEC.BAT) returned 0x80041001
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines ParseURL as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathAddBackslash">
    <summary>
      <para>Adds a backslash to the end of a string to create the correct syntax for a path. If the source path already has a trailing backslash, no backslash will be added.</para>
      <para>
        <b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchAddBackslash" /> or <see cref="PathCchAddBackslashEx" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer with a string that represents a path. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer that, when this function returns successfully, points to the new string's terminating null character. If the backslash could not be appended due to inadequate buffer size, this value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathAddBackslash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathAddBackslashA">
    <summary>
      <para>Adds a backslash to the end of a string to create the correct syntax for a path. If the source path already has a trailing backslash, no backslash will be added.</para>
      <para>
        <b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchAddBackslash" /> or <see cref="PathCchAddBackslashEx" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer with a string that represents a path. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer that, when this function returns successfully, points to the new string's terminating null character. If the backslash could not be appended due to inadequate buffer size, this value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathAddBackslash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathAddBackslashW">
    <summary>
      <para>Adds a backslash to the end of a string to create the correct syntax for a path. If the source path already has a trailing backslash, no backslash will be added.</para>
      <para>
        <b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchAddBackslash" /> or <see cref="PathCchAddBackslashEx" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer with a string that represents a path. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer that, when this function returns successfully, points to the new string's terminating null character. If the backslash could not be appended due to inadequate buffer size, this value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathAddBackslash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathAddBackslash">
    <summary>
      <para>Adds a backslash to the end of a string to create the correct syntax for a path. If the source path already has a trailing backslash, no backslash will be added.</para>
      <para>
        <b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchAddBackslash" /> or <see cref="PathCchAddBackslashEx" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer with a string that represents a path. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer that, when this function returns successfully, points to the new string's terminating null character. If the backslash could not be appended due to inadequate buffer size, this value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathAddBackslash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathAddBackslashA">
    <summary>
      <para>Adds a backslash to the end of a string to create the correct syntax for a path. If the source path already has a trailing backslash, no backslash will be added.</para>
      <para>
        <b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchAddBackslash" /> or <see cref="PathCchAddBackslashEx" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer with a string that represents a path. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer that, when this function returns successfully, points to the new string's terminating null character. If the backslash could not be appended due to inadequate buffer size, this value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathAddBackslash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathAddBackslashW">
    <summary>
      <para>Adds a backslash to the end of a string to create the correct syntax for a path. If the source path already has a trailing backslash, no backslash will be added.</para>
      <para>
        <b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchAddBackslash" /> or <see cref="PathCchAddBackslashEx" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer with a string that represents a path. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer that, when this function returns successfully, points to the new string's terminating null character. If the backslash could not be appended due to inadequate buffer size, this value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathAddBackslash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathAddExtension">
    <summary>
      <para>Adds a file name extension to a path string.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchAddExtension" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer with the null-terminated string to which the file name extension will be appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszExt">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the file name extension. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if an extension was added, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>If there is already a file name extension present, no extension will be added. If the <i>pszPath</i> points to a <b>NULL</b> string, the result will be the file name extension only. If <i>pszExtension</i> points to a <b>NULL</b> string, an ".exe" extension will be added.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
     // String for path name without file name extension.
     char buffer_1[MAX_PATH] = "file";
     char *lpStr1;
     lpStr1 = buffer_1;

     // String for path name with file name extension.
     char buffer_2[ ] = "file.doc";
     char *lpStr2;
     lpStr2 = buffer_2;

     // String for extension name.
     char F_Ext[MAX_PATH] = ".txt";
     char *lpStr3;
     lpStr3 = F_Ext;

     // Null string as path.
     char N_String[MAX_PATH] = "\0";
     char *lpStr4;
     lpStr4 = N_String;

     // Path 1 without the file name extension.
     cout &lt;&lt; "The original path string 1 is  " &lt;&lt; lpStr1 &lt;&lt; endl;

     int ret_1 = PathAddExtension(lpStr1,lpStr3);
     cout &lt;&lt; "The modified path string 1 is  " &lt;&lt; lpStr1 &lt;&lt; endl;

    // Path 2 with the file name extension already there.
    cout &lt;&lt; "The original path string 2 is  " &lt;&lt; lpStr2 &lt;&lt; endl;
    int ret_2 = PathAddExtension(lpStr2,lpStr3);
    cout &lt;&lt; "The modified path string 2 is  " &lt;&lt; lpStr2&lt;&lt; endl;

    // Path 3 null string as a path.
    int ret_3 = PathAddExtension(lpStr4,lpStr3);
    cout &lt;&lt; "The return value is " &lt;&lt; ret_3&lt;&lt; endl;
    cout &lt;&lt; "The modified path on a null string is " &lt;&lt; lpStr4&lt;&lt; endl;

}

OUTPUT:
-----------------------
The original path string 1 is  file
The modified path string 1 is  file.txt
The original path string 2 is  file.doc
The modified path string 2 is  file.doc
The return value is 1
The modified path on a null string is .txt
The return value is 1
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathAddExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathAddExtensionA">
    <summary>
      <para>Adds a file name extension to a path string.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchAddExtension" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer with the null-terminated string to which the file name extension will be appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszExt">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the file name extension. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if an extension was added, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>If there is already a file name extension present, no extension will be added. If the <i>pszPath</i> points to a <b>NULL</b> string, the result will be the file name extension only. If <i>pszExtension</i> points to a <b>NULL</b> string, an ".exe" extension will be added.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
     // String for path name without file name extension.
     char buffer_1[MAX_PATH] = "file";
     char *lpStr1;
     lpStr1 = buffer_1;

     // String for path name with file name extension.
     char buffer_2[ ] = "file.doc";
     char *lpStr2;
     lpStr2 = buffer_2;

     // String for extension name.
     char F_Ext[MAX_PATH] = ".txt";
     char *lpStr3;
     lpStr3 = F_Ext;

     // Null string as path.
     char N_String[MAX_PATH] = "\0";
     char *lpStr4;
     lpStr4 = N_String;

     // Path 1 without the file name extension.
     cout &lt;&lt; "The original path string 1 is  " &lt;&lt; lpStr1 &lt;&lt; endl;

     int ret_1 = PathAddExtension(lpStr1,lpStr3);
     cout &lt;&lt; "The modified path string 1 is  " &lt;&lt; lpStr1 &lt;&lt; endl;

    // Path 2 with the file name extension already there.
    cout &lt;&lt; "The original path string 2 is  " &lt;&lt; lpStr2 &lt;&lt; endl;
    int ret_2 = PathAddExtension(lpStr2,lpStr3);
    cout &lt;&lt; "The modified path string 2 is  " &lt;&lt; lpStr2&lt;&lt; endl;

    // Path 3 null string as a path.
    int ret_3 = PathAddExtension(lpStr4,lpStr3);
    cout &lt;&lt; "The return value is " &lt;&lt; ret_3&lt;&lt; endl;
    cout &lt;&lt; "The modified path on a null string is " &lt;&lt; lpStr4&lt;&lt; endl;

}

OUTPUT:
-----------------------
The original path string 1 is  file
The modified path string 1 is  file.txt
The original path string 2 is  file.doc
The modified path string 2 is  file.doc
The return value is 1
The modified path on a null string is .txt
The return value is 1
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathAddExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathAddExtensionW">
    <summary>
      <para>Adds a file name extension to a path string.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchAddExtension" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer with the null-terminated string to which the file name extension will be appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszExt">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the file name extension. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if an extension was added, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>If there is already a file name extension present, no extension will be added. If the <i>pszPath</i> points to a <b>NULL</b> string, the result will be the file name extension only. If <i>pszExtension</i> points to a <b>NULL</b> string, an ".exe" extension will be added.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
     // String for path name without file name extension.
     char buffer_1[MAX_PATH] = "file";
     char *lpStr1;
     lpStr1 = buffer_1;

     // String for path name with file name extension.
     char buffer_2[ ] = "file.doc";
     char *lpStr2;
     lpStr2 = buffer_2;

     // String for extension name.
     char F_Ext[MAX_PATH] = ".txt";
     char *lpStr3;
     lpStr3 = F_Ext;

     // Null string as path.
     char N_String[MAX_PATH] = "\0";
     char *lpStr4;
     lpStr4 = N_String;

     // Path 1 without the file name extension.
     cout &lt;&lt; "The original path string 1 is  " &lt;&lt; lpStr1 &lt;&lt; endl;

     int ret_1 = PathAddExtension(lpStr1,lpStr3);
     cout &lt;&lt; "The modified path string 1 is  " &lt;&lt; lpStr1 &lt;&lt; endl;

    // Path 2 with the file name extension already there.
    cout &lt;&lt; "The original path string 2 is  " &lt;&lt; lpStr2 &lt;&lt; endl;
    int ret_2 = PathAddExtension(lpStr2,lpStr3);
    cout &lt;&lt; "The modified path string 2 is  " &lt;&lt; lpStr2&lt;&lt; endl;

    // Path 3 null string as a path.
    int ret_3 = PathAddExtension(lpStr4,lpStr3);
    cout &lt;&lt; "The return value is " &lt;&lt; ret_3&lt;&lt; endl;
    cout &lt;&lt; "The modified path on a null string is " &lt;&lt; lpStr4&lt;&lt; endl;

}

OUTPUT:
-----------------------
The original path string 1 is  file
The modified path string 1 is  file.txt
The original path string 2 is  file.doc
The modified path string 2 is  file.doc
The return value is 1
The modified path on a null string is .txt
The return value is 1
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathAddExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathAddExtension">
    <summary>
      <para>Adds a file name extension to a path string.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchAddExtension" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer with the null-terminated string to which the file name extension will be appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszExt">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the file name extension. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if an extension was added, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>If there is already a file name extension present, no extension will be added. If the <i>pszPath</i> points to a <b>NULL</b> string, the result will be the file name extension only. If <i>pszExtension</i> points to a <b>NULL</b> string, an ".exe" extension will be added.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
     // String for path name without file name extension.
     char buffer_1[MAX_PATH] = "file";
     char *lpStr1;
     lpStr1 = buffer_1;

     // String for path name with file name extension.
     char buffer_2[ ] = "file.doc";
     char *lpStr2;
     lpStr2 = buffer_2;

     // String for extension name.
     char F_Ext[MAX_PATH] = ".txt";
     char *lpStr3;
     lpStr3 = F_Ext;

     // Null string as path.
     char N_String[MAX_PATH] = "\0";
     char *lpStr4;
     lpStr4 = N_String;

     // Path 1 without the file name extension.
     cout &lt;&lt; "The original path string 1 is  " &lt;&lt; lpStr1 &lt;&lt; endl;

     int ret_1 = PathAddExtension(lpStr1,lpStr3);
     cout &lt;&lt; "The modified path string 1 is  " &lt;&lt; lpStr1 &lt;&lt; endl;

    // Path 2 with the file name extension already there.
    cout &lt;&lt; "The original path string 2 is  " &lt;&lt; lpStr2 &lt;&lt; endl;
    int ret_2 = PathAddExtension(lpStr2,lpStr3);
    cout &lt;&lt; "The modified path string 2 is  " &lt;&lt; lpStr2&lt;&lt; endl;

    // Path 3 null string as a path.
    int ret_3 = PathAddExtension(lpStr4,lpStr3);
    cout &lt;&lt; "The return value is " &lt;&lt; ret_3&lt;&lt; endl;
    cout &lt;&lt; "The modified path on a null string is " &lt;&lt; lpStr4&lt;&lt; endl;

}

OUTPUT:
-----------------------
The original path string 1 is  file
The modified path string 1 is  file.txt
The original path string 2 is  file.doc
The modified path string 2 is  file.doc
The return value is 1
The modified path on a null string is .txt
The return value is 1
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathAddExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathAddExtensionA">
    <summary>
      <para>Adds a file name extension to a path string.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchAddExtension" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer with the null-terminated string to which the file name extension will be appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszExt">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the file name extension. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if an extension was added, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>If there is already a file name extension present, no extension will be added. If the <i>pszPath</i> points to a <b>NULL</b> string, the result will be the file name extension only. If <i>pszExtension</i> points to a <b>NULL</b> string, an ".exe" extension will be added.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
     // String for path name without file name extension.
     char buffer_1[MAX_PATH] = "file";
     char *lpStr1;
     lpStr1 = buffer_1;

     // String for path name with file name extension.
     char buffer_2[ ] = "file.doc";
     char *lpStr2;
     lpStr2 = buffer_2;

     // String for extension name.
     char F_Ext[MAX_PATH] = ".txt";
     char *lpStr3;
     lpStr3 = F_Ext;

     // Null string as path.
     char N_String[MAX_PATH] = "\0";
     char *lpStr4;
     lpStr4 = N_String;

     // Path 1 without the file name extension.
     cout &lt;&lt; "The original path string 1 is  " &lt;&lt; lpStr1 &lt;&lt; endl;

     int ret_1 = PathAddExtension(lpStr1,lpStr3);
     cout &lt;&lt; "The modified path string 1 is  " &lt;&lt; lpStr1 &lt;&lt; endl;

    // Path 2 with the file name extension already there.
    cout &lt;&lt; "The original path string 2 is  " &lt;&lt; lpStr2 &lt;&lt; endl;
    int ret_2 = PathAddExtension(lpStr2,lpStr3);
    cout &lt;&lt; "The modified path string 2 is  " &lt;&lt; lpStr2&lt;&lt; endl;

    // Path 3 null string as a path.
    int ret_3 = PathAddExtension(lpStr4,lpStr3);
    cout &lt;&lt; "The return value is " &lt;&lt; ret_3&lt;&lt; endl;
    cout &lt;&lt; "The modified path on a null string is " &lt;&lt; lpStr4&lt;&lt; endl;

}

OUTPUT:
-----------------------
The original path string 1 is  file
The modified path string 1 is  file.txt
The original path string 2 is  file.doc
The modified path string 2 is  file.doc
The return value is 1
The modified path on a null string is .txt
The return value is 1
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathAddExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathAddExtensionW">
    <summary>
      <para>Adds a file name extension to a path string.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchAddExtension" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer with the null-terminated string to which the file name extension will be appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszExt">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the file name extension. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if an extension was added, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>If there is already a file name extension present, no extension will be added. If the <i>pszPath</i> points to a <b>NULL</b> string, the result will be the file name extension only. If <i>pszExtension</i> points to a <b>NULL</b> string, an ".exe" extension will be added.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
     // String for path name without file name extension.
     char buffer_1[MAX_PATH] = "file";
     char *lpStr1;
     lpStr1 = buffer_1;

     // String for path name with file name extension.
     char buffer_2[ ] = "file.doc";
     char *lpStr2;
     lpStr2 = buffer_2;

     // String for extension name.
     char F_Ext[MAX_PATH] = ".txt";
     char *lpStr3;
     lpStr3 = F_Ext;

     // Null string as path.
     char N_String[MAX_PATH] = "\0";
     char *lpStr4;
     lpStr4 = N_String;

     // Path 1 without the file name extension.
     cout &lt;&lt; "The original path string 1 is  " &lt;&lt; lpStr1 &lt;&lt; endl;

     int ret_1 = PathAddExtension(lpStr1,lpStr3);
     cout &lt;&lt; "The modified path string 1 is  " &lt;&lt; lpStr1 &lt;&lt; endl;

    // Path 2 with the file name extension already there.
    cout &lt;&lt; "The original path string 2 is  " &lt;&lt; lpStr2 &lt;&lt; endl;
    int ret_2 = PathAddExtension(lpStr2,lpStr3);
    cout &lt;&lt; "The modified path string 2 is  " &lt;&lt; lpStr2&lt;&lt; endl;

    // Path 3 null string as a path.
    int ret_3 = PathAddExtension(lpStr4,lpStr3);
    cout &lt;&lt; "The return value is " &lt;&lt; ret_3&lt;&lt; endl;
    cout &lt;&lt; "The modified path on a null string is " &lt;&lt; lpStr4&lt;&lt; endl;

}

OUTPUT:
-----------------------
The original path string 1 is  file
The modified path string 1 is  file.txt
The original path string 2 is  file.doc
The modified path string 2 is  file.doc
The return value is 1
The modified path on a null string is .txt
The return value is 1
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathAddExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathAppend">
    <summary>
      <para>Appends one path to the end of another.</para>
      <para>
        <b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchAppend" /> or <see cref="PathCchAppendEx" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string to which the path specified in <i>pszMore</i> is appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszMore">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be appended.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function automatically inserts a backslash between the two strings, if one is not already present.</para>
      <para>The path supplied in <i>pszPath</i> cannot begin with "..\" or ".\" to produce a relative path string. If present, those periods are stripped from the output string. For example, appending "path3" to "..\path1\path2" results in an output of "\path1\path2\path3" rather than "..\path1\path2\path3".</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include "Shlwapi.h"

using namespace std;

int main( void )
{
    // String for path name.
    char buffer_1[MAX_PATH] = "name_1\\name_2";
    char *lpStr1;
    lpStr1 = buffer_1;

    // String of what is being added.
    char buffer_2[ ] = "name_3";
    char *lpStr2;
    lpStr2 = buffer_2;

    cout &lt;&lt; "The original path string is    " &lt;&lt; lpStr1 &lt;&lt; endl;
    cout &lt;&lt; "The part to append to end is   " &lt;&lt; lpStr2 &lt;&lt; endl;
    bool ret = PathAppend(lpStr1,lpStr2);
    cout &lt;&lt; "The appended path string is    " &lt;&lt; lpStr1 &lt;&lt; endl;
}

OUTPUT:
---------
The original path string is    name_1\name_2
The part to append to end is   name_3
The appended path string is    name_1\name_2\name_3
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathAppend as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathAppendA">
    <summary>
      <para>Appends one path to the end of another.</para>
      <para>
        <b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchAppend" /> or <see cref="PathCchAppendEx" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string to which the path specified in <i>pszMore</i> is appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszMore">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be appended.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function automatically inserts a backslash between the two strings, if one is not already present.</para>
      <para>The path supplied in <i>pszPath</i> cannot begin with "..\" or ".\" to produce a relative path string. If present, those periods are stripped from the output string. For example, appending "path3" to "..\path1\path2" results in an output of "\path1\path2\path3" rather than "..\path1\path2\path3".</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include "Shlwapi.h"

using namespace std;

int main( void )
{
    // String for path name.
    char buffer_1[MAX_PATH] = "name_1\\name_2";
    char *lpStr1;
    lpStr1 = buffer_1;

    // String of what is being added.
    char buffer_2[ ] = "name_3";
    char *lpStr2;
    lpStr2 = buffer_2;

    cout &lt;&lt; "The original path string is    " &lt;&lt; lpStr1 &lt;&lt; endl;
    cout &lt;&lt; "The part to append to end is   " &lt;&lt; lpStr2 &lt;&lt; endl;
    bool ret = PathAppend(lpStr1,lpStr2);
    cout &lt;&lt; "The appended path string is    " &lt;&lt; lpStr1 &lt;&lt; endl;
}

OUTPUT:
---------
The original path string is    name_1\name_2
The part to append to end is   name_3
The appended path string is    name_1\name_2\name_3
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathAppend as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathAppendW">
    <summary>
      <para>Appends one path to the end of another.</para>
      <para>
        <b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchAppend" /> or <see cref="PathCchAppendEx" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string to which the path specified in <i>pszMore</i> is appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszMore">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be appended.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function automatically inserts a backslash between the two strings, if one is not already present.</para>
      <para>The path supplied in <i>pszPath</i> cannot begin with "..\" or ".\" to produce a relative path string. If present, those periods are stripped from the output string. For example, appending "path3" to "..\path1\path2" results in an output of "\path1\path2\path3" rather than "..\path1\path2\path3".</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include "Shlwapi.h"

using namespace std;

int main( void )
{
    // String for path name.
    char buffer_1[MAX_PATH] = "name_1\\name_2";
    char *lpStr1;
    lpStr1 = buffer_1;

    // String of what is being added.
    char buffer_2[ ] = "name_3";
    char *lpStr2;
    lpStr2 = buffer_2;

    cout &lt;&lt; "The original path string is    " &lt;&lt; lpStr1 &lt;&lt; endl;
    cout &lt;&lt; "The part to append to end is   " &lt;&lt; lpStr2 &lt;&lt; endl;
    bool ret = PathAppend(lpStr1,lpStr2);
    cout &lt;&lt; "The appended path string is    " &lt;&lt; lpStr1 &lt;&lt; endl;
}

OUTPUT:
---------
The original path string is    name_1\name_2
The part to append to end is   name_3
The appended path string is    name_1\name_2\name_3
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathAppend as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathAppend">
    <summary>
      <para>Appends one path to the end of another.</para>
      <para>
        <b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchAppend" /> or <see cref="PathCchAppendEx" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string to which the path specified in <i>pszMore</i> is appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszMore">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be appended.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function automatically inserts a backslash between the two strings, if one is not already present.</para>
      <para>The path supplied in <i>pszPath</i> cannot begin with "..\" or ".\" to produce a relative path string. If present, those periods are stripped from the output string. For example, appending "path3" to "..\path1\path2" results in an output of "\path1\path2\path3" rather than "..\path1\path2\path3".</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include "Shlwapi.h"

using namespace std;

int main( void )
{
    // String for path name.
    char buffer_1[MAX_PATH] = "name_1\\name_2";
    char *lpStr1;
    lpStr1 = buffer_1;

    // String of what is being added.
    char buffer_2[ ] = "name_3";
    char *lpStr2;
    lpStr2 = buffer_2;

    cout &lt;&lt; "The original path string is    " &lt;&lt; lpStr1 &lt;&lt; endl;
    cout &lt;&lt; "The part to append to end is   " &lt;&lt; lpStr2 &lt;&lt; endl;
    bool ret = PathAppend(lpStr1,lpStr2);
    cout &lt;&lt; "The appended path string is    " &lt;&lt; lpStr1 &lt;&lt; endl;
}

OUTPUT:
---------
The original path string is    name_1\name_2
The part to append to end is   name_3
The appended path string is    name_1\name_2\name_3
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathAppend as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathAppendA">
    <summary>
      <para>Appends one path to the end of another.</para>
      <para>
        <b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchAppend" /> or <see cref="PathCchAppendEx" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string to which the path specified in <i>pszMore</i> is appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszMore">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be appended.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function automatically inserts a backslash between the two strings, if one is not already present.</para>
      <para>The path supplied in <i>pszPath</i> cannot begin with "..\" or ".\" to produce a relative path string. If present, those periods are stripped from the output string. For example, appending "path3" to "..\path1\path2" results in an output of "\path1\path2\path3" rather than "..\path1\path2\path3".</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include "Shlwapi.h"

using namespace std;

int main( void )
{
    // String for path name.
    char buffer_1[MAX_PATH] = "name_1\\name_2";
    char *lpStr1;
    lpStr1 = buffer_1;

    // String of what is being added.
    char buffer_2[ ] = "name_3";
    char *lpStr2;
    lpStr2 = buffer_2;

    cout &lt;&lt; "The original path string is    " &lt;&lt; lpStr1 &lt;&lt; endl;
    cout &lt;&lt; "The part to append to end is   " &lt;&lt; lpStr2 &lt;&lt; endl;
    bool ret = PathAppend(lpStr1,lpStr2);
    cout &lt;&lt; "The appended path string is    " &lt;&lt; lpStr1 &lt;&lt; endl;
}

OUTPUT:
---------
The original path string is    name_1\name_2
The part to append to end is   name_3
The appended path string is    name_1\name_2\name_3
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathAppend as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathAppendW">
    <summary>
      <para>Appends one path to the end of another.</para>
      <para>
        <b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchAppend" /> or <see cref="PathCchAppendEx" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string to which the path specified in <i>pszMore</i> is appended. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszMore">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be appended.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function automatically inserts a backslash between the two strings, if one is not already present.</para>
      <para>The path supplied in <i>pszPath</i> cannot begin with "..\" or ".\" to produce a relative path string. If present, those periods are stripped from the output string. For example, appending "path3" to "..\path1\path2" results in an output of "\path1\path2\path3" rather than "..\path1\path2\path3".</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include "Shlwapi.h"

using namespace std;

int main( void )
{
    // String for path name.
    char buffer_1[MAX_PATH] = "name_1\\name_2";
    char *lpStr1;
    lpStr1 = buffer_1;

    // String of what is being added.
    char buffer_2[ ] = "name_3";
    char *lpStr2;
    lpStr2 = buffer_2;

    cout &lt;&lt; "The original path string is    " &lt;&lt; lpStr1 &lt;&lt; endl;
    cout &lt;&lt; "The part to append to end is   " &lt;&lt; lpStr2 &lt;&lt; endl;
    bool ret = PathAppend(lpStr1,lpStr2);
    cout &lt;&lt; "The appended path string is    " &lt;&lt; lpStr1 &lt;&lt; endl;
}

OUTPUT:
---------
The original path string is    name_1\name_2
The part to append to end is   name_3
The appended path string is    name_1\name_2\name_3
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathAppend as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathBuildRoot">
    <summary>
      <para>Creates a root path from a given drive number.</para>
    </summary>
    <param name="pszRoot">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to the string that receives the constructed root path. This buffer must be at least four characters in size.</para>
    </param>
    <param name="iDrive">
      <para>Type: <b>int</b></para>
      <para>A variable of type <b>int</b> that indicates the desired drive number. It should be between 0 and 25.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>Returns the address of the constructed root path. If the call fails for any reason (for example, an invalid drive number), <i>szRoot</i> is returned unchanged.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathBuildRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathBuildRootA">
    <summary>
      <para>Creates a root path from a given drive number.</para>
    </summary>
    <param name="pszRoot">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to the string that receives the constructed root path. This buffer must be at least four characters in size.</para>
    </param>
    <param name="iDrive">
      <para>Type: <b>int</b></para>
      <para>A variable of type <b>int</b> that indicates the desired drive number. It should be between 0 and 25.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>Returns the address of the constructed root path. If the call fails for any reason (for example, an invalid drive number), <i>szRoot</i> is returned unchanged.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathBuildRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathBuildRootW">
    <summary>
      <para>Creates a root path from a given drive number.</para>
    </summary>
    <param name="pszRoot">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to the string that receives the constructed root path. This buffer must be at least four characters in size.</para>
    </param>
    <param name="iDrive">
      <para>Type: <b>int</b></para>
      <para>A variable of type <b>int</b> that indicates the desired drive number. It should be between 0 and 25.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>Returns the address of the constructed root path. If the call fails for any reason (for example, an invalid drive number), <i>szRoot</i> is returned unchanged.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathBuildRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathBuildRoot">
    <summary>
      <para>Creates a root path from a given drive number.</para>
    </summary>
    <param name="pszRoot">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to the string that receives the constructed root path. This buffer must be at least four characters in size.</para>
    </param>
    <param name="iDrive">
      <para>Type: <b>int</b></para>
      <para>A variable of type <b>int</b> that indicates the desired drive number. It should be between 0 and 25.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>Returns the address of the constructed root path. If the call fails for any reason (for example, an invalid drive number), <i>szRoot</i> is returned unchanged.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathBuildRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathBuildRootA">
    <summary>
      <para>Creates a root path from a given drive number.</para>
    </summary>
    <param name="pszRoot">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to the string that receives the constructed root path. This buffer must be at least four characters in size.</para>
    </param>
    <param name="iDrive">
      <para>Type: <b>int</b></para>
      <para>A variable of type <b>int</b> that indicates the desired drive number. It should be between 0 and 25.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>Returns the address of the constructed root path. If the call fails for any reason (for example, an invalid drive number), <i>szRoot</i> is returned unchanged.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathBuildRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathBuildRootW">
    <summary>
      <para>Creates a root path from a given drive number.</para>
    </summary>
    <param name="pszRoot">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to the string that receives the constructed root path. This buffer must be at least four characters in size.</para>
    </param>
    <param name="iDrive">
      <para>Type: <b>int</b></para>
      <para>A variable of type <b>int</b> that indicates the desired drive number. It should be between 0 and 25.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>Returns the address of the constructed root path. If the call fails for any reason (for example, an invalid drive number), <i>szRoot</i> is returned unchanged.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathBuildRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCanonicalize">
    <summary>
      <para>Simplifies a path by removing navigation elements such as "." and ".." to produce a direct, well-formed path.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchCanonicalize" /> or <see cref="PathCchCanonicalizeEx" /> function in its place.</para>
    </summary>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that receives the canonicalized path. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be canonicalized.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if a result has been computed and the content of the <i>lpszDst</i> output buffer is valid. Returns <b>FALSE</b> otherwise, and the contents of the buffer pointed to by <i>lpszDst</i> are invalid. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function allows the user to specify what to remove from a path by inserting special character sequences into the path. The ".." sequence indicates to remove a path segment from the current position to the previous path segment. The "." sequence indicates to skip over the next path segment to the following path segment. The root segment of the path cannot be removed.</para>
      <para>If there are more ".." sequences than there are path segments, the function returns <b>TRUE</b> and contents of the buffer pointed to by <i>lpszDst</i> contains just the root, "".</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include "Shlwapi.h"

using namespace std;

int main( void )
{
// Path_1 destination buffer.
char buffer_1[MAX_PATH] = "JustABufferToHoldTheCanonicalizedPathForAnExample";
char *lpStr1;
lpStr1 = buffer_1;

// Path_2 to be Canonicalized.
char buffer_2[ ] = "A:\\name_1\\.\\name_2\\..\\name_3";
char *lpStr2;
lpStr2 = buffer_2;

// Path_3 to be Canonicalized.
char buffer_3[ ] = "A:\\name_1\\..\\name_2\\.\\name_3";
char *lpStr3;
lpStr3 = buffer_3;

// Path_4 to be Canonicalized.
char buffer_4[ ] = "A:\\name_1\\name_2\\.\\name_3\\..\\name_4";
char *lpStr4;
lpStr4 = buffer_4;

// Path_5 to be Canonicalized.
char buffer_5[ ] = "A:\\name_1\\.\\name_2\\.\\name_3\\..\\name_4\\..";
char *lpStr5;
lpStr5 = buffer_5;

// Path_6 to be Canonicalized.
char buffer_6[ ] = "C:\\..";
char *lpStr6;
lpStr6 = buffer_6;

cout &lt;&lt; "The un-canonicalized path 2 is : " &lt;&lt; lpStr2
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr2)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 3 is : " &lt;&lt; lpStr3
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr3)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 4 is : " &lt;&lt; lpStr4
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr4)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 5 is : " &lt;&lt; lpStr5
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr5)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 6 is : " &lt;&lt; lpStr6
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr6)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;
}
OUTPUT:
---------
The un-canonicalized path 2 is : A:\name_1\.\name_2\..\name_3
The return value is            : 1
The canonicalized path 1 is    : A:\name_1\name_3

The un-canonicalized path 3 is : A:\name_1\..\name_2\.\name_3
The return value is            : 1
The canonicalized path 1 is    : A:\name_2\name_3

The un-canonicalized path 4 is : A:\name_1\name_2\.\name_3\..\name_4
The return value is            : 1
The canonicalized path 1 is    : A:\name_1\name_2\name_4

The un-canonicalized path 5 is : A:\name_1\.\name_2\.\name_3\..\name_4\..
The return value is            : 1
The canonicalized path 1 is    : A:\name_1\name_2

The un-canonicalized path 6 is : C:\..
The return value is            : 1
The canonicalized path 1 is    : C:\
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCanonicalize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCanonicalizeA">
    <summary>
      <para>Simplifies a path by removing navigation elements such as "." and ".." to produce a direct, well-formed path.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchCanonicalize" /> or <see cref="PathCchCanonicalizeEx" /> function in its place.</para>
    </summary>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that receives the canonicalized path. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be canonicalized.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if a result has been computed and the content of the <i>lpszDst</i> output buffer is valid. Returns <b>FALSE</b> otherwise, and the contents of the buffer pointed to by <i>lpszDst</i> are invalid. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function allows the user to specify what to remove from a path by inserting special character sequences into the path. The ".." sequence indicates to remove a path segment from the current position to the previous path segment. The "." sequence indicates to skip over the next path segment to the following path segment. The root segment of the path cannot be removed.</para>
      <para>If there are more ".." sequences than there are path segments, the function returns <b>TRUE</b> and contents of the buffer pointed to by <i>lpszDst</i> contains just the root, "".</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include "Shlwapi.h"

using namespace std;

int main( void )
{
// Path_1 destination buffer.
char buffer_1[MAX_PATH] = "JustABufferToHoldTheCanonicalizedPathForAnExample";
char *lpStr1;
lpStr1 = buffer_1;

// Path_2 to be Canonicalized.
char buffer_2[ ] = "A:\\name_1\\.\\name_2\\..\\name_3";
char *lpStr2;
lpStr2 = buffer_2;

// Path_3 to be Canonicalized.
char buffer_3[ ] = "A:\\name_1\\..\\name_2\\.\\name_3";
char *lpStr3;
lpStr3 = buffer_3;

// Path_4 to be Canonicalized.
char buffer_4[ ] = "A:\\name_1\\name_2\\.\\name_3\\..\\name_4";
char *lpStr4;
lpStr4 = buffer_4;

// Path_5 to be Canonicalized.
char buffer_5[ ] = "A:\\name_1\\.\\name_2\\.\\name_3\\..\\name_4\\..";
char *lpStr5;
lpStr5 = buffer_5;

// Path_6 to be Canonicalized.
char buffer_6[ ] = "C:\\..";
char *lpStr6;
lpStr6 = buffer_6;

cout &lt;&lt; "The un-canonicalized path 2 is : " &lt;&lt; lpStr2
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr2)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 3 is : " &lt;&lt; lpStr3
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr3)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 4 is : " &lt;&lt; lpStr4
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr4)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 5 is : " &lt;&lt; lpStr5
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr5)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 6 is : " &lt;&lt; lpStr6
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr6)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;
}
OUTPUT:
---------
The un-canonicalized path 2 is : A:\name_1\.\name_2\..\name_3
The return value is            : 1
The canonicalized path 1 is    : A:\name_1\name_3

The un-canonicalized path 3 is : A:\name_1\..\name_2\.\name_3
The return value is            : 1
The canonicalized path 1 is    : A:\name_2\name_3

The un-canonicalized path 4 is : A:\name_1\name_2\.\name_3\..\name_4
The return value is            : 1
The canonicalized path 1 is    : A:\name_1\name_2\name_4

The un-canonicalized path 5 is : A:\name_1\.\name_2\.\name_3\..\name_4\..
The return value is            : 1
The canonicalized path 1 is    : A:\name_1\name_2

The un-canonicalized path 6 is : C:\..
The return value is            : 1
The canonicalized path 1 is    : C:\
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCanonicalize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCanonicalizeW">
    <summary>
      <para>Simplifies a path by removing navigation elements such as "." and ".." to produce a direct, well-formed path.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchCanonicalize" /> or <see cref="PathCchCanonicalizeEx" /> function in its place.</para>
    </summary>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that receives the canonicalized path. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be canonicalized.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if a result has been computed and the content of the <i>lpszDst</i> output buffer is valid. Returns <b>FALSE</b> otherwise, and the contents of the buffer pointed to by <i>lpszDst</i> are invalid. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function allows the user to specify what to remove from a path by inserting special character sequences into the path. The ".." sequence indicates to remove a path segment from the current position to the previous path segment. The "." sequence indicates to skip over the next path segment to the following path segment. The root segment of the path cannot be removed.</para>
      <para>If there are more ".." sequences than there are path segments, the function returns <b>TRUE</b> and contents of the buffer pointed to by <i>lpszDst</i> contains just the root, "".</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include "Shlwapi.h"

using namespace std;

int main( void )
{
// Path_1 destination buffer.
char buffer_1[MAX_PATH] = "JustABufferToHoldTheCanonicalizedPathForAnExample";
char *lpStr1;
lpStr1 = buffer_1;

// Path_2 to be Canonicalized.
char buffer_2[ ] = "A:\\name_1\\.\\name_2\\..\\name_3";
char *lpStr2;
lpStr2 = buffer_2;

// Path_3 to be Canonicalized.
char buffer_3[ ] = "A:\\name_1\\..\\name_2\\.\\name_3";
char *lpStr3;
lpStr3 = buffer_3;

// Path_4 to be Canonicalized.
char buffer_4[ ] = "A:\\name_1\\name_2\\.\\name_3\\..\\name_4";
char *lpStr4;
lpStr4 = buffer_4;

// Path_5 to be Canonicalized.
char buffer_5[ ] = "A:\\name_1\\.\\name_2\\.\\name_3\\..\\name_4\\..";
char *lpStr5;
lpStr5 = buffer_5;

// Path_6 to be Canonicalized.
char buffer_6[ ] = "C:\\..";
char *lpStr6;
lpStr6 = buffer_6;

cout &lt;&lt; "The un-canonicalized path 2 is : " &lt;&lt; lpStr2
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr2)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 3 is : " &lt;&lt; lpStr3
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr3)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 4 is : " &lt;&lt; lpStr4
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr4)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 5 is : " &lt;&lt; lpStr5
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr5)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 6 is : " &lt;&lt; lpStr6
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr6)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;
}
OUTPUT:
---------
The un-canonicalized path 2 is : A:\name_1\.\name_2\..\name_3
The return value is            : 1
The canonicalized path 1 is    : A:\name_1\name_3

The un-canonicalized path 3 is : A:\name_1\..\name_2\.\name_3
The return value is            : 1
The canonicalized path 1 is    : A:\name_2\name_3

The un-canonicalized path 4 is : A:\name_1\name_2\.\name_3\..\name_4
The return value is            : 1
The canonicalized path 1 is    : A:\name_1\name_2\name_4

The un-canonicalized path 5 is : A:\name_1\.\name_2\.\name_3\..\name_4\..
The return value is            : 1
The canonicalized path 1 is    : A:\name_1\name_2

The un-canonicalized path 6 is : C:\..
The return value is            : 1
The canonicalized path 1 is    : C:\
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCanonicalize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCanonicalize">
    <summary>
      <para>Simplifies a path by removing navigation elements such as "." and ".." to produce a direct, well-formed path.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchCanonicalize" /> or <see cref="PathCchCanonicalizeEx" /> function in its place.</para>
    </summary>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that receives the canonicalized path. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be canonicalized.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if a result has been computed and the content of the <i>lpszDst</i> output buffer is valid. Returns <b>FALSE</b> otherwise, and the contents of the buffer pointed to by <i>lpszDst</i> are invalid. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function allows the user to specify what to remove from a path by inserting special character sequences into the path. The ".." sequence indicates to remove a path segment from the current position to the previous path segment. The "." sequence indicates to skip over the next path segment to the following path segment. The root segment of the path cannot be removed.</para>
      <para>If there are more ".." sequences than there are path segments, the function returns <b>TRUE</b> and contents of the buffer pointed to by <i>lpszDst</i> contains just the root, "".</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include "Shlwapi.h"

using namespace std;

int main( void )
{
// Path_1 destination buffer.
char buffer_1[MAX_PATH] = "JustABufferToHoldTheCanonicalizedPathForAnExample";
char *lpStr1;
lpStr1 = buffer_1;

// Path_2 to be Canonicalized.
char buffer_2[ ] = "A:\\name_1\\.\\name_2\\..\\name_3";
char *lpStr2;
lpStr2 = buffer_2;

// Path_3 to be Canonicalized.
char buffer_3[ ] = "A:\\name_1\\..\\name_2\\.\\name_3";
char *lpStr3;
lpStr3 = buffer_3;

// Path_4 to be Canonicalized.
char buffer_4[ ] = "A:\\name_1\\name_2\\.\\name_3\\..\\name_4";
char *lpStr4;
lpStr4 = buffer_4;

// Path_5 to be Canonicalized.
char buffer_5[ ] = "A:\\name_1\\.\\name_2\\.\\name_3\\..\\name_4\\..";
char *lpStr5;
lpStr5 = buffer_5;

// Path_6 to be Canonicalized.
char buffer_6[ ] = "C:\\..";
char *lpStr6;
lpStr6 = buffer_6;

cout &lt;&lt; "The un-canonicalized path 2 is : " &lt;&lt; lpStr2
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr2)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 3 is : " &lt;&lt; lpStr3
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr3)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 4 is : " &lt;&lt; lpStr4
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr4)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 5 is : " &lt;&lt; lpStr5
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr5)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 6 is : " &lt;&lt; lpStr6
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr6)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;
}
OUTPUT:
---------
The un-canonicalized path 2 is : A:\name_1\.\name_2\..\name_3
The return value is            : 1
The canonicalized path 1 is    : A:\name_1\name_3

The un-canonicalized path 3 is : A:\name_1\..\name_2\.\name_3
The return value is            : 1
The canonicalized path 1 is    : A:\name_2\name_3

The un-canonicalized path 4 is : A:\name_1\name_2\.\name_3\..\name_4
The return value is            : 1
The canonicalized path 1 is    : A:\name_1\name_2\name_4

The un-canonicalized path 5 is : A:\name_1\.\name_2\.\name_3\..\name_4\..
The return value is            : 1
The canonicalized path 1 is    : A:\name_1\name_2

The un-canonicalized path 6 is : C:\..
The return value is            : 1
The canonicalized path 1 is    : C:\
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCanonicalize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCanonicalizeA">
    <summary>
      <para>Simplifies a path by removing navigation elements such as "." and ".." to produce a direct, well-formed path.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchCanonicalize" /> or <see cref="PathCchCanonicalizeEx" /> function in its place.</para>
    </summary>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that receives the canonicalized path. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be canonicalized.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if a result has been computed and the content of the <i>lpszDst</i> output buffer is valid. Returns <b>FALSE</b> otherwise, and the contents of the buffer pointed to by <i>lpszDst</i> are invalid. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function allows the user to specify what to remove from a path by inserting special character sequences into the path. The ".." sequence indicates to remove a path segment from the current position to the previous path segment. The "." sequence indicates to skip over the next path segment to the following path segment. The root segment of the path cannot be removed.</para>
      <para>If there are more ".." sequences than there are path segments, the function returns <b>TRUE</b> and contents of the buffer pointed to by <i>lpszDst</i> contains just the root, "".</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include "Shlwapi.h"

using namespace std;

int main( void )
{
// Path_1 destination buffer.
char buffer_1[MAX_PATH] = "JustABufferToHoldTheCanonicalizedPathForAnExample";
char *lpStr1;
lpStr1 = buffer_1;

// Path_2 to be Canonicalized.
char buffer_2[ ] = "A:\\name_1\\.\\name_2\\..\\name_3";
char *lpStr2;
lpStr2 = buffer_2;

// Path_3 to be Canonicalized.
char buffer_3[ ] = "A:\\name_1\\..\\name_2\\.\\name_3";
char *lpStr3;
lpStr3 = buffer_3;

// Path_4 to be Canonicalized.
char buffer_4[ ] = "A:\\name_1\\name_2\\.\\name_3\\..\\name_4";
char *lpStr4;
lpStr4 = buffer_4;

// Path_5 to be Canonicalized.
char buffer_5[ ] = "A:\\name_1\\.\\name_2\\.\\name_3\\..\\name_4\\..";
char *lpStr5;
lpStr5 = buffer_5;

// Path_6 to be Canonicalized.
char buffer_6[ ] = "C:\\..";
char *lpStr6;
lpStr6 = buffer_6;

cout &lt;&lt; "The un-canonicalized path 2 is : " &lt;&lt; lpStr2
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr2)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 3 is : " &lt;&lt; lpStr3
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr3)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 4 is : " &lt;&lt; lpStr4
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr4)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 5 is : " &lt;&lt; lpStr5
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr5)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 6 is : " &lt;&lt; lpStr6
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr6)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;
}
OUTPUT:
---------
The un-canonicalized path 2 is : A:\name_1\.\name_2\..\name_3
The return value is            : 1
The canonicalized path 1 is    : A:\name_1\name_3

The un-canonicalized path 3 is : A:\name_1\..\name_2\.\name_3
The return value is            : 1
The canonicalized path 1 is    : A:\name_2\name_3

The un-canonicalized path 4 is : A:\name_1\name_2\.\name_3\..\name_4
The return value is            : 1
The canonicalized path 1 is    : A:\name_1\name_2\name_4

The un-canonicalized path 5 is : A:\name_1\.\name_2\.\name_3\..\name_4\..
The return value is            : 1
The canonicalized path 1 is    : A:\name_1\name_2

The un-canonicalized path 6 is : C:\..
The return value is            : 1
The canonicalized path 1 is    : C:\
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCanonicalize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCanonicalizeW">
    <summary>
      <para>Simplifies a path by removing navigation elements such as "." and ".." to produce a direct, well-formed path.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchCanonicalize" /> or <see cref="PathCchCanonicalizeEx" /> function in its place.</para>
    </summary>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that receives the canonicalized path. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be canonicalized.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if a result has been computed and the content of the <i>lpszDst</i> output buffer is valid. Returns <b>FALSE</b> otherwise, and the contents of the buffer pointed to by <i>lpszDst</i> are invalid. To get extended error information, call <see cref="GetLastError" />.</para>
    </returns>
    <remarks>
      <para>This function allows the user to specify what to remove from a path by inserting special character sequences into the path. The ".." sequence indicates to remove a path segment from the current position to the previous path segment. The "." sequence indicates to skip over the next path segment to the following path segment. The root segment of the path cannot be removed.</para>
      <para>If there are more ".." sequences than there are path segments, the function returns <b>TRUE</b> and contents of the buffer pointed to by <i>lpszDst</i> contains just the root, "".</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include "Shlwapi.h"

using namespace std;

int main( void )
{
// Path_1 destination buffer.
char buffer_1[MAX_PATH] = "JustABufferToHoldTheCanonicalizedPathForAnExample";
char *lpStr1;
lpStr1 = buffer_1;

// Path_2 to be Canonicalized.
char buffer_2[ ] = "A:\\name_1\\.\\name_2\\..\\name_3";
char *lpStr2;
lpStr2 = buffer_2;

// Path_3 to be Canonicalized.
char buffer_3[ ] = "A:\\name_1\\..\\name_2\\.\\name_3";
char *lpStr3;
lpStr3 = buffer_3;

// Path_4 to be Canonicalized.
char buffer_4[ ] = "A:\\name_1\\name_2\\.\\name_3\\..\\name_4";
char *lpStr4;
lpStr4 = buffer_4;

// Path_5 to be Canonicalized.
char buffer_5[ ] = "A:\\name_1\\.\\name_2\\.\\name_3\\..\\name_4\\..";
char *lpStr5;
lpStr5 = buffer_5;

// Path_6 to be Canonicalized.
char buffer_6[ ] = "C:\\..";
char *lpStr6;
lpStr6 = buffer_6;

cout &lt;&lt; "The un-canonicalized path 2 is : " &lt;&lt; lpStr2
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr2)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 3 is : " &lt;&lt; lpStr3
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr3)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 4 is : " &lt;&lt; lpStr4
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr4)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 5 is : " &lt;&lt; lpStr5
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr5)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;

cout &lt;&lt; "\nThe un-canonicalized path 6 is : " &lt;&lt; lpStr6
     &lt;&lt; "\nThe return value is            : "
     &lt;&lt; PathCanonicalize(lpStr1,lpStr6)
     &lt;&lt; "\nThe canonicalized path 1 is    : " &lt;&lt; lpStr1 &lt;&lt; endl;
}
OUTPUT:
---------
The un-canonicalized path 2 is : A:\name_1\.\name_2\..\name_3
The return value is            : 1
The canonicalized path 1 is    : A:\name_1\name_3

The un-canonicalized path 3 is : A:\name_1\..\name_2\.\name_3
The return value is            : 1
The canonicalized path 1 is    : A:\name_2\name_3

The un-canonicalized path 4 is : A:\name_1\name_2\.\name_3\..\name_4
The return value is            : 1
The canonicalized path 1 is    : A:\name_1\name_2\name_4

The un-canonicalized path 5 is : A:\name_1\.\name_2\.\name_3\..\name_4\..
The return value is            : 1
The canonicalized path 1 is    : A:\name_1\name_2

The un-canonicalized path 6 is : C:\..
The return value is            : 1
The canonicalized path 1 is    : C:\
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCanonicalize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCombine">
    <summary>
      <para>Concatenates two strings that represent properly formed paths into one path; also concatenates any relative path elements.</para>
      <para>
        <b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchCombine" /> or <see cref="PathCchCombineEx" /> function in its place.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the combined path string. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszDir">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the concatenated path string. This is the same string pointed to by <i>pszPathOut</i>. If this function does not return successfully, this value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>The directory path should be in the form of A:,B:, ..., Z:. The file path should be in a correct form that represents the file name part of the path. If the directory path ends with a backslash, the backslash will be maintained. Note that while <i>lpszDir</i> and <i>lpszFile</i> are both optional parameters, they cannot both be <b>NULL</b>.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// Buffer to hold combined path.
char buffer_1[MAX_PATH] = "";
char *lpStr1;
lpStr1 = buffer_1;

// String for balance of path name.
char buffer_2[ ] = "One\\Two\\Three";
char *lpStr2;
lpStr2 = buffer_2;

// String for directory name.
char buffer_3[ ] = "C:";
char *lpStr3;
lpStr3 = buffer_3;

cout &lt;&lt; "The file path to be combined is  "
     &lt;&lt; lpStr2 &lt;&lt; endl;
cout &lt;&lt; "The directory name path is       "
     &lt;&lt; lpStr3 &lt;&lt; endl;
cout &lt;&lt; "The combined path is             "
     &lt;&lt; PathCombine(lpStr1,lpStr3,lpStr2) &lt;&lt; endl;
}

------------
INPUT:
------------
Path for directory part: "C:"
Path for file part: "One\Two\Three"
------------
OUTPUT:
------------
The file path to be combined is  One\Two\Three
The directory name path is       C:
The combined path is             C:\One\Two\Three
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCombine as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCombineA">
    <summary>
      <para>Concatenates two strings that represent properly formed paths into one path; also concatenates any relative path elements.</para>
      <para>
        <b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchCombine" /> or <see cref="PathCchCombineEx" /> function in its place.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the combined path string. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszDir">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the concatenated path string. This is the same string pointed to by <i>pszPathOut</i>. If this function does not return successfully, this value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>The directory path should be in the form of A:,B:, ..., Z:. The file path should be in a correct form that represents the file name part of the path. If the directory path ends with a backslash, the backslash will be maintained. Note that while <i>lpszDir</i> and <i>lpszFile</i> are both optional parameters, they cannot both be <b>NULL</b>.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// Buffer to hold combined path.
char buffer_1[MAX_PATH] = "";
char *lpStr1;
lpStr1 = buffer_1;

// String for balance of path name.
char buffer_2[ ] = "One\\Two\\Three";
char *lpStr2;
lpStr2 = buffer_2;

// String for directory name.
char buffer_3[ ] = "C:";
char *lpStr3;
lpStr3 = buffer_3;

cout &lt;&lt; "The file path to be combined is  "
     &lt;&lt; lpStr2 &lt;&lt; endl;
cout &lt;&lt; "The directory name path is       "
     &lt;&lt; lpStr3 &lt;&lt; endl;
cout &lt;&lt; "The combined path is             "
     &lt;&lt; PathCombine(lpStr1,lpStr3,lpStr2) &lt;&lt; endl;
}

------------
INPUT:
------------
Path for directory part: "C:"
Path for file part: "One\Two\Three"
------------
OUTPUT:
------------
The file path to be combined is  One\Two\Three
The directory name path is       C:
The combined path is             C:\One\Two\Three
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCombine as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCombineW">
    <summary>
      <para>Concatenates two strings that represent properly formed paths into one path; also concatenates any relative path elements.</para>
      <para>
        <b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchCombine" /> or <see cref="PathCchCombineEx" /> function in its place.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the combined path string. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszDir">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the concatenated path string. This is the same string pointed to by <i>pszPathOut</i>. If this function does not return successfully, this value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>The directory path should be in the form of A:,B:, ..., Z:. The file path should be in a correct form that represents the file name part of the path. If the directory path ends with a backslash, the backslash will be maintained. Note that while <i>lpszDir</i> and <i>lpszFile</i> are both optional parameters, they cannot both be <b>NULL</b>.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// Buffer to hold combined path.
char buffer_1[MAX_PATH] = "";
char *lpStr1;
lpStr1 = buffer_1;

// String for balance of path name.
char buffer_2[ ] = "One\\Two\\Three";
char *lpStr2;
lpStr2 = buffer_2;

// String for directory name.
char buffer_3[ ] = "C:";
char *lpStr3;
lpStr3 = buffer_3;

cout &lt;&lt; "The file path to be combined is  "
     &lt;&lt; lpStr2 &lt;&lt; endl;
cout &lt;&lt; "The directory name path is       "
     &lt;&lt; lpStr3 &lt;&lt; endl;
cout &lt;&lt; "The combined path is             "
     &lt;&lt; PathCombine(lpStr1,lpStr3,lpStr2) &lt;&lt; endl;
}

------------
INPUT:
------------
Path for directory part: "C:"
Path for file part: "One\Two\Three"
------------
OUTPUT:
------------
The file path to be combined is  One\Two\Three
The directory name path is       C:
The combined path is             C:\One\Two\Three
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCombine as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCombine">
    <summary>
      <para>Concatenates two strings that represent properly formed paths into one path; also concatenates any relative path elements.</para>
      <para>
        <b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchCombine" /> or <see cref="PathCchCombineEx" /> function in its place.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the combined path string. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszDir">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the concatenated path string. This is the same string pointed to by <i>pszPathOut</i>. If this function does not return successfully, this value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>The directory path should be in the form of A:,B:, ..., Z:. The file path should be in a correct form that represents the file name part of the path. If the directory path ends with a backslash, the backslash will be maintained. Note that while <i>lpszDir</i> and <i>lpszFile</i> are both optional parameters, they cannot both be <b>NULL</b>.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

int main( void )
{
// Buffer to hold combined path.
char buffer_1[MAX_PATH] = "";
char *lpStr1;
lpStr1 = buffer_1;

// String for balance of path name.
char buffer_2[ ] = "One\\Two\\Three";
char *lpStr2;
lpStr2 = buffer_2;

// String for directory name.
char buffer_3[ ] = "C:";
char *lpStr3;
lpStr3 = buffer_3;

cout &lt;&lt; "The file path to be combined is  "
     &lt;&lt; lpStr2 &lt;&lt; endl;
cout &lt;&lt; "The directory name path is       "
     &lt;&lt; lpStr3 &lt;&lt; endl;
cout &lt;&lt; "The combined path is             "
     &lt;&lt; PathCombine(lpStr1,lpStr3,lpStr2) &lt;&lt; endl;
}

------------
INPUT:
------------
Path for directory part: "C:"
Path for file part: "One\Two\Three"
------------
OUTPUT:
------------
The file path to be combined is  One\Two\Three
The directory name path is       C:
The combined path is             C:\One\Two\Three
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCombine as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCombineA">
    <summary>
      <para>Concatenates two strings that represent properly formed paths into one path; also concatenates any relative path elements.</para>
      <para>
        <b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchCombine" /> or <see cref="PathCchCombineEx" /> function in its place.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the combined path string. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszDir">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the concatenated path string. This is the same string pointed to by <i>pszPathOut</i>. If this function does not return successfully, this value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>The directory path should be in the form of A:,B:, ..., Z:. The file path should be in a correct form that represents the file name part of the path. If the directory path ends with a backslash, the backslash will be maintained. Note that while <i>lpszDir</i> and <i>lpszFile</i> are both optional parameters, they cannot both be <b>NULL</b>.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

int main( void )
{
// Buffer to hold combined path.
char buffer_1[MAX_PATH] = "";
char *lpStr1;
lpStr1 = buffer_1;

// String for balance of path name.
char buffer_2[ ] = "One\\Two\\Three";
char *lpStr2;
lpStr2 = buffer_2;

// String for directory name.
char buffer_3[ ] = "C:";
char *lpStr3;
lpStr3 = buffer_3;

cout &lt;&lt; "The file path to be combined is  "
     &lt;&lt; lpStr2 &lt;&lt; endl;
cout &lt;&lt; "The directory name path is       "
     &lt;&lt; lpStr3 &lt;&lt; endl;
cout &lt;&lt; "The combined path is             "
     &lt;&lt; PathCombine(lpStr1,lpStr3,lpStr2) &lt;&lt; endl;
}

------------
INPUT:
------------
Path for directory part: "C:"
Path for file part: "One\Two\Three"
------------
OUTPUT:
------------
The file path to be combined is  One\Two\Three
The directory name path is       C:
The combined path is             C:\One\Two\Three
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCombine as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCombineW">
    <summary>
      <para>Concatenates two strings that represent properly formed paths into one path; also concatenates any relative path elements.</para>
      <para>
        <b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchCombine" /> or <see cref="PathCchCombineEx" /> function in its place.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the combined path string. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pszDir">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the concatenated path string. This is the same string pointed to by <i>pszPathOut</i>. If this function does not return successfully, this value is <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>The directory path should be in the form of A:,B:, ..., Z:. The file path should be in a correct form that represents the file name part of the path. If the directory path ends with a backslash, the backslash will be maintained. Note that while <i>lpszDir</i> and <i>lpszFile</i> are both optional parameters, they cannot both be <b>NULL</b>.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

int main( void )
{
// Buffer to hold combined path.
char buffer_1[MAX_PATH] = "";
char *lpStr1;
lpStr1 = buffer_1;

// String for balance of path name.
char buffer_2[ ] = "One\\Two\\Three";
char *lpStr2;
lpStr2 = buffer_2;

// String for directory name.
char buffer_3[ ] = "C:";
char *lpStr3;
lpStr3 = buffer_3;

cout &lt;&lt; "The file path to be combined is  "
     &lt;&lt; lpStr2 &lt;&lt; endl;
cout &lt;&lt; "The directory name path is       "
     &lt;&lt; lpStr3 &lt;&lt; endl;
cout &lt;&lt; "The combined path is             "
     &lt;&lt; PathCombine(lpStr1,lpStr3,lpStr2) &lt;&lt; endl;
}

------------
INPUT:
------------
Path for directory part: "C:"
Path for file part: "One\Two\Three"
------------
OUTPUT:
------------
The file path to be combined is  One\Two\Three
The directory name path is       C:
The combined path is             C:\One\Two\Three
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCombine as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCommonPrefix">
    <summary>
      <para>Compares two paths to determine if they share a common prefix. A prefix is one of these types: "C:\", ".", "..", "..\".</para>
    </summary>
    <param name="pszFile1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the first path name.</para>
    </param>
    <param name="pszFile2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the second path name.</para>
    </param>
    <param name="achPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that receives the common prefix. This buffer must be at least MAX_PATH characters in size. If there is no common prefix, it is set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the count of common prefix characters in the path. If the output buffer pointer is not <b>NULL</b>, then these characters are copied to the output buffer.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCommonPrefix as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCommonPrefixA">
    <summary>
      <para>Compares two paths to determine if they share a common prefix. A prefix is one of these types: "C:\", ".", "..", "..\".</para>
    </summary>
    <param name="pszFile1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the first path name.</para>
    </param>
    <param name="pszFile2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the second path name.</para>
    </param>
    <param name="achPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that receives the common prefix. This buffer must be at least MAX_PATH characters in size. If there is no common prefix, it is set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the count of common prefix characters in the path. If the output buffer pointer is not <b>NULL</b>, then these characters are copied to the output buffer.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCommonPrefix as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCommonPrefixW">
    <summary>
      <para>Compares two paths to determine if they share a common prefix. A prefix is one of these types: "C:\", ".", "..", "..\".</para>
    </summary>
    <param name="pszFile1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the first path name.</para>
    </param>
    <param name="pszFile2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the second path name.</para>
    </param>
    <param name="achPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that receives the common prefix. This buffer must be at least MAX_PATH characters in size. If there is no common prefix, it is set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the count of common prefix characters in the path. If the output buffer pointer is not <b>NULL</b>, then these characters are copied to the output buffer.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCommonPrefix as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCommonPrefix">
    <summary>
      <para>Compares two paths to determine if they share a common prefix. A prefix is one of these types: "C:\", ".", "..", "..\".</para>
    </summary>
    <param name="pszFile1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the first path name.</para>
    </param>
    <param name="pszFile2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the second path name.</para>
    </param>
    <param name="achPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that receives the common prefix. This buffer must be at least MAX_PATH characters in size. If there is no common prefix, it is set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the count of common prefix characters in the path. If the output buffer pointer is not <b>NULL</b>, then these characters are copied to the output buffer.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCommonPrefix as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCommonPrefixA">
    <summary>
      <para>Compares two paths to determine if they share a common prefix. A prefix is one of these types: "C:\", ".", "..", "..\".</para>
    </summary>
    <param name="pszFile1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the first path name.</para>
    </param>
    <param name="pszFile2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the second path name.</para>
    </param>
    <param name="achPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that receives the common prefix. This buffer must be at least MAX_PATH characters in size. If there is no common prefix, it is set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the count of common prefix characters in the path. If the output buffer pointer is not <b>NULL</b>, then these characters are copied to the output buffer.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCommonPrefix as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCommonPrefixW">
    <summary>
      <para>Compares two paths to determine if they share a common prefix. A prefix is one of these types: "C:\", ".", "..", "..\".</para>
    </summary>
    <param name="pszFile1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the first path name.</para>
    </param>
    <param name="pszFile2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the second path name.</para>
    </param>
    <param name="achPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that receives the common prefix. This buffer must be at least MAX_PATH characters in size. If there is no common prefix, it is set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the count of common prefix characters in the path. If the output buffer pointer is not <b>NULL</b>, then these characters are copied to the output buffer.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCommonPrefix as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCompactPath">
    <summary>
      <para>Truncates a file path to fit within a given pixel width by replacing path components with ellipses.</para>
    </summary>
    <param name="hDC">
      <para>Type: <b>HDC</b></para>
      <para>A handle to the device context used for font metrics. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be modified. On return, this buffer will contain the modified string.</para>
    </param>
    <param name="dx">
      <para>Type: <b>UINT</b></para>
      <para>The width, in pixels, in which the string must fit.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path was successfully compacted to the specified width. Returns <b>FALSE</b> on failure, or if the base portion of the path would not fit the specified width.</para>
    </returns>
    <remarks>
      <para>This function uses the font currently selected in <i>hDC</i> to calculate the width of the text. This function will not compact the path beyond the base file name preceded by ellipses.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

HDC hdc;  /* display DC handle to current font metrics */

void main( void )
{
// String path name 1.
char buffer_1[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr1;
lpStr1 = buffer_1;

// String path name 2.
char buffer_2[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr2;
lpStr2 = buffer_2;

// String path name 3.
char buffer_3[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr3;
lpStr3 = buffer_3;

// String path name 4.
char buffer_4[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr4;
lpStr4 = buffer_4;

// Variable to get the return from "PathCompactPath".
int retval;

cout &lt;&lt; "The un-truncated path is                " &lt;&lt; lpStr1 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr1,125);
cout &lt;&lt; "The truncated path at 125 pixels is :   " &lt;&lt; lpStr1 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr2,120);
cout &lt;&lt; "The truncated path at 120 pixels is :   " &lt;&lt; lpStr2 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr3,110);
cout &lt;&lt; "The truncated path at 110 pixels is :   " &lt;&lt; lpStr3 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr4,25);
cout &lt;&lt; "The truncated path at  25 pixels is :   " &lt;&lt; lpStr4 &lt;&lt; endl;
}

OUTPUT:
===========
The un-truncated path is                C:\path1\path2\sample.txt
The truncated path at 125 pixels is :   C:\path1\...\sample.txt
The truncated path at 120 pixels is :   C:\pat...\sample.txt
The truncated path at 110 pixels is :   C:\p...\sample.txt
The truncated path at  25 pixels is :   ...\sample.txt
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCompactPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCompactPathA">
    <summary>
      <para>Truncates a file path to fit within a given pixel width by replacing path components with ellipses.</para>
    </summary>
    <param name="hDC">
      <para>Type: <b>HDC</b></para>
      <para>A handle to the device context used for font metrics. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be modified. On return, this buffer will contain the modified string.</para>
    </param>
    <param name="dx">
      <para>Type: <b>UINT</b></para>
      <para>The width, in pixels, in which the string must fit.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path was successfully compacted to the specified width. Returns <b>FALSE</b> on failure, or if the base portion of the path would not fit the specified width.</para>
    </returns>
    <remarks>
      <para>This function uses the font currently selected in <i>hDC</i> to calculate the width of the text. This function will not compact the path beyond the base file name preceded by ellipses.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

HDC hdc;  /* display DC handle to current font metrics */

void main( void )
{
// String path name 1.
char buffer_1[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr1;
lpStr1 = buffer_1;

// String path name 2.
char buffer_2[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr2;
lpStr2 = buffer_2;

// String path name 3.
char buffer_3[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr3;
lpStr3 = buffer_3;

// String path name 4.
char buffer_4[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr4;
lpStr4 = buffer_4;

// Variable to get the return from "PathCompactPath".
int retval;

cout &lt;&lt; "The un-truncated path is                " &lt;&lt; lpStr1 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr1,125);
cout &lt;&lt; "The truncated path at 125 pixels is :   " &lt;&lt; lpStr1 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr2,120);
cout &lt;&lt; "The truncated path at 120 pixels is :   " &lt;&lt; lpStr2 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr3,110);
cout &lt;&lt; "The truncated path at 110 pixels is :   " &lt;&lt; lpStr3 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr4,25);
cout &lt;&lt; "The truncated path at  25 pixels is :   " &lt;&lt; lpStr4 &lt;&lt; endl;
}

OUTPUT:
===========
The un-truncated path is                C:\path1\path2\sample.txt
The truncated path at 125 pixels is :   C:\path1\...\sample.txt
The truncated path at 120 pixels is :   C:\pat...\sample.txt
The truncated path at 110 pixels is :   C:\p...\sample.txt
The truncated path at  25 pixels is :   ...\sample.txt
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCompactPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCompactPathW">
    <summary>
      <para>Truncates a file path to fit within a given pixel width by replacing path components with ellipses.</para>
    </summary>
    <param name="hDC">
      <para>Type: <b>HDC</b></para>
      <para>A handle to the device context used for font metrics. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be modified. On return, this buffer will contain the modified string.</para>
    </param>
    <param name="dx">
      <para>Type: <b>UINT</b></para>
      <para>The width, in pixels, in which the string must fit.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path was successfully compacted to the specified width. Returns <b>FALSE</b> on failure, or if the base portion of the path would not fit the specified width.</para>
    </returns>
    <remarks>
      <para>This function uses the font currently selected in <i>hDC</i> to calculate the width of the text. This function will not compact the path beyond the base file name preceded by ellipses.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

HDC hdc;  /* display DC handle to current font metrics */

void main( void )
{
// String path name 1.
char buffer_1[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr1;
lpStr1 = buffer_1;

// String path name 2.
char buffer_2[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr2;
lpStr2 = buffer_2;

// String path name 3.
char buffer_3[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr3;
lpStr3 = buffer_3;

// String path name 4.
char buffer_4[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr4;
lpStr4 = buffer_4;

// Variable to get the return from "PathCompactPath".
int retval;

cout &lt;&lt; "The un-truncated path is                " &lt;&lt; lpStr1 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr1,125);
cout &lt;&lt; "The truncated path at 125 pixels is :   " &lt;&lt; lpStr1 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr2,120);
cout &lt;&lt; "The truncated path at 120 pixels is :   " &lt;&lt; lpStr2 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr3,110);
cout &lt;&lt; "The truncated path at 110 pixels is :   " &lt;&lt; lpStr3 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr4,25);
cout &lt;&lt; "The truncated path at  25 pixels is :   " &lt;&lt; lpStr4 &lt;&lt; endl;
}

OUTPUT:
===========
The un-truncated path is                C:\path1\path2\sample.txt
The truncated path at 125 pixels is :   C:\path1\...\sample.txt
The truncated path at 120 pixels is :   C:\pat...\sample.txt
The truncated path at 110 pixels is :   C:\p...\sample.txt
The truncated path at  25 pixels is :   ...\sample.txt
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCompactPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCompactPathEx">
    <summary>
      <para>Truncates a path to fit within a certain number of characters by replacing path components with ellipses.</para>
    </summary>
    <param name="pszOut">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of the string that has been altered.</para>
    </param>
    <param name="pszSrc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be altered.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>UINT</b></para>
      <para>The maximum number of characters to be contained in the new string, including the terminating null character. For example, if <i>cchMax</i> = 8, the resulting string can contain a maximum of 7 characters plus the terminating null character.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The '/' separator will be used instead of '' if the original string used it. If <i>pszSrc</i> points to a file name that is too long, instead of a path, the file name will be truncated to <i>cchMax</i> characters, including the ellipsis and the terminating <b>NULL</b> character. For example, if the input file name is "My Filename" and <i>cchMax</i> is 10, <b>PathCompactPathEx</b> will return "My Fil...".</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCompactPathEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCompactPathExA">
    <summary>
      <para>Truncates a path to fit within a certain number of characters by replacing path components with ellipses.</para>
    </summary>
    <param name="pszOut">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of the string that has been altered.</para>
    </param>
    <param name="pszSrc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be altered.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>UINT</b></para>
      <para>The maximum number of characters to be contained in the new string, including the terminating null character. For example, if <i>cchMax</i> = 8, the resulting string can contain a maximum of 7 characters plus the terminating null character.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The '/' separator will be used instead of '' if the original string used it. If <i>pszSrc</i> points to a file name that is too long, instead of a path, the file name will be truncated to <i>cchMax</i> characters, including the ellipsis and the terminating <b>NULL</b> character. For example, if the input file name is "My Filename" and <i>cchMax</i> is 10, <b>PathCompactPathEx</b> will return "My Fil...".</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCompactPathEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCompactPathExW">
    <summary>
      <para>Truncates a path to fit within a certain number of characters by replacing path components with ellipses.</para>
    </summary>
    <param name="pszOut">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of the string that has been altered.</para>
    </param>
    <param name="pszSrc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be altered.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>UINT</b></para>
      <para>The maximum number of characters to be contained in the new string, including the terminating null character. For example, if <i>cchMax</i> = 8, the resulting string can contain a maximum of 7 characters plus the terminating null character.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The '/' separator will be used instead of '' if the original string used it. If <i>pszSrc</i> points to a file name that is too long, instead of a path, the file name will be truncated to <i>cchMax</i> characters, including the ellipsis and the terminating <b>NULL</b> character. For example, if the input file name is "My Filename" and <i>cchMax</i> is 10, <b>PathCompactPathEx</b> will return "My Fil...".</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCompactPathEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCompactPathEx">
    <summary>
      <para>Truncates a path to fit within a certain number of characters by replacing path components with ellipses.</para>
    </summary>
    <param name="pszOut">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of the string that has been altered.</para>
    </param>
    <param name="pszSrc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be altered.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>UINT</b></para>
      <para>The maximum number of characters to be contained in the new string, including the terminating null character. For example, if <i>cchMax</i> = 8, the resulting string can contain a maximum of 7 characters plus the terminating null character.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The '/' separator will be used instead of '\' if the original string used it. If <i>pszSrc</i> points to a file name that is too long, instead of a path, the file name will be truncated to <i>cchMax</i> characters, including the ellipsis and the terminating <b>NULL</b> character. For example, if the input file name is "My Filename" and <i>cchMax</i> is 10, <b>PathCompactPathEx</b> will return "My Fil...".</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCompactPathEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCompactPathExA">
    <summary>
      <para>Truncates a path to fit within a certain number of characters by replacing path components with ellipses.</para>
    </summary>
    <param name="pszOut">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of the string that has been altered.</para>
    </param>
    <param name="pszSrc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be altered.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>UINT</b></para>
      <para>The maximum number of characters to be contained in the new string, including the terminating null character. For example, if <i>cchMax</i> = 8, the resulting string can contain a maximum of 7 characters plus the terminating null character.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The '/' separator will be used instead of '\' if the original string used it. If <i>pszSrc</i> points to a file name that is too long, instead of a path, the file name will be truncated to <i>cchMax</i> characters, including the ellipsis and the terminating <b>NULL</b> character. For example, if the input file name is "My Filename" and <i>cchMax</i> is 10, <b>PathCompactPathEx</b> will return "My Fil...".</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCompactPathEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCompactPathExW">
    <summary>
      <para>Truncates a path to fit within a certain number of characters by replacing path components with ellipses.</para>
    </summary>
    <param name="pszOut">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of the string that has been altered.</para>
    </param>
    <param name="pszSrc">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be altered.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>UINT</b></para>
      <para>The maximum number of characters to be contained in the new string, including the terminating null character. For example, if <i>cchMax</i> = 8, the resulting string can contain a maximum of 7 characters plus the terminating null character.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The '/' separator will be used instead of '\' if the original string used it. If <i>pszSrc</i> points to a file name that is too long, instead of a path, the file name will be truncated to <i>cchMax</i> characters, including the ellipsis and the terminating <b>NULL</b> character. For example, if the input file name is "My Filename" and <i>cchMax</i> is 10, <b>PathCompactPathEx</b> will return "My Fil...".</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCompactPathEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCompactPath">
    <summary>
      <para>Truncates a file path to fit within a given pixel width by replacing path components with ellipses.</para>
    </summary>
    <param name="hDC">
      <para>Type: <b>HDC</b></para>
      <para>A handle to the device context used for font metrics. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be modified. On return, this buffer will contain the modified string.</para>
    </param>
    <param name="dx">
      <para>Type: <b>UINT</b></para>
      <para>The width, in pixels, in which the string must fit.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path was successfully compacted to the specified width. Returns <b>FALSE</b> on failure, or if the base portion of the path would not fit the specified width.</para>
    </returns>
    <remarks>
      <para>This function uses the font currently selected in <i>hDC</i> to calculate the width of the text. This function will not compact the path beyond the base file name preceded by ellipses.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

HDC hdc;  /* display DC handle to current font metrics */

void main( void )
{
// String path name 1.
char buffer_1[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr1;
lpStr1 = buffer_1;

// String path name 2.
char buffer_2[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr2;
lpStr2 = buffer_2;

// String path name 3.
char buffer_3[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr3;
lpStr3 = buffer_3;

// String path name 4.
char buffer_4[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr4;
lpStr4 = buffer_4;

// Variable to get the return from "PathCompactPath".
int retval;

cout &lt;&lt; "The un-truncated path is                " &lt;&lt; lpStr1 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr1,125);
cout &lt;&lt; "The truncated path at 125 pixels is :   " &lt;&lt; lpStr1 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr2,120);
cout &lt;&lt; "The truncated path at 120 pixels is :   " &lt;&lt; lpStr2 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr3,110);
cout &lt;&lt; "The truncated path at 110 pixels is :   " &lt;&lt; lpStr3 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr4,25);
cout &lt;&lt; "The truncated path at  25 pixels is :   " &lt;&lt; lpStr4 &lt;&lt; endl;
}

OUTPUT:
===========
The un-truncated path is                C:\path1\path2\sample.txt
The truncated path at 125 pixels is :   C:\path1\...\sample.txt
The truncated path at 120 pixels is :   C:\pat...\sample.txt
The truncated path at 110 pixels is :   C:\p...\sample.txt
The truncated path at  25 pixels is :   ...\sample.txt
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCompactPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCompactPathA">
    <summary>
      <para>Truncates a file path to fit within a given pixel width by replacing path components with ellipses.</para>
    </summary>
    <param name="hDC">
      <para>Type: <b>HDC</b></para>
      <para>A handle to the device context used for font metrics. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be modified. On return, this buffer will contain the modified string.</para>
    </param>
    <param name="dx">
      <para>Type: <b>UINT</b></para>
      <para>The width, in pixels, in which the string must fit.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path was successfully compacted to the specified width. Returns <b>FALSE</b> on failure, or if the base portion of the path would not fit the specified width.</para>
    </returns>
    <remarks>
      <para>This function uses the font currently selected in <i>hDC</i> to calculate the width of the text. This function will not compact the path beyond the base file name preceded by ellipses.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

HDC hdc;  /* display DC handle to current font metrics */

void main( void )
{
// String path name 1.
char buffer_1[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr1;
lpStr1 = buffer_1;

// String path name 2.
char buffer_2[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr2;
lpStr2 = buffer_2;

// String path name 3.
char buffer_3[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr3;
lpStr3 = buffer_3;

// String path name 4.
char buffer_4[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr4;
lpStr4 = buffer_4;

// Variable to get the return from "PathCompactPath".
int retval;

cout &lt;&lt; "The un-truncated path is                " &lt;&lt; lpStr1 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr1,125);
cout &lt;&lt; "The truncated path at 125 pixels is :   " &lt;&lt; lpStr1 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr2,120);
cout &lt;&lt; "The truncated path at 120 pixels is :   " &lt;&lt; lpStr2 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr3,110);
cout &lt;&lt; "The truncated path at 110 pixels is :   " &lt;&lt; lpStr3 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr4,25);
cout &lt;&lt; "The truncated path at  25 pixels is :   " &lt;&lt; lpStr4 &lt;&lt; endl;
}

OUTPUT:
===========
The un-truncated path is                C:\path1\path2\sample.txt
The truncated path at 125 pixels is :   C:\path1\...\sample.txt
The truncated path at 120 pixels is :   C:\pat...\sample.txt
The truncated path at 110 pixels is :   C:\p...\sample.txt
The truncated path at  25 pixels is :   ...\sample.txt
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCompactPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCompactPathW">
    <summary>
      <para>Truncates a file path to fit within a given pixel width by replacing path components with ellipses.</para>
    </summary>
    <param name="hDC">
      <para>Type: <b>HDC</b></para>
      <para>A handle to the device context used for font metrics. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be modified. On return, this buffer will contain the modified string.</para>
    </param>
    <param name="dx">
      <para>Type: <b>UINT</b></para>
      <para>The width, in pixels, in which the string must fit.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path was successfully compacted to the specified width. Returns <b>FALSE</b> on failure, or if the base portion of the path would not fit the specified width.</para>
    </returns>
    <remarks>
      <para>This function uses the font currently selected in <i>hDC</i> to calculate the width of the text. This function will not compact the path beyond the base file name preceded by ellipses.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

HDC hdc;  /* display DC handle to current font metrics */

void main( void )
{
// String path name 1.
char buffer_1[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr1;
lpStr1 = buffer_1;

// String path name 2.
char buffer_2[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr2;
lpStr2 = buffer_2;

// String path name 3.
char buffer_3[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr3;
lpStr3 = buffer_3;

// String path name 4.
char buffer_4[MAX_PATH] = "C:\\path1\\path2\\sample.txt";
char *lpStr4;
lpStr4 = buffer_4;

// Variable to get the return from "PathCompactPath".
int retval;

cout &lt;&lt; "The un-truncated path is                " &lt;&lt; lpStr1 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr1,125);
cout &lt;&lt; "The truncated path at 125 pixels is :   " &lt;&lt; lpStr1 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr2,120);
cout &lt;&lt; "The truncated path at 120 pixels is :   " &lt;&lt; lpStr2 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr3,110);
cout &lt;&lt; "The truncated path at 110 pixels is :   " &lt;&lt; lpStr3 &lt;&lt; endl;

retval = PathCompactPath(hdc,lpStr4,25);
cout &lt;&lt; "The truncated path at  25 pixels is :   " &lt;&lt; lpStr4 &lt;&lt; endl;
}

OUTPUT:
===========
The un-truncated path is                C:\path1\path2\sample.txt
The truncated path at 125 pixels is :   C:\path1\...\sample.txt
The truncated path at 120 pixels is :   C:\pat...\sample.txt
The truncated path at 110 pixels is :   C:\p...\sample.txt
The truncated path at  25 pixels is :   ...\sample.txt
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCompactPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCreateFromUrl">
    <summary>
      <para>Converts a file URL to a Microsoft MS-DOS path.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the MS-DOS path. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pcchPath">
      <para>Type: <b>DWORD*</b></para>
      <para>The number of characters in the <i>pszPath</i> buffer.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Set this parameter to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCreateFromUrl as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCreateFromUrlA">
    <summary>
      <para>Converts a file URL to a Microsoft MS-DOS path.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the MS-DOS path. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pcchPath">
      <para>Type: <b>DWORD*</b></para>
      <para>The number of characters in the <i>pszPath</i> buffer.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Set this parameter to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCreateFromUrl as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCreateFromUrlW">
    <summary>
      <para>Converts a file URL to a Microsoft MS-DOS path.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the MS-DOS path. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pcchPath">
      <para>Type: <b>DWORD*</b></para>
      <para>The number of characters in the <i>pszPath</i> buffer.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Set this parameter to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCreateFromUrl as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCreateFromUrlAlloc">
    <summary>
      <para>Creates a path from a file URL.</para>
    </summary>
    <param name="pszIn">
      <para>Type: <b>PCWSTR</b></para>
      <para>A pointer to the URL of a file, represented as a null-terminated, Unicode string.</para>
    </param>
    <param name="ppszOut">
      <para>Type: <b>PWSTR*</b></para>
      <para>The address of a pointer to a buffer of length MAX_PATH that, when this function returns successfully, receives the file path.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved, must be 0.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
  </member>
  <member name="Windows.PathCreateFromUrl">
    <summary>
      <para>Converts a file URL to a Microsoft MS-DOS path.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the MS-DOS path. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pcchPath">
      <para>Type: <b>DWORD*</b></para>
      <para>The number of characters in the <i>pszPath</i> buffer.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Set this parameter to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCreateFromUrl as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCreateFromUrlA">
    <summary>
      <para>Converts a file URL to a Microsoft MS-DOS path.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the MS-DOS path. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pcchPath">
      <para>Type: <b>DWORD*</b></para>
      <para>The number of characters in the <i>pszPath</i> buffer.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Set this parameter to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCreateFromUrl as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathCreateFromUrlW">
    <summary>
      <para>Converts a file URL to a Microsoft MS-DOS path.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the MS-DOS path. You must set the size of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="pcchPath">
      <para>Type: <b>DWORD*</b></para>
      <para>The number of characters in the <i>pszPath</i> buffer.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Set this parameter to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathCreateFromUrl as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFileExists">
    <summary>
      <para>Determines whether a path to a file system object such as a file or folder is valid.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the full path of the object to verify.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if the file exists; otherwise, <b>FALSE</b>. Call <see cref="GetLastError" /> for extended error information.</para>
    </returns>
    <remarks>
      <para>This function tests the validity of the path.</para>
      <para>A path specified by Universal Naming Convention (UNC) is limited to a file only; that is, \server\share\file is permitted. A UNC path to a server or server share is not permitted; that is, \server or \server\share. This function returns <b>FALSE</b> if a mounted remote drive is out of service.</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
    // Valid file path name (file is there).
    char buffer_1[ ] = "C:\\TEST\\file.txt";
    char *lpStr1;
    lpStr1 = buffer_1;

    // Invalid file path name (file is not there).
    char buffer_2[ ] = "C:\\TEST\\file.doc";
    char *lpStr2;
    lpStr2 = buffer_2;

    // Return value from "PathFileExists".
    int retval;

    // Search for the presence of a file with a true result.
    retval = PathFileExists(lpStr1);
    if(retval == 1)
    {
        cout &lt;&lt; "Search for the file path of : " &lt;&lt; lpStr1 &lt;&lt; endl;
        cout &lt;&lt; "The file requested \"" &lt;&lt; lpStr1 &lt;&lt; "\" is a valid file" &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }

    else
    {
        cout &lt;&lt; "\nThe file requested " &lt;&lt; lpStr1 &lt;&lt; " is not a valid file" &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }

    // Search for the presence of a file with a false result.
    retval = PathFileExists(lpStr2);

    if(retval == 1)
    {
        cout &lt;&lt; "\nThe file requested " &lt;&lt; lpStr2 &lt;&lt; "is a valid file" &lt;&lt; endl;
        cout &lt;&lt; "Search for the file path of : " &lt;&lt; lpStr2 &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; "\nThe file requested \"" &lt;&lt; lpStr2 &lt;&lt; "\" is not a valid file" &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }
}

OUTPUT
==============
Search for the file path of : C:\TEST\file.txt
The file requested "C:\TEST\file.txt" is a valid file
The return from function is : 1

The file requested "C:\TEST\file.doc" is not a valid file
The return from function is : 0
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFileExists as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFileExistsA">
    <summary>
      <para>Determines whether a path to a file system object such as a file or folder is valid.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the full path of the object to verify.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if the file exists; otherwise, <b>FALSE</b>. Call <see cref="GetLastError" /> for extended error information.</para>
    </returns>
    <remarks>
      <para>This function tests the validity of the path.</para>
      <para>A path specified by Universal Naming Convention (UNC) is limited to a file only; that is, \server\share\file is permitted. A UNC path to a server or server share is not permitted; that is, \server or \server\share. This function returns <b>FALSE</b> if a mounted remote drive is out of service.</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
    // Valid file path name (file is there).
    char buffer_1[ ] = "C:\\TEST\\file.txt";
    char *lpStr1;
    lpStr1 = buffer_1;

    // Invalid file path name (file is not there).
    char buffer_2[ ] = "C:\\TEST\\file.doc";
    char *lpStr2;
    lpStr2 = buffer_2;

    // Return value from "PathFileExists".
    int retval;

    // Search for the presence of a file with a true result.
    retval = PathFileExists(lpStr1);
    if(retval == 1)
    {
        cout &lt;&lt; "Search for the file path of : " &lt;&lt; lpStr1 &lt;&lt; endl;
        cout &lt;&lt; "The file requested \"" &lt;&lt; lpStr1 &lt;&lt; "\" is a valid file" &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }

    else
    {
        cout &lt;&lt; "\nThe file requested " &lt;&lt; lpStr1 &lt;&lt; " is not a valid file" &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }

    // Search for the presence of a file with a false result.
    retval = PathFileExists(lpStr2);

    if(retval == 1)
    {
        cout &lt;&lt; "\nThe file requested " &lt;&lt; lpStr2 &lt;&lt; "is a valid file" &lt;&lt; endl;
        cout &lt;&lt; "Search for the file path of : " &lt;&lt; lpStr2 &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; "\nThe file requested \"" &lt;&lt; lpStr2 &lt;&lt; "\" is not a valid file" &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }
}

OUTPUT
==============
Search for the file path of : C:\TEST\file.txt
The file requested "C:\TEST\file.txt" is a valid file
The return from function is : 1

The file requested "C:\TEST\file.doc" is not a valid file
The return from function is : 0
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFileExists as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFileExistsW">
    <summary>
      <para>Determines whether a path to a file system object such as a file or folder is valid.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the full path of the object to verify.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if the file exists; otherwise, <b>FALSE</b>. Call <see cref="GetLastError" /> for extended error information.</para>
    </returns>
    <remarks>
      <para>This function tests the validity of the path.</para>
      <para>A path specified by Universal Naming Convention (UNC) is limited to a file only; that is, \server\share\file is permitted. A UNC path to a server or server share is not permitted; that is, \server or \server\share. This function returns <b>FALSE</b> if a mounted remote drive is out of service.</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
    // Valid file path name (file is there).
    char buffer_1[ ] = "C:\\TEST\\file.txt";
    char *lpStr1;
    lpStr1 = buffer_1;

    // Invalid file path name (file is not there).
    char buffer_2[ ] = "C:\\TEST\\file.doc";
    char *lpStr2;
    lpStr2 = buffer_2;

    // Return value from "PathFileExists".
    int retval;

    // Search for the presence of a file with a true result.
    retval = PathFileExists(lpStr1);
    if(retval == 1)
    {
        cout &lt;&lt; "Search for the file path of : " &lt;&lt; lpStr1 &lt;&lt; endl;
        cout &lt;&lt; "The file requested \"" &lt;&lt; lpStr1 &lt;&lt; "\" is a valid file" &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }

    else
    {
        cout &lt;&lt; "\nThe file requested " &lt;&lt; lpStr1 &lt;&lt; " is not a valid file" &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }

    // Search for the presence of a file with a false result.
    retval = PathFileExists(lpStr2);

    if(retval == 1)
    {
        cout &lt;&lt; "\nThe file requested " &lt;&lt; lpStr2 &lt;&lt; "is a valid file" &lt;&lt; endl;
        cout &lt;&lt; "Search for the file path of : " &lt;&lt; lpStr2 &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; "\nThe file requested \"" &lt;&lt; lpStr2 &lt;&lt; "\" is not a valid file" &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }
}

OUTPUT
==============
Search for the file path of : C:\TEST\file.txt
The file requested "C:\TEST\file.txt" is a valid file
The return from function is : 1

The file requested "C:\TEST\file.doc" is not a valid file
The return from function is : 0
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFileExists as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFileExists">
    <summary>
      <para>Determines whether a path to a file system object such as a file or folder is valid.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the full path of the object to verify.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if the file exists; otherwise, <b>FALSE</b>. Call <see cref="GetLastError" /> for extended error information. If the file does not exist, <see cref="GetLastError" /> will return <a href="https://docs.microsoft.com//windows/win32/debug/system-error-codes--0-499-">ERROR_FILE_NOT_FOUND</a>.</para>
    </returns>
    <remarks>
      <para>This function tests the validity of the path.</para>
      <para>A path specified by Universal Naming Convention (UNC) is limited to a file only; that is, \server\share\file is permitted. A UNC path to a server or server share is not permitted; that is, \server or \server\share. This function returns <b>FALSE</b> if a mounted remote drive is out of service.</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
    // Valid file path name (file is there).
    char buffer_1[ ] = "C:\\TEST\\file.txt";
    char *lpStr1;
    lpStr1 = buffer_1;

    // Invalid file path name (file is not there).
    char buffer_2[ ] = "C:\\TEST\\file.doc";
    char *lpStr2;
    lpStr2 = buffer_2;

    // Return value from "PathFileExists".
    int retval;

    // Search for the presence of a file with a true result.
    retval = PathFileExists(lpStr1);
    if(retval == 1)
    {
        cout &lt;&lt; "Search for the file path of : " &lt;&lt; lpStr1 &lt;&lt; endl;
        cout &lt;&lt; "The file requested \"" &lt;&lt; lpStr1 &lt;&lt; "\" is a valid file" &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }

    else
    {
        cout &lt;&lt; "\nThe file requested " &lt;&lt; lpStr1 &lt;&lt; " is not a valid file" &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }

    // Search for the presence of a file with a false result.
    retval = PathFileExists(lpStr2);

    if(retval == 1)
    {
        cout &lt;&lt; "\nThe file requested " &lt;&lt; lpStr2 &lt;&lt; "is a valid file" &lt;&lt; endl;
        cout &lt;&lt; "Search for the file path of : " &lt;&lt; lpStr2 &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; "\nThe file requested \"" &lt;&lt; lpStr2 &lt;&lt; "\" is not a valid file" &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }
}

OUTPUT
==============
Search for the file path of : C:\TEST\file.txt
The file requested "C:\TEST\file.txt" is a valid file
The return from function is : 1

The file requested "C:\TEST\file.doc" is not a valid file
The return from function is : 0
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFileExists as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFileExistsA">
    <summary>
      <para>Determines whether a path to a file system object such as a file or folder is valid.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the full path of the object to verify.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if the file exists; otherwise, <b>FALSE</b>. Call <see cref="GetLastError" /> for extended error information. If the file does not exist, <see cref="GetLastError" /> will return <a href="https://docs.microsoft.com//windows/win32/debug/system-error-codes--0-499-">ERROR_FILE_NOT_FOUND</a>.</para>
    </returns>
    <remarks>
      <para>This function tests the validity of the path.</para>
      <para>A path specified by Universal Naming Convention (UNC) is limited to a file only; that is, \server\share\file is permitted. A UNC path to a server or server share is not permitted; that is, \server or \server\share. This function returns <b>FALSE</b> if a mounted remote drive is out of service.</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
    // Valid file path name (file is there).
    char buffer_1[ ] = "C:\\TEST\\file.txt";
    char *lpStr1;
    lpStr1 = buffer_1;

    // Invalid file path name (file is not there).
    char buffer_2[ ] = "C:\\TEST\\file.doc";
    char *lpStr2;
    lpStr2 = buffer_2;

    // Return value from "PathFileExists".
    int retval;

    // Search for the presence of a file with a true result.
    retval = PathFileExists(lpStr1);
    if(retval == 1)
    {
        cout &lt;&lt; "Search for the file path of : " &lt;&lt; lpStr1 &lt;&lt; endl;
        cout &lt;&lt; "The file requested \"" &lt;&lt; lpStr1 &lt;&lt; "\" is a valid file" &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }

    else
    {
        cout &lt;&lt; "\nThe file requested " &lt;&lt; lpStr1 &lt;&lt; " is not a valid file" &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }

    // Search for the presence of a file with a false result.
    retval = PathFileExists(lpStr2);

    if(retval == 1)
    {
        cout &lt;&lt; "\nThe file requested " &lt;&lt; lpStr2 &lt;&lt; "is a valid file" &lt;&lt; endl;
        cout &lt;&lt; "Search for the file path of : " &lt;&lt; lpStr2 &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; "\nThe file requested \"" &lt;&lt; lpStr2 &lt;&lt; "\" is not a valid file" &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }
}

OUTPUT
==============
Search for the file path of : C:\TEST\file.txt
The file requested "C:\TEST\file.txt" is a valid file
The return from function is : 1

The file requested "C:\TEST\file.doc" is not a valid file
The return from function is : 0
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFileExists as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFileExistsW">
    <summary>
      <para>Determines whether a path to a file system object such as a file or folder is valid.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the full path of the object to verify.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if the file exists; otherwise, <b>FALSE</b>. Call <see cref="GetLastError" /> for extended error information. If the file does not exist, <see cref="GetLastError" /> will return <a href="https://docs.microsoft.com//windows/win32/debug/system-error-codes--0-499-">ERROR_FILE_NOT_FOUND</a>.</para>
    </returns>
    <remarks>
      <para>This function tests the validity of the path.</para>
      <para>A path specified by Universal Naming Convention (UNC) is limited to a file only; that is, \server\share\file is permitted. A UNC path to a server or server share is not permitted; that is, \server or \server\share. This function returns <b>FALSE</b> if a mounted remote drive is out of service.</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
    // Valid file path name (file is there).
    char buffer_1[ ] = "C:\\TEST\\file.txt";
    char *lpStr1;
    lpStr1 = buffer_1;

    // Invalid file path name (file is not there).
    char buffer_2[ ] = "C:\\TEST\\file.doc";
    char *lpStr2;
    lpStr2 = buffer_2;

    // Return value from "PathFileExists".
    int retval;

    // Search for the presence of a file with a true result.
    retval = PathFileExists(lpStr1);
    if(retval == 1)
    {
        cout &lt;&lt; "Search for the file path of : " &lt;&lt; lpStr1 &lt;&lt; endl;
        cout &lt;&lt; "The file requested \"" &lt;&lt; lpStr1 &lt;&lt; "\" is a valid file" &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }

    else
    {
        cout &lt;&lt; "\nThe file requested " &lt;&lt; lpStr1 &lt;&lt; " is not a valid file" &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }

    // Search for the presence of a file with a false result.
    retval = PathFileExists(lpStr2);

    if(retval == 1)
    {
        cout &lt;&lt; "\nThe file requested " &lt;&lt; lpStr2 &lt;&lt; "is a valid file" &lt;&lt; endl;
        cout &lt;&lt; "Search for the file path of : " &lt;&lt; lpStr2 &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; "\nThe file requested \"" &lt;&lt; lpStr2 &lt;&lt; "\" is not a valid file" &lt;&lt; endl;
        cout &lt;&lt; "The return from function is : " &lt;&lt; retval &lt;&lt; endl;
    }
}

OUTPUT
==============
Search for the file path of : C:\TEST\file.txt
The file requested "C:\TEST\file.txt" is a valid file
The return from function is : 1

The file requested "C:\TEST\file.doc" is not a valid file
The return from function is : 0
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFileExists as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindExtension">
    <summary>
      <para>Searches a path for an extension.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search, including the extension being searched for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the "." that precedes the extension within <i>pszPath</i> if an extension is found, or the address of the terminating null character otherwise.</para>
    </returns>
    <remarks>
      <para>Note that a valid file name extension cannot contain a space. For more information on valid file name extensions, see <a href="https://docs.microsoft.com//windows/desktop/shell/fa-file-extensions">File Type Handlers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindExtensionA">
    <summary>
      <para>Searches a path for an extension.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search, including the extension being searched for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the "." that precedes the extension within <i>pszPath</i> if an extension is found, or the address of the terminating null character otherwise.</para>
    </returns>
    <remarks>
      <para>Note that a valid file name extension cannot contain a space. For more information on valid file name extensions, see <a href="https://docs.microsoft.com//windows/desktop/shell/fa-file-extensions">File Type Handlers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindExtensionW">
    <summary>
      <para>Searches a path for an extension.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search, including the extension being searched for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the "." that precedes the extension within <i>pszPath</i> if an extension is found, or the address of the terminating null character otherwise.</para>
    </returns>
    <remarks>
      <para>Note that a valid file name extension cannot contain a space. For more information on valid file name extensions, see <a href="https://docs.microsoft.com//windows/desktop/shell/fa-file-extensions">File Type Handlers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindExtension">
    <summary>
      <para>Searches a path for an extension.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search, including the extension being searched for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the "." that precedes the extension within <i>pszPath</i> if an extension is found, or the address of the terminating null character otherwise.</para>
    </returns>
    <remarks>
      <para>Note that a valid file name extension cannot contain a space. For more information on valid file name extensions, see <a href="https://docs.microsoft.com//windows/desktop/shell/fa-file-extensions">File Type Handlers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindExtensionA">
    <summary>
      <para>Searches a path for an extension.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search, including the extension being searched for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the "." that precedes the extension within <i>pszPath</i> if an extension is found, or the address of the terminating null character otherwise.</para>
    </returns>
    <remarks>
      <para>Note that a valid file name extension cannot contain a space. For more information on valid file name extensions, see <a href="https://docs.microsoft.com//windows/desktop/shell/fa-file-extensions">File Type Handlers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindExtensionW">
    <summary>
      <para>Searches a path for an extension.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search, including the extension being searched for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the "." that precedes the extension within <i>pszPath</i> if an extension is found, or the address of the terminating null character otherwise.</para>
    </returns>
    <remarks>
      <para>Note that a valid file name extension cannot contain a space. For more information on valid file name extensions, see <a href="https://docs.microsoft.com//windows/desktop/shell/fa-file-extensions">File Type Handlers</a>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindFileName">
    <summary>
      <para>Searches a path for a file name.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the address of the string if successful, or a pointer to the beginning of the path otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindFileNameA">
    <summary>
      <para>Searches a path for a file name.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the address of the string if successful, or a pointer to the beginning of the path otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindFileNameW">
    <summary>
      <para>Searches a path for a file name.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the address of the string if successful, or a pointer to the beginning of the path otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindFileName">
    <summary>
      <para>Searches a path for a file name.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the address of the string if successful, or a pointer to the beginning of the path otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindFileNameA">
    <summary>
      <para>Searches a path for a file name.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the address of the string if successful, or a pointer to the beginning of the path otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindFileNameW">
    <summary>
      <para>Searches a path for a file name.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the address of the string if successful, or a pointer to the beginning of the path otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindNextComponent">
    <summary>
      <para>Parses a path and returns the portion of that path that follows the first backslash.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path to parse. This string must not be longer than MAX_PATH characters, plus the terminating null character. Path components are delimited by backslashes. For instance, the path "c:\path1\path2\file.txt" has four components: c:, path1, path2, and file.txt.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to a null-terminated string that contains the truncated path.</para>
      <para>If <i>pszPath</i> points to the last component in the path, this function returns a pointer to the terminating null character.</para>
      <para>If <i>pszPath</i> points to the terminating null character or if the call fails, this function returns <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>PathFindNextComponent</b>  walks a path string until it encounters a backslash ("\"), ignores everything up to that point including the backslash, and returns the rest of the path. Therefore, if a path begins with a backslash (such as \path1\path2), the function simply removes the initial backslash and returns the rest (path1\path2).</para>
      <h4>Examples</h4>
      <para>The following simple console application passes various strings to <b>PathFindNextComponent</b> to demonstrate what the function recognizes as a path component and to show what is returned. To run this code in Visual Studio, you must link to Shlwapi.lib and define UNICODE in the preprocessor commands in the project settings.</para>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include &lt;shlwapi.h&gt;

#pragma comment(lib, "shlwapi.lib")     // Link to this file.

int main()
{
    using namespace std;

    PCWSTR path = L"c:\\path1\\path2\\file.txt";

    // This loop passes a full path to PathFindNextComponent and feeds the
    // results of that call back into the function until the entire path has
    // been walked.
    while (path)
    {
        PCWSTR oldPath = path;
        path = PathFindNextComponent(path);

        // The path variable pointed to the terminating null character.
        if (path == NULL)
        {
            wcout &lt;&lt; L"The terminating null character returns NULL\n\n";
        }
        // The path variable pointed to a path with only one component.
        else if (*path == 0)
        {
            wcout &lt;&lt; L"The path " &lt;&lt; oldPath
                  &lt;&lt; L" returns a pointer to the terminating null character\n";
        }
        else
        {
            wcout &lt;&lt; L"The path " &lt;&lt; oldPath &lt;&lt; L" returns " &lt;&lt; path &lt;&lt; L"\n";
        }
    }

    // These calls demonstrate the results of different path forms.
    // Note that where those paths begin with backslashes, those
    // backslashes are merely stripped away and the entire path is returned.

    PCWSTR path1 = L"\\path1";

    wcout &lt;&lt; L"The path " &lt;&lt; path1 &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(path1);

    PCWSTR path2 = L"\\path1\\path2";

    wcout &lt;&lt; L"\nThe path " &lt;&lt; path2 &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(path2);

    PCWSTR path3 = L"path1\\path2";

    wcout &lt;&lt; L"\nThe path " &lt;&lt; path3 &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(path3);

    wcout &lt;&lt; L"\nThe path " &lt;&lt; L"c:\\file.txt" &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(L"c:\\file.txt");

    return 0;
}

OUTPUT:
===========
The path c:\path1\path2\file.txt returns path1\path2\file.txt
The path path1\path2\file.txt returns path2\file.txt
The path path2\file.txt returns file.txt
The path file.txt returns a pointer to the terminating null character
The terminating null character returns NULL

The path \path1 returns path1
The path \path1\path2 returns path1\path2
The path path1\path2 returns path2
The path c:\file.txt returns file.txt
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindNextComponent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindNextComponentA">
    <summary>
      <para>Parses a path and returns the portion of that path that follows the first backslash.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path to parse. This string must not be longer than MAX_PATH characters, plus the terminating null character. Path components are delimited by backslashes. For instance, the path "c:\path1\path2\file.txt" has four components: c:, path1, path2, and file.txt.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to a null-terminated string that contains the truncated path.</para>
      <para>If <i>pszPath</i> points to the last component in the path, this function returns a pointer to the terminating null character.</para>
      <para>If <i>pszPath</i> points to the terminating null character or if the call fails, this function returns <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>PathFindNextComponent</b>  walks a path string until it encounters a backslash ("\"), ignores everything up to that point including the backslash, and returns the rest of the path. Therefore, if a path begins with a backslash (such as \path1\path2), the function simply removes the initial backslash and returns the rest (path1\path2).</para>
      <h4>Examples</h4>
      <para>The following simple console application passes various strings to <b>PathFindNextComponent</b> to demonstrate what the function recognizes as a path component and to show what is returned. To run this code in Visual Studio, you must link to Shlwapi.lib and define UNICODE in the preprocessor commands in the project settings.</para>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include &lt;shlwapi.h&gt;

#pragma comment(lib, "shlwapi.lib")     // Link to this file.

int main()
{
    using namespace std;

    PCWSTR path = L"c:\\path1\\path2\\file.txt";

    // This loop passes a full path to PathFindNextComponent and feeds the
    // results of that call back into the function until the entire path has
    // been walked.
    while (path)
    {
        PCWSTR oldPath = path;
        path = PathFindNextComponent(path);

        // The path variable pointed to the terminating null character.
        if (path == NULL)
        {
            wcout &lt;&lt; L"The terminating null character returns NULL\n\n";
        }
        // The path variable pointed to a path with only one component.
        else if (*path == 0)
        {
            wcout &lt;&lt; L"The path " &lt;&lt; oldPath
                  &lt;&lt; L" returns a pointer to the terminating null character\n";
        }
        else
        {
            wcout &lt;&lt; L"The path " &lt;&lt; oldPath &lt;&lt; L" returns " &lt;&lt; path &lt;&lt; L"\n";
        }
    }

    // These calls demonstrate the results of different path forms.
    // Note that where those paths begin with backslashes, those
    // backslashes are merely stripped away and the entire path is returned.

    PCWSTR path1 = L"\\path1";

    wcout &lt;&lt; L"The path " &lt;&lt; path1 &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(path1);

    PCWSTR path2 = L"\\path1\\path2";

    wcout &lt;&lt; L"\nThe path " &lt;&lt; path2 &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(path2);

    PCWSTR path3 = L"path1\\path2";

    wcout &lt;&lt; L"\nThe path " &lt;&lt; path3 &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(path3);

    wcout &lt;&lt; L"\nThe path " &lt;&lt; L"c:\\file.txt" &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(L"c:\\file.txt");

    return 0;
}

OUTPUT:
===========
The path c:\path1\path2\file.txt returns path1\path2\file.txt
The path path1\path2\file.txt returns path2\file.txt
The path path2\file.txt returns file.txt
The path file.txt returns a pointer to the terminating null character
The terminating null character returns NULL

The path \path1 returns path1
The path \path1\path2 returns path1\path2
The path path1\path2 returns path2
The path c:\file.txt returns file.txt
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindNextComponent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindNextComponentW">
    <summary>
      <para>Parses a path and returns the portion of that path that follows the first backslash.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path to parse. This string must not be longer than MAX_PATH characters, plus the terminating null character. Path components are delimited by backslashes. For instance, the path "c:\path1\path2\file.txt" has four components: c:, path1, path2, and file.txt.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to a null-terminated string that contains the truncated path.</para>
      <para>If <i>pszPath</i> points to the last component in the path, this function returns a pointer to the terminating null character.</para>
      <para>If <i>pszPath</i> points to the terminating null character or if the call fails, this function returns <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>PathFindNextComponent</b>  walks a path string until it encounters a backslash ("\"), ignores everything up to that point including the backslash, and returns the rest of the path. Therefore, if a path begins with a backslash (such as \path1\path2), the function simply removes the initial backslash and returns the rest (path1\path2).</para>
      <h4>Examples</h4>
      <para>The following simple console application passes various strings to <b>PathFindNextComponent</b> to demonstrate what the function recognizes as a path component and to show what is returned. To run this code in Visual Studio, you must link to Shlwapi.lib and define UNICODE in the preprocessor commands in the project settings.</para>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include &lt;shlwapi.h&gt;

#pragma comment(lib, "shlwapi.lib")     // Link to this file.

int main()
{
    using namespace std;

    PCWSTR path = L"c:\\path1\\path2\\file.txt";

    // This loop passes a full path to PathFindNextComponent and feeds the
    // results of that call back into the function until the entire path has
    // been walked.
    while (path)
    {
        PCWSTR oldPath = path;
        path = PathFindNextComponent(path);

        // The path variable pointed to the terminating null character.
        if (path == NULL)
        {
            wcout &lt;&lt; L"The terminating null character returns NULL\n\n";
        }
        // The path variable pointed to a path with only one component.
        else if (*path == 0)
        {
            wcout &lt;&lt; L"The path " &lt;&lt; oldPath
                  &lt;&lt; L" returns a pointer to the terminating null character\n";
        }
        else
        {
            wcout &lt;&lt; L"The path " &lt;&lt; oldPath &lt;&lt; L" returns " &lt;&lt; path &lt;&lt; L"\n";
        }
    }

    // These calls demonstrate the results of different path forms.
    // Note that where those paths begin with backslashes, those
    // backslashes are merely stripped away and the entire path is returned.

    PCWSTR path1 = L"\\path1";

    wcout &lt;&lt; L"The path " &lt;&lt; path1 &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(path1);

    PCWSTR path2 = L"\\path1\\path2";

    wcout &lt;&lt; L"\nThe path " &lt;&lt; path2 &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(path2);

    PCWSTR path3 = L"path1\\path2";

    wcout &lt;&lt; L"\nThe path " &lt;&lt; path3 &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(path3);

    wcout &lt;&lt; L"\nThe path " &lt;&lt; L"c:\\file.txt" &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(L"c:\\file.txt");

    return 0;
}

OUTPUT:
===========
The path c:\path1\path2\file.txt returns path1\path2\file.txt
The path path1\path2\file.txt returns path2\file.txt
The path path2\file.txt returns file.txt
The path file.txt returns a pointer to the terminating null character
The terminating null character returns NULL

The path \path1 returns path1
The path \path1\path2 returns path1\path2
The path path1\path2 returns path2
The path c:\file.txt returns file.txt
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindNextComponent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindNextComponent">
    <summary>
      <para>Parses a path and returns the portion of that path that follows the first backslash.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path to parse. This string must not be longer than MAX_PATH characters, plus the terminating null character. Path components are delimited by backslashes. For instance, the path "c:\path1\path2\file.txt" has four components: c:, path1, path2, and file.txt.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to a null-terminated string that contains the truncated path.</para>
      <para>If <i>pszPath</i> points to the last component in the path, this function returns a pointer to the terminating null character.</para>
      <para>If <i>pszPath</i> points to the terminating null character or if the call fails, this function returns <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>PathFindNextComponent</b>  walks a path string until it encounters a backslash ("\"), ignores everything up to that point including the backslash, and returns the rest of the path. Therefore, if a path begins with a backslash (such as \path1\path2), the function simply removes the initial backslash and returns the rest (path1\path2).</para>
      <h4>Examples</h4>
      <para>The following simple console application passes various strings to <b>PathFindNextComponent</b> to demonstrate what the function recognizes as a path component and to show what is returned. To run this code in Visual Studio, you must link to Shlwapi.lib and define UNICODE in the preprocessor commands in the project settings.</para>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include &lt;shlwapi.h&gt;

#pragma comment(lib, "shlwapi.lib")     // Link to this file.

int main()
{
    using namespace std;

    PCWSTR path = L"c:\\path1\\path2\\file.txt";

    // This loop passes a full path to PathFindNextComponent and feeds the
    // results of that call back into the function until the entire path has
    // been walked.
    while (path)
    {
        PCWSTR oldPath = path;
        path = PathFindNextComponent(path);

        // The path variable pointed to the terminating null character.
        if (path == NULL)
        {
            wcout &lt;&lt; L"The terminating null character returns NULL\n\n";
        }
        // The path variable pointed to a path with only one component.
        else if (*path == 0)
        {
            wcout &lt;&lt; L"The path " &lt;&lt; oldPath
                  &lt;&lt; L" returns a pointer to the terminating null character\n";
        }
        else
        {
            wcout &lt;&lt; L"The path " &lt;&lt; oldPath &lt;&lt; L" returns " &lt;&lt; path &lt;&lt; L"\n";
        }
    }

    // These calls demonstrate the results of different path forms.
    // Note that where those paths begin with backslashes, those
    // backslashes are merely stripped away and the entire path is returned.

    PCWSTR path1 = L"\\path1";

    wcout &lt;&lt; L"The path " &lt;&lt; path1 &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(path1);

    PCWSTR path2 = L"\\path1\\path2";

    wcout &lt;&lt; L"\nThe path " &lt;&lt; path2 &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(path2);

    PCWSTR path3 = L"path1\\path2";

    wcout &lt;&lt; L"\nThe path " &lt;&lt; path3 &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(path3);

    wcout &lt;&lt; L"\nThe path " &lt;&lt; L"c:\\file.txt" &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(L"c:\\file.txt");

    return 0;
}

OUTPUT:
===========
The path c:\path1\path2\file.txt returns path1\path2\file.txt
The path path1\path2\file.txt returns path2\file.txt
The path path2\file.txt returns file.txt
The path file.txt returns a pointer to the terminating null character
The terminating null character returns NULL

The path \path1 returns path1
The path \path1\path2 returns path1\path2
The path path1\path2 returns path2
The path c:\file.txt returns file.txt
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindNextComponent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindNextComponentA">
    <summary>
      <para>Parses a path and returns the portion of that path that follows the first backslash.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path to parse. This string must not be longer than MAX_PATH characters, plus the terminating null character. Path components are delimited by backslashes. For instance, the path "c:\path1\path2\file.txt" has four components: c:, path1, path2, and file.txt.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to a null-terminated string that contains the truncated path.</para>
      <para>If <i>pszPath</i> points to the last component in the path, this function returns a pointer to the terminating null character.</para>
      <para>If <i>pszPath</i> points to the terminating null character or if the call fails, this function returns <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>PathFindNextComponent</b>  walks a path string until it encounters a backslash ("\"), ignores everything up to that point including the backslash, and returns the rest of the path. Therefore, if a path begins with a backslash (such as \path1\path2), the function simply removes the initial backslash and returns the rest (path1\path2).</para>
      <h4>Examples</h4>
      <para>The following simple console application passes various strings to <b>PathFindNextComponent</b> to demonstrate what the function recognizes as a path component and to show what is returned. To run this code in Visual Studio, you must link to Shlwapi.lib and define UNICODE in the preprocessor commands in the project settings.</para>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include &lt;shlwapi.h&gt;

#pragma comment(lib, "shlwapi.lib")     // Link to this file.

int main()
{
    using namespace std;

    PCWSTR path = L"c:\\path1\\path2\\file.txt";

    // This loop passes a full path to PathFindNextComponent and feeds the
    // results of that call back into the function until the entire path has
    // been walked.
    while (path)
    {
        PCWSTR oldPath = path;
        path = PathFindNextComponent(path);

        // The path variable pointed to the terminating null character.
        if (path == NULL)
        {
            wcout &lt;&lt; L"The terminating null character returns NULL\n\n";
        }
        // The path variable pointed to a path with only one component.
        else if (*path == 0)
        {
            wcout &lt;&lt; L"The path " &lt;&lt; oldPath
                  &lt;&lt; L" returns a pointer to the terminating null character\n";
        }
        else
        {
            wcout &lt;&lt; L"The path " &lt;&lt; oldPath &lt;&lt; L" returns " &lt;&lt; path &lt;&lt; L"\n";
        }
    }

    // These calls demonstrate the results of different path forms.
    // Note that where those paths begin with backslashes, those
    // backslashes are merely stripped away and the entire path is returned.

    PCWSTR path1 = L"\\path1";

    wcout &lt;&lt; L"The path " &lt;&lt; path1 &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(path1);

    PCWSTR path2 = L"\\path1\\path2";

    wcout &lt;&lt; L"\nThe path " &lt;&lt; path2 &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(path2);

    PCWSTR path3 = L"path1\\path2";

    wcout &lt;&lt; L"\nThe path " &lt;&lt; path3 &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(path3);

    wcout &lt;&lt; L"\nThe path " &lt;&lt; L"c:\\file.txt" &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(L"c:\\file.txt");

    return 0;
}

OUTPUT:
===========
The path c:\path1\path2\file.txt returns path1\path2\file.txt
The path path1\path2\file.txt returns path2\file.txt
The path path2\file.txt returns file.txt
The path file.txt returns a pointer to the terminating null character
The terminating null character returns NULL

The path \path1 returns path1
The path \path1\path2 returns path1\path2
The path path1\path2 returns path2
The path c:\file.txt returns file.txt
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindNextComponent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindNextComponentW">
    <summary>
      <para>Parses a path and returns the portion of that path that follows the first backslash.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path to parse. This string must not be longer than MAX_PATH characters, plus the terminating null character. Path components are delimited by backslashes. For instance, the path "c:\path1\path2\file.txt" has four components: c:, path1, path2, and file.txt.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to a null-terminated string that contains the truncated path.</para>
      <para>If <i>pszPath</i> points to the last component in the path, this function returns a pointer to the terminating null character.</para>
      <para>If <i>pszPath</i> points to the terminating null character or if the call fails, this function returns <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>
        <b>PathFindNextComponent</b>  walks a path string until it encounters a backslash ("\"), ignores everything up to that point including the backslash, and returns the rest of the path. Therefore, if a path begins with a backslash (such as \path1\path2), the function simply removes the initial backslash and returns the rest (path1\path2).</para>
      <h4>Examples</h4>
      <para>The following simple console application passes various strings to <b>PathFindNextComponent</b> to demonstrate what the function recognizes as a path component and to show what is returned. To run this code in Visual Studio, you must link to Shlwapi.lib and define UNICODE in the preprocessor commands in the project settings.</para>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include &lt;shlwapi.h&gt;

#pragma comment(lib, "shlwapi.lib")     // Link to this file.

int main()
{
    using namespace std;

    PCWSTR path = L"c:\\path1\\path2\\file.txt";

    // This loop passes a full path to PathFindNextComponent and feeds the
    // results of that call back into the function until the entire path has
    // been walked.
    while (path)
    {
        PCWSTR oldPath = path;
        path = PathFindNextComponent(path);

        // The path variable pointed to the terminating null character.
        if (path == NULL)
        {
            wcout &lt;&lt; L"The terminating null character returns NULL\n\n";
        }
        // The path variable pointed to a path with only one component.
        else if (*path == 0)
        {
            wcout &lt;&lt; L"The path " &lt;&lt; oldPath
                  &lt;&lt; L" returns a pointer to the terminating null character\n";
        }
        else
        {
            wcout &lt;&lt; L"The path " &lt;&lt; oldPath &lt;&lt; L" returns " &lt;&lt; path &lt;&lt; L"\n";
        }
    }

    // These calls demonstrate the results of different path forms.
    // Note that where those paths begin with backslashes, those
    // backslashes are merely stripped away and the entire path is returned.

    PCWSTR path1 = L"\\path1";

    wcout &lt;&lt; L"The path " &lt;&lt; path1 &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(path1);

    PCWSTR path2 = L"\\path1\\path2";

    wcout &lt;&lt; L"\nThe path " &lt;&lt; path2 &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(path2);

    PCWSTR path3 = L"path1\\path2";

    wcout &lt;&lt; L"\nThe path " &lt;&lt; path3 &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(path3);

    wcout &lt;&lt; L"\nThe path " &lt;&lt; L"c:\\file.txt" &lt;&lt; L" returns "
          &lt;&lt; PathFindNextComponent(L"c:\\file.txt");

    return 0;
}

OUTPUT:
===========
The path c:\path1\path2\file.txt returns path1\path2\file.txt
The path path1\path2\file.txt returns path2\file.txt
The path path2\file.txt returns file.txt
The path file.txt returns a pointer to the terminating null character
The terminating null character returns NULL

The path \path1 returns path1
The path \path1\path2 returns path1\path2
The path path1\path2 returns path2
The path c:\file.txt returns file.txt
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindNextComponent as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindOnPath">
    <summary>
      <para>Searches for a file.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the file name for which to search. If the search is successful, this parameter is used to return the fully qualified path name.</para>
    </param>
    <param name="ppszOtherDirs">
      <para>Type: <b>LPCTSTR*</b></para>
      <para>An optional, null-terminated array of directories to be searched first. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>
        <b>PathFindOnPath</b> searches for the file specified by <i>pszFile</i>. If no directories are specified in <i>ppszOtherDirs</i>, it attempts to find the file by searching standard directories such as System32 and the directories specified in the PATH environment variable. To expedite the process or enable <b>PathFindOnPath</b> to search a wider range of directories, use the <i>ppszOtherDirs</i> parameter to specify one or more directories to be searched first. If more than one file has the name specified by <i>pszFile</i>, <b>PathFindOnPath</b> returns the first instance it finds.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindOnPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindOnPathA">
    <summary>
      <para>Searches for a file.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the file name for which to search. If the search is successful, this parameter is used to return the fully qualified path name.</para>
    </param>
    <param name="ppszOtherDirs">
      <para>Type: <b>LPCTSTR*</b></para>
      <para>An optional, null-terminated array of directories to be searched first. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>
        <b>PathFindOnPath</b> searches for the file specified by <i>pszFile</i>. If no directories are specified in <i>ppszOtherDirs</i>, it attempts to find the file by searching standard directories such as System32 and the directories specified in the PATH environment variable. To expedite the process or enable <b>PathFindOnPath</b> to search a wider range of directories, use the <i>ppszOtherDirs</i> parameter to specify one or more directories to be searched first. If more than one file has the name specified by <i>pszFile</i>, <b>PathFindOnPath</b> returns the first instance it finds.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindOnPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindOnPathW">
    <summary>
      <para>Searches for a file.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the file name for which to search. If the search is successful, this parameter is used to return the fully qualified path name.</para>
    </param>
    <param name="ppszOtherDirs">
      <para>Type: <b>LPCTSTR*</b></para>
      <para>An optional, null-terminated array of directories to be searched first. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>
        <b>PathFindOnPath</b> searches for the file specified by <i>pszFile</i>. If no directories are specified in <i>ppszOtherDirs</i>, it attempts to find the file by searching standard directories such as System32 and the directories specified in the PATH environment variable. To expedite the process or enable <b>PathFindOnPath</b> to search a wider range of directories, use the <i>ppszOtherDirs</i> parameter to specify one or more directories to be searched first. If more than one file has the name specified by <i>pszFile</i>, <b>PathFindOnPath</b> returns the first instance it finds.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindOnPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindOnPath">
    <summary>
      <para>Searches for a file.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the file name for which to search. If the search is successful, this parameter is used to return the fully qualified path name.</para>
    </param>
    <param name="ppszOtherDirs">
      <para>Type: <b>LPCTSTR*</b></para>
      <para>An optional, null-terminated array of directories to be searched first. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>
        <b>PathFindOnPath</b> searches for the file specified by <i>pszFile</i>. If no directories are specified in <i>ppszOtherDirs</i>, it attempts to find the file by searching standard directories such as System32 and the directories specified in the PATH environment variable. To expedite the process or enable <b>PathFindOnPath</b> to search a wider range of directories, use the <i>ppszOtherDirs</i> parameter to specify one or more directories to be searched first. If more than one file has the name specified by <i>pszFile</i>, <b>PathFindOnPath</b> returns the first instance it finds.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindOnPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindOnPathA">
    <summary>
      <para>Searches for a file.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the file name for which to search. If the search is successful, this parameter is used to return the fully qualified path name.</para>
    </param>
    <param name="ppszOtherDirs">
      <para>Type: <b>LPCTSTR*</b></para>
      <para>An optional, null-terminated array of directories to be searched first. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>
        <b>PathFindOnPath</b> searches for the file specified by <i>pszFile</i>. If no directories are specified in <i>ppszOtherDirs</i>, it attempts to find the file by searching standard directories such as System32 and the directories specified in the PATH environment variable. To expedite the process or enable <b>PathFindOnPath</b> to search a wider range of directories, use the <i>ppszOtherDirs</i> parameter to specify one or more directories to be searched first. If more than one file has the name specified by <i>pszFile</i>, <b>PathFindOnPath</b> returns the first instance it finds.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindOnPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindOnPathW">
    <summary>
      <para>Searches for a file.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the file name for which to search. If the search is successful, this parameter is used to return the fully qualified path name.</para>
    </param>
    <param name="ppszOtherDirs">
      <para>Type: <b>LPCTSTR*</b></para>
      <para>An optional, null-terminated array of directories to be searched first. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>
        <b>PathFindOnPath</b> searches for the file specified by <i>pszFile</i>. If no directories are specified in <i>ppszOtherDirs</i>, it attempts to find the file by searching standard directories such as System32 and the directories specified in the PATH environment variable. To expedite the process or enable <b>PathFindOnPath</b> to search a wider range of directories, use the <i>ppszOtherDirs</i> parameter to specify one or more directories to be searched first. If more than one file has the name specified by <i>pszFile</i>, <b>PathFindOnPath</b> returns the first instance it finds.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindOnPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindSuffixArray">
    <summary>
      <para>Determines whether a given file name has one of a list of suffixes.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested. A full path can be used.</para>
    </param>
    <param name="apszSuffix">
      <para>Type: <b>const LPCTSTR*</b></para>
      <para>An array of <i>iArraySize</i> string pointers. Each string pointed to is null-terminated and contains one suffix. The strings can be of variable lengths.</para>
    </param>
    <param name="iArraySize">
      <para>Type: <b>int</b></para>
      <para>The number of elements in the array pointed to by <i>apszSuffix</i>.</para>
    </param>
    <returns>
      <para>Type: <b>LPCTSTR</b></para>
      <para>Returns a pointer to a string with the matching suffix if successful, or <b>NULL</b> if <i>pszPath</i> does not end with one of the specified suffixes.</para>
    </returns>
    <remarks>
      <para>This function uses a case-sensitive comparison. The suffix must match exactly.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindSuffixArray as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindSuffixArrayA">
    <summary>
      <para>Determines whether a given file name has one of a list of suffixes.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested. A full path can be used.</para>
    </param>
    <param name="apszSuffix">
      <para>Type: <b>const LPCTSTR*</b></para>
      <para>An array of <i>iArraySize</i> string pointers. Each string pointed to is null-terminated and contains one suffix. The strings can be of variable lengths.</para>
    </param>
    <param name="iArraySize">
      <para>Type: <b>int</b></para>
      <para>The number of elements in the array pointed to by <i>apszSuffix</i>.</para>
    </param>
    <returns>
      <para>Type: <b>LPCTSTR</b></para>
      <para>Returns a pointer to a string with the matching suffix if successful, or <b>NULL</b> if <i>pszPath</i> does not end with one of the specified suffixes.</para>
    </returns>
    <remarks>
      <para>This function uses a case-sensitive comparison. The suffix must match exactly.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindSuffixArray as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindSuffixArrayW">
    <summary>
      <para>Determines whether a given file name has one of a list of suffixes.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested. A full path can be used.</para>
    </param>
    <param name="apszSuffix">
      <para>Type: <b>const LPCTSTR*</b></para>
      <para>An array of <i>iArraySize</i> string pointers. Each string pointed to is null-terminated and contains one suffix. The strings can be of variable lengths.</para>
    </param>
    <param name="iArraySize">
      <para>Type: <b>int</b></para>
      <para>The number of elements in the array pointed to by <i>apszSuffix</i>.</para>
    </param>
    <returns>
      <para>Type: <b>LPCTSTR</b></para>
      <para>Returns a pointer to a string with the matching suffix if successful, or <b>NULL</b> if <i>pszPath</i> does not end with one of the specified suffixes.</para>
    </returns>
    <remarks>
      <para>This function uses a case-sensitive comparison. The suffix must match exactly.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindSuffixArray as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindSuffixArray">
    <summary>
      <para>Determines whether a given file name has one of a list of suffixes.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested. A full path can be used.</para>
    </param>
    <param name="apszSuffix">
      <para>Type: <b>const LPCTSTR*</b></para>
      <para>An array of <i>iArraySize</i> string pointers. Each string pointed to is null-terminated and contains one suffix. The strings can be of variable lengths.</para>
    </param>
    <param name="iArraySize">
      <para>Type: <b>int</b></para>
      <para>The number of elements in the array pointed to by <i>apszSuffix</i>.</para>
    </param>
    <returns>
      <para>Type: <b>LPCTSTR</b></para>
      <para>Returns a pointer to a string with the matching suffix if successful, or <b>NULL</b> if <i>pszPath</i> does not end with one of the specified suffixes.</para>
    </returns>
    <remarks>
      <para>This function uses a case-sensitive comparison. The suffix must match exactly.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindSuffixArray as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindSuffixArrayA">
    <summary>
      <para>Determines whether a given file name has one of a list of suffixes.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested. A full path can be used.</para>
    </param>
    <param name="apszSuffix">
      <para>Type: <b>const LPCTSTR*</b></para>
      <para>An array of <i>iArraySize</i> string pointers. Each string pointed to is null-terminated and contains one suffix. The strings can be of variable lengths.</para>
    </param>
    <param name="iArraySize">
      <para>Type: <b>int</b></para>
      <para>The number of elements in the array pointed to by <i>apszSuffix</i>.</para>
    </param>
    <returns>
      <para>Type: <b>LPCTSTR</b></para>
      <para>Returns a pointer to a string with the matching suffix if successful, or <b>NULL</b> if <i>pszPath</i> does not end with one of the specified suffixes.</para>
    </returns>
    <remarks>
      <para>This function uses a case-sensitive comparison. The suffix must match exactly.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindSuffixArray as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathFindSuffixArrayW">
    <summary>
      <para>Determines whether a given file name has one of a list of suffixes.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested. A full path can be used.</para>
    </param>
    <param name="apszSuffix">
      <para>Type: <b>const LPCTSTR*</b></para>
      <para>An array of <i>iArraySize</i> string pointers. Each string pointed to is null-terminated and contains one suffix. The strings can be of variable lengths.</para>
    </param>
    <param name="iArraySize">
      <para>Type: <b>int</b></para>
      <para>The number of elements in the array pointed to by <i>apszSuffix</i>.</para>
    </param>
    <returns>
      <para>Type: <b>LPCTSTR</b></para>
      <para>Returns a pointer to a string with the matching suffix if successful, or <b>NULL</b> if <i>pszPath</i> does not end with one of the specified suffixes.</para>
    </returns>
    <remarks>
      <para>This function uses a case-sensitive comparison. The suffix must match exactly.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathFindSuffixArray as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathGetArgs">
    <summary>
      <para>Finds the command line arguments within a given path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>Pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to a null-terminated string that contains the arguments portion of the path if successful.</para>
      <para>If there are no arguments in the path, the function returns a pointer to the end of the input string.</para>
      <para>If the function is given a <b>NULL</b> argument it returns <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>This function should not be used on generic command path templates (from users or the registry), but rather should be used only on templates that the application knows to be well formed.</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
    // Path_1 to search for file arguments (2 arguments):
    char buffer_1[ ] = "test.exe temp.txt sample.doc";
    char *lpStr1;
    lpStr1 = buffer_1;

    // Path_2 to search for file arguments (3 arguments):
    char buffer_2[ ] = "test.exe 1 2 3";
    char *lpStr2;
    lpStr2 = buffer_2;

    // Path_3 to search for file arguments (3 arguments):
    char buffer_3[ ] = "test.exe sample All 15";
    char *lpStr3;
    lpStr3 = buffer_3;

    // Path_4 to search for file arguments (no arguments):
    char buffer_4[ ] = "test.exe";
    char *lpStr4;
    lpStr4 = buffer_4;

    cout &lt;&lt; "The path passed to the function was : " &lt;&lt; lpStr1 &lt;&lt;
            "\nThe arg(s)found in path 1 were      : " &lt;&lt; PathGetArgs(lpStr1) &lt;&lt; endl;

    cout &lt;&lt; "\nThe path passed to the function was : " &lt;&lt; lpStr2 &lt;&lt;
            "\nThe arg(s)found in path 2 were      : " &lt;&lt; PathGetArgs(lpStr2) &lt;&lt; endl;

    cout &lt;&lt; "\nThe path passed to the function was : " &lt;&lt; lpStr3 &lt;&lt;
            "\nThe arg(s)found in path 3 were      : " &lt;&lt; PathGetArgs(lpStr3) &lt;&lt; endl;

    cout &lt;&lt; "\nThe path passed to the function was : " &lt;&lt; lpStr4 &lt;&lt;
            "\nThe arg(s)found in path 4 were      : " &lt;&lt; PathGetArgs(lpStr4) &lt;&lt; endl;
}

OUTPUT:
===========
The path passed to the function was : test.exe temp.txt sample.doc
The arg(s)found in path 1 were      : temp.txt sample.doc

The path passed to the function was : test.exe 1 2 3
The arg(s)found in path 2 were      : 1 2 3

The path passed to the function was : test.exe sample All 15
The arg(s)found in path 3 were      : sample All 15

The path passed to the function was : test.exe
The arg(s)found in path 4 were      :
===========
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathGetArgs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathGetArgsA">
    <summary>
      <para>Finds the command line arguments within a given path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>Pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to a null-terminated string that contains the arguments portion of the path if successful.</para>
      <para>If there are no arguments in the path, the function returns a pointer to the end of the input string.</para>
      <para>If the function is given a <b>NULL</b> argument it returns <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>This function should not be used on generic command path templates (from users or the registry), but rather should be used only on templates that the application knows to be well formed.</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
    // Path_1 to search for file arguments (2 arguments):
    char buffer_1[ ] = "test.exe temp.txt sample.doc";
    char *lpStr1;
    lpStr1 = buffer_1;

    // Path_2 to search for file arguments (3 arguments):
    char buffer_2[ ] = "test.exe 1 2 3";
    char *lpStr2;
    lpStr2 = buffer_2;

    // Path_3 to search for file arguments (3 arguments):
    char buffer_3[ ] = "test.exe sample All 15";
    char *lpStr3;
    lpStr3 = buffer_3;

    // Path_4 to search for file arguments (no arguments):
    char buffer_4[ ] = "test.exe";
    char *lpStr4;
    lpStr4 = buffer_4;

    cout &lt;&lt; "The path passed to the function was : " &lt;&lt; lpStr1 &lt;&lt;
            "\nThe arg(s)found in path 1 were      : " &lt;&lt; PathGetArgs(lpStr1) &lt;&lt; endl;

    cout &lt;&lt; "\nThe path passed to the function was : " &lt;&lt; lpStr2 &lt;&lt;
            "\nThe arg(s)found in path 2 were      : " &lt;&lt; PathGetArgs(lpStr2) &lt;&lt; endl;

    cout &lt;&lt; "\nThe path passed to the function was : " &lt;&lt; lpStr3 &lt;&lt;
            "\nThe arg(s)found in path 3 were      : " &lt;&lt; PathGetArgs(lpStr3) &lt;&lt; endl;

    cout &lt;&lt; "\nThe path passed to the function was : " &lt;&lt; lpStr4 &lt;&lt;
            "\nThe arg(s)found in path 4 were      : " &lt;&lt; PathGetArgs(lpStr4) &lt;&lt; endl;
}

OUTPUT:
===========
The path passed to the function was : test.exe temp.txt sample.doc
The arg(s)found in path 1 were      : temp.txt sample.doc

The path passed to the function was : test.exe 1 2 3
The arg(s)found in path 2 were      : 1 2 3

The path passed to the function was : test.exe sample All 15
The arg(s)found in path 3 were      : sample All 15

The path passed to the function was : test.exe
The arg(s)found in path 4 were      :
===========
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathGetArgs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathGetArgsW">
    <summary>
      <para>Finds the command line arguments within a given path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>Pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to a null-terminated string that contains the arguments portion of the path if successful.</para>
      <para>If there are no arguments in the path, the function returns a pointer to the end of the input string.</para>
      <para>If the function is given a <b>NULL</b> argument it returns <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>This function should not be used on generic command path templates (from users or the registry), but rather should be used only on templates that the application knows to be well formed.</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
    // Path_1 to search for file arguments (2 arguments):
    char buffer_1[ ] = "test.exe temp.txt sample.doc";
    char *lpStr1;
    lpStr1 = buffer_1;

    // Path_2 to search for file arguments (3 arguments):
    char buffer_2[ ] = "test.exe 1 2 3";
    char *lpStr2;
    lpStr2 = buffer_2;

    // Path_3 to search for file arguments (3 arguments):
    char buffer_3[ ] = "test.exe sample All 15";
    char *lpStr3;
    lpStr3 = buffer_3;

    // Path_4 to search for file arguments (no arguments):
    char buffer_4[ ] = "test.exe";
    char *lpStr4;
    lpStr4 = buffer_4;

    cout &lt;&lt; "The path passed to the function was : " &lt;&lt; lpStr1 &lt;&lt;
            "\nThe arg(s)found in path 1 were      : " &lt;&lt; PathGetArgs(lpStr1) &lt;&lt; endl;

    cout &lt;&lt; "\nThe path passed to the function was : " &lt;&lt; lpStr2 &lt;&lt;
            "\nThe arg(s)found in path 2 were      : " &lt;&lt; PathGetArgs(lpStr2) &lt;&lt; endl;

    cout &lt;&lt; "\nThe path passed to the function was : " &lt;&lt; lpStr3 &lt;&lt;
            "\nThe arg(s)found in path 3 were      : " &lt;&lt; PathGetArgs(lpStr3) &lt;&lt; endl;

    cout &lt;&lt; "\nThe path passed to the function was : " &lt;&lt; lpStr4 &lt;&lt;
            "\nThe arg(s)found in path 4 were      : " &lt;&lt; PathGetArgs(lpStr4) &lt;&lt; endl;
}

OUTPUT:
===========
The path passed to the function was : test.exe temp.txt sample.doc
The arg(s)found in path 1 were      : temp.txt sample.doc

The path passed to the function was : test.exe 1 2 3
The arg(s)found in path 2 were      : 1 2 3

The path passed to the function was : test.exe sample All 15
The arg(s)found in path 3 were      : sample All 15

The path passed to the function was : test.exe
The arg(s)found in path 4 were      :
===========
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathGetArgs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathGetArgs">
    <summary>
      <para>Finds the command line arguments within a given path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>Pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to a null-terminated string that contains the arguments portion of the path if successful.</para>
      <para>If there are no arguments in the path, the function returns a pointer to the end of the input string.</para>
      <para>If the function is given a <b>NULL</b> argument it returns <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>This function should not be used on generic command path templates (from users or the registry), but rather should be used only on templates that the application knows to be well formed.</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
    // Path_1 to search for file arguments (2 arguments):
    char buffer_1[ ] = "test.exe temp.txt sample.doc";
    char *lpStr1;
    lpStr1 = buffer_1;

    // Path_2 to search for file arguments (3 arguments):
    char buffer_2[ ] = "test.exe 1 2 3";
    char *lpStr2;
    lpStr2 = buffer_2;

    // Path_3 to search for file arguments (3 arguments):
    char buffer_3[ ] = "test.exe sample All 15";
    char *lpStr3;
    lpStr3 = buffer_3;

    // Path_4 to search for file arguments (no arguments):
    char buffer_4[ ] = "test.exe";
    char *lpStr4;
    lpStr4 = buffer_4;

    cout &lt;&lt; "The path passed to the function was : " &lt;&lt; lpStr1 &lt;&lt;
            "\nThe arg(s)found in path 1 were      : " &lt;&lt; PathGetArgs(lpStr1) &lt;&lt; endl;

    cout &lt;&lt; "\nThe path passed to the function was : " &lt;&lt; lpStr2 &lt;&lt;
            "\nThe arg(s)found in path 2 were      : " &lt;&lt; PathGetArgs(lpStr2) &lt;&lt; endl;

    cout &lt;&lt; "\nThe path passed to the function was : " &lt;&lt; lpStr3 &lt;&lt;
            "\nThe arg(s)found in path 3 were      : " &lt;&lt; PathGetArgs(lpStr3) &lt;&lt; endl;

    cout &lt;&lt; "\nThe path passed to the function was : " &lt;&lt; lpStr4 &lt;&lt;
            "\nThe arg(s)found in path 4 were      : " &lt;&lt; PathGetArgs(lpStr4) &lt;&lt; endl;
}

OUTPUT:
===========
The path passed to the function was : test.exe temp.txt sample.doc
The arg(s)found in path 1 were      : temp.txt sample.doc

The path passed to the function was : test.exe 1 2 3
The arg(s)found in path 2 were      : 1 2 3

The path passed to the function was : test.exe sample All 15
The arg(s)found in path 3 were      : sample All 15

The path passed to the function was : test.exe
The arg(s)found in path 4 were      :
===========
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathGetArgs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathGetArgsA">
    <summary>
      <para>Finds the command line arguments within a given path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>Pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to a null-terminated string that contains the arguments portion of the path if successful.</para>
      <para>If there are no arguments in the path, the function returns a pointer to the end of the input string.</para>
      <para>If the function is given a <b>NULL</b> argument it returns <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>This function should not be used on generic command path templates (from users or the registry), but rather should be used only on templates that the application knows to be well formed.</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
    // Path_1 to search for file arguments (2 arguments):
    char buffer_1[ ] = "test.exe temp.txt sample.doc";
    char *lpStr1;
    lpStr1 = buffer_1;

    // Path_2 to search for file arguments (3 arguments):
    char buffer_2[ ] = "test.exe 1 2 3";
    char *lpStr2;
    lpStr2 = buffer_2;

    // Path_3 to search for file arguments (3 arguments):
    char buffer_3[ ] = "test.exe sample All 15";
    char *lpStr3;
    lpStr3 = buffer_3;

    // Path_4 to search for file arguments (no arguments):
    char buffer_4[ ] = "test.exe";
    char *lpStr4;
    lpStr4 = buffer_4;

    cout &lt;&lt; "The path passed to the function was : " &lt;&lt; lpStr1 &lt;&lt;
            "\nThe arg(s)found in path 1 were      : " &lt;&lt; PathGetArgs(lpStr1) &lt;&lt; endl;

    cout &lt;&lt; "\nThe path passed to the function was : " &lt;&lt; lpStr2 &lt;&lt;
            "\nThe arg(s)found in path 2 were      : " &lt;&lt; PathGetArgs(lpStr2) &lt;&lt; endl;

    cout &lt;&lt; "\nThe path passed to the function was : " &lt;&lt; lpStr3 &lt;&lt;
            "\nThe arg(s)found in path 3 were      : " &lt;&lt; PathGetArgs(lpStr3) &lt;&lt; endl;

    cout &lt;&lt; "\nThe path passed to the function was : " &lt;&lt; lpStr4 &lt;&lt;
            "\nThe arg(s)found in path 4 were      : " &lt;&lt; PathGetArgs(lpStr4) &lt;&lt; endl;
}

OUTPUT:
===========
The path passed to the function was : test.exe temp.txt sample.doc
The arg(s)found in path 1 were      : temp.txt sample.doc

The path passed to the function was : test.exe 1 2 3
The arg(s)found in path 2 were      : 1 2 3

The path passed to the function was : test.exe sample All 15
The arg(s)found in path 3 were      : sample All 15

The path passed to the function was : test.exe
The arg(s)found in path 4 were      :
===========
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathGetArgs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathGetArgsW">
    <summary>
      <para>Finds the command line arguments within a given path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>Pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to a null-terminated string that contains the arguments portion of the path if successful.</para>
      <para>If there are no arguments in the path, the function returns a pointer to the end of the input string.</para>
      <para>If the function is given a <b>NULL</b> argument it returns <b>NULL</b>.</para>
    </returns>
    <remarks>
      <para>This function should not be used on generic command path templates (from users or the registry), but rather should be used only on templates that the application knows to be well formed.</para>
      <h4>Examples</h4>
      <code>
#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
    // Path_1 to search for file arguments (2 arguments):
    char buffer_1[ ] = "test.exe temp.txt sample.doc";
    char *lpStr1;
    lpStr1 = buffer_1;

    // Path_2 to search for file arguments (3 arguments):
    char buffer_2[ ] = "test.exe 1 2 3";
    char *lpStr2;
    lpStr2 = buffer_2;

    // Path_3 to search for file arguments (3 arguments):
    char buffer_3[ ] = "test.exe sample All 15";
    char *lpStr3;
    lpStr3 = buffer_3;

    // Path_4 to search for file arguments (no arguments):
    char buffer_4[ ] = "test.exe";
    char *lpStr4;
    lpStr4 = buffer_4;

    cout &lt;&lt; "The path passed to the function was : " &lt;&lt; lpStr1 &lt;&lt;
            "\nThe arg(s)found in path 1 were      : " &lt;&lt; PathGetArgs(lpStr1) &lt;&lt; endl;

    cout &lt;&lt; "\nThe path passed to the function was : " &lt;&lt; lpStr2 &lt;&lt;
            "\nThe arg(s)found in path 2 were      : " &lt;&lt; PathGetArgs(lpStr2) &lt;&lt; endl;

    cout &lt;&lt; "\nThe path passed to the function was : " &lt;&lt; lpStr3 &lt;&lt;
            "\nThe arg(s)found in path 3 were      : " &lt;&lt; PathGetArgs(lpStr3) &lt;&lt; endl;

    cout &lt;&lt; "\nThe path passed to the function was : " &lt;&lt; lpStr4 &lt;&lt;
            "\nThe arg(s)found in path 4 were      : " &lt;&lt; PathGetArgs(lpStr4) &lt;&lt; endl;
}

OUTPUT:
===========
The path passed to the function was : test.exe temp.txt sample.doc
The arg(s)found in path 1 were      : temp.txt sample.doc

The path passed to the function was : test.exe 1 2 3
The arg(s)found in path 2 were      : 1 2 3

The path passed to the function was : test.exe sample All 15
The arg(s)found in path 3 were      : sample All 15

The path passed to the function was : test.exe
The arg(s)found in path 4 were      :
===========
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathGetArgs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathGetCharType">
    <summary>
      <para>Determines the type of character in relation to a path.</para>
    </summary>
    <param name="ch">
      <para>Type: <b>TUCHAR</b></para>
      <para>The character for which to determine the type.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>Returns one or more of the following values that define the type of character.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>GCT_INVALID</b>
            </para>
          </description>
          <description>
            <para>The character is not valid in a path.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_LFNCHAR</b>
            </para>
          </description>
          <description>
            <para>The character is valid in a long file name.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_SEPARATOR</b>
            </para>
          </description>
          <description>
            <para>The character is a path separator.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_SHORTCHAR</b>
            </para>
          </description>
          <description>
            <para>The character is valid in a short (8.3) file name.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_WILD</b>
            </para>
          </description>
          <description>
            <para>The character is a wildcard character.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathGetCharType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathGetCharTypeA">
    <summary>
      <para>Determines the type of character in relation to a path.</para>
    </summary>
    <param name="ch">
      <para>Type: <b>TUCHAR</b></para>
      <para>The character for which to determine the type.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>Returns one or more of the following values that define the type of character.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>GCT_INVALID</b>
            </para>
          </description>
          <description>
            <para>The character is not valid in a path.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_LFNCHAR</b>
            </para>
          </description>
          <description>
            <para>The character is valid in a long file name.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_SEPARATOR</b>
            </para>
          </description>
          <description>
            <para>The character is a path separator.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_SHORTCHAR</b>
            </para>
          </description>
          <description>
            <para>The character is valid in a short (8.3) file name.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_WILD</b>
            </para>
          </description>
          <description>
            <para>The character is a wildcard character.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathGetCharType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathGetCharTypeW">
    <summary>
      <para>Determines the type of character in relation to a path.</para>
    </summary>
    <param name="ch">
      <para>Type: <b>TUCHAR</b></para>
      <para>The character for which to determine the type.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>Returns one or more of the following values that define the type of character.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>GCT_INVALID</b>
            </para>
          </description>
          <description>
            <para>The character is not valid in a path.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_LFNCHAR</b>
            </para>
          </description>
          <description>
            <para>The character is valid in a long file name.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_SEPARATOR</b>
            </para>
          </description>
          <description>
            <para>The character is a path separator.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_SHORTCHAR</b>
            </para>
          </description>
          <description>
            <para>The character is valid in a short (8.3) file name.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_WILD</b>
            </para>
          </description>
          <description>
            <para>The character is a wildcard character.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathGetCharType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathGetCharType">
    <summary>
      <para>Determines the type of character in relation to a path.</para>
    </summary>
    <param name="ch">
      <para>Type: <b>TUCHAR</b></para>
      <para>The character for which to determine the type.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>Returns one or more of the following values that define the type of character.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>GCT_INVALID</b>
            </para>
          </description>
          <description>
            <para>The character is not valid in a path.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_LFNCHAR</b>
            </para>
          </description>
          <description>
            <para>The character is valid in a long file name.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_SEPARATOR</b>
            </para>
          </description>
          <description>
            <para>The character is a path separator.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_SHORTCHAR</b>
            </para>
          </description>
          <description>
            <para>The character is valid in a short (8.3) file name.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_WILD</b>
            </para>
          </description>
          <description>
            <para>The character is a wildcard character.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathGetCharType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathGetCharTypeA">
    <summary>
      <para>Determines the type of character in relation to a path.</para>
    </summary>
    <param name="ch">
      <para>Type: <b>TUCHAR</b></para>
      <para>The character for which to determine the type.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>Returns one or more of the following values that define the type of character.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>GCT_INVALID</b>
            </para>
          </description>
          <description>
            <para>The character is not valid in a path.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_LFNCHAR</b>
            </para>
          </description>
          <description>
            <para>The character is valid in a long file name.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_SEPARATOR</b>
            </para>
          </description>
          <description>
            <para>The character is a path separator.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_SHORTCHAR</b>
            </para>
          </description>
          <description>
            <para>The character is valid in a short (8.3) file name.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_WILD</b>
            </para>
          </description>
          <description>
            <para>The character is a wildcard character.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathGetCharType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathGetCharTypeW">
    <summary>
      <para>Determines the type of character in relation to a path.</para>
    </summary>
    <param name="ch">
      <para>Type: <b>TUCHAR</b></para>
      <para>The character for which to determine the type.</para>
    </param>
    <returns>
      <para>Type: <b>UINT</b></para>
      <para>Returns one or more of the following values that define the type of character.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>GCT_INVALID</b>
            </para>
          </description>
          <description>
            <para>The character is not valid in a path.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_LFNCHAR</b>
            </para>
          </description>
          <description>
            <para>The character is valid in a long file name.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_SEPARATOR</b>
            </para>
          </description>
          <description>
            <para>The character is a path separator.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_SHORTCHAR</b>
            </para>
          </description>
          <description>
            <para>The character is valid in a short (8.3) file name.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>GCT_WILD</b>
            </para>
          </description>
          <description>
            <para>The character is a wildcard character.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathGetCharType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathGetDriveNumber">
    <summary>
      <para>Searches a path for a drive letter within the range of 'A' to 'Z' and returns the corresponding drive number.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns 0 through 25 (corresponding to 'A' through 'Z') if the path has a drive letter, or -1 otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathGetDriveNumber as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathGetDriveNumberA">
    <summary>
      <para>Searches a path for a drive letter within the range of 'A' to 'Z' and returns the corresponding drive number.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns 0 through 25 (corresponding to 'A' through 'Z') if the path has a drive letter, or -1 otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathGetDriveNumber as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathGetDriveNumberW">
    <summary>
      <para>Searches a path for a drive letter within the range of 'A' to 'Z' and returns the corresponding drive number.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns 0 through 25 (corresponding to 'A' through 'Z') if the path has a drive letter, or -1 otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathGetDriveNumber as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathGetDriveNumber">
    <summary>
      <para>Searches a path for a drive letter within the range of 'A' to 'Z' and returns the corresponding drive number.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns 0 through 25 (corresponding to 'A' through 'Z') if the path has a drive letter, or -1 otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathGetDriveNumber as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathGetDriveNumberA">
    <summary>
      <para>Searches a path for a drive letter within the range of 'A' to 'Z' and returns the corresponding drive number.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns 0 through 25 (corresponding to 'A' through 'Z') if the path has a drive letter, or -1 otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathGetDriveNumber as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathGetDriveNumberW">
    <summary>
      <para>Searches a path for a drive letter within the range of 'A' to 'Z' and returns the corresponding drive number.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns 0 through 25 (corresponding to 'A' through 'Z') if the path has a drive letter, or -1 otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathGetDriveNumber as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsContentType">
    <summary>
      <para>Determines if a file's registered content type matches the specified content type. This function obtains the content type for the specified file type and compares that string with the <i>pszContentType</i>. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the file whose content type will be compared.</para>
    </param>
    <param name="pszContentType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a character buffer that contains the null-terminated content type string to which the file's registered content type will be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if the file's registered content type matches <i>pszContentType</i>, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsContentType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsContentTypeA">
    <summary>
      <para>Determines if a file's registered content type matches the specified content type. This function obtains the content type for the specified file type and compares that string with the <i>pszContentType</i>. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the file whose content type will be compared.</para>
    </param>
    <param name="pszContentType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a character buffer that contains the null-terminated content type string to which the file's registered content type will be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if the file's registered content type matches <i>pszContentType</i>, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsContentType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsContentTypeW">
    <summary>
      <para>Determines if a file's registered content type matches the specified content type. This function obtains the content type for the specified file type and compares that string with the <i>pszContentType</i>. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the file whose content type will be compared.</para>
    </param>
    <param name="pszContentType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a character buffer that contains the null-terminated content type string to which the file's registered content type will be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if the file's registered content type matches <i>pszContentType</i>, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsContentType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsContentType">
    <summary>
      <para>Determines if a file's registered content type matches the specified content type. This function obtains the content type for the specified file type and compares that string with the <i>pszContentType</i>. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the file whose content type will be compared.</para>
    </param>
    <param name="pszContentType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a character buffer that contains the null-terminated content type string to which the file's registered content type will be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if the file's registered content type matches <i>pszContentType</i>, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsContentType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsContentTypeA">
    <summary>
      <para>Determines if a file's registered content type matches the specified content type. This function obtains the content type for the specified file type and compares that string with the <i>pszContentType</i>. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the file whose content type will be compared.</para>
    </param>
    <param name="pszContentType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a character buffer that contains the null-terminated content type string to which the file's registered content type will be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if the file's registered content type matches <i>pszContentType</i>, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsContentType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsContentTypeW">
    <summary>
      <para>Determines if a file's registered content type matches the specified content type. This function obtains the content type for the specified file type and compares that string with the <i>pszContentType</i>. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the file whose content type will be compared.</para>
    </param>
    <param name="pszContentType">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a character buffer that contains the null-terminated content type string to which the file's registered content type will be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if the file's registered content type matches <i>pszContentType</i>, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsContentType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsDirectory">
    <summary>
      <para>Verifies that a path is a valid directory.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to verify.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns (BOOL)FILE_ATTRIBUTE_DIRECTORY if the path is a valid directory; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsDirectoryA">
    <summary>
      <para>Verifies that a path is a valid directory.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to verify.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns (BOOL)FILE_ATTRIBUTE_DIRECTORY if the path is a valid directory; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsDirectoryW">
    <summary>
      <para>Verifies that a path is a valid directory.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to verify.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns (BOOL)FILE_ATTRIBUTE_DIRECTORY if the path is a valid directory; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsDirectoryEmpty">
    <summary>
      <para>Determines whether a specified path is an empty directory.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be tested.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszPath</i> is an empty directory. Returns <b>FALSE</b> if <i>pszPath</i> is not a directory, or if it contains at least one file other than "." or "..".</para>
    </returns>
    <remarks>
      <para>"C:" is considered a directory.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsDirectoryEmpty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathIsDirectory" />
  </member>
  <member name="Windows.PathIsDirectoryEmptyA">
    <summary>
      <para>Determines whether a specified path is an empty directory.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be tested.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszPath</i> is an empty directory. Returns <b>FALSE</b> if <i>pszPath</i> is not a directory, or if it contains at least one file other than "." or "..".</para>
    </returns>
    <remarks>
      <para>"C:" is considered a directory.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsDirectoryEmpty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathIsDirectory" />
  </member>
  <member name="Windows.PathIsDirectoryEmptyW">
    <summary>
      <para>Determines whether a specified path is an empty directory.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be tested.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszPath</i> is an empty directory. Returns <b>FALSE</b> if <i>pszPath</i> is not a directory, or if it contains at least one file other than "." or "..".</para>
    </returns>
    <remarks>
      <para>"C:" is considered a directory.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsDirectoryEmpty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathIsDirectory" />
  </member>
  <member name="Windows.PathIsDirectoryEmpty">
    <summary>
      <para>Determines whether a specified path is an empty directory.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be tested.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszPath</i> is an empty directory. Returns <b>FALSE</b> if <i>pszPath</i> is not a directory, or if it contains at least one file other than "." or "..".</para>
    </returns>
    <remarks>
      <para>"C:" is considered a directory.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsDirectoryEmpty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathIsDirectory" />
  </member>
  <member name="Windows.PathIsDirectoryEmptyA">
    <summary>
      <para>Determines whether a specified path is an empty directory.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be tested.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszPath</i> is an empty directory. Returns <b>FALSE</b> if <i>pszPath</i> is not a directory, or if it contains at least one file other than "." or "..".</para>
    </returns>
    <remarks>
      <para>"C:" is considered a directory.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsDirectoryEmpty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathIsDirectory" />
  </member>
  <member name="Windows.PathIsDirectoryEmptyW">
    <summary>
      <para>Determines whether a specified path is an empty directory.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be tested.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszPath</i> is an empty directory. Returns <b>FALSE</b> if <i>pszPath</i> is not a directory, or if it contains at least one file other than "." or "..".</para>
    </returns>
    <remarks>
      <para>"C:" is considered a directory.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsDirectoryEmpty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathIsDirectory" />
  </member>
  <member name="Windows.PathIsDirectory">
    <summary>
      <para>Verifies that a path is a valid directory.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to verify.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns (BOOL)FILE_ATTRIBUTE_DIRECTORY if the path is a valid directory; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsDirectoryA">
    <summary>
      <para>Verifies that a path is a valid directory.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to verify.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns (BOOL)FILE_ATTRIBUTE_DIRECTORY if the path is a valid directory; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsDirectoryW">
    <summary>
      <para>Verifies that a path is a valid directory.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to verify.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns (BOOL)FILE_ATTRIBUTE_DIRECTORY if the path is a valid directory; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsFileSpec">
    <summary>
      <para>Searches a path for any path-delimiting characters (for example, ':' or '' ). If there are no path-delimiting characters present, the path is considered to be a File Spec path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if there are no path-delimiting characters within the path, or <b>FALSE</b> if there are path-delimiting characters.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsFileSpecA">
    <summary>
      <para>Searches a path for any path-delimiting characters (for example, ':' or '' ). If there are no path-delimiting characters present, the path is considered to be a File Spec path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if there are no path-delimiting characters within the path, or <b>FALSE</b> if there are path-delimiting characters.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsFileSpecW">
    <summary>
      <para>Searches a path for any path-delimiting characters (for example, ':' or '' ). If there are no path-delimiting characters present, the path is considered to be a File Spec path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if there are no path-delimiting characters within the path, or <b>FALSE</b> if there are path-delimiting characters.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsFileSpec">
    <summary>
      <para>Searches a path for any path-delimiting characters (for example, ':' or '' ). If there are no path-delimiting characters present, the path is considered to be a File Spec path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if there are no path-delimiting characters within the path, or <b>FALSE</b> if there are path-delimiting characters.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsFileSpecA">
    <summary>
      <para>Searches a path for any path-delimiting characters (for example, ':' or '' ). If there are no path-delimiting characters present, the path is considered to be a File Spec path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if there are no path-delimiting characters within the path, or <b>FALSE</b> if there are path-delimiting characters.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsFileSpecW">
    <summary>
      <para>Searches a path for any path-delimiting characters (for example, ':' or '' ). If there are no path-delimiting characters present, the path is considered to be a File Spec path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be searched.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if there are no path-delimiting characters within the path, or <b>FALSE</b> if there are path-delimiting characters.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsHTMLFile">
    <summary>
      <para>Determines if a file is an HTML file. The determination is made based on the content type that is registered for the file's extension.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a character buffer that contains the path and name of the file.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsHTMLFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsHTMLFileA">
    <summary>
      <para>Determines if a file is an HTML file. The determination is made based on the content type that is registered for the file's extension.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a character buffer that contains the path and name of the file.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsHTMLFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsHTMLFileW">
    <summary>
      <para>Determines if a file is an HTML file. The determination is made based on the content type that is registered for the file's extension.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a character buffer that contains the path and name of the file.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsHTMLFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsHTMLFile">
    <summary>
      <para>Determines if a file is an HTML file. The determination is made based on the content type that is registered for the file's extension.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a character buffer that contains the path and name of the file.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsHTMLFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsHTMLFileA">
    <summary>
      <para>Determines if a file is an HTML file. The determination is made based on the content type that is registered for the file's extension.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a character buffer that contains the path and name of the file.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsHTMLFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsHTMLFileW">
    <summary>
      <para>Determines if a file is an HTML file. The determination is made based on the content type that is registered for the file's extension.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a character buffer that contains the path and name of the file.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsHTMLFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsLFNFileSpec">
    <summary>
      <para>Determines whether a file name is in long format.</para>
    </summary>
    <param name="pszName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszName</i> exceeds the number of characters allowed by the 8.3 format, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsLFNFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathIsFileSpec" />
  </member>
  <member name="Windows.PathIsLFNFileSpecA">
    <summary>
      <para>Determines whether a file name is in long format.</para>
    </summary>
    <param name="pszName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszName</i> exceeds the number of characters allowed by the 8.3 format, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsLFNFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathIsFileSpec" />
  </member>
  <member name="Windows.PathIsLFNFileSpecW">
    <summary>
      <para>Determines whether a file name is in long format.</para>
    </summary>
    <param name="pszName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszName</i> exceeds the number of characters allowed by the 8.3 format, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsLFNFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathIsFileSpec" />
  </member>
  <member name="Windows.PathIsLFNFileSpec">
    <summary>
      <para>Determines whether a file name is in long format.</para>
    </summary>
    <param name="pszName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszName</i> exceeds the number of characters allowed by the 8.3 format, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsLFNFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathIsFileSpec" />
  </member>
  <member name="Windows.PathIsLFNFileSpecA">
    <summary>
      <para>Determines whether a file name is in long format.</para>
    </summary>
    <param name="pszName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszName</i> exceeds the number of characters allowed by the 8.3 format, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsLFNFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathIsFileSpec" />
  </member>
  <member name="Windows.PathIsLFNFileSpecW">
    <summary>
      <para>Determines whether a file name is in long format.</para>
    </summary>
    <param name="pszName">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the file name to be tested.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszName</i> exceeds the number of characters allowed by the 8.3 format, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsLFNFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathIsFileSpec" />
  </member>
  <member name="Windows.PathIsNetworkPath">
    <summary>
      <para>Determines whether a path string represents a network resource.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string represents a network resource, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>
        <b>PathIsNetworkPath</b> interprets the following two types of paths as network paths.</para>
      <list type="bullet">
        <item>
          <description>Paths that begin with two backslash characters (\\) are interpreted as Universal Naming Convention (UNC) paths.</description>
        </item>
        <item>
          <description>Paths that begin with a letter followed by a colon (:) are interpreted as a mounted network drive. However, <b>PathIsNetworkPath</b> cannot recognize a network drive mapped to a drive letter through the Microsoft MS-DOS SUBST command or the <see cref="DefineDosDevice" /> function.</description>
        </item>
      </list>
      <b>Note</b>  The function does not verify that the specified network resource exists, is currently accessible, or that the user has sufficient permissions to access it.
<blockquote><para>[!NOTE]
The shlwapi.h header defines PathIsNetworkPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
  </member>
  <member name="Windows.PathIsNetworkPathA">
    <summary>
      <para>Determines whether a path string represents a network resource.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string represents a network resource, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>
        <b>PathIsNetworkPath</b> interprets the following two types of paths as network paths.</para>
      <list type="bullet">
        <item>
          <description>Paths that begin with two backslash characters (\\) are interpreted as Universal Naming Convention (UNC) paths.</description>
        </item>
        <item>
          <description>Paths that begin with a letter followed by a colon (:) are interpreted as a mounted network drive. However, <b>PathIsNetworkPath</b> cannot recognize a network drive mapped to a drive letter through the Microsoft MS-DOS SUBST command or the <see cref="DefineDosDevice" /> function.</description>
        </item>
      </list>
      <b>Note</b>  The function does not verify that the specified network resource exists, is currently accessible, or that the user has sufficient permissions to access it.
<blockquote><para>[!NOTE]
The shlwapi.h header defines PathIsNetworkPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
  </member>
  <member name="Windows.PathIsNetworkPathW">
    <summary>
      <para>Determines whether a path string represents a network resource.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string represents a network resource, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>
        <b>PathIsNetworkPath</b> interprets the following two types of paths as network paths.</para>
      <list type="bullet">
        <item>
          <description>Paths that begin with two backslash characters (\\) are interpreted as Universal Naming Convention (UNC) paths.</description>
        </item>
        <item>
          <description>Paths that begin with a letter followed by a colon (:) are interpreted as a mounted network drive. However, <b>PathIsNetworkPath</b> cannot recognize a network drive mapped to a drive letter through the Microsoft MS-DOS SUBST command or the <see cref="DefineDosDevice" /> function.</description>
        </item>
      </list>
      <b>Note</b>  The function does not verify that the specified network resource exists, is currently accessible, or that the user has sufficient permissions to access it.
<blockquote><para>[!NOTE]
The shlwapi.h header defines PathIsNetworkPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
  </member>
  <member name="Windows.PathIsNetworkPath">
    <summary>
      <para>Determines whether a path string represents a network resource.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string represents a network resource, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>
        <b>PathIsNetworkPath</b> interprets the following two types of paths as network paths.</para>
      <list type="bullet">
        <item>
          <description>Paths that begin with two backslash characters (\\) are interpreted as Universal Naming Convention (UNC) paths.</description>
        </item>
        <item>
          <description>Paths that begin with a letter followed by a colon (:) are interpreted as a mounted network drive. However, <b>PathIsNetworkPath</b> cannot recognize a network drive mapped to a drive letter through the Microsoft MS-DOS SUBST command or the <see cref="DefineDosDevice" /> function.</description>
        </item>
      </list>
      <b>Note</b>  The function does not verify that the specified network resource exists, is currently accessible, or that the user has sufficient permissions to access it.
<blockquote><para>[!NOTE]
The shlwapi.h header defines PathIsNetworkPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
  </member>
  <member name="Windows.PathIsNetworkPathA">
    <summary>
      <para>Determines whether a path string represents a network resource.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string represents a network resource, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>
        <b>PathIsNetworkPath</b> interprets the following two types of paths as network paths.</para>
      <list type="bullet">
        <item>
          <description>Paths that begin with two backslash characters (\\) are interpreted as Universal Naming Convention (UNC) paths.</description>
        </item>
        <item>
          <description>Paths that begin with a letter followed by a colon (:) are interpreted as a mounted network drive. However, <b>PathIsNetworkPath</b> cannot recognize a network drive mapped to a drive letter through the Microsoft MS-DOS SUBST command or the <see cref="DefineDosDevice" /> function.</description>
        </item>
      </list>
      <b>Note</b>  The function does not verify that the specified network resource exists, is currently accessible, or that the user has sufficient permissions to access it.
<blockquote><para>[!NOTE]
The shlwapi.h header defines PathIsNetworkPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
  </member>
  <member name="Windows.PathIsNetworkPathW">
    <summary>
      <para>Determines whether a path string represents a network resource.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string represents a network resource, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>
        <b>PathIsNetworkPath</b> interprets the following two types of paths as network paths.</para>
      <list type="bullet">
        <item>
          <description>Paths that begin with two backslash characters (\\) are interpreted as Universal Naming Convention (UNC) paths.</description>
        </item>
        <item>
          <description>Paths that begin with a letter followed by a colon (:) are interpreted as a mounted network drive. However, <b>PathIsNetworkPath</b> cannot recognize a network drive mapped to a drive letter through the Microsoft MS-DOS SUBST command or the <see cref="DefineDosDevice" /> function.</description>
        </item>
      </list>
      <b>Note</b>  The function does not verify that the specified network resource exists, is currently accessible, or that the user has sufficient permissions to access it.
<blockquote><para>[!NOTE]
The shlwapi.h header defines PathIsNetworkPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para></blockquote></remarks>
  </member>
  <member name="Windows.PathIsPrefix">
    <summary>
      <para>Examines a path to determine if it starts with <i>pszPrefix</i>.</para>
    </summary>
    <param name="pszPrefix">
      <para>Type: <b>IN LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the prefix to match.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>IN LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be examined.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszPath</i> starts with <i>pszPrefix</i>, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsPrefix as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsPrefixA">
    <summary>
      <para>Examines a path to determine if it starts with <i>pszPrefix</i>.</para>
    </summary>
    <param name="pszPrefix">
      <para>Type: <b>IN LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the prefix to match.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>IN LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be examined.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszPath</i> starts with <i>pszPrefix</i>, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsPrefix as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsPrefixW">
    <summary>
      <para>Examines a path to determine if it starts with <i>pszPrefix</i>.</para>
    </summary>
    <param name="pszPrefix">
      <para>Type: <b>IN LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the prefix to match.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>IN LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be examined.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszPath</i> starts with <i>pszPrefix</i>, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsPrefix as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsPrefix">
    <summary>
      <para>Examines a path to determine if it starts with <i>pszPrefix</i>.</para>
    </summary>
    <param name="pszPrefix">
      <para>Type: <b>IN LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the prefix to match.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>IN LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be examined.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszPath</i> starts with <i>pszPrefix</i>, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsPrefix as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsPrefixA">
    <summary>
      <para>Examines a path to determine if it starts with <i>pszPrefix</i>.</para>
    </summary>
    <param name="pszPrefix">
      <para>Type: <b>IN LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the prefix to match.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>IN LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be examined.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszPath</i> starts with <i>pszPrefix</i>, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsPrefix as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsPrefixW">
    <summary>
      <para>Examines a path to determine if it starts with <i>pszPrefix</i>.</para>
    </summary>
    <param name="pszPrefix">
      <para>Type: <b>IN LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the prefix to match.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>IN LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be examined.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszPath</i> starts with <i>pszPrefix</i>, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsPrefix as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsRelative">
    <summary>
      <para>Searches a path and determines if it is relative.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path is relative, or <b>FALSE</b> if it is absolute.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsRelative as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsRelativeA">
    <summary>
      <para>Searches a path and determines if it is relative.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path is relative, or <b>FALSE</b> if it is absolute.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsRelative as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsRelativeW">
    <summary>
      <para>Searches a path and determines if it is relative.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path is relative, or <b>FALSE</b> if it is absolute.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsRelative as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsRelative">
    <summary>
      <para>Searches a path and determines if it is relative.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path is relative, or <b>FALSE</b> if it is absolute.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsRelative as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsRelativeA">
    <summary>
      <para>Searches a path and determines if it is relative.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path is relative, or <b>FALSE</b> if it is absolute.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsRelative as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsRelativeW">
    <summary>
      <para>Searches a path and determines if it is relative.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path is relative, or <b>FALSE</b> if it is absolute.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsRelative as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsRoot">
    <summary>
      <para>Determines whether a path string refers to the root of a volume.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the specified path is a root, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>Returns <b>TRUE</b> for paths such as "", "<i>X</i>:" or "\\<i>server</i>\<i>share</i>". Paths such as "..\path2" or "\\<i>server</i>" return <b>FALSE</b>.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// String path name 1.
char buffer_1[ ] = "C:\\";
char *lpStr1;
lpStr1 = buffer_1;

// String path name 2.
char buffer_2[ ] = "path\\file";
char *lpStr2;
lpStr2 = buffer_2;

// Variable to get the return from "PathIsRoot".
int retval;

// Test case with path not absolute.
retval = PathIsRoot(lpStr1);
cout &lt;&lt; "The return from function is       :" &lt;&lt; retval &lt;&lt; endl;
cout &lt;&lt; "The path does contain a root part :" &lt;&lt; lpStr1 &lt;&lt; endl;

// Test case with path absolute.
retval = PathIsRoot(lpStr2);
cout &lt;&lt; "The return from function is       :" &lt;&lt; retval &lt;&lt; endl;
cout &lt;&lt; "The path does not contain part    :" &lt;&lt; lpStr2 &lt;&lt; endl;
}

OUTPUT:
============
The return from function is       :1
The path does contain a root part :C:\
The return from function is       :0
The path does not contain part    :path\file
============
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsRootA">
    <summary>
      <para>Determines whether a path string refers to the root of a volume.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the specified path is a root, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>Returns <b>TRUE</b> for paths such as "", "<i>X</i>:" or "\\<i>server</i>\<i>share</i>". Paths such as "..\path2" or "\\<i>server</i>" return <b>FALSE</b>.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// String path name 1.
char buffer_1[ ] = "C:\\";
char *lpStr1;
lpStr1 = buffer_1;

// String path name 2.
char buffer_2[ ] = "path\\file";
char *lpStr2;
lpStr2 = buffer_2;

// Variable to get the return from "PathIsRoot".
int retval;

// Test case with path not absolute.
retval = PathIsRoot(lpStr1);
cout &lt;&lt; "The return from function is       :" &lt;&lt; retval &lt;&lt; endl;
cout &lt;&lt; "The path does contain a root part :" &lt;&lt; lpStr1 &lt;&lt; endl;

// Test case with path absolute.
retval = PathIsRoot(lpStr2);
cout &lt;&lt; "The return from function is       :" &lt;&lt; retval &lt;&lt; endl;
cout &lt;&lt; "The path does not contain part    :" &lt;&lt; lpStr2 &lt;&lt; endl;
}

OUTPUT:
============
The return from function is       :1
The path does contain a root part :C:\
The return from function is       :0
The path does not contain part    :path\file
============
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsRootW">
    <summary>
      <para>Determines whether a path string refers to the root of a volume.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the specified path is a root, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>Returns <b>TRUE</b> for paths such as "", "<i>X</i>:" or "\\<i>server</i>\<i>share</i>". Paths such as "..\path2" or "\\<i>server</i>" return <b>FALSE</b>.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// String path name 1.
char buffer_1[ ] = "C:\\";
char *lpStr1;
lpStr1 = buffer_1;

// String path name 2.
char buffer_2[ ] = "path\\file";
char *lpStr2;
lpStr2 = buffer_2;

// Variable to get the return from "PathIsRoot".
int retval;

// Test case with path not absolute.
retval = PathIsRoot(lpStr1);
cout &lt;&lt; "The return from function is       :" &lt;&lt; retval &lt;&lt; endl;
cout &lt;&lt; "The path does contain a root part :" &lt;&lt; lpStr1 &lt;&lt; endl;

// Test case with path absolute.
retval = PathIsRoot(lpStr2);
cout &lt;&lt; "The return from function is       :" &lt;&lt; retval &lt;&lt; endl;
cout &lt;&lt; "The path does not contain part    :" &lt;&lt; lpStr2 &lt;&lt; endl;
}

OUTPUT:
============
The return from function is       :1
The path does contain a root part :C:\
The return from function is       :0
The path does not contain part    :path\file
============
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsRoot">
    <summary>
      <para>Determines whether a path string refers to the root of a volume.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the specified path is a root, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>Returns <b>TRUE</b> for paths such as "", "<i>X</i>:" or "\\<i>server</i>\<i>share</i>". Paths such as "..\path2" or "\\<i>server</i>" return <b>FALSE</b>.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// String path name 1.
char buffer_1[ ] = "C:\\";
char *lpStr1;
lpStr1 = buffer_1;

// String path name 2.
char buffer_2[ ] = "path\\file";
char *lpStr2;
lpStr2 = buffer_2;

// Variable to get the return from "PathIsRoot".
int retval;

// Test case with path not absolute.
retval = PathIsRoot(lpStr1);
cout &lt;&lt; "The return from function is       :" &lt;&lt; retval &lt;&lt; endl;
cout &lt;&lt; "The path does contain a root part :" &lt;&lt; lpStr1 &lt;&lt; endl;

// Test case with path absolute.
retval = PathIsRoot(lpStr2);
cout &lt;&lt; "The return from function is       :" &lt;&lt; retval &lt;&lt; endl;
cout &lt;&lt; "The path does not contain part    :" &lt;&lt; lpStr2 &lt;&lt; endl;
}

OUTPUT:
============
The return from function is       :1
The path does contain a root part :C:\
The return from function is       :0
The path does not contain part    :path\file
============
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsRootA">
    <summary>
      <para>Determines whether a path string refers to the root of a volume.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the specified path is a root, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>Returns <b>TRUE</b> for paths such as "", "<i>X</i>:" or "\\<i>server</i>\<i>share</i>". Paths such as "..\path2" or "\\<i>server</i>" return <b>FALSE</b>.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// String path name 1.
char buffer_1[ ] = "C:\\";
char *lpStr1;
lpStr1 = buffer_1;

// String path name 2.
char buffer_2[ ] = "path\\file";
char *lpStr2;
lpStr2 = buffer_2;

// Variable to get the return from "PathIsRoot".
int retval;

// Test case with path not absolute.
retval = PathIsRoot(lpStr1);
cout &lt;&lt; "The return from function is       :" &lt;&lt; retval &lt;&lt; endl;
cout &lt;&lt; "The path does contain a root part :" &lt;&lt; lpStr1 &lt;&lt; endl;

// Test case with path absolute.
retval = PathIsRoot(lpStr2);
cout &lt;&lt; "The return from function is       :" &lt;&lt; retval &lt;&lt; endl;
cout &lt;&lt; "The path does not contain part    :" &lt;&lt; lpStr2 &lt;&lt; endl;
}

OUTPUT:
============
The return from function is       :1
The path does contain a root part :C:\
The return from function is       :0
The path does not contain part    :path\file
============
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsRootW">
    <summary>
      <para>Determines whether a path string refers to the root of a volume.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the specified path is a root, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>Returns <b>TRUE</b> for paths such as "", "<i>X</i>:" or "\\<i>server</i>\<i>share</i>". Paths such as "..\path2" or "\\<i>server</i>" return <b>FALSE</b>.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// String path name 1.
char buffer_1[ ] = "C:\\";
char *lpStr1;
lpStr1 = buffer_1;

// String path name 2.
char buffer_2[ ] = "path\\file";
char *lpStr2;
lpStr2 = buffer_2;

// Variable to get the return from "PathIsRoot".
int retval;

// Test case with path not absolute.
retval = PathIsRoot(lpStr1);
cout &lt;&lt; "The return from function is       :" &lt;&lt; retval &lt;&lt; endl;
cout &lt;&lt; "The path does contain a root part :" &lt;&lt; lpStr1 &lt;&lt; endl;

// Test case with path absolute.
retval = PathIsRoot(lpStr2);
cout &lt;&lt; "The return from function is       :" &lt;&lt; retval &lt;&lt; endl;
cout &lt;&lt; "The path does not contain part    :" &lt;&lt; lpStr2 &lt;&lt; endl;
}

OUTPUT:
============
The return from function is       :1
The path does contain a root part :C:\
The return from function is       :0
The path does not contain part    :path\file
============
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsSameRoot">
    <summary>
      <para>Compares two paths to determine if they have a common root component.</para>
    </summary>
    <param name="pszPath1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path to be compared.</para>
    </param>
    <param name="pszPath2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if both strings have the same root component, or <b>FALSE</b> otherwise. If <i>pszPath1</i> contains only the server and share, this function also returns <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsSameRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsSameRootA">
    <summary>
      <para>Compares two paths to determine if they have a common root component.</para>
    </summary>
    <param name="pszPath1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path to be compared.</para>
    </param>
    <param name="pszPath2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if both strings have the same root component, or <b>FALSE</b> otherwise. If <i>pszPath1</i> contains only the server and share, this function also returns <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsSameRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsSameRootW">
    <summary>
      <para>Compares two paths to determine if they have a common root component.</para>
    </summary>
    <param name="pszPath1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path to be compared.</para>
    </param>
    <param name="pszPath2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if both strings have the same root component, or <b>FALSE</b> otherwise. If <i>pszPath1</i> contains only the server and share, this function also returns <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsSameRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsSameRoot">
    <summary>
      <para>Compares two paths to determine if they have a common root component.</para>
    </summary>
    <param name="pszPath1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path to be compared.</para>
    </param>
    <param name="pszPath2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if both strings have the same root component, or <b>FALSE</b> otherwise. If <i>pszPath1</i> contains only the server and share, this function also returns <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsSameRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsSameRootA">
    <summary>
      <para>Compares two paths to determine if they have a common root component.</para>
    </summary>
    <param name="pszPath1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path to be compared.</para>
    </param>
    <param name="pszPath2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if both strings have the same root component, or <b>FALSE</b> otherwise. If <i>pszPath1</i> contains only the server and share, this function also returns <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsSameRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsSameRootW">
    <summary>
      <para>Compares two paths to determine if they have a common root component.</para>
    </summary>
    <param name="pszPath1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the first path to be compared.</para>
    </param>
    <param name="pszPath2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the second path to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if both strings have the same root component, or <b>FALSE</b> otherwise. If <i>pszPath1</i> contains only the server and share, this function also returns <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsSameRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsSystemFolder">
    <summary>
      <para>Determines if an existing folder contains the attributes that make it a system folder. Alternately, this function indicates if certain attributes qualify a folder to be a system folder.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder. The attributes for this folder will be retrieved and compared with those that define a system folder. If this folder contains the attributes to make it a system folder, the function returns nonzero. If this value is <b>NULL</b>, this function determines if the attributes passed in <i>dwAttrb</i> qualify it to be a system folder.</para>
    </param>
    <param name="dwAttrb">
      <para>Type: <b>DWORD</b></para>
      <para>The file attributes to be compared. Used only if <i>pszPath</i> is <b>NULL</b>. In that case, the attributes passed in this value are compared with those that qualify a folder as a system folder. If the attributes are sufficient to make this a system folder, this function returns nonzero. These attributes are the attributes that are returned from <see cref="GetFileAttributes" />.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if the <i>pszPath</i> or <i>dwAttrb</i> represent a system folder, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsSystemFolderA">
    <summary>
      <para>Determines if an existing folder contains the attributes that make it a system folder. Alternately, this function indicates if certain attributes qualify a folder to be a system folder.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder. The attributes for this folder will be retrieved and compared with those that define a system folder. If this folder contains the attributes to make it a system folder, the function returns nonzero. If this value is <b>NULL</b>, this function determines if the attributes passed in <i>dwAttrb</i> qualify it to be a system folder.</para>
    </param>
    <param name="dwAttrb">
      <para>Type: <b>DWORD</b></para>
      <para>The file attributes to be compared. Used only if <i>pszPath</i> is <b>NULL</b>. In that case, the attributes passed in this value are compared with those that qualify a folder as a system folder. If the attributes are sufficient to make this a system folder, this function returns nonzero. These attributes are the attributes that are returned from <see cref="GetFileAttributes" />.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if the <i>pszPath</i> or <i>dwAttrb</i> represent a system folder, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsSystemFolderW">
    <summary>
      <para>Determines if an existing folder contains the attributes that make it a system folder. Alternately, this function indicates if certain attributes qualify a folder to be a system folder.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder. The attributes for this folder will be retrieved and compared with those that define a system folder. If this folder contains the attributes to make it a system folder, the function returns nonzero. If this value is <b>NULL</b>, this function determines if the attributes passed in <i>dwAttrb</i> qualify it to be a system folder.</para>
    </param>
    <param name="dwAttrb">
      <para>Type: <b>DWORD</b></para>
      <para>The file attributes to be compared. Used only if <i>pszPath</i> is <b>NULL</b>. In that case, the attributes passed in this value are compared with those that qualify a folder as a system folder. If the attributes are sufficient to make this a system folder, this function returns nonzero. These attributes are the attributes that are returned from <see cref="GetFileAttributes" />.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if the <i>pszPath</i> or <i>dwAttrb</i> represent a system folder, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsSystemFolder">
    <summary>
      <para>Determines if an existing folder contains the attributes that make it a system folder. Alternately, this function indicates if certain attributes qualify a folder to be a system folder.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder. The attributes for this folder will be retrieved and compared with those that define a system folder. If this folder contains the attributes to make it a system folder, the function returns nonzero. If this value is <b>NULL</b>, this function determines if the attributes passed in <i>dwAttrb</i> qualify it to be a system folder.</para>
    </param>
    <param name="dwAttrb">
      <para>Type: <b>DWORD</b></para>
      <para>The file attributes to be compared. Used only if <i>pszPath</i> is <b>NULL</b>. In that case, the attributes passed in this value are compared with those that qualify a folder as a system folder. If the attributes are sufficient to make this a system folder, this function returns nonzero. These attributes are the attributes that are returned from <see cref="GetFileAttributes" />.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if the <i>pszPath</i> or <i>dwAttrb</i> represent a system folder, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsSystemFolderA">
    <summary>
      <para>Determines if an existing folder contains the attributes that make it a system folder. Alternately, this function indicates if certain attributes qualify a folder to be a system folder.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder. The attributes for this folder will be retrieved and compared with those that define a system folder. If this folder contains the attributes to make it a system folder, the function returns nonzero. If this value is <b>NULL</b>, this function determines if the attributes passed in <i>dwAttrb</i> qualify it to be a system folder.</para>
    </param>
    <param name="dwAttrb">
      <para>Type: <b>DWORD</b></para>
      <para>The file attributes to be compared. Used only if <i>pszPath</i> is <b>NULL</b>. In that case, the attributes passed in this value are compared with those that qualify a folder as a system folder. If the attributes are sufficient to make this a system folder, this function returns nonzero. These attributes are the attributes that are returned from <see cref="GetFileAttributes" />.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if the <i>pszPath</i> or <i>dwAttrb</i> represent a system folder, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsSystemFolderW">
    <summary>
      <para>Determines if an existing folder contains the attributes that make it a system folder. Alternately, this function indicates if certain attributes qualify a folder to be a system folder.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder. The attributes for this folder will be retrieved and compared with those that define a system folder. If this folder contains the attributes to make it a system folder, the function returns nonzero. If this value is <b>NULL</b>, this function determines if the attributes passed in <i>dwAttrb</i> qualify it to be a system folder.</para>
    </param>
    <param name="dwAttrb">
      <para>Type: <b>DWORD</b></para>
      <para>The file attributes to be compared. Used only if <i>pszPath</i> is <b>NULL</b>. In that case, the attributes passed in this value are compared with those that qualify a folder as a system folder. If the attributes are sufficient to make this a system folder, this function returns nonzero. These attributes are the attributes that are returned from <see cref="GetFileAttributes" />.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if the <i>pszPath</i> or <i>dwAttrb</i> represent a system folder, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsUNC">
    <summary>
      <para>Determines if a path string is a valid Universal Naming Convention (UNC) path, as opposed to a path based on a drive letter.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is a valid UNC path; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsUNC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathIsUNCEx" />
  </member>
  <member name="Windows.PathIsUNCA">
    <summary>
      <para>Determines if a path string is a valid Universal Naming Convention (UNC) path, as opposed to a path based on a drive letter.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is a valid UNC path; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsUNC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathIsUNCEx" />
  </member>
  <member name="Windows.PathIsUNCW">
    <summary>
      <para>Determines if a path string is a valid Universal Naming Convention (UNC) path, as opposed to a path based on a drive letter.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is a valid UNC path; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsUNC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathIsUNCEx" />
  </member>
  <member name="Windows.PathIsUNCServer">
    <summary>
      <para>Determines if a string is a valid Universal Naming Convention (UNC) for a server path only.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is a valid UNC path for a server only (no share name), or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsUNCServer as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsUNCServerA">
    <summary>
      <para>Determines if a string is a valid Universal Naming Convention (UNC) for a server path only.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is a valid UNC path for a server only (no share name), or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsUNCServer as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsUNCServerW">
    <summary>
      <para>Determines if a string is a valid Universal Naming Convention (UNC) for a server path only.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is a valid UNC path for a server only (no share name), or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsUNCServer as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsUNCServerShare">
    <summary>
      <para>Determines if a string is a valid Universal Naming Convention (UNC) share path, \\<i>server</i>\<i>share</i>.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is in the form \\<i>server</i>\<i>share</i>, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsUNCServerShare as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsUNCServerShareA">
    <summary>
      <para>Determines if a string is a valid Universal Naming Convention (UNC) share path, \\<i>server</i>\<i>share</i>.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is in the form \\<i>server</i>\<i>share</i>, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsUNCServerShare as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsUNCServerShareW">
    <summary>
      <para>Determines if a string is a valid Universal Naming Convention (UNC) share path, \\<i>server</i>\<i>share</i>.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is in the form \\<i>server</i>\<i>share</i>, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsUNCServerShare as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsUNCServerShare">
    <summary>
      <para>Determines if a string is a valid Universal Naming Convention (UNC) share path, \\<i>server</i>\<i>share</i>.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is in the form \\<i>server</i>\<i>share</i>, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsUNCServerShare as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsUNCServerShareA">
    <summary>
      <para>Determines if a string is a valid Universal Naming Convention (UNC) share path, \\<i>server</i>\<i>share</i>.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is in the form \\<i>server</i>\<i>share</i>, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsUNCServerShare as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsUNCServerShareW">
    <summary>
      <para>Determines if a string is a valid Universal Naming Convention (UNC) share path, \\<i>server</i>\<i>share</i>.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be validated.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is in the form \\<i>server</i>\<i>share</i>, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsUNCServerShare as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsUNCServer">
    <summary>
      <para>Determines if a string is a valid Universal Naming Convention (UNC) for a server path only.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is a valid UNC path for a server only (no share name), or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsUNCServer as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsUNCServerA">
    <summary>
      <para>Determines if a string is a valid Universal Naming Convention (UNC) for a server path only.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is a valid UNC path for a server only (no share name), or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsUNCServer as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsUNCServerW">
    <summary>
      <para>Determines if a string is a valid Universal Naming Convention (UNC) for a server path only.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is a valid UNC path for a server only (no share name), or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsUNCServer as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsUNC">
    <summary>
      <para>Determines if a path string is a valid Universal Naming Convention (UNC) path, as opposed to a path based on a drive letter.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is a valid UNC path; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsUNC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathIsUNCEx" />
  </member>
  <member name="Windows.PathIsUNCA">
    <summary>
      <para>Determines if a path string is a valid Universal Naming Convention (UNC) path, as opposed to a path based on a drive letter.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is a valid UNC path; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsUNC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathIsUNCEx" />
  </member>
  <member name="Windows.PathIsUNCW">
    <summary>
      <para>Determines if a path string is a valid Universal Naming Convention (UNC) path, as opposed to a path based on a drive letter.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to validate.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is a valid UNC path; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsUNC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathIsUNCEx" />
  </member>
  <member name="Windows.PathIsURL">
    <summary>
      <para>Tests a given string to determine if it conforms to a valid URL format.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the URL path to validate.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszPath</i> has a valid URL format, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function does not verify that the path points to an existing site—only that it has a valid URL format.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// String path name 1.
char buffer_1[ ] = "http://www.microsoft.com/software/index.html";
char *lpStr1;
lpStr1 = buffer_1;

// String path name 2.
char buffer_2[ ] = "http://www.microsoft.com";
char *lpStr2;
lpStr2 = buffer_2;

// String path name 3.
char buffer_3[ ] = "microsoft.com";
char *lpStr3;
lpStr3 = buffer_3;

// Variable to get the return
// from "PathIsURL".
int retval;

// Test path name 1.
retval = PathIsURL(lpStr1);
cout &lt;&lt; "The contents of String 1: " &lt;&lt; lpStr1
     &lt;&lt; "\nThe return value from the function is " &lt;&lt; retval &lt;&lt; " = TRUE" &lt;&lt; endl;

// Test path name 2.
retval = PathIsURL(lpStr2);
cout &lt;&lt; "The contents of String 2: " &lt;&lt; lpStr2
     &lt;&lt; "\nThe return value from the function is " &lt;&lt; retval &lt;&lt; " = TRUE" &lt;&lt; endl;

// Test path name 3.
retval = PathIsURL(lpStr3);
cout &lt;&lt; "The contents of String 3: " &lt;&lt; lpStr3
     &lt;&lt; "\nThe return value from the function is " &lt;&lt; retval &lt;&lt; " = FALSE"&lt;&lt; endl;
}

OUTPUT:
=============
The contents of String 1: http://www.microsoft.com/software/index.html
The return value from the function is 1 = TRUE
The contents of String 2: http://www.microsoft.com
The return value from the function is 1 = TRUE
The contents of String 3: microsoft.com
The return value from the function is 0 = FALSE
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsURL as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsURLA">
    <summary>
      <para>Tests a given string to determine if it conforms to a valid URL format.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the URL path to validate.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszPath</i> has a valid URL format, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function does not verify that the path points to an existing site—only that it has a valid URL format.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// String path name 1.
char buffer_1[ ] = "http://www.microsoft.com/software/index.html";
char *lpStr1;
lpStr1 = buffer_1;

// String path name 2.
char buffer_2[ ] = "http://www.microsoft.com";
char *lpStr2;
lpStr2 = buffer_2;

// String path name 3.
char buffer_3[ ] = "microsoft.com";
char *lpStr3;
lpStr3 = buffer_3;

// Variable to get the return
// from "PathIsURL".
int retval;

// Test path name 1.
retval = PathIsURL(lpStr1);
cout &lt;&lt; "The contents of String 1: " &lt;&lt; lpStr1
     &lt;&lt; "\nThe return value from the function is " &lt;&lt; retval &lt;&lt; " = TRUE" &lt;&lt; endl;

// Test path name 2.
retval = PathIsURL(lpStr2);
cout &lt;&lt; "The contents of String 2: " &lt;&lt; lpStr2
     &lt;&lt; "\nThe return value from the function is " &lt;&lt; retval &lt;&lt; " = TRUE" &lt;&lt; endl;

// Test path name 3.
retval = PathIsURL(lpStr3);
cout &lt;&lt; "The contents of String 3: " &lt;&lt; lpStr3
     &lt;&lt; "\nThe return value from the function is " &lt;&lt; retval &lt;&lt; " = FALSE"&lt;&lt; endl;
}

OUTPUT:
=============
The contents of String 1: http://www.microsoft.com/software/index.html
The return value from the function is 1 = TRUE
The contents of String 2: http://www.microsoft.com
The return value from the function is 1 = TRUE
The contents of String 3: microsoft.com
The return value from the function is 0 = FALSE
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsURL as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsURLW">
    <summary>
      <para>Tests a given string to determine if it conforms to a valid URL format.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the URL path to validate.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszPath</i> has a valid URL format, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function does not verify that the path points to an existing site—only that it has a valid URL format.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// String path name 1.
char buffer_1[ ] = "http://www.microsoft.com/software/index.html";
char *lpStr1;
lpStr1 = buffer_1;

// String path name 2.
char buffer_2[ ] = "http://www.microsoft.com";
char *lpStr2;
lpStr2 = buffer_2;

// String path name 3.
char buffer_3[ ] = "microsoft.com";
char *lpStr3;
lpStr3 = buffer_3;

// Variable to get the return
// from "PathIsURL".
int retval;

// Test path name 1.
retval = PathIsURL(lpStr1);
cout &lt;&lt; "The contents of String 1: " &lt;&lt; lpStr1
     &lt;&lt; "\nThe return value from the function is " &lt;&lt; retval &lt;&lt; " = TRUE" &lt;&lt; endl;

// Test path name 2.
retval = PathIsURL(lpStr2);
cout &lt;&lt; "The contents of String 2: " &lt;&lt; lpStr2
     &lt;&lt; "\nThe return value from the function is " &lt;&lt; retval &lt;&lt; " = TRUE" &lt;&lt; endl;

// Test path name 3.
retval = PathIsURL(lpStr3);
cout &lt;&lt; "The contents of String 3: " &lt;&lt; lpStr3
     &lt;&lt; "\nThe return value from the function is " &lt;&lt; retval &lt;&lt; " = FALSE"&lt;&lt; endl;
}

OUTPUT:
=============
The contents of String 1: http://www.microsoft.com/software/index.html
The return value from the function is 1 = TRUE
The contents of String 2: http://www.microsoft.com
The return value from the function is 1 = TRUE
The contents of String 3: microsoft.com
The return value from the function is 0 = FALSE
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsURL as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsURL">
    <summary>
      <para>Tests a given string to determine if it conforms to a valid URL format.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the URL path to validate.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszPath</i> has a valid URL format, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function does not verify that the path points to an existing site—only that it has a valid URL format.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// String path name 1.
char buffer_1[ ] = "http://www.microsoft.com/software/index.html";
char *lpStr1;
lpStr1 = buffer_1;

// String path name 2.
char buffer_2[ ] = "http://www.microsoft.com";
char *lpStr2;
lpStr2 = buffer_2;

// String path name 3.
char buffer_3[ ] = "microsoft.com";
char *lpStr3;
lpStr3 = buffer_3;

// Variable to get the return
// from "PathIsURL".
int retval;

// Test path name 1.
retval = PathIsURL(lpStr1);
cout &lt;&lt; "The contents of String 1: " &lt;&lt; lpStr1
     &lt;&lt; "\nThe return value from the function is " &lt;&lt; retval &lt;&lt; " = TRUE" &lt;&lt; endl;

// Test path name 2.
retval = PathIsURL(lpStr2);
cout &lt;&lt; "The contents of String 2: " &lt;&lt; lpStr2
     &lt;&lt; "\nThe return value from the function is " &lt;&lt; retval &lt;&lt; " = TRUE" &lt;&lt; endl;

// Test path name 3.
retval = PathIsURL(lpStr3);
cout &lt;&lt; "The contents of String 3: " &lt;&lt; lpStr3
     &lt;&lt; "\nThe return value from the function is " &lt;&lt; retval &lt;&lt; " = FALSE"&lt;&lt; endl;
}

OUTPUT:
=============
The contents of String 1: http://www.microsoft.com/software/index.html
The return value from the function is 1 = TRUE
The contents of String 2: http://www.microsoft.com
The return value from the function is 1 = TRUE
The contents of String 3: microsoft.com
The return value from the function is 0 = FALSE
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsURL as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsURLA">
    <summary>
      <para>Tests a given string to determine if it conforms to a valid URL format.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the URL path to validate.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszPath</i> has a valid URL format, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function does not verify that the path points to an existing site—only that it has a valid URL format.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// String path name 1.
char buffer_1[ ] = "http://www.microsoft.com/software/index.html";
char *lpStr1;
lpStr1 = buffer_1;

// String path name 2.
char buffer_2[ ] = "http://www.microsoft.com";
char *lpStr2;
lpStr2 = buffer_2;

// String path name 3.
char buffer_3[ ] = "microsoft.com";
char *lpStr3;
lpStr3 = buffer_3;

// Variable to get the return
// from "PathIsURL".
int retval;

// Test path name 1.
retval = PathIsURL(lpStr1);
cout &lt;&lt; "The contents of String 1: " &lt;&lt; lpStr1
     &lt;&lt; "\nThe return value from the function is " &lt;&lt; retval &lt;&lt; " = TRUE" &lt;&lt; endl;

// Test path name 2.
retval = PathIsURL(lpStr2);
cout &lt;&lt; "The contents of String 2: " &lt;&lt; lpStr2
     &lt;&lt; "\nThe return value from the function is " &lt;&lt; retval &lt;&lt; " = TRUE" &lt;&lt; endl;

// Test path name 3.
retval = PathIsURL(lpStr3);
cout &lt;&lt; "The contents of String 3: " &lt;&lt; lpStr3
     &lt;&lt; "\nThe return value from the function is " &lt;&lt; retval &lt;&lt; " = FALSE"&lt;&lt; endl;
}

OUTPUT:
=============
The contents of String 1: http://www.microsoft.com/software/index.html
The return value from the function is 1 = TRUE
The contents of String 2: http://www.microsoft.com
The return value from the function is 1 = TRUE
The contents of String 3: microsoft.com
The return value from the function is 0 = FALSE
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsURL as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathIsURLW">
    <summary>
      <para>Tests a given string to determine if it conforms to a valid URL format.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the URL path to validate.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if <i>pszPath</i> has a valid URL format, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function does not verify that the path points to an existing site—only that it has a valid URL format.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// String path name 1.
char buffer_1[ ] = "http://www.microsoft.com/software/index.html";
char *lpStr1;
lpStr1 = buffer_1;

// String path name 2.
char buffer_2[ ] = "http://www.microsoft.com";
char *lpStr2;
lpStr2 = buffer_2;

// String path name 3.
char buffer_3[ ] = "microsoft.com";
char *lpStr3;
lpStr3 = buffer_3;

// Variable to get the return
// from "PathIsURL".
int retval;

// Test path name 1.
retval = PathIsURL(lpStr1);
cout &lt;&lt; "The contents of String 1: " &lt;&lt; lpStr1
     &lt;&lt; "\nThe return value from the function is " &lt;&lt; retval &lt;&lt; " = TRUE" &lt;&lt; endl;

// Test path name 2.
retval = PathIsURL(lpStr2);
cout &lt;&lt; "The contents of String 2: " &lt;&lt; lpStr2
     &lt;&lt; "\nThe return value from the function is " &lt;&lt; retval &lt;&lt; " = TRUE" &lt;&lt; endl;

// Test path name 3.
retval = PathIsURL(lpStr3);
cout &lt;&lt; "The contents of String 3: " &lt;&lt; lpStr3
     &lt;&lt; "\nThe return value from the function is " &lt;&lt; retval &lt;&lt; " = FALSE"&lt;&lt; endl;
}

OUTPUT:
=============
The contents of String 1: http://www.microsoft.com/software/index.html
The return value from the function is 1 = TRUE
The contents of String 2: http://www.microsoft.com
The return value from the function is 1 = TRUE
The contents of String 3: microsoft.com
The return value from the function is 0 = FALSE
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathIsURL as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathMakePretty">
    <summary>
      <para>Converts an all-uppercase path to all lowercase characters to give the path a consistent appearance.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be converted.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path has been converted, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function only operates on paths that are entirely uppercase. For example: C:\WINDOWS will be converted to c:\windows, but c:\Windows will not be changed.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// Path name 1.
char buffer_1[ ] = "C:\\TEST\\FILE";
char *lpStr1;
lpStr1 = buffer_1;

// Path name 2.
char buffer_2[ ] = "c:\\test\\file";
char *lpStr2;
lpStr2 = buffer_2;

// Test path name 1.
    cout &lt;&lt; "The content of the unconverted path is : " &lt;&lt; lpStr1 &lt;&lt; endl;
    cout &lt;&lt; "The \"PathMakePretty\" function returns the value "
         &lt;&lt; PathMakePretty(lpStr1) &lt;&lt; "  = TRUE &amp;amp;amp;amp;amp;amp; converts"  &lt;&lt; endl;
    cout &lt;&lt; "The content of the converted path is   : " &lt;&lt; lpStr1 &lt;&lt; endl;

// Test path name 2.
    cout &lt;&lt; "\nThe content of the unconverted path is : " &lt;&lt; lpStr2 &lt;&lt; endl;
    cout &lt;&lt; "The \"PathMakePretty\" function returns the value "
         &lt;&lt; PathMakePretty(lpStr2) &lt;&lt; "  = FALSE &amp;amp;amp;amp;amp;amp; no conversion"  &lt;&lt; endl;
    cout &lt;&lt; "The content of the converted path is   : " &lt;&lt; lpStr2 &lt;&lt; endl;
}

OUTPUT:
=============
The content of the unconverted path is : C:\TEST\FILE
The "PathMakePretty" function returns the value 1  = TRUE &amp;amp;amp;amp;amp;amp; converts
The content of the converted path is   : C:\test\file

The content of the unconverted path is : c:\test\file
The "PathMakePretty" function returns the value 0  = FALSE &amp;amp;amp;amp;amp;amp; no conversion
The content of the converted path is   : c:\test\file
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMakePretty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathMakePrettyA">
    <summary>
      <para>Converts an all-uppercase path to all lowercase characters to give the path a consistent appearance.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be converted.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path has been converted, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function only operates on paths that are entirely uppercase. For example: C:\WINDOWS will be converted to c:\windows, but c:\Windows will not be changed.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// Path name 1.
char buffer_1[ ] = "C:\\TEST\\FILE";
char *lpStr1;
lpStr1 = buffer_1;

// Path name 2.
char buffer_2[ ] = "c:\\test\\file";
char *lpStr2;
lpStr2 = buffer_2;

// Test path name 1.
    cout &lt;&lt; "The content of the unconverted path is : " &lt;&lt; lpStr1 &lt;&lt; endl;
    cout &lt;&lt; "The \"PathMakePretty\" function returns the value "
         &lt;&lt; PathMakePretty(lpStr1) &lt;&lt; "  = TRUE &amp;amp;amp;amp;amp;amp; converts"  &lt;&lt; endl;
    cout &lt;&lt; "The content of the converted path is   : " &lt;&lt; lpStr1 &lt;&lt; endl;

// Test path name 2.
    cout &lt;&lt; "\nThe content of the unconverted path is : " &lt;&lt; lpStr2 &lt;&lt; endl;
    cout &lt;&lt; "The \"PathMakePretty\" function returns the value "
         &lt;&lt; PathMakePretty(lpStr2) &lt;&lt; "  = FALSE &amp;amp;amp;amp;amp;amp; no conversion"  &lt;&lt; endl;
    cout &lt;&lt; "The content of the converted path is   : " &lt;&lt; lpStr2 &lt;&lt; endl;
}

OUTPUT:
=============
The content of the unconverted path is : C:\TEST\FILE
The "PathMakePretty" function returns the value 1  = TRUE &amp;amp;amp;amp;amp;amp; converts
The content of the converted path is   : C:\test\file

The content of the unconverted path is : c:\test\file
The "PathMakePretty" function returns the value 0  = FALSE &amp;amp;amp;amp;amp;amp; no conversion
The content of the converted path is   : c:\test\file
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMakePretty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathMakePrettyW">
    <summary>
      <para>Converts an all-uppercase path to all lowercase characters to give the path a consistent appearance.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be converted.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path has been converted, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function only operates on paths that are entirely uppercase. For example: C:\WINDOWS will be converted to c:\windows, but c:\Windows will not be changed.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// Path name 1.
char buffer_1[ ] = "C:\\TEST\\FILE";
char *lpStr1;
lpStr1 = buffer_1;

// Path name 2.
char buffer_2[ ] = "c:\\test\\file";
char *lpStr2;
lpStr2 = buffer_2;

// Test path name 1.
    cout &lt;&lt; "The content of the unconverted path is : " &lt;&lt; lpStr1 &lt;&lt; endl;
    cout &lt;&lt; "The \"PathMakePretty\" function returns the value "
         &lt;&lt; PathMakePretty(lpStr1) &lt;&lt; "  = TRUE &amp;amp;amp;amp;amp;amp; converts"  &lt;&lt; endl;
    cout &lt;&lt; "The content of the converted path is   : " &lt;&lt; lpStr1 &lt;&lt; endl;

// Test path name 2.
    cout &lt;&lt; "\nThe content of the unconverted path is : " &lt;&lt; lpStr2 &lt;&lt; endl;
    cout &lt;&lt; "The \"PathMakePretty\" function returns the value "
         &lt;&lt; PathMakePretty(lpStr2) &lt;&lt; "  = FALSE &amp;amp;amp;amp;amp;amp; no conversion"  &lt;&lt; endl;
    cout &lt;&lt; "The content of the converted path is   : " &lt;&lt; lpStr2 &lt;&lt; endl;
}

OUTPUT:
=============
The content of the unconverted path is : C:\TEST\FILE
The "PathMakePretty" function returns the value 1  = TRUE &amp;amp;amp;amp;amp;amp; converts
The content of the converted path is   : C:\test\file

The content of the unconverted path is : c:\test\file
The "PathMakePretty" function returns the value 0  = FALSE &amp;amp;amp;amp;amp;amp; no conversion
The content of the converted path is   : c:\test\file
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMakePretty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathMakePretty">
    <summary>
      <para>Converts an all-uppercase path to all lowercase characters to give the path a consistent appearance.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be converted.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path has been converted, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function only operates on paths that are entirely uppercase. For example: C:\WINDOWS will be converted to c:\windows, but c:\Windows will not be changed.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// Path name 1.
char buffer_1[ ] = "C:\\TEST\\FILE";
char *lpStr1;
lpStr1 = buffer_1;

// Path name 2.
char buffer_2[ ] = "c:\\test\\file";
char *lpStr2;
lpStr2 = buffer_2;

// Test path name 1.
    cout &lt;&lt; "The content of the unconverted path is : " &lt;&lt; lpStr1 &lt;&lt; endl;
    cout &lt;&lt; "The \"PathMakePretty\" function returns the value "
         &lt;&lt; PathMakePretty(lpStr1) &lt;&lt; "  = TRUE &amp;amp;amp;amp;amp;amp; converts"  &lt;&lt; endl;
    cout &lt;&lt; "The content of the converted path is   : " &lt;&lt; lpStr1 &lt;&lt; endl;

// Test path name 2.
    cout &lt;&lt; "\nThe content of the unconverted path is : " &lt;&lt; lpStr2 &lt;&lt; endl;
    cout &lt;&lt; "The \"PathMakePretty\" function returns the value "
         &lt;&lt; PathMakePretty(lpStr2) &lt;&lt; "  = FALSE &amp;amp;amp;amp;amp;amp; no conversion"  &lt;&lt; endl;
    cout &lt;&lt; "The content of the converted path is   : " &lt;&lt; lpStr2 &lt;&lt; endl;
}

OUTPUT:
=============
The content of the unconverted path is : C:\TEST\FILE
The "PathMakePretty" function returns the value 1  = TRUE &amp;amp;amp;amp;amp;amp; converts
The content of the converted path is   : C:\test\file

The content of the unconverted path is : c:\test\file
The "PathMakePretty" function returns the value 0  = FALSE &amp;amp;amp;amp;amp;amp; no conversion
The content of the converted path is   : c:\test\file
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMakePretty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathMakePrettyA">
    <summary>
      <para>Converts an all-uppercase path to all lowercase characters to give the path a consistent appearance.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be converted.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path has been converted, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function only operates on paths that are entirely uppercase. For example: C:\WINDOWS will be converted to c:\windows, but c:\Windows will not be changed.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// Path name 1.
char buffer_1[ ] = "C:\\TEST\\FILE";
char *lpStr1;
lpStr1 = buffer_1;

// Path name 2.
char buffer_2[ ] = "c:\\test\\file";
char *lpStr2;
lpStr2 = buffer_2;

// Test path name 1.
    cout &lt;&lt; "The content of the unconverted path is : " &lt;&lt; lpStr1 &lt;&lt; endl;
    cout &lt;&lt; "The \"PathMakePretty\" function returns the value "
         &lt;&lt; PathMakePretty(lpStr1) &lt;&lt; "  = TRUE &amp;amp;amp;amp;amp;amp; converts"  &lt;&lt; endl;
    cout &lt;&lt; "The content of the converted path is   : " &lt;&lt; lpStr1 &lt;&lt; endl;

// Test path name 2.
    cout &lt;&lt; "\nThe content of the unconverted path is : " &lt;&lt; lpStr2 &lt;&lt; endl;
    cout &lt;&lt; "The \"PathMakePretty\" function returns the value "
         &lt;&lt; PathMakePretty(lpStr2) &lt;&lt; "  = FALSE &amp;amp;amp;amp;amp;amp; no conversion"  &lt;&lt; endl;
    cout &lt;&lt; "The content of the converted path is   : " &lt;&lt; lpStr2 &lt;&lt; endl;
}

OUTPUT:
=============
The content of the unconverted path is : C:\TEST\FILE
The "PathMakePretty" function returns the value 1  = TRUE &amp;amp;amp;amp;amp;amp; converts
The content of the converted path is   : C:\test\file

The content of the unconverted path is : c:\test\file
The "PathMakePretty" function returns the value 0  = FALSE &amp;amp;amp;amp;amp;amp; no conversion
The content of the converted path is   : c:\test\file
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMakePretty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathMakePrettyW">
    <summary>
      <para>Converts an all-uppercase path to all lowercase characters to give the path a consistent appearance.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be converted.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path has been converted, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function only operates on paths that are entirely uppercase. For example: C:\WINDOWS will be converted to c:\windows, but c:\Windows will not be changed.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
// Path name 1.
char buffer_1[ ] = "C:\\TEST\\FILE";
char *lpStr1;
lpStr1 = buffer_1;

// Path name 2.
char buffer_2[ ] = "c:\\test\\file";
char *lpStr2;
lpStr2 = buffer_2;

// Test path name 1.
    cout &lt;&lt; "The content of the unconverted path is : " &lt;&lt; lpStr1 &lt;&lt; endl;
    cout &lt;&lt; "The \"PathMakePretty\" function returns the value "
         &lt;&lt; PathMakePretty(lpStr1) &lt;&lt; "  = TRUE &amp;amp;amp;amp;amp;amp; converts"  &lt;&lt; endl;
    cout &lt;&lt; "The content of the converted path is   : " &lt;&lt; lpStr1 &lt;&lt; endl;

// Test path name 2.
    cout &lt;&lt; "\nThe content of the unconverted path is : " &lt;&lt; lpStr2 &lt;&lt; endl;
    cout &lt;&lt; "The \"PathMakePretty\" function returns the value "
         &lt;&lt; PathMakePretty(lpStr2) &lt;&lt; "  = FALSE &amp;amp;amp;amp;amp;amp; no conversion"  &lt;&lt; endl;
    cout &lt;&lt; "The content of the converted path is   : " &lt;&lt; lpStr2 &lt;&lt; endl;
}

OUTPUT:
=============
The content of the unconverted path is : C:\TEST\FILE
The "PathMakePretty" function returns the value 1  = TRUE &amp;amp;amp;amp;amp;amp; converts
The content of the converted path is   : C:\test\file

The content of the unconverted path is : c:\test\file
The "PathMakePretty" function returns the value 0  = FALSE &amp;amp;amp;amp;amp;amp; no conversion
The content of the converted path is   : c:\test\file
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMakePretty as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathMakeSystemFolder">
    <summary>
      <para>Gives an existing folder the proper attributes to become a system folder.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the name of an existing folder that will be made into a system folder.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if successful, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMakeSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathMakeSystemFolderA">
    <summary>
      <para>Gives an existing folder the proper attributes to become a system folder.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the name of an existing folder that will be made into a system folder.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if successful, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMakeSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathMakeSystemFolderW">
    <summary>
      <para>Gives an existing folder the proper attributes to become a system folder.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the name of an existing folder that will be made into a system folder.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if successful, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMakeSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathMakeSystemFolder">
    <summary>
      <para>Gives an existing folder the proper attributes to become a system folder.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the name of an existing folder that will be made into a system folder.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if successful, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMakeSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathMakeSystemFolderA">
    <summary>
      <para>Gives an existing folder the proper attributes to become a system folder.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the name of an existing folder that will be made into a system folder.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if successful, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMakeSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathMakeSystemFolderW">
    <summary>
      <para>Gives an existing folder the proper attributes to become a system folder.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the name of an existing folder that will be made into a system folder.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if successful, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMakeSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathMatchSpec">
    <summary>
      <para>Searches a string using a Microsoft MS-DOS wildcard match type.</para>
    </summary>
    <param name="pszFile">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path to be searched.</para>
    </param>
    <param name="pszSpec">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to a null-terminated string that contains the file type for which to search. For example, to test whether <i>pszFile</i> is a .doc file, <i>pszSpec</i> should be set to "*.doc".</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string matches, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMatchSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathMatchSpecA">
    <summary>
      <para>Searches a string using a Microsoft MS-DOS wildcard match type.</para>
    </summary>
    <param name="pszFile">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path to be searched.</para>
    </param>
    <param name="pszSpec">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to a null-terminated string that contains the file type for which to search. For example, to test whether <i>pszFile</i> is a .doc file, <i>pszSpec</i> should be set to "*.doc".</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string matches, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMatchSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathMatchSpecW">
    <summary>
      <para>Searches a string using a Microsoft MS-DOS wildcard match type.</para>
    </summary>
    <param name="pszFile">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path to be searched.</para>
    </param>
    <param name="pszSpec">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to a null-terminated string that contains the file type for which to search. For example, to test whether <i>pszFile</i> is a .doc file, <i>pszSpec</i> should be set to "*.doc".</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string matches, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMatchSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathMatchSpecEx">
    <summary>
      <para>Matches a file name from a path against one or more file name patterns.</para>
    </summary>
    <param name="pszFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path from which the file name to be matched is taken.</para>
    </param>
    <param name="pszSpec">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the file name pattern for which to search. This can be the exact name, or it can contain wildcard characters. If exactly one pattern is specified, set the <b>PMSF_NORMAL</b> flag in <i>dwFlags</i>. If more than one pattern is specified, separate them with semicolons and set the <b>PMSF_MULTIPLE</b> flag.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Modifies the search condition. The following are valid flags.</para>
      <h4>PMSF_NORMAL (0x00000000)</h4>
      <para>The <i>pszSpec</i> parameter points to a single file name pattern to be matched.</para>
      <h4>PMSF_MULTIPLE (0x00000001)</h4>
      <para>The <i>pszSpec</i> parameter points to a semicolon-delimited list of file name patterns to be matched.</para>
      <h4>PMSF_DONT_STRIP_SPACES (0x00010000)</h4>
      <para>If <b>PMSF_NORMAL</b> is used, don't ignore leading spaces in the string pointed to by <i>pszSpec</i>. If <b>PMSF_MULTIPLE</b> is used, don't ignore leading spaces in each file type contained in the string pointed to by <i>pszSpec</i>. This flag can be combined with <b>PMSF_NORMAL</b> and <b>PMSF_MULTIPLE</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>A file name pattern specified in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>No file name pattern specified in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMatchSpecEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathMatchSpec" />
  </member>
  <member name="Windows.PathMatchSpecExA">
    <summary>
      <para>Matches a file name from a path against one or more file name patterns.</para>
    </summary>
    <param name="pszFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path from which the file name to be matched is taken.</para>
    </param>
    <param name="pszSpec">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the file name pattern for which to search. This can be the exact name, or it can contain wildcard characters. If exactly one pattern is specified, set the <b>PMSF_NORMAL</b> flag in <i>dwFlags</i>. If more than one pattern is specified, separate them with semicolons and set the <b>PMSF_MULTIPLE</b> flag.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Modifies the search condition. The following are valid flags.</para>
      <h4>PMSF_NORMAL (0x00000000)</h4>
      <para>The <i>pszSpec</i> parameter points to a single file name pattern to be matched.</para>
      <h4>PMSF_MULTIPLE (0x00000001)</h4>
      <para>The <i>pszSpec</i> parameter points to a semicolon-delimited list of file name patterns to be matched.</para>
      <h4>PMSF_DONT_STRIP_SPACES (0x00010000)</h4>
      <para>If <b>PMSF_NORMAL</b> is used, don't ignore leading spaces in the string pointed to by <i>pszSpec</i>. If <b>PMSF_MULTIPLE</b> is used, don't ignore leading spaces in each file type contained in the string pointed to by <i>pszSpec</i>. This flag can be combined with <b>PMSF_NORMAL</b> and <b>PMSF_MULTIPLE</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>A file name pattern specified in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>No file name pattern specified in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMatchSpecEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathMatchSpec" />
  </member>
  <member name="Windows.PathMatchSpecExW">
    <summary>
      <para>Matches a file name from a path against one or more file name patterns.</para>
    </summary>
    <param name="pszFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path from which the file name to be matched is taken.</para>
    </param>
    <param name="pszSpec">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the file name pattern for which to search. This can be the exact name, or it can contain wildcard characters. If exactly one pattern is specified, set the <b>PMSF_NORMAL</b> flag in <i>dwFlags</i>. If more than one pattern is specified, separate them with semicolons and set the <b>PMSF_MULTIPLE</b> flag.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Modifies the search condition. The following are valid flags.</para>
      <h4>PMSF_NORMAL (0x00000000)</h4>
      <para>The <i>pszSpec</i> parameter points to a single file name pattern to be matched.</para>
      <h4>PMSF_MULTIPLE (0x00000001)</h4>
      <para>The <i>pszSpec</i> parameter points to a semicolon-delimited list of file name patterns to be matched.</para>
      <h4>PMSF_DONT_STRIP_SPACES (0x00010000)</h4>
      <para>If <b>PMSF_NORMAL</b> is used, don't ignore leading spaces in the string pointed to by <i>pszSpec</i>. If <b>PMSF_MULTIPLE</b> is used, don't ignore leading spaces in each file type contained in the string pointed to by <i>pszSpec</i>. This flag can be combined with <b>PMSF_NORMAL</b> and <b>PMSF_MULTIPLE</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>A file name pattern specified in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>No file name pattern specified in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMatchSpecEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathMatchSpec" />
  </member>
  <member name="Windows.PathMatchSpecEx">
    <summary>
      <para>Matches a file name from a path against one or more file name patterns.</para>
    </summary>
    <param name="pszFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path from which the file name to be matched is taken.</para>
    </param>
    <param name="pszSpec">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the file name pattern for which to search. This can be the exact name, or it can contain wildcard characters. If exactly one pattern is specified, set the <b>PMSF_NORMAL</b> flag in <i>dwFlags</i>. If more than one pattern is specified, separate them with semicolons and set the <b>PMSF_MULTIPLE</b> flag.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Modifies the search condition. The following are valid flags.</para>
      <h4>PMSF_NORMAL (0x00000000)</h4>
      <para>The <i>pszSpec</i> parameter points to a single file name pattern to be matched.</para>
      <h4>PMSF_MULTIPLE (0x00000001)</h4>
      <para>The <i>pszSpec</i> parameter points to a semicolon-delimited list of file name patterns to be matched.</para>
      <h4>PMSF_DONT_STRIP_SPACES (0x00010000)</h4>
      <para>If <b>PMSF_NORMAL</b> is used, don't ignore leading spaces in the string pointed to by <i>pszSpec</i>. If <b>PMSF_MULTIPLE</b> is used, don't ignore leading spaces in each file type contained in the string pointed to by <i>pszSpec</i>. This flag can be combined with <b>PMSF_NORMAL</b> and <b>PMSF_MULTIPLE</b>.</para>
      <h5>- dwFlags.PMSF_DONT_STRIP_SPACES (0x00010000)</h5>
      <para>If <b>PMSF_NORMAL</b> is used, don't ignore leading spaces in the string pointed to by <i>pszSpec</i>. If <b>PMSF_MULTIPLE</b> is used, don't ignore leading spaces in each file type contained in the string pointed to by <i>pszSpec</i>. This flag can be combined with <b>PMSF_NORMAL</b> and <b>PMSF_MULTIPLE</b>.</para>
      <h5>- dwFlags.PMSF_MULTIPLE (0x00000001)</h5>
      <para>The <i>pszSpec</i> parameter points to a semicolon-delimited list of file name patterns to be matched.</para>
      <h5>- dwFlags.PMSF_NORMAL (0x00000000)</h5>
      <para>The <i>pszSpec</i> parameter points to a single file name pattern to be matched.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>A file name pattern specified in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>No file name pattern specified in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMatchSpecEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathMatchSpec" />
  </member>
  <member name="Windows.PathMatchSpecExA">
    <summary>
      <para>Matches a file name from a path against one or more file name patterns.</para>
    </summary>
    <param name="pszFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path from which the file name to be matched is taken.</para>
    </param>
    <param name="pszSpec">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the file name pattern for which to search. This can be the exact name, or it can contain wildcard characters. If exactly one pattern is specified, set the <b>PMSF_NORMAL</b> flag in <i>dwFlags</i>. If more than one pattern is specified, separate them with semicolons and set the <b>PMSF_MULTIPLE</b> flag.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Modifies the search condition. The following are valid flags.</para>
      <h4>PMSF_NORMAL (0x00000000)</h4>
      <para>The <i>pszSpec</i> parameter points to a single file name pattern to be matched.</para>
      <h4>PMSF_MULTIPLE (0x00000001)</h4>
      <para>The <i>pszSpec</i> parameter points to a semicolon-delimited list of file name patterns to be matched.</para>
      <h4>PMSF_DONT_STRIP_SPACES (0x00010000)</h4>
      <para>If <b>PMSF_NORMAL</b> is used, don't ignore leading spaces in the string pointed to by <i>pszSpec</i>. If <b>PMSF_MULTIPLE</b> is used, don't ignore leading spaces in each file type contained in the string pointed to by <i>pszSpec</i>. This flag can be combined with <b>PMSF_NORMAL</b> and <b>PMSF_MULTIPLE</b>.</para>
      <h5>- dwFlags.PMSF_DONT_STRIP_SPACES (0x00010000)</h5>
      <para>If <b>PMSF_NORMAL</b> is used, don't ignore leading spaces in the string pointed to by <i>pszSpec</i>. If <b>PMSF_MULTIPLE</b> is used, don't ignore leading spaces in each file type contained in the string pointed to by <i>pszSpec</i>. This flag can be combined with <b>PMSF_NORMAL</b> and <b>PMSF_MULTIPLE</b>.</para>
      <h5>- dwFlags.PMSF_MULTIPLE (0x00000001)</h5>
      <para>The <i>pszSpec</i> parameter points to a semicolon-delimited list of file name patterns to be matched.</para>
      <h5>- dwFlags.PMSF_NORMAL (0x00000000)</h5>
      <para>The <i>pszSpec</i> parameter points to a single file name pattern to be matched.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>A file name pattern specified in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>No file name pattern specified in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMatchSpecEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathMatchSpec" />
  </member>
  <member name="Windows.PathMatchSpecExW">
    <summary>
      <para>Matches a file name from a path against one or more file name patterns.</para>
    </summary>
    <param name="pszFile">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path from which the file name to be matched is taken.</para>
    </param>
    <param name="pszSpec">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the file name pattern for which to search. This can be the exact name, or it can contain wildcard characters. If exactly one pattern is specified, set the <b>PMSF_NORMAL</b> flag in <i>dwFlags</i>. If more than one pattern is specified, separate them with semicolons and set the <b>PMSF_MULTIPLE</b> flag.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Modifies the search condition. The following are valid flags.</para>
      <h4>PMSF_NORMAL (0x00000000)</h4>
      <para>The <i>pszSpec</i> parameter points to a single file name pattern to be matched.</para>
      <h4>PMSF_MULTIPLE (0x00000001)</h4>
      <para>The <i>pszSpec</i> parameter points to a semicolon-delimited list of file name patterns to be matched.</para>
      <h4>PMSF_DONT_STRIP_SPACES (0x00010000)</h4>
      <para>If <b>PMSF_NORMAL</b> is used, don't ignore leading spaces in the string pointed to by <i>pszSpec</i>. If <b>PMSF_MULTIPLE</b> is used, don't ignore leading spaces in each file type contained in the string pointed to by <i>pszSpec</i>. This flag can be combined with <b>PMSF_NORMAL</b> and <b>PMSF_MULTIPLE</b>.</para>
      <h5>- dwFlags.PMSF_DONT_STRIP_SPACES (0x00010000)</h5>
      <para>If <b>PMSF_NORMAL</b> is used, don't ignore leading spaces in the string pointed to by <i>pszSpec</i>. If <b>PMSF_MULTIPLE</b> is used, don't ignore leading spaces in each file type contained in the string pointed to by <i>pszSpec</i>. This flag can be combined with <b>PMSF_NORMAL</b> and <b>PMSF_MULTIPLE</b>.</para>
      <h5>- dwFlags.PMSF_MULTIPLE (0x00000001)</h5>
      <para>The <i>pszSpec</i> parameter points to a semicolon-delimited list of file name patterns to be matched.</para>
      <h5>- dwFlags.PMSF_NORMAL (0x00000000)</h5>
      <para>The <i>pszSpec</i> parameter points to a single file name pattern to be matched.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns one of the following values.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>A file name pattern specified in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>No file name pattern specified in <i>pszSpec</i> matched the file name found in the string pointed to by <i>pszFile</i>.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMatchSpecEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathMatchSpec" />
  </member>
  <member name="Windows.PathMatchSpec">
    <summary>
      <para>Searches a string using a Microsoft MS-DOS wildcard match type.</para>
    </summary>
    <param name="pszFile">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path to be searched.</para>
    </param>
    <param name="pszSpec">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to a null-terminated string that contains the file type for which to search. For example, to test whether <i>pszFile</i> is a .doc file, <i>pszSpec</i> should be set to "*.doc".</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string matches, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMatchSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathMatchSpecA">
    <summary>
      <para>Searches a string using a Microsoft MS-DOS wildcard match type.</para>
    </summary>
    <param name="pszFile">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path to be searched.</para>
    </param>
    <param name="pszSpec">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to a null-terminated string that contains the file type for which to search. For example, to test whether <i>pszFile</i> is a .doc file, <i>pszSpec</i> should be set to "*.doc".</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string matches, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMatchSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathMatchSpecW">
    <summary>
      <para>Searches a string using a Microsoft MS-DOS wildcard match type.</para>
    </summary>
    <param name="pszFile">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path to be searched.</para>
    </param>
    <param name="pszSpec">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to a null-terminated string that contains the file type for which to search. For example, to test whether <i>pszFile</i> is a .doc file, <i>pszSpec</i> should be set to "*.doc".</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string matches, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathMatchSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathParseIconLocation">
    <summary>
      <para>Parses a file location string that contains a file location and icon index, and returns separate values.</para>
    </summary>
    <param name="pszIconFile">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains a file location string. It should be in the form "<i>path</i>,<i>iconindex</i>". When the function returns, <i>pszIconFile</i> will point to the file's path.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the valid icon index value.</para>
    </returns>
    <remarks>
      <para>This function is useful for taking a DefaultIcon value retrieved from the registry by <see cref="SHGetValue" /> and separating the icon index from the path.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
// Path to parse for file and icon index.
char buffer_1[ ] = "C:\\TEST\\sample.txt,3";
char *lpStr1;
lpStr1 = buffer_1;

// Return value from "PathParseIconLocation".
int retval;

// Search a path to parse for file and icon index.
retval = PathParseIconLocation(lpStr1);
cout &lt;&lt; "The path to parse for file and icon index is   : " &lt;&lt; lpStr1 &lt;&lt; endl;
cout &lt;&lt; "PathParseIconLocation returns the icon index of: " &lt;&lt; retval &lt;&lt; endl;
}

OUTPUT:
==========
The path to parse for file and icon index is   : C:\TEST\sample.txt
PathParseIconLocation returns the icon index of: 3
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathParseIconLocation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathParseIconLocationA">
    <summary>
      <para>Parses a file location string that contains a file location and icon index, and returns separate values.</para>
    </summary>
    <param name="pszIconFile">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains a file location string. It should be in the form "<i>path</i>,<i>iconindex</i>". When the function returns, <i>pszIconFile</i> will point to the file's path.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the valid icon index value.</para>
    </returns>
    <remarks>
      <para>This function is useful for taking a DefaultIcon value retrieved from the registry by <see cref="SHGetValue" /> and separating the icon index from the path.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
// Path to parse for file and icon index.
char buffer_1[ ] = "C:\\TEST\\sample.txt,3";
char *lpStr1;
lpStr1 = buffer_1;

// Return value from "PathParseIconLocation".
int retval;

// Search a path to parse for file and icon index.
retval = PathParseIconLocation(lpStr1);
cout &lt;&lt; "The path to parse for file and icon index is   : " &lt;&lt; lpStr1 &lt;&lt; endl;
cout &lt;&lt; "PathParseIconLocation returns the icon index of: " &lt;&lt; retval &lt;&lt; endl;
}

OUTPUT:
==========
The path to parse for file and icon index is   : C:\TEST\sample.txt
PathParseIconLocation returns the icon index of: 3
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathParseIconLocation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathParseIconLocationW">
    <summary>
      <para>Parses a file location string that contains a file location and icon index, and returns separate values.</para>
    </summary>
    <param name="pszIconFile">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains a file location string. It should be in the form "<i>path</i>,<i>iconindex</i>". When the function returns, <i>pszIconFile</i> will point to the file's path.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the valid icon index value.</para>
    </returns>
    <remarks>
      <para>This function is useful for taking a DefaultIcon value retrieved from the registry by <see cref="SHGetValue" /> and separating the icon index from the path.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
// Path to parse for file and icon index.
char buffer_1[ ] = "C:\\TEST\\sample.txt,3";
char *lpStr1;
lpStr1 = buffer_1;

// Return value from "PathParseIconLocation".
int retval;

// Search a path to parse for file and icon index.
retval = PathParseIconLocation(lpStr1);
cout &lt;&lt; "The path to parse for file and icon index is   : " &lt;&lt; lpStr1 &lt;&lt; endl;
cout &lt;&lt; "PathParseIconLocation returns the icon index of: " &lt;&lt; retval &lt;&lt; endl;
}

OUTPUT:
==========
The path to parse for file and icon index is   : C:\TEST\sample.txt
PathParseIconLocation returns the icon index of: 3
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathParseIconLocation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathParseIconLocation">
    <summary>
      <para>Parses a file location string that contains a file location and icon index, and returns separate values.</para>
    </summary>
    <param name="pszIconFile">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains a file location string. It should be in the form "<i>path</i>,<i>iconindex</i>". When the function returns, <i>pszIconFile</i> will point to the file's path.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the valid icon index value.</para>
    </returns>
    <remarks>
      <para>This function is useful for taking a DefaultIcon value retrieved from the registry by <see cref="SHGetValue" /> and separating the icon index from the path.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
// Path to parse for file and icon index.
char buffer_1[ ] = "C:\\TEST\\sample.txt,3";
char *lpStr1;
lpStr1 = buffer_1;

// Return value from "PathParseIconLocation".
int retval;

// Search a path to parse for file and icon index.
retval = PathParseIconLocation(lpStr1);
cout &lt;&lt; "The path to parse for file and icon index is   : " &lt;&lt; lpStr1 &lt;&lt; endl;
cout &lt;&lt; "PathParseIconLocation returns the icon index of: " &lt;&lt; retval &lt;&lt; endl;
}

OUTPUT:
==========
The path to parse for file and icon index is   : C:\TEST\sample.txt
PathParseIconLocation returns the icon index of: 3
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathParseIconLocation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathParseIconLocationA">
    <summary>
      <para>Parses a file location string that contains a file location and icon index, and returns separate values.</para>
    </summary>
    <param name="pszIconFile">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains a file location string. It should be in the form "<i>path</i>,<i>iconindex</i>". When the function returns, <i>pszIconFile</i> will point to the file's path.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the valid icon index value.</para>
    </returns>
    <remarks>
      <para>This function is useful for taking a DefaultIcon value retrieved from the registry by <see cref="SHGetValue" /> and separating the icon index from the path.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
// Path to parse for file and icon index.
char buffer_1[ ] = "C:\\TEST\\sample.txt,3";
char *lpStr1;
lpStr1 = buffer_1;

// Return value from "PathParseIconLocation".
int retval;

// Search a path to parse for file and icon index.
retval = PathParseIconLocation(lpStr1);
cout &lt;&lt; "The path to parse for file and icon index is   : " &lt;&lt; lpStr1 &lt;&lt; endl;
cout &lt;&lt; "PathParseIconLocation returns the icon index of: " &lt;&lt; retval &lt;&lt; endl;
}

OUTPUT:
==========
The path to parse for file and icon index is   : C:\TEST\sample.txt
PathParseIconLocation returns the icon index of: 3
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathParseIconLocation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathParseIconLocationW">
    <summary>
      <para>Parses a file location string that contains a file location and icon index, and returns separate values.</para>
    </summary>
    <param name="pszIconFile">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains a file location string. It should be in the form "<i>path</i>,<i>iconindex</i>". When the function returns, <i>pszIconFile</i> will point to the file's path.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the valid icon index value.</para>
    </returns>
    <remarks>
      <para>This function is useful for taking a DefaultIcon value retrieved from the registry by <see cref="SHGetValue" /> and separating the icon index from the path.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
// Path to parse for file and icon index.
char buffer_1[ ] = "C:\\TEST\\sample.txt,3";
char *lpStr1;
lpStr1 = buffer_1;

// Return value from "PathParseIconLocation".
int retval;

// Search a path to parse for file and icon index.
retval = PathParseIconLocation(lpStr1);
cout &lt;&lt; "The path to parse for file and icon index is   : " &lt;&lt; lpStr1 &lt;&lt; endl;
cout &lt;&lt; "PathParseIconLocation returns the icon index of: " &lt;&lt; retval &lt;&lt; endl;
}

OUTPUT:
==========
The path to parse for file and icon index is   : C:\TEST\sample.txt
PathParseIconLocation returns the icon index of: 3
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathParseIconLocation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathQuoteSpaces">
    <summary>
      <para>Searches a path for spaces. If spaces are found, the entire path is enclosed in quotation marks.</para>
    </summary>
    <param name="lpsz">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path to search. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if spaces were found; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathQuoteSpaces as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathQuoteSpacesA">
    <summary>
      <para>Searches a path for spaces. If spaces are found, the entire path is enclosed in quotation marks.</para>
    </summary>
    <param name="lpsz">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path to search. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if spaces were found; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathQuoteSpaces as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathQuoteSpacesW">
    <summary>
      <para>Searches a path for spaces. If spaces are found, the entire path is enclosed in quotation marks.</para>
    </summary>
    <param name="lpsz">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path to search. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if spaces were found; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathQuoteSpaces as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathQuoteSpaces">
    <summary>
      <para>Searches a path for spaces. If spaces are found, the entire path is enclosed in quotation marks.</para>
    </summary>
    <param name="lpsz">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path to search. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if spaces were found; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathQuoteSpaces as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathQuoteSpacesA">
    <summary>
      <para>Searches a path for spaces. If spaces are found, the entire path is enclosed in quotation marks.</para>
    </summary>
    <param name="lpsz">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path to search. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if spaces were found; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathQuoteSpaces as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathQuoteSpacesW">
    <summary>
      <para>Searches a path for spaces. If spaces are found, the entire path is enclosed in quotation marks.</para>
    </summary>
    <param name="lpsz">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the path to search. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if spaces were found; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathQuoteSpaces as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRelativePathTo">
    <summary>
      <para>Creates a relative path from one file or folder to another.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that receives the relative path. This buffer must be at least MAX_PATH characters in size.</para>
    </param>
    <param name="pszFrom">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the start of the relative path.</para>
    </param>
    <param name="dwAttrFrom">
      <para>Type: <b>DWORD</b></para>
      <para>The file attributes of <i>pszFrom</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY, <i>pszFrom</i> is assumed to be a directory; otherwise, <i>pszFrom</i> is assumed to be a file.</para>
    </param>
    <param name="pszTo">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the endpoint of the relative path.</para>
    </param>
    <param name="dwAttrTo">
      <para>Type: <b>DWORD</b></para>
      <para>The file attributes of <i>pszTo</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY, <i>pszTo</i> is assumed to be directory; otherwise, <i>pszTo</i> is assumed to be a file.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function takes a pair of paths and generates a relative path from one to the other. The paths do not have to be fully qualified, but they must have a common prefix, or the function will fail and return <b>FALSE</b>.</para>
      <para>For example, let the starting point, <i>pszFrom</i>, be "c:\FolderA\FolderB\FolderC", and the ending point, <i>pszTo</i>, be "c:\FolderA\FolderD\FolderE". <b>PathRelativePathTo</b> will return the relative path from <i>pszFrom</i> to <i>pszTo</i> as: "....\FolderD\FolderE". You will get the same result if you set <i>pszFrom</i> to "\FolderA\FolderB\FolderC" and <i>pszTo</i> to "\FolderA\FolderD\FolderE". On the other hand, "c:\FolderA\FolderB" and "a:\FolderA\FolderD do not share a common prefix, and the function will fail. Note that "\" is not considered a prefix and is ignored. If you set <i>pszFrom</i> to "\FolderA\FolderB", and <i>pszTo</i> to "\FolderC\FolderD", the function will fail.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
    char szOut[MAX_PATH] = "";
    char szFrom[ ] = "c:\\a\\b\\path";
    char szTo[ ] = "c:\\a\\x\\y\\file";

    cout  &lt;&lt;  "The relative path is relative from: ";
    cout  &lt;&lt;  szFrom;
    cout  &lt;&lt;  "\n";

    cout  &lt;&lt;  "The relative path is relative to: ";
    cout  &lt;&lt;  szTo;
    cout  &lt;&lt;  "\n";

    PathRelativePathTo(szOut,
                       szFrom,
                       FILE_ATTRIBUTE_DIRECTORY,
                       szTo,
                       FILE_ATTRIBUTE_NORMAL);

    cout  &lt;&lt;  "The relative path is: ";
    cout  &lt;&lt;  szOut;
    cout  &lt;&lt;  "\n";
}

OUTPUT:
==================
The relative path is relative from: c:\a\b\path
The relative path is relative to: c:\a\x\y\file
The relative path is: ..\..\x\y\file
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRelativePathTo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRelativePathToA">
    <summary>
      <para>Creates a relative path from one file or folder to another.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that receives the relative path. This buffer must be at least MAX_PATH characters in size.</para>
    </param>
    <param name="pszFrom">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the start of the relative path.</para>
    </param>
    <param name="dwAttrFrom">
      <para>Type: <b>DWORD</b></para>
      <para>The file attributes of <i>pszFrom</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY, <i>pszFrom</i> is assumed to be a directory; otherwise, <i>pszFrom</i> is assumed to be a file.</para>
    </param>
    <param name="pszTo">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the endpoint of the relative path.</para>
    </param>
    <param name="dwAttrTo">
      <para>Type: <b>DWORD</b></para>
      <para>The file attributes of <i>pszTo</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY, <i>pszTo</i> is assumed to be directory; otherwise, <i>pszTo</i> is assumed to be a file.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function takes a pair of paths and generates a relative path from one to the other. The paths do not have to be fully qualified, but they must have a common prefix, or the function will fail and return <b>FALSE</b>.</para>
      <para>For example, let the starting point, <i>pszFrom</i>, be "c:\FolderA\FolderB\FolderC", and the ending point, <i>pszTo</i>, be "c:\FolderA\FolderD\FolderE". <b>PathRelativePathTo</b> will return the relative path from <i>pszFrom</i> to <i>pszTo</i> as: "....\FolderD\FolderE". You will get the same result if you set <i>pszFrom</i> to "\FolderA\FolderB\FolderC" and <i>pszTo</i> to "\FolderA\FolderD\FolderE". On the other hand, "c:\FolderA\FolderB" and "a:\FolderA\FolderD do not share a common prefix, and the function will fail. Note that "\" is not considered a prefix and is ignored. If you set <i>pszFrom</i> to "\FolderA\FolderB", and <i>pszTo</i> to "\FolderC\FolderD", the function will fail.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
    char szOut[MAX_PATH] = "";
    char szFrom[ ] = "c:\\a\\b\\path";
    char szTo[ ] = "c:\\a\\x\\y\\file";

    cout  &lt;&lt;  "The relative path is relative from: ";
    cout  &lt;&lt;  szFrom;
    cout  &lt;&lt;  "\n";

    cout  &lt;&lt;  "The relative path is relative to: ";
    cout  &lt;&lt;  szTo;
    cout  &lt;&lt;  "\n";

    PathRelativePathTo(szOut,
                       szFrom,
                       FILE_ATTRIBUTE_DIRECTORY,
                       szTo,
                       FILE_ATTRIBUTE_NORMAL);

    cout  &lt;&lt;  "The relative path is: ";
    cout  &lt;&lt;  szOut;
    cout  &lt;&lt;  "\n";
}

OUTPUT:
==================
The relative path is relative from: c:\a\b\path
The relative path is relative to: c:\a\x\y\file
The relative path is: ..\..\x\y\file
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRelativePathTo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRelativePathToW">
    <summary>
      <para>Creates a relative path from one file or folder to another.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that receives the relative path. This buffer must be at least MAX_PATH characters in size.</para>
    </param>
    <param name="pszFrom">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the start of the relative path.</para>
    </param>
    <param name="dwAttrFrom">
      <para>Type: <b>DWORD</b></para>
      <para>The file attributes of <i>pszFrom</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY, <i>pszFrom</i> is assumed to be a directory; otherwise, <i>pszFrom</i> is assumed to be a file.</para>
    </param>
    <param name="pszTo">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the endpoint of the relative path.</para>
    </param>
    <param name="dwAttrTo">
      <para>Type: <b>DWORD</b></para>
      <para>The file attributes of <i>pszTo</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY, <i>pszTo</i> is assumed to be directory; otherwise, <i>pszTo</i> is assumed to be a file.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function takes a pair of paths and generates a relative path from one to the other. The paths do not have to be fully qualified, but they must have a common prefix, or the function will fail and return <b>FALSE</b>.</para>
      <para>For example, let the starting point, <i>pszFrom</i>, be "c:\FolderA\FolderB\FolderC", and the ending point, <i>pszTo</i>, be "c:\FolderA\FolderD\FolderE". <b>PathRelativePathTo</b> will return the relative path from <i>pszFrom</i> to <i>pszTo</i> as: "....\FolderD\FolderE". You will get the same result if you set <i>pszFrom</i> to "\FolderA\FolderB\FolderC" and <i>pszTo</i> to "\FolderA\FolderD\FolderE". On the other hand, "c:\FolderA\FolderB" and "a:\FolderA\FolderD do not share a common prefix, and the function will fail. Note that "\" is not considered a prefix and is ignored. If you set <i>pszFrom</i> to "\FolderA\FolderB", and <i>pszTo</i> to "\FolderC\FolderD", the function will fail.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
    char szOut[MAX_PATH] = "";
    char szFrom[ ] = "c:\\a\\b\\path";
    char szTo[ ] = "c:\\a\\x\\y\\file";

    cout  &lt;&lt;  "The relative path is relative from: ";
    cout  &lt;&lt;  szFrom;
    cout  &lt;&lt;  "\n";

    cout  &lt;&lt;  "The relative path is relative to: ";
    cout  &lt;&lt;  szTo;
    cout  &lt;&lt;  "\n";

    PathRelativePathTo(szOut,
                       szFrom,
                       FILE_ATTRIBUTE_DIRECTORY,
                       szTo,
                       FILE_ATTRIBUTE_NORMAL);

    cout  &lt;&lt;  "The relative path is: ";
    cout  &lt;&lt;  szOut;
    cout  &lt;&lt;  "\n";
}

OUTPUT:
==================
The relative path is relative from: c:\a\b\path
The relative path is relative to: c:\a\x\y\file
The relative path is: ..\..\x\y\file
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRelativePathTo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRelativePathTo">
    <summary>
      <para>Creates a relative path from one file or folder to another.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that receives the relative path. This buffer must be at least MAX_PATH characters in size.</para>
    </param>
    <param name="pszFrom">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the start of the relative path.</para>
    </param>
    <param name="dwAttrFrom">
      <para>Type: <b>DWORD</b></para>
      <para>The file attributes of <i>pszFrom</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY, <i>pszFrom</i> is assumed to be a directory; otherwise, <i>pszFrom</i> is assumed to be a file.</para>
    </param>
    <param name="pszTo">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the endpoint of the relative path.</para>
    </param>
    <param name="dwAttrTo">
      <para>Type: <b>DWORD</b></para>
      <para>The file attributes of <i>pszTo</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY, <i>pszTo</i> is assumed to be directory; otherwise, <i>pszTo</i> is assumed to be a file.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function takes a pair of paths and generates a relative path from one to the other. The paths do not have to be fully qualified, but they must have a common prefix, or the function will fail and return <b>FALSE</b>.</para>
      <para>For example, let the starting point, <i>pszFrom</i>, be "c:\FolderA\FolderB\FolderC", and the ending point, <i>pszTo</i>, be "c:\FolderA\FolderD\FolderE". <b>PathRelativePathTo</b> will return the relative path from <i>pszFrom</i> to <i>pszTo</i> as: "....\FolderD\FolderE". You will get the same result if you set <i>pszFrom</i> to "\FolderA\FolderB\FolderC" and <i>pszTo</i> to "\FolderA\FolderD\FolderE". On the other hand, "c:\FolderA\FolderB" and "a:\FolderA\FolderD do not share a common prefix, and the function will fail. Note that "\" is not considered a prefix and is ignored. If you set <i>pszFrom</i> to "\FolderA\FolderB", and <i>pszTo</i> to "\FolderC\FolderD", the function will fail.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
    char szOut[MAX_PATH] = "";
    char szFrom[ ] = "c:\\a\\b\\path";
    char szTo[ ] = "c:\\a\\x\\y\\file";

    cout  &lt;&lt;  "The relative path is relative from: ";
    cout  &lt;&lt;  szFrom;
    cout  &lt;&lt;  "\n";

    cout  &lt;&lt;  "The relative path is relative to: ";
    cout  &lt;&lt;  szTo;
    cout  &lt;&lt;  "\n";

    PathRelativePathTo(szOut,
                       szFrom,
                       FILE_ATTRIBUTE_DIRECTORY,
                       szTo,
                       FILE_ATTRIBUTE_NORMAL);

    cout  &lt;&lt;  "The relative path is: ";
    cout  &lt;&lt;  szOut;
    cout  &lt;&lt;  "\n";
}

OUTPUT:
==================
The relative path is relative from: c:\a\b\path
The relative path is relative to: c:\a\x\y\file
The relative path is: ..\..\x\y\file
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRelativePathTo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRelativePathToA">
    <summary>
      <para>Creates a relative path from one file or folder to another.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that receives the relative path. This buffer must be at least MAX_PATH characters in size.</para>
    </param>
    <param name="pszFrom">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the start of the relative path.</para>
    </param>
    <param name="dwAttrFrom">
      <para>Type: <b>DWORD</b></para>
      <para>The file attributes of <i>pszFrom</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY, <i>pszFrom</i> is assumed to be a directory; otherwise, <i>pszFrom</i> is assumed to be a file.</para>
    </param>
    <param name="pszTo">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the endpoint of the relative path.</para>
    </param>
    <param name="dwAttrTo">
      <para>Type: <b>DWORD</b></para>
      <para>The file attributes of <i>pszTo</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY, <i>pszTo</i> is assumed to be directory; otherwise, <i>pszTo</i> is assumed to be a file.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function takes a pair of paths and generates a relative path from one to the other. The paths do not have to be fully qualified, but they must have a common prefix, or the function will fail and return <b>FALSE</b>.</para>
      <para>For example, let the starting point, <i>pszFrom</i>, be "c:\FolderA\FolderB\FolderC", and the ending point, <i>pszTo</i>, be "c:\FolderA\FolderD\FolderE". <b>PathRelativePathTo</b> will return the relative path from <i>pszFrom</i> to <i>pszTo</i> as: "....\FolderD\FolderE". You will get the same result if you set <i>pszFrom</i> to "\FolderA\FolderB\FolderC" and <i>pszTo</i> to "\FolderA\FolderD\FolderE". On the other hand, "c:\FolderA\FolderB" and "a:\FolderA\FolderD do not share a common prefix, and the function will fail. Note that "\" is not considered a prefix and is ignored. If you set <i>pszFrom</i> to "\FolderA\FolderB", and <i>pszTo</i> to "\FolderC\FolderD", the function will fail.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
    char szOut[MAX_PATH] = "";
    char szFrom[ ] = "c:\\a\\b\\path";
    char szTo[ ] = "c:\\a\\x\\y\\file";

    cout  &lt;&lt;  "The relative path is relative from: ";
    cout  &lt;&lt;  szFrom;
    cout  &lt;&lt;  "\n";

    cout  &lt;&lt;  "The relative path is relative to: ";
    cout  &lt;&lt;  szTo;
    cout  &lt;&lt;  "\n";

    PathRelativePathTo(szOut,
                       szFrom,
                       FILE_ATTRIBUTE_DIRECTORY,
                       szTo,
                       FILE_ATTRIBUTE_NORMAL);

    cout  &lt;&lt;  "The relative path is: ";
    cout  &lt;&lt;  szOut;
    cout  &lt;&lt;  "\n";
}

OUTPUT:
==================
The relative path is relative from: c:\a\b\path
The relative path is relative to: c:\a\x\y\file
The relative path is: ..\..\x\y\file
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRelativePathTo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRelativePathToW">
    <summary>
      <para>Creates a relative path from one file or folder to another.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a string that receives the relative path. This buffer must be at least MAX_PATH characters in size.</para>
    </param>
    <param name="pszFrom">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the start of the relative path.</para>
    </param>
    <param name="dwAttrFrom">
      <para>Type: <b>DWORD</b></para>
      <para>The file attributes of <i>pszFrom</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY, <i>pszFrom</i> is assumed to be a directory; otherwise, <i>pszFrom</i> is assumed to be a file.</para>
    </param>
    <param name="pszTo">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path that defines the endpoint of the relative path.</para>
    </param>
    <param name="dwAttrTo">
      <para>Type: <b>DWORD</b></para>
      <para>The file attributes of <i>pszTo</i>. If this value contains FILE_ATTRIBUTE_DIRECTORY, <i>pszTo</i> is assumed to be directory; otherwise, <i>pszTo</i> is assumed to be a file.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function takes a pair of paths and generates a relative path from one to the other. The paths do not have to be fully qualified, but they must have a common prefix, or the function will fail and return <b>FALSE</b>.</para>
      <para>For example, let the starting point, <i>pszFrom</i>, be "c:\FolderA\FolderB\FolderC", and the ending point, <i>pszTo</i>, be "c:\FolderA\FolderD\FolderE". <b>PathRelativePathTo</b> will return the relative path from <i>pszFrom</i> to <i>pszTo</i> as: "....\FolderD\FolderE". You will get the same result if you set <i>pszFrom</i> to "\FolderA\FolderB\FolderC" and <i>pszTo</i> to "\FolderA\FolderD\FolderE". On the other hand, "c:\FolderA\FolderB" and "a:\FolderA\FolderD do not share a common prefix, and the function will fail. Note that "\" is not considered a prefix and is ignored. If you set <i>pszFrom</i> to "\FolderA\FolderB", and <i>pszTo</i> to "\FolderC\FolderD", the function will fail.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
    char szOut[MAX_PATH] = "";
    char szFrom[ ] = "c:\\a\\b\\path";
    char szTo[ ] = "c:\\a\\x\\y\\file";

    cout  &lt;&lt;  "The relative path is relative from: ";
    cout  &lt;&lt;  szFrom;
    cout  &lt;&lt;  "\n";

    cout  &lt;&lt;  "The relative path is relative to: ";
    cout  &lt;&lt;  szTo;
    cout  &lt;&lt;  "\n";

    PathRelativePathTo(szOut,
                       szFrom,
                       FILE_ATTRIBUTE_DIRECTORY,
                       szTo,
                       FILE_ATTRIBUTE_NORMAL);

    cout  &lt;&lt;  "The relative path is: ";
    cout  &lt;&lt;  szOut;
    cout  &lt;&lt;  "\n";
}

OUTPUT:
==================
The relative path is relative from: c:\a\b\path
The relative path is relative to: c:\a\x\y\file
The relative path is: ..\..\x\y\file
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRelativePathTo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveArgs">
    <summary>
      <para>Removes any arguments from a given path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove arguments.</para>
    </param>
    <remarks>
      <para>This function should not be used on generic command path templates (from users or the registry), but rather it should be used only on templates that the application knows to be well formed.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
    // Path with arguments.
    char buffer_1[ ] = "c:\\a\\b\\FileA Arg1 Arg2";
    char *lpStr1;
    lpStr1 = buffer_1;

    // Path before "PathRemoveArgs".
    cout &lt;&lt; "Path before calling \"PathRemoveArgs\": " &lt;&lt; lpStr1 &lt;&lt; endl;

    // Call function "PathRemoveArgs".
    PathRemoveArgs(lpStr1);

    // Path after "PathRemoveArgs".
    cout &lt;&lt; "Path after calling \"PathRemoveArgs\": " &lt;&lt; lpStr1 &lt;&lt; endl;
}

OUTPUT:
==================
Path before calling "PathRemoveArgs": c:\a\b\FileA Arg1 Arg2
Path after calling "PathRemoveArgs": c:\a\b\FileA
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveArgs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveArgsA">
    <summary>
      <para>Removes any arguments from a given path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove arguments.</para>
    </param>
    <remarks>
      <para>This function should not be used on generic command path templates (from users or the registry), but rather it should be used only on templates that the application knows to be well formed.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
    // Path with arguments.
    char buffer_1[ ] = "c:\\a\\b\\FileA Arg1 Arg2";
    char *lpStr1;
    lpStr1 = buffer_1;

    // Path before "PathRemoveArgs".
    cout &lt;&lt; "Path before calling \"PathRemoveArgs\": " &lt;&lt; lpStr1 &lt;&lt; endl;

    // Call function "PathRemoveArgs".
    PathRemoveArgs(lpStr1);

    // Path after "PathRemoveArgs".
    cout &lt;&lt; "Path after calling \"PathRemoveArgs\": " &lt;&lt; lpStr1 &lt;&lt; endl;
}

OUTPUT:
==================
Path before calling "PathRemoveArgs": c:\a\b\FileA Arg1 Arg2
Path after calling "PathRemoveArgs": c:\a\b\FileA
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveArgs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveArgsW">
    <summary>
      <para>Removes any arguments from a given path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove arguments.</para>
    </param>
    <remarks>
      <para>This function should not be used on generic command path templates (from users or the registry), but rather it should be used only on templates that the application knows to be well formed.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
    // Path with arguments.
    char buffer_1[ ] = "c:\\a\\b\\FileA Arg1 Arg2";
    char *lpStr1;
    lpStr1 = buffer_1;

    // Path before "PathRemoveArgs".
    cout &lt;&lt; "Path before calling \"PathRemoveArgs\": " &lt;&lt; lpStr1 &lt;&lt; endl;

    // Call function "PathRemoveArgs".
    PathRemoveArgs(lpStr1);

    // Path after "PathRemoveArgs".
    cout &lt;&lt; "Path after calling \"PathRemoveArgs\": " &lt;&lt; lpStr1 &lt;&lt; endl;
}

OUTPUT:
==================
Path before calling "PathRemoveArgs": c:\a\b\FileA Arg1 Arg2
Path after calling "PathRemoveArgs": c:\a\b\FileA
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveArgs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveArgs">
    <summary>
      <para>Removes any arguments from a given path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove arguments.</para>
    </param>
    <remarks>
      <para>This function should not be used on generic command path templates (from users or the registry), but rather it should be used only on templates that the application knows to be well formed.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
    // Path with arguments.
    char buffer_1[ ] = "c:\\a\\b\\FileA Arg1 Arg2";
    char *lpStr1;
    lpStr1 = buffer_1;

    // Path before "PathRemoveArgs".
    cout &lt;&lt; "Path before calling \"PathRemoveArgs\": " &lt;&lt; lpStr1 &lt;&lt; endl;

    // Call function "PathRemoveArgs".
    PathRemoveArgs(lpStr1);

    // Path after "PathRemoveArgs".
    cout &lt;&lt; "Path after calling \"PathRemoveArgs\": " &lt;&lt; lpStr1 &lt;&lt; endl;
}

OUTPUT:
==================
Path before calling "PathRemoveArgs": c:\a\b\FileA Arg1 Arg2
Path after calling "PathRemoveArgs": c:\a\b\FileA
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveArgs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveArgsA">
    <summary>
      <para>Removes any arguments from a given path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove arguments.</para>
    </param>
    <remarks>
      <para>This function should not be used on generic command path templates (from users or the registry), but rather it should be used only on templates that the application knows to be well formed.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
    // Path with arguments.
    char buffer_1[ ] = "c:\\a\\b\\FileA Arg1 Arg2";
    char *lpStr1;
    lpStr1 = buffer_1;

    // Path before "PathRemoveArgs".
    cout &lt;&lt; "Path before calling \"PathRemoveArgs\": " &lt;&lt; lpStr1 &lt;&lt; endl;

    // Call function "PathRemoveArgs".
    PathRemoveArgs(lpStr1);

    // Path after "PathRemoveArgs".
    cout &lt;&lt; "Path after calling \"PathRemoveArgs\": " &lt;&lt; lpStr1 &lt;&lt; endl;
}

OUTPUT:
==================
Path before calling "PathRemoveArgs": c:\a\b\FileA Arg1 Arg2
Path after calling "PathRemoveArgs": c:\a\b\FileA
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveArgs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveArgsW">
    <summary>
      <para>Removes any arguments from a given path.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove arguments.</para>
    </param>
    <remarks>
      <para>This function should not be used on generic command path templates (from users or the registry), but rather it should be used only on templates that the application knows to be well formed.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main( void )
{
    // Path with arguments.
    char buffer_1[ ] = "c:\\a\\b\\FileA Arg1 Arg2";
    char *lpStr1;
    lpStr1 = buffer_1;

    // Path before "PathRemoveArgs".
    cout &lt;&lt; "Path before calling \"PathRemoveArgs\": " &lt;&lt; lpStr1 &lt;&lt; endl;

    // Call function "PathRemoveArgs".
    PathRemoveArgs(lpStr1);

    // Path after "PathRemoveArgs".
    cout &lt;&lt; "Path after calling \"PathRemoveArgs\": " &lt;&lt; lpStr1 &lt;&lt; endl;
}

OUTPUT:
==================
Path before calling "PathRemoveArgs": c:\a\b\FileA Arg1 Arg2
Path after calling "PathRemoveArgs": c:\a\b\FileA
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveArgs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveBackslash">
    <summary>
      <para>Removes the trailing backslash from a given path.
<b>Note</b>  This function is deprecated. We recommend the use of the <see cref="PathCchRemoveBackslash" /> or <see cref="PathCchRemoveBackslashEx" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the backslash.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer that, when this function returns successfully and if a backslash has been removed, points to the terminating null character that has replaced the backslash at the end of the string. If the path did not include a trailing backslash, this value will point to the final character in the string.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveBackslash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveBackslashA">
    <summary>
      <para>Removes the trailing backslash from a given path.
<b>Note</b>  This function is deprecated. We recommend the use of the <see cref="PathCchRemoveBackslash" /> or <see cref="PathCchRemoveBackslashEx" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the backslash.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer that, when this function returns successfully and if a backslash has been removed, points to the terminating null character that has replaced the backslash at the end of the string. If the path did not include a trailing backslash, this value will point to the final character in the string.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveBackslash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveBackslashW">
    <summary>
      <para>Removes the trailing backslash from a given path.
<b>Note</b>  This function is deprecated. We recommend the use of the <see cref="PathCchRemoveBackslash" /> or <see cref="PathCchRemoveBackslashEx" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the backslash.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer that, when this function returns successfully and if a backslash has been removed, points to the terminating null character that has replaced the backslash at the end of the string. If the path did not include a trailing backslash, this value will point to the final character in the string.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveBackslash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveBackslash">
    <summary>
      <para>Removes the trailing backslash from a given path.
<b>Note</b>  This function is deprecated. We recommend the use of the <see cref="PathCchRemoveBackslash" /> or <see cref="PathCchRemoveBackslashEx" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the backslash.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer that, when this function returns successfully and if a backslash has been removed, points to the terminating null character that has replaced the backslash at the end of the string. If the path did not include a trailing backslash, this value will point to the final character in the string.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveBackslash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveBackslashA">
    <summary>
      <para>Removes the trailing backslash from a given path.
<b>Note</b>  This function is deprecated. We recommend the use of the <see cref="PathCchRemoveBackslash" /> or <see cref="PathCchRemoveBackslashEx" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the backslash.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer that, when this function returns successfully and if a backslash has been removed, points to the terminating null character that has replaced the backslash at the end of the string. If the path did not include a trailing backslash, this value will point to the final character in the string.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveBackslash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveBackslashW">
    <summary>
      <para>Removes the trailing backslash from a given path.
<b>Note</b>  This function is deprecated. We recommend the use of the <see cref="PathCchRemoveBackslash" /> or <see cref="PathCchRemoveBackslashEx" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the backslash.</para>
    </param>
    <returns>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer that, when this function returns successfully and if a backslash has been removed, points to the terminating null character that has replaced the backslash at the end of the string. If the path did not include a trailing backslash, this value will point to the final character in the string.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveBackslash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveBlanks">
    <summary>
      <para>Removes all leading and trailing spaces from a string.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH from which to strip all leading and trailing spaces.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveBlanks as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveBlanksA">
    <summary>
      <para>Removes all leading and trailing spaces from a string.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH from which to strip all leading and trailing spaces.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveBlanks as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveBlanksW">
    <summary>
      <para>Removes all leading and trailing spaces from a string.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH from which to strip all leading and trailing spaces.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveBlanks as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveBlanks">
    <summary>
      <para>Removes all leading and trailing spaces from a string.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH from which to strip all leading and trailing spaces.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveBlanks as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveBlanksA">
    <summary>
      <para>Removes all leading and trailing spaces from a string.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH from which to strip all leading and trailing spaces.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveBlanks as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveBlanksW">
    <summary>
      <para>Removes all leading and trailing spaces from a string.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH from which to strip all leading and trailing spaces.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveBlanks as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveExtension">
    <summary>
      <para>Removes the file name extension from a path, if one is present.</para>
      <para>
        <b>Note</b>  This function is deprecated. We recommend the use of the <see cref="PathCchRemoveExtension" /> in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH from which to remove the extension.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveExtensionA">
    <summary>
      <para>Removes the file name extension from a path, if one is present.</para>
      <para>
        <b>Note</b>  This function is deprecated. We recommend the use of the <see cref="PathCchRemoveExtension" /> in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH from which to remove the extension.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveExtensionW">
    <summary>
      <para>Removes the file name extension from a path, if one is present.</para>
      <para>
        <b>Note</b>  This function is deprecated. We recommend the use of the <see cref="PathCchRemoveExtension" /> in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH from which to remove the extension.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveExtension">
    <summary>
      <para>Removes the file name extension from a path, if one is present.</para>
      <para>
        <b>Note</b>  This function is deprecated. We recommend the use of the <see cref="PathCchRemoveExtension" /> in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH from which to remove the extension.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveExtensionA">
    <summary>
      <para>Removes the file name extension from a path, if one is present.</para>
      <para>
        <b>Note</b>  This function is deprecated. We recommend the use of the <see cref="PathCchRemoveExtension" /> in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH from which to remove the extension.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveExtensionW">
    <summary>
      <para>Removes the file name extension from a path, if one is present.</para>
      <para>
        <b>Note</b>  This function is deprecated. We recommend the use of the <see cref="PathCchRemoveExtension" /> in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH from which to remove the extension.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveFileSpec">
    <summary>
      <para>Removes the trailing file name and backslash from a path, if they are present.
<b>Note</b>  This function is deprecated. We recommend the use of the <see cref="PathCchRemoveFileSpec" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the file name.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if something was removed, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveFileSpecA">
    <summary>
      <para>Removes the trailing file name and backslash from a path, if they are present.
<b>Note</b>  This function is deprecated. We recommend the use of the <see cref="PathCchRemoveFileSpec" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the file name.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if something was removed, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveFileSpecW">
    <summary>
      <para>Removes the trailing file name and backslash from a path, if they are present.
<b>Note</b>  This function is deprecated. We recommend the use of the <see cref="PathCchRemoveFileSpec" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the file name.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if something was removed, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveFileSpec">
    <summary>
      <para>Removes the trailing file name and backslash from a path, if they are present.
<b>Note</b>  This function is deprecated. We recommend the use of the <see cref="PathCchRemoveFileSpec" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the file name.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if something was removed, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveFileSpecA">
    <summary>
      <para>Removes the trailing file name and backslash from a path, if they are present.
<b>Note</b>  This function is deprecated. We recommend the use of the <see cref="PathCchRemoveFileSpec" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the file name.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if something was removed, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRemoveFileSpecW">
    <summary>
      <para>Removes the trailing file name and backslash from a path, if they are present.
<b>Note</b>  This function is deprecated. We recommend the use of the <see cref="PathCchRemoveFileSpec" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path from which to remove the file name.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if something was removed, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRemoveFileSpec as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRenameExtension">
    <summary>
      <para>Replaces the extension of a file name with a new extension. If the file name does not contain an extension, the extension will be attached to the end of the string.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchRenameExtension" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a null-terminated string of length MAX_PATH in which to replace the extension.</para>
    </param>
    <param name="pszExt">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a character buffer that contains a '.' character followed by the new extension.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if successful, or zero if the new path and extension would exceed MAX_PATH characters.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRenameExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRenameExtensionA">
    <summary>
      <para>Replaces the extension of a file name with a new extension. If the file name does not contain an extension, the extension will be attached to the end of the string.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchRenameExtension" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a null-terminated string of length MAX_PATH in which to replace the extension.</para>
    </param>
    <param name="pszExt">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a character buffer that contains a '.' character followed by the new extension.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if successful, or zero if the new path and extension would exceed MAX_PATH characters.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRenameExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRenameExtensionW">
    <summary>
      <para>Replaces the extension of a file name with a new extension. If the file name does not contain an extension, the extension will be attached to the end of the string.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchRenameExtension" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a null-terminated string of length MAX_PATH in which to replace the extension.</para>
    </param>
    <param name="pszExt">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a character buffer that contains a '.' character followed by the new extension.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if successful, or zero if the new path and extension would exceed MAX_PATH characters.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRenameExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRenameExtension">
    <summary>
      <para>Replaces the extension of a file name with a new extension. If the file name does not contain an extension, the extension will be attached to the end of the string.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchRenameExtension" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a null-terminated string of length MAX_PATH in which to replace the extension.</para>
    </param>
    <param name="pszExt">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a character buffer that contains a '.' character followed by the new extension.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if successful, or zero if the new path and extension would exceed MAX_PATH characters.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRenameExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRenameExtensionA">
    <summary>
      <para>Replaces the extension of a file name with a new extension. If the file name does not contain an extension, the extension will be attached to the end of the string.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchRenameExtension" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a null-terminated string of length MAX_PATH in which to replace the extension.</para>
    </param>
    <param name="pszExt">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a character buffer that contains a '.' character followed by the new extension.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if successful, or zero if the new path and extension would exceed MAX_PATH characters.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRenameExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathRenameExtensionW">
    <summary>
      <para>Replaces the extension of a file name with a new extension. If the file name does not contain an extension, the extension will be attached to the end of the string.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchRenameExtension" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>Pointer to a null-terminated string of length MAX_PATH in which to replace the extension.</para>
    </param>
    <param name="pszExt">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a character buffer that contains a '.' character followed by the new extension.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if successful, or zero if the new path and extension would exceed MAX_PATH characters.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathRenameExtension as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathSearchAndQualify">
    <summary>
      <para>Determines if a given path is correctly formatted and fully qualified.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be referenced.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of the buffer pointed to by <i>pszFullyQualifiedPath</i>, in characters.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path is qualified, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathSearchAndQualify as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathSearchAndQualifyA">
    <summary>
      <para>Determines if a given path is correctly formatted and fully qualified.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be referenced.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of the buffer pointed to by <i>pszFullyQualifiedPath</i>, in characters.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path is qualified, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathSearchAndQualify as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathSearchAndQualifyW">
    <summary>
      <para>Determines if a given path is correctly formatted and fully qualified.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be referenced.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of the buffer pointed to by <i>pszFullyQualifiedPath</i>, in characters.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path is qualified, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathSearchAndQualify as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathSearchAndQualify">
    <summary>
      <para>Determines if a given path is correctly formatted and fully qualified.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be referenced.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of the buffer pointed to by <i>pszFullyQualifiedPath</i>, in characters.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path is qualified, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathSearchAndQualify as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathSearchAndQualifyA">
    <summary>
      <para>Determines if a given path is correctly formatted and fully qualified.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be referenced.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of the buffer pointed to by <i>pszFullyQualifiedPath</i>, in characters.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path is qualified, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathSearchAndQualify as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathSearchAndQualifyW">
    <summary>
      <para>Determines if a given path is correctly formatted and fully qualified.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to search.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be referenced.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of the buffer pointed to by <i>pszFullyQualifiedPath</i>, in characters.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the path is qualified, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathSearchAndQualify as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathSetDlgItemPath">
    <summary>
      <para>Sets the text of a child control in a window or dialog box, using <see cref="PathCompactPath" /> to ensure the path fits in the control.</para>
    </summary>
    <param name="hDlg">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the dialog box or window.</para>
    </param>
    <param name="id">
      <para>Type: <b>int</b></para>
      <para>The identifier of the control.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to set in the control.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathSetDlgItemPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathSetDlgItemPathA">
    <summary>
      <para>Sets the text of a child control in a window or dialog box, using <see cref="PathCompactPath" /> to ensure the path fits in the control.</para>
    </summary>
    <param name="hDlg">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the dialog box or window.</para>
    </param>
    <param name="id">
      <para>Type: <b>int</b></para>
      <para>The identifier of the control.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to set in the control.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathSetDlgItemPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathSetDlgItemPathW">
    <summary>
      <para>Sets the text of a child control in a window or dialog box, using <see cref="PathCompactPath" /> to ensure the path fits in the control.</para>
    </summary>
    <param name="hDlg">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the dialog box or window.</para>
    </param>
    <param name="id">
      <para>Type: <b>int</b></para>
      <para>The identifier of the control.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to set in the control.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathSetDlgItemPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathSetDlgItemPath">
    <summary>
      <para>Sets the text of a child control in a window or dialog box, using <see cref="PathCompactPath" /> to ensure the path fits in the control.</para>
    </summary>
    <param name="hDlg">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the dialog box or window.</para>
    </param>
    <param name="id">
      <para>Type: <b>int</b></para>
      <para>The identifier of the control.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to set in the control.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathSetDlgItemPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathSetDlgItemPathA">
    <summary>
      <para>Sets the text of a child control in a window or dialog box, using <see cref="PathCompactPath" /> to ensure the path fits in the control.</para>
    </summary>
    <param name="hDlg">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the dialog box or window.</para>
    </param>
    <param name="id">
      <para>Type: <b>int</b></para>
      <para>The identifier of the control.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to set in the control.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathSetDlgItemPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathSetDlgItemPathW">
    <summary>
      <para>Sets the text of a child control in a window or dialog box, using <see cref="PathCompactPath" /> to ensure the path fits in the control.</para>
    </summary>
    <param name="hDlg">
      <para>Type: <b>HWND</b></para>
      <para>A handle to the dialog box or window.</para>
    </param>
    <param name="id">
      <para>Type: <b>int</b></para>
      <para>The identifier of the control.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to set in the control.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathSetDlgItemPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathSkipRoot">
    <summary>
      <para>Retrieves a pointer to the first character in a path following the drive letter or Universal Naming Convention (UNC) server/share path elements.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to parse.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer that, when this function returns successfully, points to the beginning of the subpath that follows the root (drive letter or UNC server/share). If the function encounters an error, this value will be <b>NULL</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathSkipRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathCchSkipRoot" />
  </member>
  <member name="Windows.PathSkipRootA">
    <summary>
      <para>Retrieves a pointer to the first character in a path following the drive letter or Universal Naming Convention (UNC) server/share path elements.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to parse.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer that, when this function returns successfully, points to the beginning of the subpath that follows the root (drive letter or UNC server/share). If the function encounters an error, this value will be <b>NULL</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathSkipRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathCchSkipRoot" />
  </member>
  <member name="Windows.PathSkipRootW">
    <summary>
      <para>Retrieves a pointer to the first character in a path following the drive letter or Universal Naming Convention (UNC) server/share path elements.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to parse.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer that, when this function returns successfully, points to the beginning of the subpath that follows the root (drive letter or UNC server/share). If the function encounters an error, this value will be <b>NULL</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathSkipRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathCchSkipRoot" />
  </member>
  <member name="Windows.PathSkipRoot">
    <summary>
      <para>Retrieves a pointer to the first character in a path following the drive letter or Universal Naming Convention (UNC) server/share path elements.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to parse.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer that, when this function returns successfully, points to the beginning of the subpath that follows the root (drive letter or UNC server/share). If the function encounters an error, this value will be <b>NULL</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathSkipRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathCchSkipRoot" />
  </member>
  <member name="Windows.PathSkipRootA">
    <summary>
      <para>Retrieves a pointer to the first character in a path following the drive letter or Universal Naming Convention (UNC) server/share path elements.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to parse.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer that, when this function returns successfully, points to the beginning of the subpath that follows the root (drive letter or UNC server/share). If the function encounters an error, this value will be <b>NULL</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathSkipRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathCchSkipRoot" />
  </member>
  <member name="Windows.PathSkipRootW">
    <summary>
      <para>Retrieves a pointer to the first character in a path following the drive letter or Universal Naming Convention (UNC) server/share path elements.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to parse.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer that, when this function returns successfully, points to the beginning of the subpath that follows the root (drive letter or UNC server/share). If the function encounters an error, this value will be <b>NULL</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathSkipRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="PathCchSkipRoot" />
  </member>
  <member name="Windows.PathStripPath">
    <summary>
      <para>Removes the path portion of a fully qualified path and file.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path and file name. When this function returns successfully, the string contains only the file name, with the path removed.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathStripPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathStripPathA">
    <summary>
      <para>Removes the path portion of a fully qualified path and file.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path and file name. When this function returns successfully, the string contains only the file name, with the path removed.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathStripPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathStripPathW">
    <summary>
      <para>Removes the path portion of a fully qualified path and file.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path and file name. When this function returns successfully, the string contains only the file name, with the path removed.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathStripPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathStripPath">
    <summary>
      <para>Removes the path portion of a fully qualified path and file.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path and file name. When this function returns successfully, the string contains only the file name, with the path removed.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathStripPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathStripPathA">
    <summary>
      <para>Removes the path portion of a fully qualified path and file.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path and file name. When this function returns successfully, the string contains only the file name, with the path removed.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathStripPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathStripPathW">
    <summary>
      <para>Removes the path portion of a fully qualified path and file.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path and file name. When this function returns successfully, the string contains only the file name, with the path removed.</para>
    </param>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathStripPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathStripToRoot">
    <summary>
      <para>Removes all file and directory elements in a path except for the root information.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchStripToRoot" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be converted. When this function returns successfully, this string contains only the root information taken from that path.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if a valid drive letter was found in the path, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathStripToRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathStripToRootA">
    <summary>
      <para>Removes all file and directory elements in a path except for the root information.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchStripToRoot" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be converted. When this function returns successfully, this string contains only the root information taken from that path.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if a valid drive letter was found in the path, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathStripToRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathStripToRootW">
    <summary>
      <para>Removes all file and directory elements in a path except for the root information.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchStripToRoot" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be converted. When this function returns successfully, this string contains only the root information taken from that path.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if a valid drive letter was found in the path, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathStripToRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathStripToRoot">
    <summary>
      <para>Removes all file and directory elements in a path except for the root information.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchStripToRoot" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be converted. When this function returns successfully, this string contains only the root information taken from that path.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if a valid drive letter was found in the path, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathStripToRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathStripToRootA">
    <summary>
      <para>Removes all file and directory elements in a path except for the root information.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchStripToRoot" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be converted. When this function returns successfully, this string contains only the root information taken from that path.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if a valid drive letter was found in the path, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathStripToRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathStripToRootW">
    <summary>
      <para>Removes all file and directory elements in a path except for the root information.
<b>Note</b>  Misuse of this function can lead to a buffer overrun. We recommend the use of the safer <see cref="PathCchStripToRoot" /> function in its place.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path to be converted. When this function returns successfully, this string contains only the root information taken from that path.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if a valid drive letter was found in the path, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathStripToRoot as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathUndecorate">
    <summary>
      <para>Removes the decoration from a path string.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A null-terminated string of length MAX_PATH that contains the path. When the function returns, <i>pszPath</i> points to the undecorated string.</para>
    </param>
    <remarks>
      <para>A decoration consists of a pair of square brackets with one or more digits in between, inserted immediately after the base name and before the file name extension.</para>
      <h4>Examples</h4>
      <para>The following table illustrates how strings are modified by <b>PathUndecorate</b>.</para>
      <list type="table">
        <listheader>
          <description>Initial String</description>
          <description>Undecorated String</description>
        </listheader>
        <item>
          <description>C:\Path\File[5].txt</description>
          <description>C:\Path\File.txt</description>
        </item>
        <item>
          <description>C:\Path\File[12]</description>
          <description>C:\Path\File</description>
        </item>
        <item>
          <description>C:\Path\File.txt</description>
          <description>C:\Path\File.txt</description>
        </item>
        <item>
          <description>C:\Path\[3].txt</description>
          <description>C:\Path\[3].txt</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUndecorate as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathUndecorateA">
    <summary>
      <para>Removes the decoration from a path string.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A null-terminated string of length MAX_PATH that contains the path. When the function returns, <i>pszPath</i> points to the undecorated string.</para>
    </param>
    <remarks>
      <para>A decoration consists of a pair of square brackets with one or more digits in between, inserted immediately after the base name and before the file name extension.</para>
      <h4>Examples</h4>
      <para>The following table illustrates how strings are modified by <b>PathUndecorate</b>.</para>
      <list type="table">
        <listheader>
          <description>Initial String</description>
          <description>Undecorated String</description>
        </listheader>
        <item>
          <description>C:\Path\File[5].txt</description>
          <description>C:\Path\File.txt</description>
        </item>
        <item>
          <description>C:\Path\File[12]</description>
          <description>C:\Path\File</description>
        </item>
        <item>
          <description>C:\Path\File.txt</description>
          <description>C:\Path\File.txt</description>
        </item>
        <item>
          <description>C:\Path\[3].txt</description>
          <description>C:\Path\[3].txt</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUndecorate as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathUndecorateW">
    <summary>
      <para>Removes the decoration from a path string.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A null-terminated string of length MAX_PATH that contains the path. When the function returns, <i>pszPath</i> points to the undecorated string.</para>
    </param>
    <remarks>
      <para>A decoration consists of a pair of square brackets with one or more digits in between, inserted immediately after the base name and before the file name extension.</para>
      <h4>Examples</h4>
      <para>The following table illustrates how strings are modified by <b>PathUndecorate</b>.</para>
      <list type="table">
        <listheader>
          <description>Initial String</description>
          <description>Undecorated String</description>
        </listheader>
        <item>
          <description>C:\Path\File[5].txt</description>
          <description>C:\Path\File.txt</description>
        </item>
        <item>
          <description>C:\Path\File[12]</description>
          <description>C:\Path\File</description>
        </item>
        <item>
          <description>C:\Path\File.txt</description>
          <description>C:\Path\File.txt</description>
        </item>
        <item>
          <description>C:\Path\[3].txt</description>
          <description>C:\Path\[3].txt</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUndecorate as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathUndecorate">
    <summary>
      <para>Removes the decoration from a path string.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A null-terminated string of length MAX_PATH that contains the path. When the function returns, <i>pszPath</i> points to the undecorated string.</para>
    </param>
    <remarks>
      <para>A decoration consists of a pair of square brackets with one or more digits in between, inserted immediately after the base name and before the file name extension.</para>
      <h4>Examples</h4>
      <para>The following table illustrates how strings are modified by <b>PathUndecorate</b>.</para>
      <list type="table">
        <listheader>
          <description>Initial String</description>
          <description>Undecorated String</description>
        </listheader>
        <item>
          <description>C:\Path\File[5].txt</description>
          <description>C:\Path\File.txt</description>
        </item>
        <item>
          <description>C:\Path\File[12]</description>
          <description>C:\Path\File</description>
        </item>
        <item>
          <description>C:\Path\File.txt</description>
          <description>C:\Path\File.txt</description>
        </item>
        <item>
          <description>C:\Path\[3].txt</description>
          <description>C:\Path\[3].txt</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUndecorate as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathUndecorateA">
    <summary>
      <para>Removes the decoration from a path string.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A null-terminated string of length MAX_PATH that contains the path. When the function returns, <i>pszPath</i> points to the undecorated string.</para>
    </param>
    <remarks>
      <para>A decoration consists of a pair of square brackets with one or more digits in between, inserted immediately after the base name and before the file name extension.</para>
      <h4>Examples</h4>
      <para>The following table illustrates how strings are modified by <b>PathUndecorate</b>.</para>
      <list type="table">
        <listheader>
          <description>Initial String</description>
          <description>Undecorated String</description>
        </listheader>
        <item>
          <description>C:\Path\File[5].txt</description>
          <description>C:\Path\File.txt</description>
        </item>
        <item>
          <description>C:\Path\File[12]</description>
          <description>C:\Path\File</description>
        </item>
        <item>
          <description>C:\Path\File.txt</description>
          <description>C:\Path\File.txt</description>
        </item>
        <item>
          <description>C:\Path\[3].txt</description>
          <description>C:\Path\[3].txt</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUndecorate as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathUndecorateW">
    <summary>
      <para>Removes the decoration from a path string.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A null-terminated string of length MAX_PATH that contains the path. When the function returns, <i>pszPath</i> points to the undecorated string.</para>
    </param>
    <remarks>
      <para>A decoration consists of a pair of square brackets with one or more digits in between, inserted immediately after the base name and before the file name extension.</para>
      <h4>Examples</h4>
      <para>The following table illustrates how strings are modified by <b>PathUndecorate</b>.</para>
      <list type="table">
        <listheader>
          <description>Initial String</description>
          <description>Undecorated String</description>
        </listheader>
        <item>
          <description>C:\Path\File[5].txt</description>
          <description>C:\Path\File.txt</description>
        </item>
        <item>
          <description>C:\Path\File[12]</description>
          <description>C:\Path\File</description>
        </item>
        <item>
          <description>C:\Path\File.txt</description>
          <description>C:\Path\File.txt</description>
        </item>
        <item>
          <description>C:\Path\[3].txt</description>
          <description>C:\Path\[3].txt</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUndecorate as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathUnExpandEnvStrings">
    <summary>
      <para>Replaces certain folder names in a fully qualified path with their associated environment string.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be unexpanded.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this method returns successfully, receives the unexpanded string. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size, in characters, in the <i>pszBuf</i> buffer.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The following folder paths are replaced by their equivalent environment string.</para>
      <list type="table">
        <listheader>
          <description>Folder</description>
          <description>Environment String</description>
        </listheader>
        <item>
          <description>The All Users profile folder</description>
          <description>%ALLUSERSPROFILE%</description>
        </item>
        <item>
          <description>The current user's application data folder (Windows Vista and later only).</description>
          <description>%APPDATA%</description>
        </item>
        <item>
          <description>The system name</description>
          <description>%COMPUTERNAME%</description>
        </item>
        <item>
          <description>The Program Files folder</description>
          <description>%ProgramFiles%</description>
        </item>
        <item>
          <description>The system root folder</description>
          <description>%SystemRoot%</description>
        </item>
        <item>
          <description>The system drive letter</description>
          <description>%SystemDrive%</description>
        </item>
        <item>
          <description>The current user's profile folder</description>
          <description>%USERPROFILE%</description>
        </item>
      </list>
      <para>
        <b>Note</b>  %APPDATA% and %USERPROFILE% are relative to the user making the call. This function does not work if the user is being impersonated from a service. For further discussion of access control issues, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a>.</para>
      <para>The environment variables listed in the above table might not all be set on all systems. If an environment variable is not set, it is not unexpanded.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUnExpandEnvStrings as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DoEnvironmentSubst" />
  </member>
  <member name="Windows.PathUnExpandEnvStringsA">
    <summary>
      <para>Replaces certain folder names in a fully qualified path with their associated environment string.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be unexpanded.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this method returns successfully, receives the unexpanded string. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size, in characters, in the <i>pszBuf</i> buffer.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The following folder paths are replaced by their equivalent environment string.</para>
      <list type="table">
        <listheader>
          <description>Folder</description>
          <description>Environment String</description>
        </listheader>
        <item>
          <description>The All Users profile folder</description>
          <description>%ALLUSERSPROFILE%</description>
        </item>
        <item>
          <description>The current user's application data folder (Windows Vista and later only).</description>
          <description>%APPDATA%</description>
        </item>
        <item>
          <description>The system name</description>
          <description>%COMPUTERNAME%</description>
        </item>
        <item>
          <description>The Program Files folder</description>
          <description>%ProgramFiles%</description>
        </item>
        <item>
          <description>The system root folder</description>
          <description>%SystemRoot%</description>
        </item>
        <item>
          <description>The system drive letter</description>
          <description>%SystemDrive%</description>
        </item>
        <item>
          <description>The current user's profile folder</description>
          <description>%USERPROFILE%</description>
        </item>
      </list>
      <para>
        <b>Note</b>  %APPDATA% and %USERPROFILE% are relative to the user making the call. This function does not work if the user is being impersonated from a service. For further discussion of access control issues, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a>.</para>
      <para>The environment variables listed in the above table might not all be set on all systems. If an environment variable is not set, it is not unexpanded.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUnExpandEnvStrings as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DoEnvironmentSubst" />
  </member>
  <member name="Windows.PathUnExpandEnvStringsW">
    <summary>
      <para>Replaces certain folder names in a fully qualified path with their associated environment string.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be unexpanded.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this method returns successfully, receives the unexpanded string. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size, in characters, in the <i>pszBuf</i> buffer.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The following folder paths are replaced by their equivalent environment string.</para>
      <list type="table">
        <listheader>
          <description>Folder</description>
          <description>Environment String</description>
        </listheader>
        <item>
          <description>The All Users profile folder</description>
          <description>%ALLUSERSPROFILE%</description>
        </item>
        <item>
          <description>The current user's application data folder (Windows Vista and later only).</description>
          <description>%APPDATA%</description>
        </item>
        <item>
          <description>The system name</description>
          <description>%COMPUTERNAME%</description>
        </item>
        <item>
          <description>The Program Files folder</description>
          <description>%ProgramFiles%</description>
        </item>
        <item>
          <description>The system root folder</description>
          <description>%SystemRoot%</description>
        </item>
        <item>
          <description>The system drive letter</description>
          <description>%SystemDrive%</description>
        </item>
        <item>
          <description>The current user's profile folder</description>
          <description>%USERPROFILE%</description>
        </item>
      </list>
      <para>
        <b>Note</b>  %APPDATA% and %USERPROFILE% are relative to the user making the call. This function does not work if the user is being impersonated from a service. For further discussion of access control issues, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a>.</para>
      <para>The environment variables listed in the above table might not all be set on all systems. If an environment variable is not set, it is not unexpanded.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUnExpandEnvStrings as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DoEnvironmentSubst" />
  </member>
  <member name="Windows.PathUnExpandEnvStrings">
    <summary>
      <para>Replaces certain folder names in a fully qualified path with their associated environment string.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be unexpanded.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this method returns successfully, receives the unexpanded string. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size, in characters, in the <i>pszBuf</i> buffer.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The following folder paths are replaced by their equivalent environment string.</para>
      <list type="table">
        <listheader>
          <description>Folder</description>
          <description>Environment String</description>
        </listheader>
        <item>
          <description>The All Users profile folder</description>
          <description>%ALLUSERSPROFILE%</description>
        </item>
        <item>
          <description>The current user's application data folder (Windows Vista and later only).</description>
          <description>%APPDATA%</description>
        </item>
        <item>
          <description>The system name</description>
          <description>%COMPUTERNAME%</description>
        </item>
        <item>
          <description>The Program Files folder</description>
          <description>%ProgramFiles%</description>
        </item>
        <item>
          <description>The system root folder</description>
          <description>%SystemRoot%</description>
        </item>
        <item>
          <description>The system drive letter</description>
          <description>%SystemDrive%</description>
        </item>
        <item>
          <description>The current user's profile folder</description>
          <description>%USERPROFILE%</description>
        </item>
      </list>
      <para>
        <b>Note</b>  %APPDATA% and %USERPROFILE% are relative to the user making the call. This function does not work if the user is being impersonated from a service. For further discussion of access control issues, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a>.</para>
      <para>The environment variables listed in the above table might not all be set on all systems. If an environment variable is not set, it is not unexpanded.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUnExpandEnvStrings as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DoEnvironmentSubst" />
  </member>
  <member name="Windows.PathUnExpandEnvStringsA">
    <summary>
      <para>Replaces certain folder names in a fully qualified path with their associated environment string.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be unexpanded.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this method returns successfully, receives the unexpanded string. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size, in characters, in the <i>pszBuf</i> buffer.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The following folder paths are replaced by their equivalent environment string.</para>
      <list type="table">
        <listheader>
          <description>Folder</description>
          <description>Environment String</description>
        </listheader>
        <item>
          <description>The All Users profile folder</description>
          <description>%ALLUSERSPROFILE%</description>
        </item>
        <item>
          <description>The current user's application data folder (Windows Vista and later only).</description>
          <description>%APPDATA%</description>
        </item>
        <item>
          <description>The system name</description>
          <description>%COMPUTERNAME%</description>
        </item>
        <item>
          <description>The Program Files folder</description>
          <description>%ProgramFiles%</description>
        </item>
        <item>
          <description>The system root folder</description>
          <description>%SystemRoot%</description>
        </item>
        <item>
          <description>The system drive letter</description>
          <description>%SystemDrive%</description>
        </item>
        <item>
          <description>The current user's profile folder</description>
          <description>%USERPROFILE%</description>
        </item>
      </list>
      <para>
        <b>Note</b>  %APPDATA% and %USERPROFILE% are relative to the user making the call. This function does not work if the user is being impersonated from a service. For further discussion of access control issues, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a>.</para>
      <para>The environment variables listed in the above table might not all be set on all systems. If an environment variable is not set, it is not unexpanded.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUnExpandEnvStrings as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DoEnvironmentSubst" />
  </member>
  <member name="Windows.PathUnExpandEnvStringsW">
    <summary>
      <para>Replaces certain folder names in a fully qualified path with their associated environment string.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the path to be unexpanded.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a buffer that, when this method returns successfully, receives the unexpanded string. The size of this buffer must be set to MAX_PATH to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size, in characters, in the <i>pszBuf</i> buffer.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if successful; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The following folder paths are replaced by their equivalent environment string.</para>
      <list type="table">
        <listheader>
          <description>Folder</description>
          <description>Environment String</description>
        </listheader>
        <item>
          <description>The All Users profile folder</description>
          <description>%ALLUSERSPROFILE%</description>
        </item>
        <item>
          <description>The current user's application data folder (Windows Vista and later only).</description>
          <description>%APPDATA%</description>
        </item>
        <item>
          <description>The system name</description>
          <description>%COMPUTERNAME%</description>
        </item>
        <item>
          <description>The Program Files folder</description>
          <description>%ProgramFiles%</description>
        </item>
        <item>
          <description>The system root folder</description>
          <description>%SystemRoot%</description>
        </item>
        <item>
          <description>The system drive letter</description>
          <description>%SystemDrive%</description>
        </item>
        <item>
          <description>The current user's profile folder</description>
          <description>%USERPROFILE%</description>
        </item>
      </list>
      <para>
        <b>Note</b>  %APPDATA% and %USERPROFILE% are relative to the user making the call. This function does not work if the user is being impersonated from a service. For further discussion of access control issues, see <a href="https://docs.microsoft.com//windows/desktop/SecAuthZ/access-control">Access Control</a>.</para>
      <para>The environment variables listed in the above table might not all be set on all systems. If an environment variable is not set, it is not unexpanded.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUnExpandEnvStrings as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="DoEnvironmentSubst" />
  </member>
  <member name="Windows.PathUnmakeSystemFolder">
    <summary>
      <para>Removes the attributes from a folder that make it a system folder. This folder must actually exist in the file system.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder that will have the system folder attributes removed.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if successful, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUnmakeSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathUnmakeSystemFolderA">
    <summary>
      <para>Removes the attributes from a folder that make it a system folder. This folder must actually exist in the file system.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder that will have the system folder attributes removed.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if successful, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUnmakeSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathUnmakeSystemFolderW">
    <summary>
      <para>Removes the attributes from a folder that make it a system folder. This folder must actually exist in the file system.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder that will have the system folder attributes removed.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if successful, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUnmakeSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathUnmakeSystemFolder">
    <summary>
      <para>Removes the attributes from a folder that make it a system folder. This folder must actually exist in the file system.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder that will have the system folder attributes removed.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if successful, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUnmakeSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathUnmakeSystemFolderA">
    <summary>
      <para>Removes the attributes from a folder that make it a system folder. This folder must actually exist in the file system.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder that will have the system folder attributes removed.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if successful, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUnmakeSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathUnmakeSystemFolderW">
    <summary>
      <para>Removes the attributes from a folder that make it a system folder. This folder must actually exist in the file system.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length MAX_PATH that contains the name of an existing folder that will have the system folder attributes removed.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns nonzero if successful, or zero otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUnmakeSystemFolder as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathUnquoteSpaces">
    <summary>
      <para>Removes quotes from the beginning and end of a path.</para>
    </summary>
    <param name="lpsz">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path. When the function returns successfully, points to the string with beginning and ending quotation marks removed.</para>
    </param>
    <returns>
      <para>No return value.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUnquoteSpaces as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathUnquoteSpacesA">
    <summary>
      <para>Removes quotes from the beginning and end of a path.</para>
    </summary>
    <param name="lpsz">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path. When the function returns successfully, points to the string with beginning and ending quotation marks removed.</para>
    </param>
    <returns>
      <para>No return value.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUnquoteSpaces as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathUnquoteSpacesW">
    <summary>
      <para>Removes quotes from the beginning and end of a path.</para>
    </summary>
    <param name="lpsz">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path. When the function returns successfully, points to the string with beginning and ending quotation marks removed.</para>
    </param>
    <returns>
      <para>No return value.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUnquoteSpaces as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathUnquoteSpaces">
    <summary>
      <para>Removes quotes from the beginning and end of a path.</para>
    </summary>
    <param name="lpsz">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path. When the function returns successfully, points to the string with beginning and ending quotation marks removed.</para>
    </param>
    <returns>
      <para>No return value.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUnquoteSpaces as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathUnquoteSpacesA">
    <summary>
      <para>Removes quotes from the beginning and end of a path.</para>
    </summary>
    <param name="lpsz">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path. When the function returns successfully, points to the string with beginning and ending quotation marks removed.</para>
    </param>
    <returns>
      <para>No return value.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUnquoteSpaces as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.PathUnquoteSpacesW">
    <summary>
      <para>Removes quotes from the beginning and end of a path.</para>
    </summary>
    <param name="lpsz">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string of length MAX_PATH that contains the path. When the function returns successfully, points to the string with beginning and ending quotation marks removed.</para>
    </param>
    <returns>
      <para>No return value.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines PathUnquoteSpaces as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.QISearch">
    <summary>
      <para>A table-driven implementation of the <see cref="IUnknown.QueryInterface" /> method.</para>
    </summary>
    <param name="that">
      <para>Type: <b>void*</b></para>
      <para>A pointer to the base of a COM object.</para>
    </param>
    <param name="pqit">
      <para>Type: <b>LPCQITAB</b></para>
      <para>An array of <see cref="QITAB" /> structures. The last structure in the array must have its <b>piid</b> member set to <b>NULL</b> and its <b>dwOffset</b> member set to 0.</para>
    </param>
    <param name="riid">
      <para>Type: <b>REFIID</b></para>
      <para>A reference to the IID of the interface to retrieve through <i>ppv</i>.</para>
    </param>
    <param name="ppv">
      <para>Type: <b>void**</b></para>
      <para>When this method returns successfully, contains the interface pointer requested in <i>riid</i>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if the requested interface was found in the table or if the requested interface was IUnknown. Returns E_NOINTERFACE if the requested interface was not found.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  Prior to Windows Vista, <b>QISearch</b> was not exported by name or declared in a public header file. To use it in those cases, you must use <see cref="GetProcAddress" /> and request ordinal 219 from Shlwapi.dll to obtain a function pointer. Under Windows Vista, <b>QISearch</b> is included in Shlwapi.h and this is not necessary.</para>
      <para>If the requested interface is IUnknown, then <b>QISearch</b> uses the first entry of the specified array of <see cref="QITAB" /> structures. Otherwise, <b>QISearch</b> searches the table until it either finds a matching IID or reaches the end of the table.  If a matching IID is found, the function advances the associated interface pointer by the number of bytes specified by the <b>dwOffset</b> member of the interface's <b>QITAB</b> structure and reinterpreted as a COM pointer.  That pointer is assigned to the <b>QISearch</b> function's  <i>ppv</i> parameter. The method also calls IUnknown.AddRef to increment the interface's reference count.</para>
      <para>If <b>QISearch</b> reaches the end of the table without finding the interface, it returns E_NOINTERFACE and sets <i>ppv</i> to <b>NULL</b>.</para>
      <para>It is important to include all applicable interfaces in the table. For example, if the object implements a derived interface, you should also include the base interface in the table.</para>
      <para>We recommend that you use the <see cref="IID_PPV_ARGS" /> macro, defined in Objbase.h, to package the <i>riid</i> and <i>ppv</i> parameters. This macro provides the correct IID based on the interface pointed to by the value in <i>ppv</i>, which eliminates the possibility of a coding error in <i>riid</i> that could lead to unexpected results.</para>
      <para>
        <b>Note</b>  Active Template Library (ATL) provides a significantly better version of a table-driven implementation of QueryInterface.</para>
      <h4>Examples</h4>
      <para>The following example illustrates how to use <b>QISearch</b> to implement QueryInterface.  It uses the offsetofclass macro from ATL to compute the offset from the base of the CSample object to a specified interface.</para>
      <para>This object supports two interfaces aside from IUnknown, so there are two non-<b>NULL</b> entries in the <see cref="QITAB" /> table. The entry for each interface specifies a pointer to the associated IID (IID_IPersist or IID_IPersistFolder) and the offset of the interface pointer relative to the class's base pointer. The sample uses the <b>offsetofclass</b> macro from ATL to determine that offset.</para>
      <para>
        <b>Note</b>  Forgetting to include all base classes, including indirect ones, is a common error. Notice that there is an entry for the <see cref="IPersist" /> interface. This interface is an indirect base class for CSample, inherited through <see cref="IPersistFolder" />.</para>
      <code>
class CSample : public IPersistFolder
{
  public:
    CSample() { /* other construction goes here */ }

    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // *** IPersist ***
    STDMETHODIMP GetClassID(CLSID *pClassID);

    // *** IPersistFolder ***
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

  private:
  // private members go here
};

HRESULT CSample.QueryInterface(REFIID riid, void **ppv)
{
    static QITAB rgqit[] =
    {
        QITABENT(CSample, IPersist),
        QITABENT(CSample, IPersistFolder)
        { 0 },
    };

    return QISearch(this, rgqit, IID_PPV_ARGS(&amp;amp;amp;amp;amp;amp;ppv));
}
</code>
    </remarks>
  </member>
  <member name="Windows.SetProcessReference">
    <summary>
      <para>Provides a Component Object Model (COM) object that allows hosted Shell extensions and other components to prevent their host process from closing prematurely. The host process is typically Windows Explorer or Windows Internet Explorer, but this function can also be used by other applications.</para>
    </summary>
    <param name="punk">
      <para>A pointer to the object for which you want to store a reference. This value can be <b>NULL</b>.</para>
    </param>
    <remarks>
      <para>Windows Explorer and Internet Explorer can use <b>SetProcessReference</b> to allow components such as Shell extensions to extend the lifetime of the process. Other applications can also use <b>SetProcessReference</b> to allow for the same capability. For instance, the browser message loop and the proxy desktop use <b>SetProcessReference</b> to let other threads extend their lifetime.</para>
      <para>Applications other than Windows Explorer and Internet Explorer that call this function might encounter compatibility problems because some components use <b>SetProcessReference</b> to detect whether they are being hosted from within Windows Explorer or Internet Explorer.</para>
      <para>The interface pointer passed to <b>SetProcessReference</b> must reference a free-threaded object.</para>
      <para>Each time a component calls <see cref="GetProcessReference" />, the system calls the <see cref="AddRef" /> method before returning the interface pointer to the calling component. The component then calls the <see cref="IUnknown.Release" /> method when processing is complete. The process that calls <b>SetProcessReference</b> must not terminate while the reference count of the provided interface pointer is nonzero.</para>
      <para>For further information on how components use the process references, see <see cref="GetProcessReference" />.</para>
    </remarks>
    <seealso cref="GetProcessReference" />
    <seealso cref="SHSetInstanceExplorer" />
    <seealso href="https://docs.microsoft.com//windows/desktop/apiindex/windows-apisets">Windows API Sets</seealso>
  </member>
  <member name="Windows.SHAutoComplete">
    <summary>
      <para>Instructs system edit controls to use AutoComplete to help complete URLs or file system paths.</para>
    </summary>
    <param name="hwndEdit">
      <para>Type: <b>HWND</b></para>
      <para>The window handle of a system edit control. Typically, this parameter is the handle of an edit control or the edit control embedded in a <a href="https://docs.microsoft.com//windows/desktop/Controls/comboboxex-control-reference">ComboBoxEx</a> control.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The flags to control the operation of <b>SHAutoComplete</b>. The first four flags are used to override the Internet Explorer registry settings. The user can change these settings manually by launching the <b>Internet Options</b> property sheet from the <b>Tools</b> menu and clicking the <b>Advanced</b> tab.</para>
      <h4>SHACF_AUTOAPPEND_FORCE_OFF (0x80000000)</h4>
      <para>Ignore the registry default and force the AutoAppend feature off. This flag must be used in combination with one or more of the SHACF_FILESYS* or SHACF_URL* flags.</para>
      <h4>SHACF_AUTOAPPEND_FORCE_ON (0x40000000)</h4>
      <para>Ignore the registry value and force the AutoAppend feature on. The completed string will be displayed in the edit box with the added characters highlighted. This flag must be used in combination with one or more of the SHACF_FILESYS* or SHACF_URL* flags.</para>
      <h4>SHACF_AUTOSUGGEST_FORCE_OFF (0x20000000)</h4>
      <para>Ignore the registry default and force the AutoSuggest feature off. This flag must be used in combination with one or more of the SHACF_FILESYS* or SHACF_URL* flags.</para>
      <h4>SHACF_AUTOSUGGEST_FORCE_ON (0x10000000)</h4>
      <para>Ignore the registry value and force the AutoSuggest feature on. A selection of possible completed strings will be displayed as a drop-down list, below the edit box. This flag must be used in combination with one or more of the SHACF_FILESYS* or SHACF_URL* flags.</para>
      <h4>SHACF_DEFAULT (0x00000000)</h4>
      <para>The default setting, equivalent to <b>SHACF_FILESYSTEM</b> | <b>SHACF_URLALL</b>. <b>SHACF_DEFAULT</b> cannot be combined with any other flags.</para>
      <h4>SHACF_FILESYS_ONLY (0x00000010)</h4>
      <para>Include the file system only.</para>
      <h4>SHACF_FILESYS_DIRS (0x00000020)</h4>
      <para>Include the file system and directories, UNC servers, and UNC server shares.</para>
      <h4>SHACF_FILESYSTEM (0x00000001)</h4>
      <para>Include the file system and the rest of the Shell (Desktop, Computer, and Control Panel, for example).</para>
      <h4>SHACF_URLALL (SHACF_URLHISTORY | SHACF_URLMRU)</h4>
      <para>Include the URLs in the users <b>History</b> and <b>Recently Used</b> lists. Equivalent to <b>SHACF_URLHISTORY</b> | <b>SHACF_URLMRU</b>.</para>
      <h4>SHACF_URLHISTORY (0x00000002)</h4>
      <para>Include the URLs in the user's <b>History</b> list.</para>
      <h4>SHACF_URLMRU (0x00000004)</h4>
      <para>Include the URLs in the user's <b>Recently Used</b> list.</para>
      <h4>SHACF_USETAB (0x00000008)</h4>
      <para>Allow the user to select from the autosuggest list by pressing the TAB key. If this flag is not set, pressing the TAB key will shift focus to the next control and close the autosuggest list. If <b>SHACF_USETAB</b> is set, pressing the TAB key will select the first item in the list. Pressing TAB again will select the next item in the list, and so on. When the user reaches the end of the list, the next TAB key press will cycle the focus back to the edit control. This flag must be used in combination with one or more of the SHACF_FILESYS* or SHACF_URL* flags listed on this page.</para>
      <h4>SHACF_VIRTUAL_NAMESPACE (0x00000040)</h4>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>
        <b>SHAutoComplete</b> works on any system edit control, including the edit control and controls that contain edit controls such as <a href="https://docs.microsoft.com//windows/desktop/Controls/comboboxex-control-reference">ComboBoxEx</a> controls. To retrieve a handle to an edit control embedded in a ComboBoxEx control, send the ComboBoxEx control a <a href="https://docs.microsoft.com//windows/desktop/Controls/cbem-geteditcontrol">CBEM_GETEDITCONTROL</a> message.</para>
      <para>An application must have invoked either <see cref="CoInitialize" /> or <see cref="OleInitialize" /> prior to calling this function. <see cref="CoUninitialize" /> or <see cref="OleUninitialize" /> cannot be called until the edit box has finished processing the <a href="https://docs.microsoft.com//windows/desktop/winmsg/wm-destroy">WM_DESTROY</a> message for <i>hwndEdit</i>.</para>
      <para>The maximum number of items that can be displayed in an autosuggest drop-down list box is 1000.</para>
      <para>On versions of Windows prior to Windows Vista and server versions prior to Windows Server 2008, <b>SHAutoComplete</b> should not be called more than once with the same <b>HWND</b>. Doing so results in a memory leak. It prevents the original resources from being released, including the previous instance of the AutoComplete object, enumerator objects that the previous AutoComplete object has referenced, and Windows Graphics Device Interface (GDI) resources. Rather than call <b>SHAutoComplete</b> again with a different set of flags to change the AutoComplete list, call <see cref="CoCreateInstance" /> with CLSID_AutoComplete to obtain the AutoComplete object. Then pass the <b>HWND</b> to the object to initialize it and provide your own custom enumerator. You can use CLSID_ACLMulti if you want AutoComplete to use multiple lists.</para>
    </remarks>
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776884(v=vs.85)">Using Autocomplete</seealso>
  </member>
  <member name="Windows.SHCopyKey">
    <summary>
      <para>Recursively copies the subkeys and values of the source subkey to the destination key. <b>SHCopyKey</b> does not copy the security attributes of the keys.</para>
    </summary>
    <param name="hkeySrc">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the source key (for example, <b>HKEY_CURRENT_USER</b>).</para>
    </param>
    <param name="pszSrcSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The subkey whose subkeys and values are to be copied.</para>
    </param>
    <param name="hkeyDest">
      <para>Type: <b>HKEY</b></para>
      <para>The destination key.</para>
    </param>
    <param name="fReserved">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Must be 0.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or one of the nonzero error codes defined in Winerror.h otherwise. Use <see cref="FormatMessage" /> with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>
        <b>Important</b>  This function does not duplicate the security attributes of the keys and values that it copies. Rather, all security attributes in the destination key are the default attributes.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHCopyKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHCopyKeyA">
    <summary>
      <para>Recursively copies the subkeys and values of the source subkey to the destination key. <b>SHCopyKey</b> does not copy the security attributes of the keys.</para>
    </summary>
    <param name="hkeySrc">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the source key (for example, <b>HKEY_CURRENT_USER</b>).</para>
    </param>
    <param name="pszSrcSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The subkey whose subkeys and values are to be copied.</para>
    </param>
    <param name="hkeyDest">
      <para>Type: <b>HKEY</b></para>
      <para>The destination key.</para>
    </param>
    <param name="fReserved">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Must be 0.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or one of the nonzero error codes defined in Winerror.h otherwise. Use <see cref="FormatMessage" /> with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>
        <b>Important</b>  This function does not duplicate the security attributes of the keys and values that it copies. Rather, all security attributes in the destination key are the default attributes.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHCopyKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHCopyKeyW">
    <summary>
      <para>Recursively copies the subkeys and values of the source subkey to the destination key. <b>SHCopyKey</b> does not copy the security attributes of the keys.</para>
    </summary>
    <param name="hkeySrc">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the source key (for example, <b>HKEY_CURRENT_USER</b>).</para>
    </param>
    <param name="pszSrcSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The subkey whose subkeys and values are to be copied.</para>
    </param>
    <param name="hkeyDest">
      <para>Type: <b>HKEY</b></para>
      <para>The destination key.</para>
    </param>
    <param name="fReserved">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Must be 0.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or one of the nonzero error codes defined in Winerror.h otherwise. Use <see cref="FormatMessage" /> with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>
        <b>Important</b>  This function does not duplicate the security attributes of the keys and values that it copies. Rather, all security attributes in the destination key are the default attributes.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHCopyKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHCopyKey">
    <summary>
      <para>Recursively copies the subkeys and values of the source subkey to the destination key. <b>SHCopyKey</b> does not copy the security attributes of the keys.</para>
    </summary>
    <param name="hkeySrc">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the source key (for example, <b>HKEY_CURRENT_USER</b>).</para>
    </param>
    <param name="pszSrcSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The subkey whose subkeys and values are to be copied.</para>
    </param>
    <param name="hkeyDest">
      <para>Type: <b>HKEY</b></para>
      <para>The destination key.</para>
    </param>
    <param name="fReserved">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Must be 0.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or one of the nonzero error codes defined in Winerror.h otherwise. Use <see cref="FormatMessage" /> with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>
        <b>Important</b>  This function does not duplicate the security attributes of the keys and values that it copies. Rather, all security attributes in the destination key are the default attributes.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHCopyKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHCopyKeyA">
    <summary>
      <para>Recursively copies the subkeys and values of the source subkey to the destination key. <b>SHCopyKey</b> does not copy the security attributes of the keys.</para>
    </summary>
    <param name="hkeySrc">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the source key (for example, <b>HKEY_CURRENT_USER</b>).</para>
    </param>
    <param name="pszSrcSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The subkey whose subkeys and values are to be copied.</para>
    </param>
    <param name="hkeyDest">
      <para>Type: <b>HKEY</b></para>
      <para>The destination key.</para>
    </param>
    <param name="fReserved">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Must be 0.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or one of the nonzero error codes defined in Winerror.h otherwise. Use <see cref="FormatMessage" /> with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>
        <b>Important</b>  This function does not duplicate the security attributes of the keys and values that it copies. Rather, all security attributes in the destination key are the default attributes.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHCopyKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHCopyKeyW">
    <summary>
      <para>Recursively copies the subkeys and values of the source subkey to the destination key. <b>SHCopyKey</b> does not copy the security attributes of the keys.</para>
    </summary>
    <param name="hkeySrc">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the source key (for example, <b>HKEY_CURRENT_USER</b>).</para>
    </param>
    <param name="pszSrcSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The subkey whose subkeys and values are to be copied.</para>
    </param>
    <param name="hkeyDest">
      <para>Type: <b>HKEY</b></para>
      <para>The destination key.</para>
    </param>
    <param name="fReserved">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Must be 0.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or one of the nonzero error codes defined in Winerror.h otherwise. Use <see cref="FormatMessage" /> with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>
        <b>Important</b>  This function does not duplicate the security attributes of the keys and values that it copies. Rather, all security attributes in the destination key are the default attributes.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHCopyKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHCreateMemStream">
    <summary>
      <para>Creates a memory stream using a similar process to <see cref="CreateStreamOnHGlobal" />.</para>
    </summary>
    <param name="pInit">
      <para>Type: <b>const BYTE*</b></para>
      <para>A pointer to a buffer of size <i>cbInit</i>. The contents of this buffer are used to set the initial contents of the memory stream. If this parameter is <b>NULL</b>, the returned memory stream does not have any initial content.</para>
    </param>
    <param name="cbInit">
      <para>Type: <b>UINT</b></para>
      <para>The number of bytes in the buffer pointed to by <i>pInit</i>. If <i>pInit</i> is set to <b>NULL</b>, <i>cbInit</i> must be zero.</para>
    </param>
    <returns>
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>On success, returns a pointer to the created memory stream. Returns <b>NULL</b> if the stream object could not be allocated.</para>
    </returns>
    <remarks>
      <para>Prior to Windows Vista, this function was not included in the public Shlwapi.h file, nor was it exported by name from Shlwapi.dll. To use it on earlier systems, you must call it directly from the Shlwapi.dll file as ordinal 12.</para>
      <para>This function creates a memory stream. This is an implementation of the <see cref="IStream" /> interface that stores its contents in memory. <b>SHCreateMemStream</b> differs from <see cref="CreateStreamOnHGlobal" /> in the following ways.</para>
      <list type="bullet">
        <item>
          <description>Thread safety. The stream created by <b>SHCreateMemStream</b> is thread-safe as of Windows 8. On earlier systems, the stream is not thread-safe. The stream created by <see cref="CreateStreamOnHGlobal" /> is thread-safe.</description>
        </item>
        <item>
          <description>Initial contents. <b>SHCreateMemStream</b> accepts the initial contents in the form of a buffer. <see cref="CreateStreamOnHGlobal" /> accepts the initial contents in the form of an HGLOBAL.</description>
        </item>
        <item>
          <description>Access to contents. <b>SHCreateMemStream</b> does not allow direct access to the stream contents. <see cref="CreateStreamOnHGlobal" /> permits access through <see cref="GetHGlobalFromStream" />.</description>
        </item>
        <item>
          <description>Failure information. If <b>SHCreateMemStream</b> returns <b>NULL</b>, it was unable to allocate the necessary memory. Callers should assume the cause is E_OUTOFMEMORY.</description>
        </item>
        <item>
          <description>Support for <see cref="IStream.Clone" />. Prior to Windows 8, the stream created by <b>SHCreateMemStream</b> does not support <b>IStream.Clone</b>. The stream created by <see cref="CreateStreamOnHGlobal" /> does. As of Windows 8, the stream created by <b>SHCreateMemStream</b> does support <b>IStream.Clone</b>.</description>
        </item>
        <item>
          <description>The stream returned by <b>SHCreateMemStream</b> returns S_FALSE from <see cref="IStream.Read" /> if you attempt to read past the end of the buffer. The stream returned by <see cref="CreateStreamOnHGlobal" /> returns S_OK and sets *pcbRead to 0 if you attempt to read past the end of the buffer.</description>
        </item>
      </list>
    </remarks>
  </member>
  <member name="Windows.SHCreateShellPalette">
    <summary>
      <para>Creates a halftone palette for the specified device context.</para>
    </summary>
    <param name="hdc">
      <para>Type: <b>HDC</b></para>
      <para>The device context.</para>
    </param>
    <returns>
      <para>Type: <b>HPALETTE</b></para>
      <para>Returns the palette if successful; otherwise 0.</para>
    </returns>
    <remarks>
      <para>This function behaves the same as <see cref="CreateHalftonePalette" />. The palette that is returned depends on the device context in the following way:</para>
      <list type="bullet">
        <item>
          <description>If <i>hdc</i> is set to <b>NULL</b>, a full palette is returned.</description>
        </item>
        <item>
          <description>If the device context is indexed, a full palette is returned.</description>
        </item>
        <item>
          <description>If the device context is not indexed, a default palette (VGA colors) is returned.</description>
        </item>
      </list>
    </remarks>
  </member>
  <member name="Windows.SHCreateStreamOnFileEx">
    <summary>
      <para>Opens or creates a file and retrieves a stream to read or write to that file.</para>
    </summary>
    <param name="pszFile">
      <para>Type: <b>LPCWSTR</b></para>
      <para>A pointer to a null-terminated string that specifies the file name.</para>
    </param>
    <param name="grfMode">
      <para>Type: <b>DWORD</b></para>
      <para>One or more <a href="https://docs.microsoft.com//windows/desktop/Stg/stgm-constants">STGM</a> values that are used to specify the file access mode and how the object that exposes the stream is created and deleted.</para>
    </param>
    <param name="dwAttributes">
      <para>Type: <b>DWORD</b></para>
      <para>One or more flag values that specify file attributes in the case that a new file is created. For a complete list of possible values, see the <i>dwFlagsAndAttributes</i> parameter of the <see cref="CreateFile" /> function.</para>
    </param>
    <param name="fCreate">
      <para>Type: <b>BOOL</b></para>
      <para>A <b>BOOL</b> value that helps specify, in conjunction with <i>grfMode</i>, how existing files should be treated when creating the stream. See Remarks for details.</para>
    </param>
    <param name="pstmTemplate">
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>Reserved.</para>
    </param>
    <param name="ppstm">
      <para>Type: <b><see cref="IStream" />**</b></para>
      <para>Receives an <see cref="IStream" /> interface pointer for the stream associated with the file.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>The <b>SHCreateStreamOnFileEx</b> function extends the semantics of the <a href="https://docs.microsoft.com//windows/desktop/Stg/stgm-constants">STGM</a> flags and produces the same effect as calling the <see cref="CreateFile" /> function.</para>
      <para>The <i>grfMode</i> and <i>fCreate</i> parameters work together to specify how the function should behave with respect to existing files.</para>
      <list type="table">
        <listheader>
          <description>
            <i>grfMode</i>
          </description>
          <description>
            <i>fCreate</i>
          </description>
          <description>File exists?</description>
          <description>Behavior</description>
        </listheader>
        <item>
          <description>
            <b>STGM_CREATE</b>
          </description>
          <description>Ignored</description>
          <description>Yes</description>
          <description>The file is recreated.</description>
        </item>
        <item>
          <description>
            <b>STGM_CREATE</b>
          </description>
          <description>Ignored</description>
          <description>No</description>
          <description>The file is created.</description>
        </item>
        <item>
          <description>
            <b>STGM_FAILIFTHERE</b>
          </description>
          <description>
            <b>FALSE</b>
          </description>
          <description>Yes</description>
          <description>The file is opened.</description>
        </item>
        <item>
          <description>
            <b>STGM_FAILIFTHERE</b>
          </description>
          <description>
            <b>FALSE</b>
          </description>
          <description>No</description>
          <description>The call fails.</description>
        </item>
        <item>
          <description>
            <b>STGM_FAILIFTHERE</b>
          </description>
          <description>
            <b>TRUE</b>
          </description>
          <description>Yes</description>
          <description>The call fails.</description>
        </item>
        <item>
          <description>
            <b>STGM_FAILIFTHERE</b>
          </description>
          <description>
            <b>TRUE</b>
          </description>
          <description>No</description>
          <description>The file is created.</description>
        </item>
      </list>
    </remarks>
  </member>
  <member name="Windows.SHCreateThread">
    <summary>
      <para>Creates a thread.</para>
    </summary>
    <param name="pfnThreadProc">
      <para>Type: <b>LPTHREAD_START_ROUTINE</b></para>
      <para>A pointer to an application-defined function of the <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">LPTHREAD_START_ROUTINE</a> type. If a new thread was successfully created, this application-defined function is called in the context of that thread. <b>SHCreateThread</b> does not wait for the function pointed to by this parameter to complete before returning to its caller.  The application-defined function's return value is the exit code of the thread.</para>
    </param>
    <param name="pData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to an optional application-defined data structure that contains initialization data. It is passed to the function pointed to by <i>pfnThreadProc</i> and, optionally, <i>pfnCallback</i>. This value can be <b>NULL</b>.</para>
    </param>
    <param name="flags">
      <para>Type: <b>SHCT_FLAGS</b></para>
      <para>The flags that control the behavior of the function. One or more of the <a href="https://docs.microsoft.com//windows/desktop/shell/ctf">CTF</a> constants.</para>
    </param>
    <param name="pfnCallback">
      <para>Type: <b>LPTHREAD_START_ROUTINE</b></para>
      <para>A pointer to an optional application-defined function of the
<a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">LPTHREAD_START_ROUTINE</a> type. This function is called
in the context of the created thread before the function pointed to by
<i>pfnThreadProc</i> is called. It will also receive <i>pData</i> as
its argument. <b>SHCreateThread</b> will wait for the
function pointed to by <i>pfnCallback</i> to return before returning to its caller. The
return value of the function pointed to by <i>pfnCallback</i> is ignored.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the thread is successfully created, or <b>FALSE</b> otherwise. On failure, use <see cref="GetLastError" /> to retrieve the specific error value as shown here.</para>
      <code>if (!SHCreateThread(...))
{
    hr = HRESULT_FROM_WIN32( GetLastError() );
}
else
{
    ....
}
</code>
    </returns>
    <remarks>
      <para>The function pointed to by <i>pfnThreadProc</i> and <i>pfnCallback</i> must take the following form.</para>
      <code>DWORD WINAPI ThreadProc(LPVOID pData)
{
  ...
}
</code>
      <para>The function name is arbitrary. The <i>pData</i> parameter points to an application-defined data structure with initialization information.</para>
    </remarks>
    <seealso cref="CreateProcess" />
    <seealso cref="CreateThread" />
    <seealso cref="SHCreateThreadRef" />
    <seealso cref="SHGetThreadRef" />
    <seealso cref="SHReleaseThreadRef" />
    <seealso cref="SHSetThreadRef" />
    <seealso href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/bb776779(v=vs.85)">Shell and Common Controls Versions</seealso>
  </member>
  <member name="Windows.SHCreateThreadRef">
    <summary>
      <para>Creates a per-thread reference to a Component Object Model (COM) object.</para>
    </summary>
    <param name="pcRef">
      <para>Type: <b>LONG*</b></para>
      <para>A pointer to a value, usually a local variable in the thread's <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">ThreadProc</a>, that is used by the interface in <i>ppunk</i> as a reference counter.</para>
    </param>
    <param name="ppunk">
      <para>Type: <b><see cref="IUnknown" />**</b></para>
      <para>The address of a pointer to an <see cref="IUnknown" /> interface. If successful, this parameter holds the thread's <b>IUnknown</b> pointer on return. Your application is responsible for freeing the pointer when it is finished.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>See <a href="https://docs.microsoft.com//windows/desktop/shell/managing-thread-references">Managing Thread References</a> for more details on using the Shlwapi thread APIs.</para>
    </remarks>
    <seealso cref="SHCreateThread" />
    <seealso cref="SHGetThreadRef" />
    <seealso cref="SHReleaseThreadRef" />
    <seealso cref="SHSetThreadRef" />
  </member>
  <member name="Windows.SHCreateThreadWithHandle">
    <summary>
      <para>Creates a new thread and retrieves its handle.</para>
    </summary>
    <param name="pfnThreadProc">
      <para>Type: <b>LPTHREAD_START_ROUTINE</b></para>
      <para>A pointer to an application-defined function of type <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">LPTHREAD_START_ROUTINE</a>. If a new thread was successfully created, this application-defined function is called in the context of that thread. <b>SHCreateThreadWithHandle</b> does not wait for the function pointed to by <i>pfnThreadProc</i> to complete before returning to its caller. The return value for the function specified by <i>pfnThreadProc</i> is the exit code of the thread.</para>
    </param>
    <param name="pData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to an optional application-defined data structure that contains initialization data. It is passed to the function pointed to by <i>pfnThreadProc</i> and, optionally, the function pointed to by <i>pfnCallback</i>.</para>
    </param>
    <param name="flags">
      <para>Type: <b>SHCT_FLAGS</b></para>
      <para>Flags that control the behavior of the function; one or more of the <a href="https://docs.microsoft.com//windows/desktop/shell/ctf">CTF</a> constants.</para>
    </param>
    <param name="pfnCallback">
      <para>Type: <b>LPTHREAD_START_ROUTINE</b></para>
      <para>A pointer to an optional application-defined function of type <a href="https://docs.microsoft.com//previous-versions/windows/desktop/legacy/ms686736(v=vs.85)">LPTHREAD_START_ROUTINE</a>. This function is called in the context of the created thread before the function pointed to by <i>pfnThreadProc</i> is called. It will also receive <i>pData</i> as its argument. <b>SHCreateThreadWithHandle</b> waits for the function pointed to by <i>pfnCallback</i> to complete before returning to its caller. The return value for the function specified by <i>pfnCallback</i> is ignored.</para>
    </param>
    <param name="pHandle">
      <para>Type: <b>HANDLE*</b></para>
      <para>A pointer to the <b>HANDLE</b> of the created thread. When it is no longer needed, this handle should be closed by calling the <see cref="CloseHandle" /> function. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if the thread is successfully created; otherwise, <b>FALSE</b></para>
    </returns>
    <remarks>
      <para>Prior to Windows 7, this function did not have an associated header or library file. To use this function under those earlier operating systems, call <see cref="LoadLibrary" /> with the DLL name (Shlwapi.dll) to obtain a module handle. Then call <see cref="GetProcAddress" /> with that module handle and a function ordinal of 615 to get the address of this function.</para>
      <para>The function pointed to by <i>pfnThreadProc</i> and <i>pfnCallback</i> must take the following form.</para>
      <code>DWORD WINAPI ThreadProc(LPVOID pData)
{
    ...
}
</code>
      <para>The function name is arbitrary. The <i>pData</i> parameter points to an application-defined data structure with initialization information.</para>
      <h4>Examples</h4>
      <para>The following code example provides a function pointer prototype typedef for calling <b>SHCreateThreadWithHandle</b> by ordinal and shows how to accomplish such a call.</para>
      <code>// Define SHCREATETHREADWITHHANDLE as a function pointer to SHCreateThreadWithHandle.
typedef BOOL (STDMETHODCALLTYPE *SHCREATETHREADWITHHANDLE)(LPTHREAD_START_ROUTINE,
                                                           void *,
                                                           DWORD,
                                                           LPTHREAD_START_ROUTINE,
                                                           HANDLE *);

// CallSHCreateThreadWithHandle is an example function that:
// 1. Accepts parameters for the SHCreateThreadWithHandle function.
// 2. Loads Shlwapi.dll, which implements SHCreateThreadWithHandle.
// 3. Obtains the address of SHCreateThreadWithHandle in the loaded library.
// 4. Calls SHCreateThreadWithHandle through a SHCREATETHREADWITHHANDLE function pointer.

BOOL CallSHCreateThreadWithHandle(LPTHREAD_START_ROUTINE pfnThreadProc,
                                  void *pData,
                                  DWORD dwFlags,
                                  LPTHREAD_START_ROUTINE pfnCallback,
                                  HANDLE *pHandle)
{
    // Build a string that contains the local path to Shlwapi.dll.
    WCHAR szPath[MAX_PATH];
    GetSystemDirectory(szPath, ARRAYSIZE(szPath));
    PathAppend(szPath, L"shlwapi.dll");

    // Attempt to load Shlwapi.dll.
    HMODULE hModule = LoadLibrary(szPath);

    HRESULT hr = hModule ? S_OK : HRESULT_FROM_WIN32(GetLastError());
    if (SUCCEEDED(hr))
    {
        // Shlwapi.dll is loaded.
        // Before Windows 7, SHCreateThreadWithHandle must be accessed through
        // its ordinal. The following commented lines are used for this.

        // Get the address of SHCreateThreadWithHandle through its ordinal value of 615.
        // SHCREATETHREADWITHHANDLE pfn =
        //     (SHCREATETHREADWITHHANDLE)GetProcAddress(hModule, MAKEINTRESOURCEA(615));
        //
        // hr = pfn ? S_OK : HRESULT_FROM_WIN32(GetLastError());
        //
        // if (SUCCEEDED(hr))
        // {
        //     // Call SHCreateThreadWithHandle through SHCREATETHREADWITHHANDLE.
        //     hr = pfn(pfnThreadProc, pData, dwFlags, pfnCallback, pHandle)
        //               ? S_OK : HRESULT_FROM_WIN32(GetLastError());
        // }
        // FreeLibrary(hModule);

        hr = SHCreateThreadWithHandle(pfnThreadProc, pData, dwFlags, pfnCallback, pHandle)
                       ? S_OK : HRESULT_FROM_WIN32(GetLastError());
    }
    return SUCCEEDED(hr);
}
</code>
    </remarks>
    <seealso cref="GetLastError" />
    <seealso cref="GetProcAddress" />
    <seealso cref="GetSystemDirectory" />
    <seealso cref="HRESULT_FROM_WIN32" />
    <seealso cref="LoadLibrary" />
  </member>
  <member name="Windows.SHDeleteEmptyKey">
    <summary>
      <para>Deletes an empty key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to an open registry key, or one of the following <a href="https://docs.microsoft.com//windows/desktop/SysInfo/predefined-keys">predefined keys</a>:</para>
      <para></para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <para></para>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <para></para>
      <h4>HKEY_CURRENT_USER</h4>
      <para></para>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <para></para>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <para></para>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string specifying the name of the key to delete.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>
        <b>SHDeleteEmptyKey</b> does not delete a key if it contains any subkeys or values. Use <see cref="SHDeleteKey" /> instead.</para>
      <para>Alternatively, use the <see cref="RegDeleteKey" /> or <see cref="RegDeleteTree" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHDeleteEmptyKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDeleteEmptyKeyA">
    <summary>
      <para>Deletes an empty key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to an open registry key, or one of the following <a href="https://docs.microsoft.com//windows/desktop/SysInfo/predefined-keys">predefined keys</a>:</para>
      <para></para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <para></para>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <para></para>
      <h4>HKEY_CURRENT_USER</h4>
      <para></para>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <para></para>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <para></para>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string specifying the name of the key to delete.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>
        <b>SHDeleteEmptyKey</b> does not delete a key if it contains any subkeys or values. Use <see cref="SHDeleteKey" /> instead.</para>
      <para>Alternatively, use the <see cref="RegDeleteKey" /> or <see cref="RegDeleteTree" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHDeleteEmptyKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDeleteEmptyKeyW">
    <summary>
      <para>Deletes an empty key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to an open registry key, or one of the following <a href="https://docs.microsoft.com//windows/desktop/SysInfo/predefined-keys">predefined keys</a>:</para>
      <para></para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <para></para>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <para></para>
      <h4>HKEY_CURRENT_USER</h4>
      <para></para>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <para></para>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <para></para>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string specifying the name of the key to delete.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>
        <b>SHDeleteEmptyKey</b> does not delete a key if it contains any subkeys or values. Use <see cref="SHDeleteKey" /> instead.</para>
      <para>Alternatively, use the <see cref="RegDeleteKey" /> or <see cref="RegDeleteTree" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHDeleteEmptyKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDeleteEmptyKey">
    <summary>
      <para>Deletes an empty key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to an open registry key, or one of the following <a href="https://docs.microsoft.com//windows/desktop/SysInfo/predefined-keys">predefined keys</a>:</para>
      <para></para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <para></para>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <para></para>
      <h4>HKEY_CURRENT_USER</h4>
      <para></para>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <para></para>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <para></para>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string specifying the name of the key to delete.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <para></para>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <para></para>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <para></para>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <para></para>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <para></para>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>
        <b>SHDeleteEmptyKey</b> does not delete a key if it contains any subkeys or values. Use <see cref="SHDeleteKey" /> instead.</para>
      <para>Alternatively, use the <see cref="RegDeleteKey" /> or <see cref="RegDeleteTree" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHDeleteEmptyKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDeleteEmptyKeyA">
    <summary>
      <para>Deletes an empty key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to an open registry key, or one of the following <a href="https://docs.microsoft.com//windows/desktop/SysInfo/predefined-keys">predefined keys</a>:</para>
      <para></para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <para></para>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <para></para>
      <h4>HKEY_CURRENT_USER</h4>
      <para></para>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <para></para>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <para></para>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string specifying the name of the key to delete.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <para></para>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <para></para>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <para></para>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <para></para>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <para></para>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>
        <b>SHDeleteEmptyKey</b> does not delete a key if it contains any subkeys or values. Use <see cref="SHDeleteKey" /> instead.</para>
      <para>Alternatively, use the <see cref="RegDeleteKey" /> or <see cref="RegDeleteTree" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHDeleteEmptyKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDeleteEmptyKeyW">
    <summary>
      <para>Deletes an empty key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to an open registry key, or one of the following <a href="https://docs.microsoft.com//windows/desktop/SysInfo/predefined-keys">predefined keys</a>:</para>
      <para></para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <para></para>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <para></para>
      <h4>HKEY_CURRENT_USER</h4>
      <para></para>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <para></para>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <para></para>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string specifying the name of the key to delete.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <para></para>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <para></para>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <para></para>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <para></para>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <para></para>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>
        <b>SHDeleteEmptyKey</b> does not delete a key if it contains any subkeys or values. Use <see cref="SHDeleteKey" /> instead.</para>
      <para>Alternatively, use the <see cref="RegDeleteKey" /> or <see cref="RegDeleteTree" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHDeleteEmptyKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDeleteKey">
    <summary>
      <para>Deletes a subkey and all its descendants. This function removes the key and all the key's values from the registry.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to an open registry key, or one of the following <a href="https://docs.microsoft.com//windows/desktop/SysInfo/predefined-keys">predefined keys</a>:</para>
      <para></para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <para></para>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <para></para>
      <h4>HKEY_CURRENT_USER</h4>
      <para></para>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <para></para>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <para></para>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string specifying the name of the key to delete.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>Alternatively, use the <see cref="RegDeleteKey" /> or <see cref="RegDeleteTree" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHDeleteKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDeleteKeyA">
    <summary>
      <para>Deletes a subkey and all its descendants. This function removes the key and all the key's values from the registry.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to an open registry key, or one of the following <a href="https://docs.microsoft.com//windows/desktop/SysInfo/predefined-keys">predefined keys</a>:</para>
      <para></para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <para></para>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <para></para>
      <h4>HKEY_CURRENT_USER</h4>
      <para></para>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <para></para>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <para></para>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string specifying the name of the key to delete.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>Alternatively, use the <see cref="RegDeleteKey" /> or <see cref="RegDeleteTree" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHDeleteKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDeleteKeyW">
    <summary>
      <para>Deletes a subkey and all its descendants. This function removes the key and all the key's values from the registry.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to an open registry key, or one of the following <a href="https://docs.microsoft.com//windows/desktop/SysInfo/predefined-keys">predefined keys</a>:</para>
      <para></para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <para></para>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <para></para>
      <h4>HKEY_CURRENT_USER</h4>
      <para></para>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <para></para>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <para></para>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string specifying the name of the key to delete.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>Alternatively, use the <see cref="RegDeleteKey" /> or <see cref="RegDeleteTree" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHDeleteKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDeleteKey">
    <summary>
      <para>Deletes a subkey and all its descendants. This function removes the key and all the key's values from the registry.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to an open registry key, or one of the following <a href="https://docs.microsoft.com//windows/desktop/SysInfo/predefined-keys">predefined keys</a>:</para>
      <para></para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <para></para>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <para></para>
      <h4>HKEY_CURRENT_USER</h4>
      <para></para>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <para></para>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <para></para>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string specifying the name of the key to delete.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <para></para>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <para></para>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <para></para>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <para></para>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <para></para>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>Alternatively, use the <see cref="RegDeleteKey" /> or <see cref="RegDeleteTree" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHDeleteKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDeleteKeyA">
    <summary>
      <para>Deletes a subkey and all its descendants. This function removes the key and all the key's values from the registry.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to an open registry key, or one of the following <a href="https://docs.microsoft.com//windows/desktop/SysInfo/predefined-keys">predefined keys</a>:</para>
      <para></para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <para></para>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <para></para>
      <h4>HKEY_CURRENT_USER</h4>
      <para></para>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <para></para>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <para></para>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string specifying the name of the key to delete.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <para></para>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <para></para>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <para></para>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <para></para>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <para></para>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>Alternatively, use the <see cref="RegDeleteKey" /> or <see cref="RegDeleteTree" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHDeleteKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDeleteKeyW">
    <summary>
      <para>Deletes a subkey and all its descendants. This function removes the key and all the key's values from the registry.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to an open registry key, or one of the following <a href="https://docs.microsoft.com//windows/desktop/SysInfo/predefined-keys">predefined keys</a>:</para>
      <para></para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <para></para>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <para></para>
      <h4>HKEY_CURRENT_USER</h4>
      <para></para>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <para></para>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <para></para>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string specifying the name of the key to delete.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <para></para>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <para></para>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <para></para>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <para></para>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <para></para>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>Alternatively, use the <see cref="RegDeleteKey" /> or <see cref="RegDeleteTree" /> function.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHDeleteKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDeleteValue">
    <summary>
      <para>Deletes a named value from the specified registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string specifying the name of the subkey for which to change the value.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of the value to be deleted.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHDeleteValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDeleteValueA">
    <summary>
      <para>Deletes a named value from the specified registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string specifying the name of the subkey for which to change the value.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of the value to be deleted.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHDeleteValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDeleteValueW">
    <summary>
      <para>Deletes a named value from the specified registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string specifying the name of the subkey for which to change the value.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of the value to be deleted.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHDeleteValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDeleteValue">
    <summary>
      <para>Deletes a named value from the specified registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string specifying the name of the subkey for which to change the value.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of the value to be deleted.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHDeleteValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDeleteValueA">
    <summary>
      <para>Deletes a named value from the specified registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string specifying the name of the subkey for which to change the value.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of the value to be deleted.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHDeleteValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHDeleteValueW">
    <summary>
      <para>Deletes a named value from the specified registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string specifying the name of the subkey for which to change the value.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of the value to be deleted.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHDeleteValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHEnumKeyEx">
    <summary>
      <para>Enumerates the subkeys of the specified open registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszName">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a character buffer that receives the enumerated key name.</para>
    </param>
    <param name="pcchName">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHEnumKeyEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHEnumKeyExA">
    <summary>
      <para>Enumerates the subkeys of the specified open registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszName">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a character buffer that receives the enumerated key name.</para>
    </param>
    <param name="pcchName">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHEnumKeyEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHEnumKeyExW">
    <summary>
      <para>Enumerates the subkeys of the specified open registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszName">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a character buffer that receives the enumerated key name.</para>
    </param>
    <param name="pcchName">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHEnumKeyEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHEnumKeyEx">
    <summary>
      <para>Enumerates the subkeys of the specified open registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszName">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a character buffer that receives the enumerated key name.</para>
    </param>
    <param name="pcchName">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHEnumKeyEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHEnumKeyExA">
    <summary>
      <para>Enumerates the subkeys of the specified open registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszName">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a character buffer that receives the enumerated key name.</para>
    </param>
    <param name="pcchName">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHEnumKeyEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHEnumKeyExW">
    <summary>
      <para>Enumerates the subkeys of the specified open registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszName">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a character buffer that receives the enumerated key name.</para>
    </param>
    <param name="pcchName">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHEnumKeyEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHEnumValue">
    <summary>
      <para>Enumerates the values of the specified open registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszValueName">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a character buffer that receives the enumerated value name. The size of this buffer is specified in <i>pcchValueName</i>.</para>
    </param>
    <param name="pcchValueName">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszValueName</i>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the data type of the value. These are the same values as those described under the <i>lpType</i> parameter of <see cref="RegEnumValue" />.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID</b></para>
      <para>The address of a buffer that receives the data for the value entry. The size of this buffer is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pvData</i>, in bytes. On exit, this contains the number of bytes that were copied to <i>pvData</i>.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHEnumValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHEnumValueA">
    <summary>
      <para>Enumerates the values of the specified open registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszValueName">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a character buffer that receives the enumerated value name. The size of this buffer is specified in <i>pcchValueName</i>.</para>
    </param>
    <param name="pcchValueName">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszValueName</i>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the data type of the value. These are the same values as those described under the <i>lpType</i> parameter of <see cref="RegEnumValue" />.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID</b></para>
      <para>The address of a buffer that receives the data for the value entry. The size of this buffer is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pvData</i>, in bytes. On exit, this contains the number of bytes that were copied to <i>pvData</i>.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHEnumValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHEnumValueW">
    <summary>
      <para>Enumerates the values of the specified open registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszValueName">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a character buffer that receives the enumerated value name. The size of this buffer is specified in <i>pcchValueName</i>.</para>
    </param>
    <param name="pcchValueName">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszValueName</i>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the data type of the value. These are the same values as those described under the <i>lpType</i> parameter of <see cref="RegEnumValue" />.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID</b></para>
      <para>The address of a buffer that receives the data for the value entry. The size of this buffer is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pvData</i>, in bytes. On exit, this contains the number of bytes that were copied to <i>pvData</i>.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHEnumValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHEnumValue">
    <summary>
      <para>Enumerates the values of the specified open registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszValueName">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a character buffer that receives the enumerated value name. The size of this buffer is specified in <i>pcchValueName</i>.</para>
    </param>
    <param name="pcchValueName">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszValueName</i>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the data type of the value. These are the same values as those described under the <i>lpType</i> parameter of <see cref="RegEnumValue" />.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID</b></para>
      <para>The address of a buffer that receives the data for the value entry. The size of this buffer is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pvData</i>, in bytes. On exit, this contains the number of bytes that were copied to <i>pvData</i>.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHEnumValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHEnumValueA">
    <summary>
      <para>Enumerates the values of the specified open registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszValueName">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a character buffer that receives the enumerated value name. The size of this buffer is specified in <i>pcchValueName</i>.</para>
    </param>
    <param name="pcchValueName">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszValueName</i>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the data type of the value. These are the same values as those described under the <i>lpType</i> parameter of <see cref="RegEnumValue" />.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID</b></para>
      <para>The address of a buffer that receives the data for the value entry. The size of this buffer is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pvData</i>, in bytes. On exit, this contains the number of bytes that were copied to <i>pvData</i>.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHEnumValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHEnumValueW">
    <summary>
      <para>Enumerates the values of the specified open registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszValueName">
      <para>Type: <b>LPTSTR</b></para>
      <para>The address of a character buffer that receives the enumerated value name. The size of this buffer is specified in <i>pcchValueName</i>.</para>
    </param>
    <param name="pcchValueName">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszValueName</i>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the data type of the value. These are the same values as those described under the <i>lpType</i> parameter of <see cref="RegEnumValue" />.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID</b></para>
      <para>The address of a buffer that receives the data for the value entry. The size of this buffer is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pvData</i>, in bytes. On exit, this contains the number of bytes that were copied to <i>pvData</i>.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHEnumValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHGetAssocKeys">
    <summary>
      <para>Retrieves an array of class subkeys associated with an <see cref="IQueryAssociations" /> object.</para>
    </summary>
    <param name="pqa">
      <para>A <see cref="IQueryAssociations" /> interface pointer to the object you're interested in.</para>
    </param>
    <param name="rgKeys">
      <para>A pointer to an array of <b>HKEY</b> elements that, when this function returns successfully, receives the retrieved class subkeys.</para>
    </param>
    <param name="cKeys">
      <para>The number of elements in the <i>rgKeys</i> array. If you are interested in only the primary class subkey, set this value to 1.</para>
    </param>
    <returns>
      <para>The number of subkeys inserted into the array.</para>
    </returns>
  </member>
  <member name="Windows.SHGetThreadRef">
    <summary>
      <para>Retrieves the per-thread object reference set by <see cref="SHSetThreadRef" />.</para>
    </summary>
    <param name="ppunk">
      <para>Type: <b><see cref="IUnknown" />**</b></para>
      <para>The address of a pointer that, when this function returns successfully, points to the object whose reference is stored. Your application is responsible for freeing this resource when it is no longer needed.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if the object reference exists, or <b>E_NOINTERFACE</b> otherwise.</para>
    </returns>
    <seealso cref="SHCreateThread" />
    <seealso cref="SHCreateThreadRef" />
    <seealso cref="SHReleaseThreadRef" />
    <seealso cref="SHSetThreadRef" />
  </member>
  <member name="Windows.SHGetValue">
    <summary>
      <para>Retrieves a registry value.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string that specifies the name of the subkey from which to retrieve the value.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of the value.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>The type of value. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID</b></para>
      <para>The address of the destination data buffer.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>The size of the destination data buffer.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>If your application must set/retrieve a series of values in the same key, it is better to open the key once and set/retrieve the values with the regular Microsoft Win32 registry functions rather than use this function repeatedly.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHGetValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHGetValueA">
    <summary>
      <para>Retrieves a registry value.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string that specifies the name of the subkey from which to retrieve the value.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of the value.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>The type of value. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID</b></para>
      <para>The address of the destination data buffer.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>The size of the destination data buffer.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>If your application must set/retrieve a series of values in the same key, it is better to open the key once and set/retrieve the values with the regular Microsoft Win32 registry functions rather than use this function repeatedly.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHGetValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHGetValueW">
    <summary>
      <para>Retrieves a registry value.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string that specifies the name of the subkey from which to retrieve the value.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of the value.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>The type of value. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID</b></para>
      <para>The address of the destination data buffer.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>The size of the destination data buffer.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>If your application must set/retrieve a series of values in the same key, it is better to open the key once and set/retrieve the values with the regular Microsoft Win32 registry functions rather than use this function repeatedly.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHGetValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHGetValue">
    <summary>
      <para>Retrieves a registry value.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string that specifies the name of the subkey from which to retrieve the value.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of the value.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>The type of value. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID</b></para>
      <para>The address of the destination data buffer.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>The size of the destination data buffer.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>If your application must set/retrieve a series of values in the same key, it is better to open the key once and set/retrieve the values with the regular Microsoft Win32 registry functions rather than use this function repeatedly.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHGetValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHGetValueA">
    <summary>
      <para>Retrieves a registry value.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string that specifies the name of the subkey from which to retrieve the value.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of the value.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>The type of value. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID</b></para>
      <para>The address of the destination data buffer.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>The size of the destination data buffer.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>If your application must set/retrieve a series of values in the same key, it is better to open the key once and set/retrieve the values with the regular Microsoft Win32 registry functions rather than use this function repeatedly.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHGetValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHGetValueW">
    <summary>
      <para>Retrieves a registry value.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string that specifies the name of the subkey from which to retrieve the value.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of the value.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>The type of value. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID</b></para>
      <para>The address of the destination data buffer.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>The size of the destination data buffer.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>If your application must set/retrieve a series of values in the same key, it is better to open the key once and set/retrieve the values with the regular Microsoft Win32 registry functions rather than use this function repeatedly.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHGetValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHGlobalCounterDecrement">
    <summary>
      <para>Decrements a global counter.</para>
    </summary>
    <param name="id">
      <para>Type: <b>const <see cref="SHGLOBALCOUNTER" /></b></para>
      <para>The <see cref="SHGLOBALCOUNTER" /> to decrement.</para>
    </param>
    <returns>
      <para>Type: <b>long</b></para>
      <para>The value of the counter after the decrement.</para>
    </returns>
    <seealso cref="SHGLOBALCOUNTER" />
    <seealso cref="SHGlobalCounterGetValue" />
    <seealso cref="SHGlobalCounterIncrement" />
  </member>
  <member name="Windows.SHGlobalCounterGetValue">
    <summary>
      <para>Gets the current value of a global counter.</para>
    </summary>
    <param name="id">
      <para>Type: <b>const <see cref="SHGLOBALCOUNTER" /></b></para>
      <para>The <see cref="SHGLOBALCOUNTER" /> for which to retrieve the current value.</para>
    </param>
    <returns>
      <para>Type: <b>long</b></para>
      <para>The current value of the counter.</para>
    </returns>
    <seealso cref="SHGLOBALCOUNTER" />
    <seealso cref="SHGlobalCounterDecrement" />
    <seealso cref="SHGlobalCounterIncrement" />
  </member>
  <member name="Windows.SHGlobalCounterIncrement">
    <summary>
      <para>Increments a global counter.</para>
    </summary>
    <param name="id">
      <para>Type: <b>const <see cref="SHGLOBALCOUNTER" /></b></para>
      <para>The <see cref="SHGLOBALCOUNTER" /> to increment.</para>
    </param>
    <returns>
      <para>Type: <b>long</b></para>
      <para>The value of the counter after the increment.</para>
    </returns>
    <seealso cref="SHGLOBALCOUNTER" />
    <seealso cref="SHGlobalCounterDecrement" />
    <seealso cref="SHGlobalCounterGetValue" />
  </member>
  <member name="Windows.SHIsLowMemoryMachine">
    <summary>
      <para>Not supported.</para>
    </summary>
    <param name="dwType">
      <para>Type: <b>DWORD</b></para>
      <para>The type of machine being examined. The following is the only recognized value.</para>
      <h4>ILMM_IE4</h4>
      <para>An older (circa 1997), low-end machine. Since system resources in general were lower on these older machines, the low-memory threshold is accordingly lower.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if the machine is considered low on resources, <b>FALSE</b> otherwise.</para>
      <para>
        <b>Note</b>  Always returns <b>FALSE</b> under Windows XP.</para>
    </returns>
  </member>
  <member name="Windows.SHLoadIndirectString">
    <summary>
      <para>Extracts a specified text resource when given that resource in the form of an indirect string (a string that begins with the '@' symbol).</para>
    </summary>
    <param name="pszSource">
      <para>Type: <b>PCWSTR</b></para>
      <para>A pointer to a buffer that contains the indirect string from which the resource will be retrieved. This string should begin with the '@' symbol and use one of the forms discussed in the Remarks section. This function will successfully accept a string that does not begin with an '@' symbol, but the string will be simply passed unchanged to <i>pszOutBuf</i>.</para>
    </param>
    <param name="pszOutBuf">
      <para>Type: <b>PWSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the text resource. Both <i>pszOutBuf</i> and <i>pszSource</i> can point to the same buffer, in which case the original string will be overwritten.</para>
    </param>
    <param name="cchOutBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of the buffer pointed to by <i>pszOutBuf</i>, in characters.</para>
    </param>
    <param name="ppvReserved">
      <para>Type: <b>void**</b></para>
      <para>Not used; set to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>An indirect string can be provided in several forms, each of which has its own interpretation:</para>
      <list type="bullet">
        <item>
          <description>
            <b>File name and resource ID</b>
            <code>@filename,resource
</code>
            <para>The string is extracted from the file named, using the <i>resource</i> value as a locator. If the resource value is zero or greater, the number becomes the index of the string in the binary file. If the number is negative, it becomes a resource ID. The retrieved string is copied to the output buffer and the function returns S_OK.</para>
          </description>
        </item>
        <item>
          <description>
            <b>File name and resource ID with a version modifier</b>
            <code>@filename,resource;v2
</code>
            <para>This form can be used when a resource is changed but still uses the same index or ID as the old resource. Without a version modifier, the Multilingual User Interface (MUI) cache will not recognize that the resource has changed and will not refresh. By appending the version modifier, the value is seen as a new resource and is added to the cache. Note that it is recommended that you use a new ID or index for a new resource, and use a version modifier only when that is not possible.</para>
          </description>
        </item>
        <item>
          <description>
            <b>PRI file path and resource ID</b>
            <code>@{PRIFilepath?resource}
</code>
            <para>The Package Resource Index (PRI) is a binary format introduced in Windows 8 that contains indexed resources or references to resources. The .pri file is bundled as part of an app's package. For more information on .pri files, see <a href="https://docs.microsoft.com//previous-versions/hh694557(v=vs.110)">Creating and retrieving resources in Windows Store apps</a>.</para>
            <para>The string is extracted from the .pri file named, using the <i>resource</i> as a locator. The retrieved string is copied to the output buffer and the function returns S_OK. The string is extracted based on the current Shell environment or <a href="https://docs.microsoft.com//uwp/api/windows.applicationmodel.resources.core.resourcecontext">ResourceContext</a>.</para>
            <para>An example of this type of indirect string is shown here.</para>
            <code>
@{C:\Program Files\WindowsApps\Microsoft.Camera_6.2.8376.0_x64__8wekyb3d8bbwe\resources.pri? ms-resource://Microsoft.Camera/resources/manifestAppDescription}
</code>
          </description>
        </item>
        <item>
          <description>
            <b>Package name and resource ID</b>
            <code>@{PackageFullName?resource}
</code>
            <para>The string is extracted from the Resources.pri file stored in the app's root directory of the package identified by <i>PackageFullName</i>, using the <i>resource</i> as a locator. The retrieved string is copied to the output buffer and the function returns S_OK. The string is extracted based on the app's environment or <a href="https://docs.microsoft.com//uwp/api/windows.applicationmodel.resources.core.resourcecontext">ResourceContext</a>.</para>
            <para>
              <b>Note</b>  This string must refer to a package installed for the current user. If it does not, the call will fail.</para>
            <para>An example of this type of indirect string is shown here. In this example, the reference name is fully-qualified, but it contains no namespace (for example, "resources"). The deployment stack expands the name to look for it in all namespaces.</para>
            <code>
@{Microsoft.Camera_6.2.8376.0_x64__8wekyb3d8bbwe? ms-resource://Microsoft.Camera/manifestAppDescription}
</code>
            <para>In this next example, the fully-qualified reference name does specify a namespace to limit the lookup to.</para>
            <code>
@{Microsoft.Camera_6.2.8376.0_x64__8wekyb3d8bbwe? ms-resource://Microsoft.Camera/resources/manifestAppDescription}
</code>
          </description>
        </item>
      </list>
      <para>If the string is not an indirect string, then the string is directly copied without change to <i>pszOutBuf</i> and the function returns S_OK.</para>
    </remarks>
  </member>
  <member name="Windows.SHLocalStrDup">
    <summary>
      <para>Makes a copy of a string in newly allocated memory.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated, Unicode string to be copied.</para>
    </param>
    <param name="ppsz">
      <para>Type: <b>PTSTR*</b></para>
      <para>The address of a pointer to an allocated string that, when this function returns successfully, receives the result. <b>SHLocalStrDup</b> allocates memory for this string with <see cref="LocalAlloc" />. You should free the string with <see cref="LocalFree" /> when it is no longer needed.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHLocalStrDup as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHLocalStrDupA">
    <summary>
      <para>Makes a copy of a string in newly allocated memory.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated, Unicode string to be copied.</para>
    </param>
    <param name="ppsz">
      <para>Type: <b>PTSTR*</b></para>
      <para>The address of a pointer to an allocated string that, when this function returns successfully, receives the result. <b>SHLocalStrDup</b> allocates memory for this string with <see cref="LocalAlloc" />. You should free the string with <see cref="LocalFree" /> when it is no longer needed.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHLocalStrDup as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHLocalStrDupW">
    <summary>
      <para>Makes a copy of a string in newly allocated memory.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated, Unicode string to be copied.</para>
    </param>
    <param name="ppsz">
      <para>Type: <b>PTSTR*</b></para>
      <para>The address of a pointer to an allocated string that, when this function returns successfully, receives the result. <b>SHLocalStrDup</b> allocates memory for this string with <see cref="LocalAlloc" />. You should free the string with <see cref="LocalFree" /> when it is no longer needed.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHLocalStrDup as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHLocalStrDup">
    <summary>
      <para>Makes a copy of a string in newly allocated memory.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated, Unicode string to be copied.</para>
    </param>
    <param name="ppsz">
      <para>Type: <b>PTSTR*</b></para>
      <para>The address of a pointer to an allocated string that, when this function returns successfully, receives the result. <b>SHLocalStrDup</b> allocates memory for this string with <see cref="LocalAlloc" />. You should free the string with <see cref="LocalFree" /> when it is no longer needed.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHLocalStrDup as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHLocalStrDupA">
    <summary>
      <para>Makes a copy of a string in newly allocated memory.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated, Unicode string to be copied.</para>
    </param>
    <param name="ppsz">
      <para>Type: <b>PTSTR*</b></para>
      <para>The address of a pointer to an allocated string that, when this function returns successfully, receives the result. <b>SHLocalStrDup</b> allocates memory for this string with <see cref="LocalAlloc" />. You should free the string with <see cref="LocalFree" /> when it is no longer needed.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHLocalStrDup as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHLocalStrDupW">
    <summary>
      <para>Makes a copy of a string in newly allocated memory.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated, Unicode string to be copied.</para>
    </param>
    <param name="ppsz">
      <para>Type: <b>PTSTR*</b></para>
      <para>The address of a pointer to an allocated string that, when this function returns successfully, receives the result. <b>SHLocalStrDup</b> allocates memory for this string with <see cref="LocalAlloc" />. You should free the string with <see cref="LocalFree" /> when it is no longer needed.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHLocalStrDup as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHOpenRegStream2">
    <summary>
      <para>Opens a registry value and supplies a stream that can be used to read from or write to the value. This function supersedes <see cref="SHOpenRegStream" />.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.</para>
    </param>
    <param name="pszSubkey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Optional. Pointer to a null-terminated string that specifies the subkey that contains the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the value to be accessed. This value can be <b>NULL</b>.</para>
    </param>
    <param name="grfMode">
      <para>Type: <b>DWORD</b></para>
      <para>The type of access for the stream. This can be one of the following values:</para>
      <h4>STGM_READ</h4>
      <para>Open the stream for reading.</para>
      <h4>STGM_WRITE</h4>
      <para>Open the stream for writing.</para>
      <h4>STGM_READWRITE</h4>
      <para>Open the stream for reading and writing.</para>
    </param>
    <returns>
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>Returns an <see cref="IStream" /> interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b> value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, a subkey named by <i>pszSubkey</i> that does not exist, a caller without sufficient permissions to access the subkey, or an inability to open the stream.</para>
    </returns>
    <remarks>
      <para>The calling application is responsible for calling the <see cref="Release" /> method of the returned object when that <see cref="IStream" /> object is no longer needed.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHOpenRegStream2 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHOpenRegStream2A">
    <summary>
      <para>Opens a registry value and supplies a stream that can be used to read from or write to the value. This function supersedes <see cref="SHOpenRegStream" />.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.</para>
    </param>
    <param name="pszSubkey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Optional. Pointer to a null-terminated string that specifies the subkey that contains the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the value to be accessed. This value can be <b>NULL</b>.</para>
    </param>
    <param name="grfMode">
      <para>Type: <b>DWORD</b></para>
      <para>The type of access for the stream. This can be one of the following values:</para>
      <h4>STGM_READ</h4>
      <para>Open the stream for reading.</para>
      <h4>STGM_WRITE</h4>
      <para>Open the stream for writing.</para>
      <h4>STGM_READWRITE</h4>
      <para>Open the stream for reading and writing.</para>
    </param>
    <returns>
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>Returns an <see cref="IStream" /> interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b> value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, a subkey named by <i>pszSubkey</i> that does not exist, a caller without sufficient permissions to access the subkey, or an inability to open the stream.</para>
    </returns>
    <remarks>
      <para>The calling application is responsible for calling the <see cref="Release" /> method of the returned object when that <see cref="IStream" /> object is no longer needed.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHOpenRegStream2 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHOpenRegStream2W">
    <summary>
      <para>Opens a registry value and supplies a stream that can be used to read from or write to the value. This function supersedes <see cref="SHOpenRegStream" />.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.</para>
    </param>
    <param name="pszSubkey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Optional. Pointer to a null-terminated string that specifies the subkey that contains the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the value to be accessed. This value can be <b>NULL</b>.</para>
    </param>
    <param name="grfMode">
      <para>Type: <b>DWORD</b></para>
      <para>The type of access for the stream. This can be one of the following values:</para>
      <h4>STGM_READ</h4>
      <para>Open the stream for reading.</para>
      <h4>STGM_WRITE</h4>
      <para>Open the stream for writing.</para>
      <h4>STGM_READWRITE</h4>
      <para>Open the stream for reading and writing.</para>
    </param>
    <returns>
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>Returns an <see cref="IStream" /> interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b> value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, a subkey named by <i>pszSubkey</i> that does not exist, a caller without sufficient permissions to access the subkey, or an inability to open the stream.</para>
    </returns>
    <remarks>
      <para>The calling application is responsible for calling the <see cref="Release" /> method of the returned object when that <see cref="IStream" /> object is no longer needed.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHOpenRegStream2 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHOpenRegStream2">
    <summary>
      <para>Opens a registry value and supplies a stream that can be used to read from or write to the value. This function supersedes <see cref="SHOpenRegStream" />.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.</para>
    </param>
    <param name="pszSubkey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Optional. Pointer to a null-terminated string that specifies the subkey that contains the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the value to be accessed. This value can be <b>NULL</b>.</para>
    </param>
    <param name="grfMode">
      <para>Type: <b>DWORD</b></para>
      <para>The type of access for the stream. This can be one of the following values:</para>
      <h4>STGM_READ</h4>
      <para>Open the stream for reading.</para>
      <h4>STGM_WRITE</h4>
      <para>Open the stream for writing.</para>
      <h4>STGM_READWRITE</h4>
      <para>Open the stream for reading and writing.</para>
      <h5>- grfMode.STGM_READ</h5>
      <para>Open the stream for reading.</para>
      <h5>- grfMode.STGM_READWRITE</h5>
      <para>Open the stream for reading and writing.</para>
      <h5>- grfMode.STGM_WRITE</h5>
      <para>Open the stream for writing.</para>
    </param>
    <returns>
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>Returns an <see cref="IStream" /> interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b> value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, a subkey named by <i>pszSubkey</i> that does not exist, a caller without sufficient permissions to access the subkey, or an inability to open the stream.</para>
    </returns>
    <remarks>
      <para>The calling application is responsible for calling the <see cref="Release" /> method of the returned object when that <see cref="IStream" /> object is no longer needed.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHOpenRegStream2 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHOpenRegStream2A">
    <summary>
      <para>Opens a registry value and supplies a stream that can be used to read from or write to the value. This function supersedes <see cref="SHOpenRegStream" />.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.</para>
    </param>
    <param name="pszSubkey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Optional. Pointer to a null-terminated string that specifies the subkey that contains the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the value to be accessed. This value can be <b>NULL</b>.</para>
    </param>
    <param name="grfMode">
      <para>Type: <b>DWORD</b></para>
      <para>The type of access for the stream. This can be one of the following values:</para>
      <h4>STGM_READ</h4>
      <para>Open the stream for reading.</para>
      <h4>STGM_WRITE</h4>
      <para>Open the stream for writing.</para>
      <h4>STGM_READWRITE</h4>
      <para>Open the stream for reading and writing.</para>
      <h5>- grfMode.STGM_READ</h5>
      <para>Open the stream for reading.</para>
      <h5>- grfMode.STGM_READWRITE</h5>
      <para>Open the stream for reading and writing.</para>
      <h5>- grfMode.STGM_WRITE</h5>
      <para>Open the stream for writing.</para>
    </param>
    <returns>
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>Returns an <see cref="IStream" /> interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b> value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, a subkey named by <i>pszSubkey</i> that does not exist, a caller without sufficient permissions to access the subkey, or an inability to open the stream.</para>
    </returns>
    <remarks>
      <para>The calling application is responsible for calling the <see cref="Release" /> method of the returned object when that <see cref="IStream" /> object is no longer needed.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHOpenRegStream2 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHOpenRegStream2W">
    <summary>
      <para>Opens a registry value and supplies a stream that can be used to read from or write to the value. This function supersedes <see cref="SHOpenRegStream" />.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.</para>
    </param>
    <param name="pszSubkey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Optional. Pointer to a null-terminated string that specifies the subkey that contains the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the value to be accessed. This value can be <b>NULL</b>.</para>
    </param>
    <param name="grfMode">
      <para>Type: <b>DWORD</b></para>
      <para>The type of access for the stream. This can be one of the following values:</para>
      <h4>STGM_READ</h4>
      <para>Open the stream for reading.</para>
      <h4>STGM_WRITE</h4>
      <para>Open the stream for writing.</para>
      <h4>STGM_READWRITE</h4>
      <para>Open the stream for reading and writing.</para>
      <h5>- grfMode.STGM_READ</h5>
      <para>Open the stream for reading.</para>
      <h5>- grfMode.STGM_READWRITE</h5>
      <para>Open the stream for reading and writing.</para>
      <h5>- grfMode.STGM_WRITE</h5>
      <para>Open the stream for writing.</para>
    </param>
    <returns>
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>Returns an <see cref="IStream" /> interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b> value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, a subkey named by <i>pszSubkey</i> that does not exist, a caller without sufficient permissions to access the subkey, or an inability to open the stream.</para>
    </returns>
    <remarks>
      <para>The calling application is responsible for calling the <see cref="Release" /> method of the returned object when that <see cref="IStream" /> object is no longer needed.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHOpenRegStream2 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHOpenRegStream">
    <summary>
      <para>Deprecated. Opens a registry value and supplies a stream that can be used to read from or write to the value.</para>
      <para>
        <b>Note</b>  This function has been replaced by <see cref="SHOpenRegStream2" />. It is recommended that you use <b>SHOpenRegStream2</b> at all times.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.</para>
    </param>
    <param name="pszSubkey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Optional. Pointer to a null-terminated string that specifies the subkey that contains the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the value to be accessed. This value can be <b>NULL</b>.</para>
    </param>
    <param name="grfMode">
      <para>Type: <b>DWORD</b></para>
      <para>The type of access for the stream. This can be one of the following values:</para>
      <h4>STGM_READ</h4>
      <para>Open the stream for reading.</para>
      <h4>STGM_WRITE</h4>
      <para>Open the stream for writing.</para>
      <h4>STGM_READWRITE</h4>
      <para>Open the stream for both reading and writing.</para>
    </param>
    <returns>
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>Returns an <see cref="IStream" /> interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b> value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, or an inability to open the stream.</para>
      <para>
        <b>Note</b>  In some situations, such as when the subkey named by <i>pszSubkey</i> does not exist or the caller does not have sufficient permissions to access the subkey, a zero-length stream is returned rather than a <b>NULL</b> value. <see cref="SHOpenRegStream2" /> returns <b>NULL</b> in all error situations and is the preferred function for that reason.</para>
    </returns>
    <remarks>
      <para>The calling application is responsible for calling the <see cref="Release" /> method of the returned object when that <see cref="IStream" /> object is no longer needed.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHOpenRegStream as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHOpenRegStreamA">
    <summary>
      <para>Deprecated. Opens a registry value and supplies a stream that can be used to read from or write to the value.</para>
      <para>
        <b>Note</b>  This function has been replaced by <see cref="SHOpenRegStream2" />. It is recommended that you use <b>SHOpenRegStream2</b> at all times.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.</para>
    </param>
    <param name="pszSubkey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Optional. Pointer to a null-terminated string that specifies the subkey that contains the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the value to be accessed. This value can be <b>NULL</b>.</para>
    </param>
    <param name="grfMode">
      <para>Type: <b>DWORD</b></para>
      <para>The type of access for the stream. This can be one of the following values:</para>
      <h4>STGM_READ</h4>
      <para>Open the stream for reading.</para>
      <h4>STGM_WRITE</h4>
      <para>Open the stream for writing.</para>
      <h4>STGM_READWRITE</h4>
      <para>Open the stream for both reading and writing.</para>
    </param>
    <returns>
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>Returns an <see cref="IStream" /> interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b> value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, or an inability to open the stream.</para>
      <para>
        <b>Note</b>  In some situations, such as when the subkey named by <i>pszSubkey</i> does not exist or the caller does not have sufficient permissions to access the subkey, a zero-length stream is returned rather than a <b>NULL</b> value. <see cref="SHOpenRegStream2" /> returns <b>NULL</b> in all error situations and is the preferred function for that reason.</para>
    </returns>
    <remarks>
      <para>The calling application is responsible for calling the <see cref="Release" /> method of the returned object when that <see cref="IStream" /> object is no longer needed.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHOpenRegStream as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHOpenRegStreamW">
    <summary>
      <para>Deprecated. Opens a registry value and supplies a stream that can be used to read from or write to the value.</para>
      <para>
        <b>Note</b>  This function has been replaced by <see cref="SHOpenRegStream2" />. It is recommended that you use <b>SHOpenRegStream2</b> at all times.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.</para>
    </param>
    <param name="pszSubkey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Optional. Pointer to a null-terminated string that specifies the subkey that contains the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the value to be accessed. This value can be <b>NULL</b>.</para>
    </param>
    <param name="grfMode">
      <para>Type: <b>DWORD</b></para>
      <para>The type of access for the stream. This can be one of the following values:</para>
      <h4>STGM_READ</h4>
      <para>Open the stream for reading.</para>
      <h4>STGM_WRITE</h4>
      <para>Open the stream for writing.</para>
      <h4>STGM_READWRITE</h4>
      <para>Open the stream for both reading and writing.</para>
    </param>
    <returns>
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>Returns an <see cref="IStream" /> interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b> value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, or an inability to open the stream.</para>
      <para>
        <b>Note</b>  In some situations, such as when the subkey named by <i>pszSubkey</i> does not exist or the caller does not have sufficient permissions to access the subkey, a zero-length stream is returned rather than a <b>NULL</b> value. <see cref="SHOpenRegStream2" /> returns <b>NULL</b> in all error situations and is the preferred function for that reason.</para>
    </returns>
    <remarks>
      <para>The calling application is responsible for calling the <see cref="Release" /> method of the returned object when that <see cref="IStream" /> object is no longer needed.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHOpenRegStream as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHOpenRegStream">
    <summary>
      <para>Deprecated. Opens a registry value and supplies a stream that can be used to read from or write to the value.</para>
      <para>
        <b>Note</b>  This function has been replaced by <see cref="SHOpenRegStream2" />. It is recommended that you use <b>SHOpenRegStream2</b> at all times.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.</para>
    </param>
    <param name="pszSubkey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Optional. Pointer to a null-terminated string that specifies the subkey that contains the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the value to be accessed. This value can be <b>NULL</b>.</para>
    </param>
    <param name="grfMode">
      <para>Type: <b>DWORD</b></para>
      <para>The type of access for the stream. This can be one of the following values:</para>
      <h4>STGM_READ</h4>
      <para>Open the stream for reading.</para>
      <h4>STGM_WRITE</h4>
      <para>Open the stream for writing.</para>
      <h4>STGM_READWRITE</h4>
      <para>Open the stream for both reading and writing.</para>
      <h5>- grfMode.STGM_READ</h5>
      <para>Open the stream for reading.</para>
      <h5>- grfMode.STGM_READWRITE</h5>
      <para>Open the stream for both reading and writing.</para>
      <h5>- grfMode.STGM_WRITE</h5>
      <para>Open the stream for writing.</para>
    </param>
    <returns>
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>Returns an <see cref="IStream" /> interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b> value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, or an inability to open the stream.</para>
      <para>
        <b>Note</b>  In some situations, such as when the subkey named by <i>pszSubkey</i> does not exist or the caller does not have sufficient permissions to access the subkey, a zero-length stream is returned rather than a <b>NULL</b> value. <see cref="SHOpenRegStream2" /> returns <b>NULL</b> in all error situations and is the preferred function for that reason.</para>
    </returns>
    <remarks>
      <para>The calling application is responsible for calling the <see cref="Release" /> method of the returned object when that <see cref="IStream" /> object is no longer needed.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHOpenRegStream as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHOpenRegStreamA">
    <summary>
      <para>Deprecated. Opens a registry value and supplies a stream that can be used to read from or write to the value.</para>
      <para>
        <b>Note</b>  This function has been replaced by <see cref="SHOpenRegStream2" />. It is recommended that you use <b>SHOpenRegStream2</b> at all times.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.</para>
    </param>
    <param name="pszSubkey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Optional. Pointer to a null-terminated string that specifies the subkey that contains the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the value to be accessed. This value can be <b>NULL</b>.</para>
    </param>
    <param name="grfMode">
      <para>Type: <b>DWORD</b></para>
      <para>The type of access for the stream. This can be one of the following values:</para>
      <h4>STGM_READ</h4>
      <para>Open the stream for reading.</para>
      <h4>STGM_WRITE</h4>
      <para>Open the stream for writing.</para>
      <h4>STGM_READWRITE</h4>
      <para>Open the stream for both reading and writing.</para>
      <h5>- grfMode.STGM_READ</h5>
      <para>Open the stream for reading.</para>
      <h5>- grfMode.STGM_READWRITE</h5>
      <para>Open the stream for both reading and writing.</para>
      <h5>- grfMode.STGM_WRITE</h5>
      <para>Open the stream for writing.</para>
    </param>
    <returns>
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>Returns an <see cref="IStream" /> interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b> value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, or an inability to open the stream.</para>
      <para>
        <b>Note</b>  In some situations, such as when the subkey named by <i>pszSubkey</i> does not exist or the caller does not have sufficient permissions to access the subkey, a zero-length stream is returned rather than a <b>NULL</b> value. <see cref="SHOpenRegStream2" /> returns <b>NULL</b> in all error situations and is the preferred function for that reason.</para>
    </returns>
    <remarks>
      <para>The calling application is responsible for calling the <see cref="Release" /> method of the returned object when that <see cref="IStream" /> object is no longer needed.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHOpenRegStream as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHOpenRegStreamW">
    <summary>
      <para>Deprecated. Opens a registry value and supplies a stream that can be used to read from or write to the value.</para>
      <para>
        <b>Note</b>  This function has been replaced by <see cref="SHOpenRegStream2" />. It is recommended that you use <b>SHOpenRegStream2</b> at all times.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>Required. The subtree, such as HKEY_LOCAL_MACHINE, that contains the value.</para>
    </param>
    <param name="pszSubkey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Optional. Pointer to a null-terminated string that specifies the subkey that contains the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>Pointer to a null-terminated string that specifies the value to be accessed. This value can be <b>NULL</b>.</para>
    </param>
    <param name="grfMode">
      <para>Type: <b>DWORD</b></para>
      <para>The type of access for the stream. This can be one of the following values:</para>
      <h4>STGM_READ</h4>
      <para>Open the stream for reading.</para>
      <h4>STGM_WRITE</h4>
      <para>Open the stream for writing.</para>
      <h4>STGM_READWRITE</h4>
      <para>Open the stream for both reading and writing.</para>
      <h5>- grfMode.STGM_READ</h5>
      <para>Open the stream for reading.</para>
      <h5>- grfMode.STGM_READWRITE</h5>
      <para>Open the stream for both reading and writing.</para>
      <h5>- grfMode.STGM_WRITE</h5>
      <para>Open the stream for writing.</para>
    </param>
    <returns>
      <para>Type: <b><see cref="IStream" />*</b></para>
      <para>Returns an <see cref="IStream" /> interface pointer if successful; otherwise, <b>NULL</b>. A <b>NULL</b> value can be caused by several situations, including an invalid <i>hkey</i> or <i>pszSubkey</i>, or an inability to open the stream.</para>
      <para>
        <b>Note</b>  In some situations, such as when the subkey named by <i>pszSubkey</i> does not exist or the caller does not have sufficient permissions to access the subkey, a zero-length stream is returned rather than a <b>NULL</b> value. <see cref="SHOpenRegStream2" /> returns <b>NULL</b> in all error situations and is the preferred function for that reason.</para>
    </returns>
    <remarks>
      <para>The calling application is responsible for calling the <see cref="Release" /> method of the returned object when that <see cref="IStream" /> object is no longer needed.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHOpenRegStream as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHQueryInfoKey">
    <summary>
      <para>Retrieves information about a specified registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pcSubKeys">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of subkeys under the specified key.</para>
    </param>
    <param name="pcchMaxSubKeyLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of characters in the name of the subkey with the largest name.</para>
    </param>
    <param name="pcValues">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of values under the specified key.</para>
    </param>
    <param name="pcchMaxValueNameLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of characters in the name of the value with the largest name.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHQueryInfoKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHQueryInfoKeyA">
    <summary>
      <para>Retrieves information about a specified registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pcSubKeys">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of subkeys under the specified key.</para>
    </param>
    <param name="pcchMaxSubKeyLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of characters in the name of the subkey with the largest name.</para>
    </param>
    <param name="pcValues">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of values under the specified key.</para>
    </param>
    <param name="pcchMaxValueNameLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of characters in the name of the value with the largest name.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHQueryInfoKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHQueryInfoKeyW">
    <summary>
      <para>Retrieves information about a specified registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pcSubKeys">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of subkeys under the specified key.</para>
    </param>
    <param name="pcchMaxSubKeyLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of characters in the name of the subkey with the largest name.</para>
    </param>
    <param name="pcValues">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of values under the specified key.</para>
    </param>
    <param name="pcchMaxValueNameLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of characters in the name of the value with the largest name.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHQueryInfoKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHQueryInfoKey">
    <summary>
      <para>Retrieves information about a specified registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pcSubKeys">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of subkeys under the specified key.</para>
    </param>
    <param name="pcchMaxSubKeyLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of characters in the name of the subkey with the largest name.</para>
    </param>
    <param name="pcValues">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of values under the specified key.</para>
    </param>
    <param name="pcchMaxValueNameLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of characters in the name of the value with the largest name.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHQueryInfoKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHQueryInfoKeyA">
    <summary>
      <para>Retrieves information about a specified registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pcSubKeys">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of subkeys under the specified key.</para>
    </param>
    <param name="pcchMaxSubKeyLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of characters in the name of the subkey with the largest name.</para>
    </param>
    <param name="pcValues">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of values under the specified key.</para>
    </param>
    <param name="pcchMaxValueNameLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of characters in the name of the value with the largest name.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHQueryInfoKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHQueryInfoKeyW">
    <summary>
      <para>Retrieves information about a specified registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pcSubKeys">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of subkeys under the specified key.</para>
    </param>
    <param name="pcchMaxSubKeyLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of characters in the name of the subkey with the largest name.</para>
    </param>
    <param name="pcValues">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of values under the specified key.</para>
    </param>
    <param name="pcchMaxValueNameLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of a <b>DWORD</b> that receives the number of characters in the name of the value with the largest name.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHQueryInfoKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHQueryValueEx">
    <summary>
      <para>Opens a registry key and queries it for a specific value.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of the <b>null</b>-terminated string that contains the name of the value to be queried.</para>
    </param>
    <param name="pdwReserved">
      <para>Type: <b>LPDWORD</b></para>
      <para>Reserved. Must be <b>NULL</b>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of the variable that receives the key's value type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID</b></para>
      <para>The address of the buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of the variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>pvData</i>.</para>
    </param>
    <returns>
      <para>Type: <b>DWORD</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHQueryValueEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHQueryValueExA">
    <summary>
      <para>Opens a registry key and queries it for a specific value.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of the <b>null</b>-terminated string that contains the name of the value to be queried.</para>
    </param>
    <param name="pdwReserved">
      <para>Type: <b>LPDWORD</b></para>
      <para>Reserved. Must be <b>NULL</b>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of the variable that receives the key's value type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID</b></para>
      <para>The address of the buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of the variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>pvData</i>.</para>
    </param>
    <returns>
      <para>Type: <b>DWORD</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHQueryValueEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHQueryValueExW">
    <summary>
      <para>Opens a registry key and queries it for a specific value.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of the <b>null</b>-terminated string that contains the name of the value to be queried.</para>
    </param>
    <param name="pdwReserved">
      <para>Type: <b>LPDWORD</b></para>
      <para>Reserved. Must be <b>NULL</b>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of the variable that receives the key's value type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID</b></para>
      <para>The address of the buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of the variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>pvData</i>.</para>
    </param>
    <returns>
      <para>Type: <b>DWORD</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHQueryValueEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHQueryValueEx">
    <summary>
      <para>Opens a registry key and queries it for a specific value.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of the <b>null</b>-terminated string that contains the name of the value to be queried.</para>
    </param>
    <param name="pdwReserved">
      <para>Type: <b>LPDWORD</b></para>
      <para>Reserved. Must be <b>NULL</b>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of the variable that receives the key's value type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID</b></para>
      <para>The address of the buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of the variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>pvData</i>.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>DWORD</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHQueryValueEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHQueryValueExA">
    <summary>
      <para>Opens a registry key and queries it for a specific value.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of the <b>null</b>-terminated string that contains the name of the value to be queried.</para>
    </param>
    <param name="pdwReserved">
      <para>Type: <b>LPDWORD</b></para>
      <para>Reserved. Must be <b>NULL</b>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of the variable that receives the key's value type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID</b></para>
      <para>The address of the buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of the variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>pvData</i>.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>DWORD</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHQueryValueEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHQueryValueExW">
    <summary>
      <para>Opens a registry key and queries it for a specific value.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of the <b>null</b>-terminated string that contains the name of the value to be queried.</para>
    </param>
    <param name="pdwReserved">
      <para>Type: <b>LPDWORD</b></para>
      <para>Reserved. Must be <b>NULL</b>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of the variable that receives the key's value type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID</b></para>
      <para>The address of the buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>The address of the variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>pvData</i>.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>DWORD</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHQueryValueEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegCloseUSKey">
    <summary>
      <para>Closes a handle to a user-specific registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. Use <see cref="FormatMessage" /> with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
  </member>
  <member name="Windows.SHRegCreateUSKey">
    <summary>
      <para>Creates or opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the subkey to be created or opened. If a value with this name is already present in the subkey, it will be opened.</para>
    </param>
    <param name="samDesired">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a></b></para>
      <para>The desired security access. For more information on security access, see <a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a>.</para>
    </param>
    <param name="hRelativeUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set <i>hRelativeUSKey</i> to <b>NULL</b>. The key will then be created under <b>HKEY_LOCAL_MACHINE</b> or <b>HKEY_CURRENT_USER</b>, depending the value of <i>dwFlags</i>.</para>
    </param>
    <param name="phNewUSKey">
      <para>Type: <b>PHUSKEY</b></para>
      <para>A pointer to an <b>HUSKEY</b> that will receive the handle to the new key.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The base key under which the key should be opened. This can be one or more of the following values.</para>
      <h4>SHREGSET_HKCU</h4>
      <para>Create/open the key under <b>HKEY_CURRENT_USER</b>. Only creates a key if it is empty.</para>
      <h4>SHREGSET_FORCE_HKCU</h4>
      <para>Create/open the key under <b>HKEY_CURRENT_USER</b>. Creates a key even if it is not empty.</para>
      <h4>SHREGSET_HKLM</h4>
      <para>Create/open the key under <b>HKEY_LOCAL_MACHINE</b>. Only creates a key if it is empty.</para>
      <h4>SHREGSET_FORCE_HKLM</h4>
      <para>Create/open the key under <b>HKEY_LOCAL_MACHINE</b>. Creates a key even if it is not empty.</para>
      <h4>SHREGSET_DEFAULT</h4>
      <para>Create/open the key under both <b>HKEY_CURRENT_USER</b> (forced) and <b>HKEY_LOCAL_MACHINE</b> (only if empty). This flag is the equivalent of (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>If you want to write values to the new key, use <see cref="SHRegWriteUSValue" /> to write each value, passing the <b>HUSKEY</b> handle that is returned through <i>phNewUSKey</i>. When you have finished, close the user-specific registry key with <see cref="SHRegCloseUSKey" />.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegCreateUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegCreateUSKeyA">
    <summary>
      <para>Creates or opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the subkey to be created or opened. If a value with this name is already present in the subkey, it will be opened.</para>
    </param>
    <param name="samDesired">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a></b></para>
      <para>The desired security access. For more information on security access, see <a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a>.</para>
    </param>
    <param name="hRelativeUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set <i>hRelativeUSKey</i> to <b>NULL</b>. The key will then be created under <b>HKEY_LOCAL_MACHINE</b> or <b>HKEY_CURRENT_USER</b>, depending the value of <i>dwFlags</i>.</para>
    </param>
    <param name="phNewUSKey">
      <para>Type: <b>PHUSKEY</b></para>
      <para>A pointer to an <b>HUSKEY</b> that will receive the handle to the new key.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The base key under which the key should be opened. This can be one or more of the following values.</para>
      <h4>SHREGSET_HKCU</h4>
      <para>Create/open the key under <b>HKEY_CURRENT_USER</b>. Only creates a key if it is empty.</para>
      <h4>SHREGSET_FORCE_HKCU</h4>
      <para>Create/open the key under <b>HKEY_CURRENT_USER</b>. Creates a key even if it is not empty.</para>
      <h4>SHREGSET_HKLM</h4>
      <para>Create/open the key under <b>HKEY_LOCAL_MACHINE</b>. Only creates a key if it is empty.</para>
      <h4>SHREGSET_FORCE_HKLM</h4>
      <para>Create/open the key under <b>HKEY_LOCAL_MACHINE</b>. Creates a key even if it is not empty.</para>
      <h4>SHREGSET_DEFAULT</h4>
      <para>Create/open the key under both <b>HKEY_CURRENT_USER</b> (forced) and <b>HKEY_LOCAL_MACHINE</b> (only if empty). This flag is the equivalent of (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>If you want to write values to the new key, use <see cref="SHRegWriteUSValue" /> to write each value, passing the <b>HUSKEY</b> handle that is returned through <i>phNewUSKey</i>. When you have finished, close the user-specific registry key with <see cref="SHRegCloseUSKey" />.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegCreateUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegCreateUSKeyW">
    <summary>
      <para>Creates or opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the subkey to be created or opened. If a value with this name is already present in the subkey, it will be opened.</para>
    </param>
    <param name="samDesired">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a></b></para>
      <para>The desired security access. For more information on security access, see <a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a>.</para>
    </param>
    <param name="hRelativeUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set <i>hRelativeUSKey</i> to <b>NULL</b>. The key will then be created under <b>HKEY_LOCAL_MACHINE</b> or <b>HKEY_CURRENT_USER</b>, depending the value of <i>dwFlags</i>.</para>
    </param>
    <param name="phNewUSKey">
      <para>Type: <b>PHUSKEY</b></para>
      <para>A pointer to an <b>HUSKEY</b> that will receive the handle to the new key.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The base key under which the key should be opened. This can be one or more of the following values.</para>
      <h4>SHREGSET_HKCU</h4>
      <para>Create/open the key under <b>HKEY_CURRENT_USER</b>. Only creates a key if it is empty.</para>
      <h4>SHREGSET_FORCE_HKCU</h4>
      <para>Create/open the key under <b>HKEY_CURRENT_USER</b>. Creates a key even if it is not empty.</para>
      <h4>SHREGSET_HKLM</h4>
      <para>Create/open the key under <b>HKEY_LOCAL_MACHINE</b>. Only creates a key if it is empty.</para>
      <h4>SHREGSET_FORCE_HKLM</h4>
      <para>Create/open the key under <b>HKEY_LOCAL_MACHINE</b>. Creates a key even if it is not empty.</para>
      <h4>SHREGSET_DEFAULT</h4>
      <para>Create/open the key under both <b>HKEY_CURRENT_USER</b> (forced) and <b>HKEY_LOCAL_MACHINE</b> (only if empty). This flag is the equivalent of (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>If you want to write values to the new key, use <see cref="SHRegWriteUSValue" /> to write each value, passing the <b>HUSKEY</b> handle that is returned through <i>phNewUSKey</i>. When you have finished, close the user-specific registry key with <see cref="SHRegCloseUSKey" />.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegCreateUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegCreateUSKey">
    <summary>
      <para>Creates or opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pwzPath">
      <para>TBD</para>
    </param>
    <param name="samDesired">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a></b></para>
      <para>The desired security access. For more information on security access, see <a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a>.</para>
    </param>
    <param name="hRelativeUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set <i>hRelativeUSKey</i> to <b>NULL</b>. The key will then be created under <b>HKEY_LOCAL_MACHINE</b> or <b>HKEY_CURRENT_USER</b>, depending the value of <i>dwFlags</i>.</para>
    </param>
    <param name="phNewUSKey">
      <para>Type: <b>PHUSKEY</b></para>
      <para>A pointer to an <b>HUSKEY</b> that will receive the handle to the new key.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The base key under which the key should be opened. This can be one or more of the following values.</para>
      <h4>SHREGSET_HKCU</h4>
      <para>Create/open the key under <b>HKEY_CURRENT_USER</b>. Only creates a key if it is empty.</para>
      <h4>SHREGSET_FORCE_HKCU</h4>
      <para>Create/open the key under <b>HKEY_CURRENT_USER</b>. Creates a key even if it is not empty.</para>
      <h4>SHREGSET_HKLM</h4>
      <para>Create/open the key under <b>HKEY_LOCAL_MACHINE</b>. Only creates a key if it is empty.</para>
      <h4>SHREGSET_FORCE_HKLM</h4>
      <para>Create/open the key under <b>HKEY_LOCAL_MACHINE</b>. Creates a key even if it is not empty.</para>
      <h4>SHREGSET_DEFAULT</h4>
      <para>Create/open the key under both <b>HKEY_CURRENT_USER</b> (forced) and <b>HKEY_LOCAL_MACHINE</b> (only if empty). This flag is the equivalent of (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <param name="dwFlags.SHREGSET_DEFAULT">
      <para>Create/open the key under both <b>HKEY_CURRENT_USER</b> (forced) and <b>HKEY_LOCAL_MACHINE</b> (only if empty). This flag is the equivalent of (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <param name="dwFlags.SHREGSET_FORCE_HKCU">
      <para>Create/open the key under <b>HKEY_CURRENT_USER</b>. Creates a key even if it is not empty.</para>
    </param>
    <param name="dwFlags.SHREGSET_FORCE_HKLM">
      <para>Create/open the key under <b>HKEY_LOCAL_MACHINE</b>. Creates a key even if it is not empty.</para>
    </param>
    <param name="dwFlags.SHREGSET_HKCU">
      <para>Create/open the key under <b>HKEY_CURRENT_USER</b>. Only creates a key if it is empty.</para>
    </param>
    <param name="dwFlags.SHREGSET_HKLM">
      <para>Create/open the key under <b>HKEY_LOCAL_MACHINE</b>. Only creates a key if it is empty.</para>
      <h4>- pszPath [in]</h4>
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the subkey to be created or opened. If a value with this name is already present in the subkey, it will be opened.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>If you want to write values to the new key, use <see cref="SHRegWriteUSValue" /> to write each value, passing the <b>HUSKEY</b> handle that is returned through <i>phNewUSKey</i>. When you have finished, close the user-specific registry key with <see cref="SHRegCloseUSKey" />.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegCreateUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegCreateUSKeyA">
    <summary>
      <para>Creates or opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pwzPath">
      <para>TBD</para>
    </param>
    <param name="samDesired">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a></b></para>
      <para>The desired security access. For more information on security access, see <a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a>.</para>
    </param>
    <param name="hRelativeUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set <i>hRelativeUSKey</i> to <b>NULL</b>. The key will then be created under <b>HKEY_LOCAL_MACHINE</b> or <b>HKEY_CURRENT_USER</b>, depending the value of <i>dwFlags</i>.</para>
    </param>
    <param name="phNewUSKey">
      <para>Type: <b>PHUSKEY</b></para>
      <para>A pointer to an <b>HUSKEY</b> that will receive the handle to the new key.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The base key under which the key should be opened. This can be one or more of the following values.</para>
      <h4>SHREGSET_HKCU</h4>
      <para>Create/open the key under <b>HKEY_CURRENT_USER</b>. Only creates a key if it is empty.</para>
      <h4>SHREGSET_FORCE_HKCU</h4>
      <para>Create/open the key under <b>HKEY_CURRENT_USER</b>. Creates a key even if it is not empty.</para>
      <h4>SHREGSET_HKLM</h4>
      <para>Create/open the key under <b>HKEY_LOCAL_MACHINE</b>. Only creates a key if it is empty.</para>
      <h4>SHREGSET_FORCE_HKLM</h4>
      <para>Create/open the key under <b>HKEY_LOCAL_MACHINE</b>. Creates a key even if it is not empty.</para>
      <h4>SHREGSET_DEFAULT</h4>
      <para>Create/open the key under both <b>HKEY_CURRENT_USER</b> (forced) and <b>HKEY_LOCAL_MACHINE</b> (only if empty). This flag is the equivalent of (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <param name="dwFlags.SHREGSET_DEFAULT">
      <para>Create/open the key under both <b>HKEY_CURRENT_USER</b> (forced) and <b>HKEY_LOCAL_MACHINE</b> (only if empty). This flag is the equivalent of (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <param name="dwFlags.SHREGSET_FORCE_HKCU">
      <para>Create/open the key under <b>HKEY_CURRENT_USER</b>. Creates a key even if it is not empty.</para>
    </param>
    <param name="dwFlags.SHREGSET_FORCE_HKLM">
      <para>Create/open the key under <b>HKEY_LOCAL_MACHINE</b>. Creates a key even if it is not empty.</para>
    </param>
    <param name="dwFlags.SHREGSET_HKCU">
      <para>Create/open the key under <b>HKEY_CURRENT_USER</b>. Only creates a key if it is empty.</para>
    </param>
    <param name="dwFlags.SHREGSET_HKLM">
      <para>Create/open the key under <b>HKEY_LOCAL_MACHINE</b>. Only creates a key if it is empty.</para>
      <h4>- pszPath [in]</h4>
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the subkey to be created or opened. If a value with this name is already present in the subkey, it will be opened.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>If you want to write values to the new key, use <see cref="SHRegWriteUSValue" /> to write each value, passing the <b>HUSKEY</b> handle that is returned through <i>phNewUSKey</i>. When you have finished, close the user-specific registry key with <see cref="SHRegCloseUSKey" />.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegCreateUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegCreateUSKeyW">
    <summary>
      <para>Creates or opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pwzPath">
      <para>TBD</para>
    </param>
    <param name="samDesired">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a></b></para>
      <para>The desired security access. For more information on security access, see <a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a>.</para>
    </param>
    <param name="hRelativeUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set <i>hRelativeUSKey</i> to <b>NULL</b>. The key will then be created under <b>HKEY_LOCAL_MACHINE</b> or <b>HKEY_CURRENT_USER</b>, depending the value of <i>dwFlags</i>.</para>
    </param>
    <param name="phNewUSKey">
      <para>Type: <b>PHUSKEY</b></para>
      <para>A pointer to an <b>HUSKEY</b> that will receive the handle to the new key.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The base key under which the key should be opened. This can be one or more of the following values.</para>
      <h4>SHREGSET_HKCU</h4>
      <para>Create/open the key under <b>HKEY_CURRENT_USER</b>. Only creates a key if it is empty.</para>
      <h4>SHREGSET_FORCE_HKCU</h4>
      <para>Create/open the key under <b>HKEY_CURRENT_USER</b>. Creates a key even if it is not empty.</para>
      <h4>SHREGSET_HKLM</h4>
      <para>Create/open the key under <b>HKEY_LOCAL_MACHINE</b>. Only creates a key if it is empty.</para>
      <h4>SHREGSET_FORCE_HKLM</h4>
      <para>Create/open the key under <b>HKEY_LOCAL_MACHINE</b>. Creates a key even if it is not empty.</para>
      <h4>SHREGSET_DEFAULT</h4>
      <para>Create/open the key under both <b>HKEY_CURRENT_USER</b> (forced) and <b>HKEY_LOCAL_MACHINE</b> (only if empty). This flag is the equivalent of (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <param name="dwFlags.SHREGSET_DEFAULT">
      <para>Create/open the key under both <b>HKEY_CURRENT_USER</b> (forced) and <b>HKEY_LOCAL_MACHINE</b> (only if empty). This flag is the equivalent of (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <param name="dwFlags.SHREGSET_FORCE_HKCU">
      <para>Create/open the key under <b>HKEY_CURRENT_USER</b>. Creates a key even if it is not empty.</para>
    </param>
    <param name="dwFlags.SHREGSET_FORCE_HKLM">
      <para>Create/open the key under <b>HKEY_LOCAL_MACHINE</b>. Creates a key even if it is not empty.</para>
    </param>
    <param name="dwFlags.SHREGSET_HKCU">
      <para>Create/open the key under <b>HKEY_CURRENT_USER</b>. Only creates a key if it is empty.</para>
    </param>
    <param name="dwFlags.SHREGSET_HKLM">
      <para>Create/open the key under <b>HKEY_LOCAL_MACHINE</b>. Only creates a key if it is empty.</para>
      <h4>- pszPath [in]</h4>
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the subkey to be created or opened. If a value with this name is already present in the subkey, it will be opened.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>If you want to write values to the new key, use <see cref="SHRegWriteUSValue" /> to write each value, passing the <b>HUSKEY</b> handle that is returned through <i>phNewUSKey</i>. When you have finished, close the user-specific registry key with <see cref="SHRegCloseUSKey" />.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegCreateUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegDeleteEmptyUSKey">
    <summary>
      <para>Deletes an empty registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to  the null-terminated string that specifies the empty user-defined registry subkey to be deleted.</para>
    </param>
    <param name="delRegFlags">
      <para>Type: <b><see cref="SHREGDEL_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGDEL_FLAGS" /> that specifies from which base key the subkey will be deleted.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegDeleteEmptyUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHRegDeleteUSValue" />
  </member>
  <member name="Windows.SHRegDeleteEmptyUSKeyA">
    <summary>
      <para>Deletes an empty registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to  the null-terminated string that specifies the empty user-defined registry subkey to be deleted.</para>
    </param>
    <param name="delRegFlags">
      <para>Type: <b><see cref="SHREGDEL_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGDEL_FLAGS" /> that specifies from which base key the subkey will be deleted.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegDeleteEmptyUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHRegDeleteUSValue" />
  </member>
  <member name="Windows.SHRegDeleteEmptyUSKeyW">
    <summary>
      <para>Deletes an empty registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to  the null-terminated string that specifies the empty user-defined registry subkey to be deleted.</para>
    </param>
    <param name="delRegFlags">
      <para>Type: <b><see cref="SHREGDEL_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGDEL_FLAGS" /> that specifies from which base key the subkey will be deleted.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegDeleteEmptyUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHRegDeleteUSValue" />
  </member>
  <member name="Windows.SHRegDeleteEmptyUSKey">
    <summary>
      <para>Deletes an empty registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pwzSubKey">
      <para>TBD</para>
    </param>
    <param name="delRegFlags">
      <para>Type: <b><see cref="SHREGDEL_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGDEL_FLAGS" /> that specifies from which base key the subkey will be deleted.</para>
      <h4>- pszSubKey [in]</h4>
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to  the null-terminated string that specifies the empty user-defined registry subkey to be deleted.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegDeleteEmptyUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHRegDeleteUSValue" />
  </member>
  <member name="Windows.SHRegDeleteEmptyUSKeyA">
    <summary>
      <para>Deletes an empty registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pwzSubKey">
      <para>TBD</para>
    </param>
    <param name="delRegFlags">
      <para>Type: <b><see cref="SHREGDEL_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGDEL_FLAGS" /> that specifies from which base key the subkey will be deleted.</para>
      <h4>- pszSubKey [in]</h4>
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to  the null-terminated string that specifies the empty user-defined registry subkey to be deleted.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegDeleteEmptyUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHRegDeleteUSValue" />
  </member>
  <member name="Windows.SHRegDeleteEmptyUSKeyW">
    <summary>
      <para>Deletes an empty registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pwzSubKey">
      <para>TBD</para>
    </param>
    <param name="delRegFlags">
      <para>Type: <b><see cref="SHREGDEL_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGDEL_FLAGS" /> that specifies from which base key the subkey will be deleted.</para>
      <h4>- pszSubKey [in]</h4>
      <para>Type: <b>LPCSTR</b></para>
      <para>A pointer to  the null-terminated string that specifies the empty user-defined registry subkey to be deleted.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegDeleteEmptyUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHRegDeleteUSValue" />
  </member>
  <member name="Windows.SHRegDeleteUSValue">
    <summary>
      <para>Deletes a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the null-terminated string that names the value to remove.</para>
    </param>
    <param name="delRegFlags">
      <para>Type: <b><see cref="SHREGDEL_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGDEL_FLAGS" /> that specifies from which base key the value will be deleted.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegDeleteUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHRegDeleteEmptyUSKey" />
  </member>
  <member name="Windows.SHRegDeleteUSValueA">
    <summary>
      <para>Deletes a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the null-terminated string that names the value to remove.</para>
    </param>
    <param name="delRegFlags">
      <para>Type: <b><see cref="SHREGDEL_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGDEL_FLAGS" /> that specifies from which base key the value will be deleted.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegDeleteUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHRegDeleteEmptyUSKey" />
  </member>
  <member name="Windows.SHRegDeleteUSValueW">
    <summary>
      <para>Deletes a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the null-terminated string that names the value to remove.</para>
    </param>
    <param name="delRegFlags">
      <para>Type: <b><see cref="SHREGDEL_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGDEL_FLAGS" /> that specifies from which base key the value will be deleted.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegDeleteUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHRegDeleteEmptyUSKey" />
  </member>
  <member name="Windows.SHRegDeleteUSValue">
    <summary>
      <para>Deletes a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pwzValue">
      <para>TBD</para>
    </param>
    <param name="delRegFlags">
      <para>Type: <b><see cref="SHREGDEL_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGDEL_FLAGS" /> that specifies from which base key the value will be deleted.</para>
      <h4>- pszValue [in]</h4>
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the null-terminated string that names the value to remove.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegDeleteUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHRegDeleteEmptyUSKey" />
  </member>
  <member name="Windows.SHRegDeleteUSValueA">
    <summary>
      <para>Deletes a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pwzValue">
      <para>TBD</para>
    </param>
    <param name="delRegFlags">
      <para>Type: <b><see cref="SHREGDEL_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGDEL_FLAGS" /> that specifies from which base key the value will be deleted.</para>
      <h4>- pszValue [in]</h4>
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the null-terminated string that names the value to remove.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegDeleteUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHRegDeleteEmptyUSKey" />
  </member>
  <member name="Windows.SHRegDeleteUSValueW">
    <summary>
      <para>Deletes a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pwzValue">
      <para>TBD</para>
    </param>
    <param name="delRegFlags">
      <para>Type: <b><see cref="SHREGDEL_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGDEL_FLAGS" /> that specifies from which base key the value will be deleted.</para>
      <h4>- pszValue [in]</h4>
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the null-terminated string that names the value to remove.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegDeleteUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="SHRegDeleteEmptyUSKey" />
  </member>
  <member name="Windows.SHRegDuplicateHKey">
    <summary>
      <para>Duplicates a registry key's HKEY handle.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>The HKEY handle to be duplicated.</para>
    </param>
    <returns>
      <para>Type: <b>HKEY</b></para>
      <para>Returns a duplicate of the handle specified in <i>hkey</i>.</para>
    </returns>
  </member>
  <member name="Windows.SHRegEnumUSKey">
    <summary>
      <para>Enumerates the subkeys of a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszName">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a character buffer that receives the enumerated key name.</para>
    </param>
    <param name="pcchName">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to  a DWORD that, on entry, contains the size of the buffer at <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.</para>
    </param>
    <param name="enumRegFlags">
      <para>Type: <b><see cref="SHREGENUM_FLAGS" /></b></para>
      <para>A <see cref="SHREGENUM_FLAGS" /> that specifies the base key in which the enumeration should take place.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegEnumUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegEnumUSKeyA">
    <summary>
      <para>Enumerates the subkeys of a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszName">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a character buffer that receives the enumerated key name.</para>
    </param>
    <param name="pcchName">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to  a DWORD that, on entry, contains the size of the buffer at <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.</para>
    </param>
    <param name="enumRegFlags">
      <para>Type: <b><see cref="SHREGENUM_FLAGS" /></b></para>
      <para>A <see cref="SHREGENUM_FLAGS" /> that specifies the base key in which the enumeration should take place.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegEnumUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegEnumUSKeyW">
    <summary>
      <para>Enumerates the subkeys of a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszName">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a character buffer that receives the enumerated key name.</para>
    </param>
    <param name="pcchName">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to  a DWORD that, on entry, contains the size of the buffer at <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.</para>
    </param>
    <param name="enumRegFlags">
      <para>Type: <b><see cref="SHREGENUM_FLAGS" /></b></para>
      <para>A <see cref="SHREGENUM_FLAGS" /> that specifies the base key in which the enumeration should take place.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegEnumUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegEnumUSKey">
    <summary>
      <para>Enumerates the subkeys of a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pwzName">
      <para>TBD</para>
    </param>
    <param name="pcchName">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to  a DWORD that, on entry, contains the size of the buffer at <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.</para>
    </param>
    <param name="enumRegFlags">
      <para>Type: <b><see cref="SHREGENUM_FLAGS" /></b></para>
      <para>A <see cref="SHREGENUM_FLAGS" /> that specifies the base key in which the enumeration should take place.</para>
      <h4>- pszName [out]</h4>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a character buffer that receives the enumerated key name.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegEnumUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegEnumUSKeyA">
    <summary>
      <para>Enumerates the subkeys of a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pwzName">
      <para>TBD</para>
    </param>
    <param name="pcchName">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to  a DWORD that, on entry, contains the size of the buffer at <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.</para>
    </param>
    <param name="enumRegFlags">
      <para>Type: <b><see cref="SHREGENUM_FLAGS" /></b></para>
      <para>A <see cref="SHREGENUM_FLAGS" /> that specifies the base key in which the enumeration should take place.</para>
      <h4>- pszName [out]</h4>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a character buffer that receives the enumerated key name.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegEnumUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegEnumUSKeyW">
    <summary>
      <para>Enumerates the subkeys of a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the subkey to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pwzName">
      <para>TBD</para>
    </param>
    <param name="pcchName">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to  a DWORD that, on entry, contains the size of the buffer at <i>pszName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszName</i>.</para>
    </param>
    <param name="enumRegFlags">
      <para>Type: <b><see cref="SHREGENUM_FLAGS" /></b></para>
      <para>A <see cref="SHREGENUM_FLAGS" /> that specifies the base key in which the enumeration should take place.</para>
      <h4>- pszName [out]</h4>
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a character buffer that receives the enumerated key name.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegEnumUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegEnumUSValue">
    <summary>
      <para>Enumerates the values of the specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSkey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszValueName">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a character buffer that receives the enumerated value name. The size of this buffer is specified in <i>pcchValueNameLen</i>.</para>
    </param>
    <param name="pcchValueName">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszValueName</i>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the data type of the value. These are the same values as those described under the <i>lpType</i> parameter of <see cref="RegEnumValue" />.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that receives the data for the value entry. The size of this buffer is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pvData</i>. On exit, this contains the number of bytes that were copied to <i>pvData</i>.</para>
    </param>
    <param name="enumRegFlags">
      <para>Type: <b><see cref="SHREGENUM_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGENUM_FLAGS" /> that specifies the base key in which the enumeration should take place.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegEnumUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegEnumUSValueA">
    <summary>
      <para>Enumerates the values of the specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSkey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszValueName">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a character buffer that receives the enumerated value name. The size of this buffer is specified in <i>pcchValueNameLen</i>.</para>
    </param>
    <param name="pcchValueName">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszValueName</i>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the data type of the value. These are the same values as those described under the <i>lpType</i> parameter of <see cref="RegEnumValue" />.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that receives the data for the value entry. The size of this buffer is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pvData</i>. On exit, this contains the number of bytes that were copied to <i>pvData</i>.</para>
    </param>
    <param name="enumRegFlags">
      <para>Type: <b><see cref="SHREGENUM_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGENUM_FLAGS" /> that specifies the base key in which the enumeration should take place.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegEnumUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegEnumUSValueW">
    <summary>
      <para>Enumerates the values of the specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSkey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszValueName">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a character buffer that receives the enumerated value name. The size of this buffer is specified in <i>pcchValueNameLen</i>.</para>
    </param>
    <param name="pcchValueName">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszValueName</i>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the data type of the value. These are the same values as those described under the <i>lpType</i> parameter of <see cref="RegEnumValue" />.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that receives the data for the value entry. The size of this buffer is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pvData</i>. On exit, this contains the number of bytes that were copied to <i>pvData</i>.</para>
    </param>
    <param name="enumRegFlags">
      <para>Type: <b><see cref="SHREGENUM_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGENUM_FLAGS" /> that specifies the base key in which the enumeration should take place.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegEnumUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegEnumUSValue">
    <summary>
      <para>Enumerates the values of the specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSkey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszValueName">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a character buffer that receives the enumerated value name. The size of this buffer is specified in <i>pcchValueNameLen</i>.</para>
    </param>
    <param name="pcchValueName">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszValueName</i>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the data type of the value. These are the same values as those described under the <i>lpType</i> parameter of <see cref="RegEnumValue" />.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that receives the data for the value entry. The size of this buffer is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pvData</i>. On exit, this contains the number of bytes that were copied to <i>pvData</i>.</para>
    </param>
    <param name="enumRegFlags">
      <para>Type: <b><see cref="SHREGENUM_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGENUM_FLAGS" /> that specifies the base key in which the enumeration should take place.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegEnumUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegEnumUSValueA">
    <summary>
      <para>Enumerates the values of the specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSkey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszValueName">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a character buffer that receives the enumerated value name. The size of this buffer is specified in <i>pcchValueNameLen</i>.</para>
    </param>
    <param name="pcchValueName">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszValueName</i>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the data type of the value. These are the same values as those described under the <i>lpType</i> parameter of <see cref="RegEnumValue" />.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that receives the data for the value entry. The size of this buffer is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pvData</i>. On exit, this contains the number of bytes that were copied to <i>pvData</i>.</para>
    </param>
    <param name="enumRegFlags">
      <para>Type: <b><see cref="SHREGENUM_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGENUM_FLAGS" /> that specifies the base key in which the enumeration should take place.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegEnumUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegEnumUSValueW">
    <summary>
      <para>Enumerates the values of the specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSkey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="dwIndex">
      <para>Type: <b>DWORD</b></para>
      <para>The index of the value to retrieve. This parameter should be zero for the first call and incremented for subsequent calls.</para>
    </param>
    <param name="pszValueName">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a character buffer that receives the enumerated value name. The size of this buffer is specified in <i>pcchValueNameLen</i>.</para>
    </param>
    <param name="pcchValueName">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pszValueName</i>, in characters. On exit, this contains the number of characters that were copied to <i>pszValueName</i>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the data type of the value. These are the same values as those described under the <i>lpType</i> parameter of <see cref="RegEnumValue" />.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that receives the data for the value entry. The size of this buffer is specified in <i>pcbData</i>. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that, on entry, contains the size of the buffer at <i>pvData</i>. On exit, this contains the number of bytes that were copied to <i>pvData</i>.</para>
    </param>
    <param name="enumRegFlags">
      <para>Type: <b><see cref="SHREGENUM_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGENUM_FLAGS" /> that specifies the base key in which the enumeration should take place.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegEnumUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegGetBoolUSValue">
    <summary>
      <para>Retrieves a Boolean value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey relative to <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example, "Software\MyCompany\MyProduct".</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that specifies the name of the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>A variable that specifies which key to look under. When set to <b>TRUE</b>, <see cref="SHRegGetUSValue" /> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="fDefault">
      <para>Type: <b>BOOL</b></para>
      <para>A value that is returned if there is no registry value.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns either the value from the registry, or <i>fDefault</i> if none is found.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegGetBoolUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegGetBoolUSValueA">
    <summary>
      <para>Retrieves a Boolean value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey relative to <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example, "Software\MyCompany\MyProduct".</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that specifies the name of the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>A variable that specifies which key to look under. When set to <b>TRUE</b>, <see cref="SHRegGetUSValue" /> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="fDefault">
      <para>Type: <b>BOOL</b></para>
      <para>A value that is returned if there is no registry value.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns either the value from the registry, or <i>fDefault</i> if none is found.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegGetBoolUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegGetBoolUSValueW">
    <summary>
      <para>Retrieves a Boolean value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey relative to <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example, "Software\MyCompany\MyProduct".</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that specifies the name of the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>A variable that specifies which key to look under. When set to <b>TRUE</b>, <see cref="SHRegGetUSValue" /> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="fDefault">
      <para>Type: <b>BOOL</b></para>
      <para>A value that is returned if there is no registry value.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns either the value from the registry, or <i>fDefault</i> if none is found.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegGetBoolUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegGetBoolUSValue">
    <summary>
      <para>Retrieves a Boolean value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey relative to <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example, "Software\MyCompany\MyProduct".</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that specifies the name of the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>A variable that specifies which key to look under. When set to <b>TRUE</b>, <see cref="SHRegGetUSValue" /> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="fDefault">
      <para>Type: <b>BOOL</b></para>
      <para>A value that is returned if there is no registry value.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns either the value from the registry, or <i>fDefault</i> if none is found.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegGetBoolUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegGetBoolUSValueA">
    <summary>
      <para>Retrieves a Boolean value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey relative to <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example, "Software\MyCompany\MyProduct".</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that specifies the name of the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>A variable that specifies which key to look under. When set to <b>TRUE</b>, <see cref="SHRegGetUSValue" /> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="fDefault">
      <para>Type: <b>BOOL</b></para>
      <para>A value that is returned if there is no registry value.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns either the value from the registry, or <i>fDefault</i> if none is found.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegGetBoolUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegGetBoolUSValueW">
    <summary>
      <para>Retrieves a Boolean value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey relative to <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example, "Software\MyCompany\MyProduct".</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that specifies the name of the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>A variable that specifies which key to look under. When set to <b>TRUE</b>, <see cref="SHRegGetUSValue" /> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="fDefault">
      <para>Type: <b>BOOL</b></para>
      <para>A value that is returned if there is no registry value.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns either the value from the registry, or <i>fDefault</i> if none is found.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegGetBoolUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegGetIntW">
    <summary>
      <para>Reads a numeric string value from the registry and converts it to an integer.</para>
    </summary>
    <param name="hk">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the registry key that specifies the value to be read.</para>
    </param>
    <param name="pwzKey">
      <para>Type: <b>LPCWSTR</b></para>
      <para>A pointer to a string value that specifies the name of the value to be read. The string must be null-terminated.</para>
    </param>
    <param name="iDefault">
      <para>Type: <b>int</b></para>
      <para>An <b>int</b> that specifies the value returned if the registry value cannot be retrieved successfully.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the converted string as an <b>int</b>, or the default value specified by <i>nDefault</i>.</para>
    </returns>
    <remarks>
      <para>Prior to Windows 2000 Service Pack 3 (SP3), Windows Server 2003 Service Pack 1 (SP1), and Windows XP, <b>SHRegGetIntW</b> was not exported by name. On those systems you must load it directly from Shlwapi.dll as ordinal 280.</para>
      <para>This function is only available in a Unicode version. ANSI is not supported.</para>
    </remarks>
  </member>
  <member name="Windows.SHRegGetPath">
    <summary>
      <para>Retrieves a file path from the registry, expanding environment variables as needed.</para>
    </summary>
    <param name="hKey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to a key that is currently open, or a registry root key.</para>
    </param>
    <param name="pcszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the name of the subkey.</para>
    </param>
    <param name="pcszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the name of the value that holds the unexpanded path string.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A buffer to hold the expanded path. You should set the size of this buffer to <b>MAX_PATH</b> to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a Windows error code otherwise.</para>
    </returns>
    <remarks>
      <para>The data type of the specified registry value must be either <b>REG_EXPAND_SZ</b> or <b>REG_SZ</b>. If it has the <b>REG_EXPAND_SZ</b> type, any environment variables in the registry string will be expanded with <see cref="ExpandEnvironmentStrings" />. If it has the <b>REG_SZ</b> data type, environment variables will not be expanded and the string pointed to by <i>pszPath</i> will be identical to the string in the registry.</para>
      <para>The following environment strings will be replaced by their equivalent path.</para>
      <list type="table">
        <listheader>
          <description>Environment string</description>
          <description>Folder</description>
        </listheader>
        <item>
          <description>%USERPROFILE%
</description>
          <description>The current user's profile folder</description>
        </item>
        <item>
          <description>%ALLUSERSPROFILE%
</description>
          <description>The All Users profile folder</description>
        </item>
        <item>
          <description>%ProgramFiles%
</description>
          <description>The Program Files folder</description>
        </item>
        <item>
          <description>%SystemRoot%
</description>
          <description>The system root folder</description>
        </item>
        <item>
          <description>%SystemDrive%
</description>
          <description>The system drive letter</description>
        </item>
      </list>
      <para>
        <b>Note</b>  %USERPROFILE% is relative to the user making the call. This function does not work if the user is being impersonated from a service.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegGetPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegGetPathA">
    <summary>
      <para>Retrieves a file path from the registry, expanding environment variables as needed.</para>
    </summary>
    <param name="hKey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to a key that is currently open, or a registry root key.</para>
    </param>
    <param name="pcszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the name of the subkey.</para>
    </param>
    <param name="pcszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the name of the value that holds the unexpanded path string.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A buffer to hold the expanded path. You should set the size of this buffer to <b>MAX_PATH</b> to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a Windows error code otherwise.</para>
    </returns>
    <remarks>
      <para>The data type of the specified registry value must be either <b>REG_EXPAND_SZ</b> or <b>REG_SZ</b>. If it has the <b>REG_EXPAND_SZ</b> type, any environment variables in the registry string will be expanded with <see cref="ExpandEnvironmentStrings" />. If it has the <b>REG_SZ</b> data type, environment variables will not be expanded and the string pointed to by <i>pszPath</i> will be identical to the string in the registry.</para>
      <para>The following environment strings will be replaced by their equivalent path.</para>
      <list type="table">
        <listheader>
          <description>Environment string</description>
          <description>Folder</description>
        </listheader>
        <item>
          <description>%USERPROFILE%
</description>
          <description>The current user's profile folder</description>
        </item>
        <item>
          <description>%ALLUSERSPROFILE%
</description>
          <description>The All Users profile folder</description>
        </item>
        <item>
          <description>%ProgramFiles%
</description>
          <description>The Program Files folder</description>
        </item>
        <item>
          <description>%SystemRoot%
</description>
          <description>The system root folder</description>
        </item>
        <item>
          <description>%SystemDrive%
</description>
          <description>The system drive letter</description>
        </item>
      </list>
      <para>
        <b>Note</b>  %USERPROFILE% is relative to the user making the call. This function does not work if the user is being impersonated from a service.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegGetPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegGetPathW">
    <summary>
      <para>Retrieves a file path from the registry, expanding environment variables as needed.</para>
    </summary>
    <param name="hKey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to a key that is currently open, or a registry root key.</para>
    </param>
    <param name="pcszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the name of the subkey.</para>
    </param>
    <param name="pcszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the name of the value that holds the unexpanded path string.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A buffer to hold the expanded path. You should set the size of this buffer to <b>MAX_PATH</b> to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a Windows error code otherwise.</para>
    </returns>
    <remarks>
      <para>The data type of the specified registry value must be either <b>REG_EXPAND_SZ</b> or <b>REG_SZ</b>. If it has the <b>REG_EXPAND_SZ</b> type, any environment variables in the registry string will be expanded with <see cref="ExpandEnvironmentStrings" />. If it has the <b>REG_SZ</b> data type, environment variables will not be expanded and the string pointed to by <i>pszPath</i> will be identical to the string in the registry.</para>
      <para>The following environment strings will be replaced by their equivalent path.</para>
      <list type="table">
        <listheader>
          <description>Environment string</description>
          <description>Folder</description>
        </listheader>
        <item>
          <description>%USERPROFILE%
</description>
          <description>The current user's profile folder</description>
        </item>
        <item>
          <description>%ALLUSERSPROFILE%
</description>
          <description>The All Users profile folder</description>
        </item>
        <item>
          <description>%ProgramFiles%
</description>
          <description>The Program Files folder</description>
        </item>
        <item>
          <description>%SystemRoot%
</description>
          <description>The system root folder</description>
        </item>
        <item>
          <description>%SystemDrive%
</description>
          <description>The system drive letter</description>
        </item>
      </list>
      <para>
        <b>Note</b>  %USERPROFILE% is relative to the user making the call. This function does not work if the user is being impersonated from a service.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegGetPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegGetPath">
    <summary>
      <para>Retrieves a file path from the registry, expanding environment variables as needed.</para>
    </summary>
    <param name="hKey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to a key that is currently open, or a registry root key.</para>
    </param>
    <param name="pcszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the name of the subkey.</para>
    </param>
    <param name="pcszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the name of the value that holds the unexpanded path string.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A buffer to hold the expanded path. You should set the size of this buffer to <b>MAX_PATH</b> to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a Windows error code otherwise.</para>
    </returns>
    <remarks>
      <para>The data type of the specified registry value must be either <b>REG_EXPAND_SZ</b> or <b>REG_SZ</b>. If it has the <b>REG_EXPAND_SZ</b> type, any environment variables in the registry string will be expanded with <see cref="ExpandEnvironmentStrings" />. If it has the <b>REG_SZ</b> data type, environment variables will not be expanded and the string pointed to by <i>pszPath</i> will be identical to the string in the registry.</para>
      <para>The following environment strings will be replaced by their equivalent path.</para>
      <list type="table">
        <listheader>
          <description>Environment string</description>
          <description>Folder</description>
        </listheader>
        <item>
          <description>%USERPROFILE%
</description>
          <description>The current user's profile folder</description>
        </item>
        <item>
          <description>%ALLUSERSPROFILE%
</description>
          <description>The All Users profile folder</description>
        </item>
        <item>
          <description>%ProgramFiles%
</description>
          <description>The Program Files folder</description>
        </item>
        <item>
          <description>%SystemRoot%
</description>
          <description>The system root folder</description>
        </item>
        <item>
          <description>%SystemDrive%
</description>
          <description>The system drive letter</description>
        </item>
      </list>
      <para>
        <b>Note</b>  %USERPROFILE% is relative to the user making the call. This function does not work if the user is being impersonated from a service.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegGetPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegGetPathA">
    <summary>
      <para>Retrieves a file path from the registry, expanding environment variables as needed.</para>
    </summary>
    <param name="hKey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to a key that is currently open, or a registry root key.</para>
    </param>
    <param name="pcszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the name of the subkey.</para>
    </param>
    <param name="pcszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the name of the value that holds the unexpanded path string.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A buffer to hold the expanded path. You should set the size of this buffer to <b>MAX_PATH</b> to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a Windows error code otherwise.</para>
    </returns>
    <remarks>
      <para>The data type of the specified registry value must be either <b>REG_EXPAND_SZ</b> or <b>REG_SZ</b>. If it has the <b>REG_EXPAND_SZ</b> type, any environment variables in the registry string will be expanded with <see cref="ExpandEnvironmentStrings" />. If it has the <b>REG_SZ</b> data type, environment variables will not be expanded and the string pointed to by <i>pszPath</i> will be identical to the string in the registry.</para>
      <para>The following environment strings will be replaced by their equivalent path.</para>
      <list type="table">
        <listheader>
          <description>Environment string</description>
          <description>Folder</description>
        </listheader>
        <item>
          <description>%USERPROFILE%
</description>
          <description>The current user's profile folder</description>
        </item>
        <item>
          <description>%ALLUSERSPROFILE%
</description>
          <description>The All Users profile folder</description>
        </item>
        <item>
          <description>%ProgramFiles%
</description>
          <description>The Program Files folder</description>
        </item>
        <item>
          <description>%SystemRoot%
</description>
          <description>The system root folder</description>
        </item>
        <item>
          <description>%SystemDrive%
</description>
          <description>The system drive letter</description>
        </item>
      </list>
      <para>
        <b>Note</b>  %USERPROFILE% is relative to the user making the call. This function does not work if the user is being impersonated from a service.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegGetPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegGetPathW">
    <summary>
      <para>Retrieves a file path from the registry, expanding environment variables as needed.</para>
    </summary>
    <param name="hKey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to a key that is currently open, or a registry root key.</para>
    </param>
    <param name="pcszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the name of the subkey.</para>
    </param>
    <param name="pcszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the name of the value that holds the unexpanded path string.</para>
    </param>
    <param name="pszPath">
      <para>Type: <b>LPTSTR</b></para>
      <para>A buffer to hold the expanded path. You should set the size of this buffer to <b>MAX_PATH</b> to ensure that it is large enough to hold the returned string.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns <b>ERROR_SUCCESS</b> if successful, or a Windows error code otherwise.</para>
    </returns>
    <remarks>
      <para>The data type of the specified registry value must be either <b>REG_EXPAND_SZ</b> or <b>REG_SZ</b>. If it has the <b>REG_EXPAND_SZ</b> type, any environment variables in the registry string will be expanded with <see cref="ExpandEnvironmentStrings" />. If it has the <b>REG_SZ</b> data type, environment variables will not be expanded and the string pointed to by <i>pszPath</i> will be identical to the string in the registry.</para>
      <para>The following environment strings will be replaced by their equivalent path.</para>
      <list type="table">
        <listheader>
          <description>Environment string</description>
          <description>Folder</description>
        </listheader>
        <item>
          <description>%USERPROFILE%
</description>
          <description>The current user's profile folder</description>
        </item>
        <item>
          <description>%ALLUSERSPROFILE%
</description>
          <description>The All Users profile folder</description>
        </item>
        <item>
          <description>%ProgramFiles%
</description>
          <description>The Program Files folder</description>
        </item>
        <item>
          <description>%SystemRoot%
</description>
          <description>The system root folder</description>
        </item>
        <item>
          <description>%SystemDrive%
</description>
          <description>The system drive letter</description>
        </item>
      </list>
      <para>
        <b>Note</b>  %USERPROFILE% is relative to the user making the call. This function does not work if the user is being impersonated from a service.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegGetPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegGetUSValue">
    <summary>
      <para>Retrieves a value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey relative to <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example: "Software\MyCompany\MyProduct".</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the type of data stored in the retrieved value. When using default values, the input <i>pdwType</i> is the type of the default value. For possible values, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>. If type information is not required, this parameter can be <b>NULL</b>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that receives the value's data.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by <i>pvData</i>. When <b>SHRegGetUSValue</b> returns, <i>pcbData</i> contains the size of the data copied to <i>pvData</i>.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>A variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegGetUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="pvDefaultData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that receives the value's default data.</para>
    </param>
    <param name="dwDefaultDataSize">
      <para>Type: <b>DWORD</b></para>
      <para>The length, in bytes, of the buffer pointed to by <i>pvDefaultData</i>.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>When <i>fIgnoreHKCU</i> is set to <b>TRUE</b>, <b>SHRegGetUSValue</b> returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>. When set to <b>FALSE</b>, <b>SHRegGetUSValue</b> first tries to return the value from the key under <b>HKEY_CURRENT_USER</b>. However, if the key is not found under <b>HKEY_CURRENT_USER</b>, the value is returned from the key under <b>HKEY_LOCAL_MACHINE</b>. If neither key is present, or if an error occurred and <i>dwDefaultDataSize</i> is nonzero, then the default data is copied to <i>pvData</i> and ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no way of distinguishing which value copies to <i>pvData</i>. To prevent the use of default data, set <i>pvDefaultData</i> to <b>NULL</b> and <i>dwDefaultDataSize</i> to zero.</para>
      <para>This function opens the key each time it is used. If your code involves getting a series of values from the same key, it is more efficient to open the key once with <see cref="SHRegOpenUSKey" /> and then use <see cref="SHRegQueryUSValue" /> to retrieve the data.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegGetUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegGetUSValueA">
    <summary>
      <para>Retrieves a value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey relative to <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example: "Software\MyCompany\MyProduct".</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the type of data stored in the retrieved value. When using default values, the input <i>pdwType</i> is the type of the default value. For possible values, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>. If type information is not required, this parameter can be <b>NULL</b>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that receives the value's data.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by <i>pvData</i>. When <b>SHRegGetUSValue</b> returns, <i>pcbData</i> contains the size of the data copied to <i>pvData</i>.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>A variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegGetUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="pvDefaultData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that receives the value's default data.</para>
    </param>
    <param name="dwDefaultDataSize">
      <para>Type: <b>DWORD</b></para>
      <para>The length, in bytes, of the buffer pointed to by <i>pvDefaultData</i>.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>When <i>fIgnoreHKCU</i> is set to <b>TRUE</b>, <b>SHRegGetUSValue</b> returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>. When set to <b>FALSE</b>, <b>SHRegGetUSValue</b> first tries to return the value from the key under <b>HKEY_CURRENT_USER</b>. However, if the key is not found under <b>HKEY_CURRENT_USER</b>, the value is returned from the key under <b>HKEY_LOCAL_MACHINE</b>. If neither key is present, or if an error occurred and <i>dwDefaultDataSize</i> is nonzero, then the default data is copied to <i>pvData</i> and ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no way of distinguishing which value copies to <i>pvData</i>. To prevent the use of default data, set <i>pvDefaultData</i> to <b>NULL</b> and <i>dwDefaultDataSize</i> to zero.</para>
      <para>This function opens the key each time it is used. If your code involves getting a series of values from the same key, it is more efficient to open the key once with <see cref="SHRegOpenUSKey" /> and then use <see cref="SHRegQueryUSValue" /> to retrieve the data.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegGetUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegGetUSValueW">
    <summary>
      <para>Retrieves a value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey relative to <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example: "Software\MyCompany\MyProduct".</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the type of data stored in the retrieved value. When using default values, the input <i>pdwType</i> is the type of the default value. For possible values, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>. If type information is not required, this parameter can be <b>NULL</b>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that receives the value's data.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by <i>pvData</i>. When <b>SHRegGetUSValue</b> returns, <i>pcbData</i> contains the size of the data copied to <i>pvData</i>.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>A variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegGetUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="pvDefaultData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that receives the value's default data.</para>
    </param>
    <param name="dwDefaultDataSize">
      <para>Type: <b>DWORD</b></para>
      <para>The length, in bytes, of the buffer pointed to by <i>pvDefaultData</i>.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>When <i>fIgnoreHKCU</i> is set to <b>TRUE</b>, <b>SHRegGetUSValue</b> returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>. When set to <b>FALSE</b>, <b>SHRegGetUSValue</b> first tries to return the value from the key under <b>HKEY_CURRENT_USER</b>. However, if the key is not found under <b>HKEY_CURRENT_USER</b>, the value is returned from the key under <b>HKEY_LOCAL_MACHINE</b>. If neither key is present, or if an error occurred and <i>dwDefaultDataSize</i> is nonzero, then the default data is copied to <i>pvData</i> and ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no way of distinguishing which value copies to <i>pvData</i>. To prevent the use of default data, set <i>pvDefaultData</i> to <b>NULL</b> and <i>dwDefaultDataSize</i> to zero.</para>
      <para>This function opens the key each time it is used. If your code involves getting a series of values from the same key, it is more efficient to open the key once with <see cref="SHRegOpenUSKey" /> and then use <see cref="SHRegQueryUSValue" /> to retrieve the data.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegGetUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegGetUSValue">
    <summary>
      <para>Retrieves a value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey relative to <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example: "Software\MyCompany\MyProduct".</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the type of data stored in the retrieved value. When using default values, the input <i>pdwType</i> is the type of the default value. For possible values, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>. If type information is not required, this parameter can be <b>NULL</b>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that receives the value's data.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by <i>pvData</i>. When <b>SHRegGetUSValue</b> returns, <i>pcbData</i> contains the size of the data copied to <i>pvData</i>.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>A variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegGetUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="pvDefaultData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that receives the value's default data.</para>
    </param>
    <param name="dwDefaultDataSize">
      <para>Type: <b>DWORD</b></para>
      <para>The length, in bytes, of the buffer pointed to by <i>pvDefaultData</i>.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>When <i>fIgnoreHKCU</i> is set to <b>TRUE</b>, <b>SHRegGetUSValue</b> returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>. When set to <b>FALSE</b>, <b>SHRegGetUSValue</b> first tries to return the value from the key under <b>HKEY_CURRENT_USER</b>. However, if the key is not found under <b>HKEY_CURRENT_USER</b>, the value is returned from the key under <b>HKEY_LOCAL_MACHINE</b>. If neither key is present, or if an error occurred and <i>dwDefaultDataSize</i> is nonzero, then the default data is copied to <i>pvData</i> and ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no way of distinguishing which value copies to <i>pvData</i>. To prevent the use of default data, set <i>pvDefaultData</i> to <b>NULL</b> and <i>dwDefaultDataSize</i> to zero.</para>
      <para>This function opens the key each time it is used. If your code involves getting a series of values from the same key, it is more efficient to open the key once with <see cref="SHRegOpenUSKey" /> and then use <see cref="SHRegQueryUSValue" /> to retrieve the data.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegGetUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegGetUSValueA">
    <summary>
      <para>Retrieves a value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey relative to <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example: "Software\MyCompany\MyProduct".</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the type of data stored in the retrieved value. When using default values, the input <i>pdwType</i> is the type of the default value. For possible values, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>. If type information is not required, this parameter can be <b>NULL</b>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that receives the value's data.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by <i>pvData</i>. When <b>SHRegGetUSValue</b> returns, <i>pcbData</i> contains the size of the data copied to <i>pvData</i>.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>A variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegGetUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="pvDefaultData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that receives the value's default data.</para>
    </param>
    <param name="dwDefaultDataSize">
      <para>Type: <b>DWORD</b></para>
      <para>The length, in bytes, of the buffer pointed to by <i>pvDefaultData</i>.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>When <i>fIgnoreHKCU</i> is set to <b>TRUE</b>, <b>SHRegGetUSValue</b> returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>. When set to <b>FALSE</b>, <b>SHRegGetUSValue</b> first tries to return the value from the key under <b>HKEY_CURRENT_USER</b>. However, if the key is not found under <b>HKEY_CURRENT_USER</b>, the value is returned from the key under <b>HKEY_LOCAL_MACHINE</b>. If neither key is present, or if an error occurred and <i>dwDefaultDataSize</i> is nonzero, then the default data is copied to <i>pvData</i> and ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no way of distinguishing which value copies to <i>pvData</i>. To prevent the use of default data, set <i>pvDefaultData</i> to <b>NULL</b> and <i>dwDefaultDataSize</i> to zero.</para>
      <para>This function opens the key each time it is used. If your code involves getting a series of values from the same key, it is more efficient to open the key once with <see cref="SHRegOpenUSKey" /> and then use <see cref="SHRegQueryUSValue" /> to retrieve the data.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegGetUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegGetUSValueW">
    <summary>
      <para>Retrieves a value from a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey relative to <b>HKEY_LOCAL_MACHINE</b> and <b>HKEY_CURRENT_USER</b>. For example: "Software\MyCompany\MyProduct".</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the type of data stored in the retrieved value. When using default values, the input <i>pdwType</i> is the type of the default value. For possible values, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>. If type information is not required, this parameter can be <b>NULL</b>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that receives the value's data.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a variable that specifies the size, in bytes, of the buffer pointed to by <i>pvData</i>. When <b>SHRegGetUSValue</b> returns, <i>pcbData</i> contains the size of the data copied to <i>pvData</i>.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>A variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegGetUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="pvDefaultData">
      <para>Type: <b>void*</b></para>
      <para>A pointer to a buffer that receives the value's default data.</para>
    </param>
    <param name="dwDefaultDataSize">
      <para>Type: <b>DWORD</b></para>
      <para>The length, in bytes, of the buffer pointed to by <i>pvDefaultData</i>.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>When <i>fIgnoreHKCU</i> is set to <b>TRUE</b>, <b>SHRegGetUSValue</b> returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>. When set to <b>FALSE</b>, <b>SHRegGetUSValue</b> first tries to return the value from the key under <b>HKEY_CURRENT_USER</b>. However, if the key is not found under <b>HKEY_CURRENT_USER</b>, the value is returned from the key under <b>HKEY_LOCAL_MACHINE</b>. If neither key is present, or if an error occurred and <i>dwDefaultDataSize</i> is nonzero, then the default data is copied to <i>pvData</i> and ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no way of distinguishing which value copies to <i>pvData</i>. To prevent the use of default data, set <i>pvDefaultData</i> to <b>NULL</b> and <i>dwDefaultDataSize</i> to zero.</para>
      <para>This function opens the key each time it is used. If your code involves getting a series of values from the same key, it is more efficient to open the key once with <see cref="SHRegOpenUSKey" /> and then use <see cref="SHRegQueryUSValue" /> to retrieve the data.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegGetUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegOpenUSKey">
    <summary>
      <para>Opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey.</para>
    </param>
    <param name="samDesired">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a></b></para>
      <para>The desired security access. For more information on security access, see <a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a>.</para>
    </param>
    <param name="hRelativeUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set <i>hRelativeUSKey</i> to <b>NULL</b>.</para>
    </param>
    <param name="phNewUSKey">
      <para>Type: <b>PHUSKEY</b></para>
      <para>A pointer to the handle of the opened key.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>The variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegOpenUSKey</b> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegOpenUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegOpenUSKeyA">
    <summary>
      <para>Opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey.</para>
    </param>
    <param name="samDesired">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a></b></para>
      <para>The desired security access. For more information on security access, see <a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a>.</para>
    </param>
    <param name="hRelativeUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set <i>hRelativeUSKey</i> to <b>NULL</b>.</para>
    </param>
    <param name="phNewUSKey">
      <para>Type: <b>PHUSKEY</b></para>
      <para>A pointer to the handle of the opened key.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>The variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegOpenUSKey</b> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegOpenUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegOpenUSKeyW">
    <summary>
      <para>Opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey.</para>
    </param>
    <param name="samDesired">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a></b></para>
      <para>The desired security access. For more information on security access, see <a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a>.</para>
    </param>
    <param name="hRelativeUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set <i>hRelativeUSKey</i> to <b>NULL</b>.</para>
    </param>
    <param name="phNewUSKey">
      <para>Type: <b>PHUSKEY</b></para>
      <para>A pointer to the handle of the opened key.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>The variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegOpenUSKey</b> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegOpenUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegOpenUSKey">
    <summary>
      <para>Opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pwzPath">
      <para>TBD</para>
    </param>
    <param name="samDesired">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a></b></para>
      <para>The desired security access. For more information on security access, see <a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a>.</para>
    </param>
    <param name="hRelativeUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set <i>hRelativeUSKey</i> to <b>NULL</b>.</para>
    </param>
    <param name="phNewUSKey">
      <para>Type: <b>PHUSKEY</b></para>
      <para>A pointer to the handle of the opened key.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>The variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegOpenUSKey</b> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.</para>
      <h4>- pszPath [in]</h4>
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegOpenUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegOpenUSKeyA">
    <summary>
      <para>Opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pwzPath">
      <para>TBD</para>
    </param>
    <param name="samDesired">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a></b></para>
      <para>The desired security access. For more information on security access, see <a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a>.</para>
    </param>
    <param name="hRelativeUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set <i>hRelativeUSKey</i> to <b>NULL</b>.</para>
    </param>
    <param name="phNewUSKey">
      <para>Type: <b>PHUSKEY</b></para>
      <para>A pointer to the handle of the opened key.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>The variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegOpenUSKey</b> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.</para>
      <h4>- pszPath [in]</h4>
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegOpenUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegOpenUSKeyW">
    <summary>
      <para>Opens a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pwzPath">
      <para>TBD</para>
    </param>
    <param name="samDesired">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a></b></para>
      <para>The desired security access. For more information on security access, see <a href="https://docs.microsoft.com//windows/desktop/shell/messages">REGSAM</a>.</para>
    </param>
    <param name="hRelativeUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>The key to be used as a base for relative paths. If <i>pszPath</i> is a relative path, the key it specifies will be relative to <i>hRelativeUSKey</i>. If <i>pszPath</i> is an absolute path, set <i>hRelativeUSKey</i> to <b>NULL</b>.</para>
    </param>
    <param name="phNewUSKey">
      <para>Type: <b>PHUSKEY</b></para>
      <para>A pointer to the handle of the opened key.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>The variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegOpenUSKey</b> ignores <b>HKEY_CURRENT_USER</b> and returns a value from <b>HKEY_LOCAL_MACHINE</b>.</para>
      <h4>- pszPath [in]</h4>
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegOpenUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegQueryInfoUSKey">
    <summary>
      <para>Retrieves information about a specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pcSubKeys">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to  a <b>DWORD</b> that receives the number of subkeys under the specified key.</para>
    </param>
    <param name="pcchMaxSubKeyLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the number of characters in the largest subkey name.</para>
    </param>
    <param name="pcValues">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to  a <b>DWORD</b> that receives the number of values under the specified key.</para>
    </param>
    <param name="pcchMaxValueNameLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the number of characters in the largest value name.</para>
    </param>
    <param name="enumRegFlags">
      <para>Type: <b><see cref="SHREGENUM_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGENUM_FLAGS" /> that specifies the base key in which the query should take place.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegQueryInfoUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegQueryInfoUSKeyA">
    <summary>
      <para>Retrieves information about a specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pcSubKeys">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to  a <b>DWORD</b> that receives the number of subkeys under the specified key.</para>
    </param>
    <param name="pcchMaxSubKeyLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the number of characters in the largest subkey name.</para>
    </param>
    <param name="pcValues">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to  a <b>DWORD</b> that receives the number of values under the specified key.</para>
    </param>
    <param name="pcchMaxValueNameLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the number of characters in the largest value name.</para>
    </param>
    <param name="enumRegFlags">
      <para>Type: <b><see cref="SHREGENUM_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGENUM_FLAGS" /> that specifies the base key in which the query should take place.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegQueryInfoUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegQueryInfoUSKeyW">
    <summary>
      <para>Retrieves information about a specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pcSubKeys">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to  a <b>DWORD</b> that receives the number of subkeys under the specified key.</para>
    </param>
    <param name="pcchMaxSubKeyLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the number of characters in the largest subkey name.</para>
    </param>
    <param name="pcValues">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to  a <b>DWORD</b> that receives the number of values under the specified key.</para>
    </param>
    <param name="pcchMaxValueNameLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the number of characters in the largest value name.</para>
    </param>
    <param name="enumRegFlags">
      <para>Type: <b><see cref="SHREGENUM_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGENUM_FLAGS" /> that specifies the base key in which the query should take place.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegQueryInfoUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegQueryInfoUSKey">
    <summary>
      <para>Retrieves information about a specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pcSubKeys">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to  a <b>DWORD</b> that receives the number of subkeys under the specified key.</para>
    </param>
    <param name="pcchMaxSubKeyLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the number of characters in the largest subkey name.</para>
    </param>
    <param name="pcValues">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to  a <b>DWORD</b> that receives the number of values under the specified key.</para>
    </param>
    <param name="pcchMaxValueNameLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the number of characters in the largest value name.</para>
    </param>
    <param name="enumRegFlags">
      <para>Type: <b><see cref="SHREGENUM_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGENUM_FLAGS" /> that specifies the base key in which the query should take place.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegQueryInfoUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegQueryInfoUSKeyA">
    <summary>
      <para>Retrieves information about a specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pcSubKeys">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to  a <b>DWORD</b> that receives the number of subkeys under the specified key.</para>
    </param>
    <param name="pcchMaxSubKeyLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the number of characters in the largest subkey name.</para>
    </param>
    <param name="pcValues">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to  a <b>DWORD</b> that receives the number of values under the specified key.</para>
    </param>
    <param name="pcchMaxValueNameLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the number of characters in the largest value name.</para>
    </param>
    <param name="enumRegFlags">
      <para>Type: <b><see cref="SHREGENUM_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGENUM_FLAGS" /> that specifies the base key in which the query should take place.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegQueryInfoUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegQueryInfoUSKeyW">
    <summary>
      <para>Retrieves information about a specified registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pcSubKeys">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to  a <b>DWORD</b> that receives the number of subkeys under the specified key.</para>
    </param>
    <param name="pcchMaxSubKeyLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the number of characters in the largest subkey name.</para>
    </param>
    <param name="pcValues">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to  a <b>DWORD</b> that receives the number of values under the specified key.</para>
    </param>
    <param name="pcchMaxValueNameLen">
      <para>Type: <b>LPDWORD</b></para>
      <para>A pointer to a <b>DWORD</b> that receives the number of characters in the largest value name.</para>
    </param>
    <param name="enumRegFlags">
      <para>Type: <b><see cref="SHREGENUM_FLAGS" /></b></para>
      <para>One of the <see cref="SHREGENUM_FLAGS" /> that specifies the base key in which the query should take place.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a textual description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegQueryInfoUSKey as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegQueryUSValue">
    <summary>
      <para>Retrieves the type and data for a specified name associated with an open registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey, or one of the following predefined values. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the <b>null</b>-terminated string that contains the name of the value to be queried.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD*</b></para>
      <para>A pointer to the variable that sets or receives the key's value type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID*</b></para>
      <para>A pointer to the buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD*</b></para>
      <para>A pointer to  the variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>pvData</i>.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>The variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegQueryUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="pvDefaultData">
      <para>Type: <b>LPVOID*</b></para>
      <para>A pointer to the default data.</para>
    </param>
    <param name="dwDefaultDataSize">
      <para>Type: <b>DWORD</b></para>
      <para>The length, in bytes, of the default data.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>When <i>fIgnoreHKCU</i> is set to <b>TRUE</b>, <b>SHRegQueryUSValue</b> returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>. When set to <b>FALSE</b>, <b>SHRegQueryUSValue</b> first tries to return the value from the key under <b>HKEY_CURRENT_USER</b>. However, if the key is not found under <b>HKEY_CURRENT_USER</b>, the value returns from the key under <b>HKEY_LOCAL_MACHINE</b>. If neither key is present, or if an error occurs and <i>dwDefaultDataSize</i> is nonzero, then the default data is copied to <i>pvData</i> and ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no way of distinguishing which value copies to <i>pvData</i>. To prevent the use of default data, set <i>pvDefaultData</i> to <b>NULL</b> and <i>dwDefaultDataSize</i> to zero.</para>
      <para>If you only need to read a single value, <see cref="SHRegGetUSValue" /> will both open the key and return the value. To use <b>SHRegQueryUSValue</b>, you must first open the key with <see cref="SHRegOpenUSKey" />. However, once the key is opened, you can use <b>SHRegQueryUSValue</b> as many times as necessary. If you need to retrieve more than one value from the same key, using multiple calls to <b>SHRegQueryUSValue</b> is usually more efficient than <b>SHRegGetUSValue</b>, as the key is only opened once.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegQueryUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegQueryUSValueA">
    <summary>
      <para>Retrieves the type and data for a specified name associated with an open registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey, or one of the following predefined values. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the <b>null</b>-terminated string that contains the name of the value to be queried.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD*</b></para>
      <para>A pointer to the variable that sets or receives the key's value type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID*</b></para>
      <para>A pointer to the buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD*</b></para>
      <para>A pointer to  the variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>pvData</i>.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>The variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegQueryUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="pvDefaultData">
      <para>Type: <b>LPVOID*</b></para>
      <para>A pointer to the default data.</para>
    </param>
    <param name="dwDefaultDataSize">
      <para>Type: <b>DWORD</b></para>
      <para>The length, in bytes, of the default data.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>When <i>fIgnoreHKCU</i> is set to <b>TRUE</b>, <b>SHRegQueryUSValue</b> returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>. When set to <b>FALSE</b>, <b>SHRegQueryUSValue</b> first tries to return the value from the key under <b>HKEY_CURRENT_USER</b>. However, if the key is not found under <b>HKEY_CURRENT_USER</b>, the value returns from the key under <b>HKEY_LOCAL_MACHINE</b>. If neither key is present, or if an error occurs and <i>dwDefaultDataSize</i> is nonzero, then the default data is copied to <i>pvData</i> and ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no way of distinguishing which value copies to <i>pvData</i>. To prevent the use of default data, set <i>pvDefaultData</i> to <b>NULL</b> and <i>dwDefaultDataSize</i> to zero.</para>
      <para>If you only need to read a single value, <see cref="SHRegGetUSValue" /> will both open the key and return the value. To use <b>SHRegQueryUSValue</b>, you must first open the key with <see cref="SHRegOpenUSKey" />. However, once the key is opened, you can use <b>SHRegQueryUSValue</b> as many times as necessary. If you need to retrieve more than one value from the same key, using multiple calls to <b>SHRegQueryUSValue</b> is usually more efficient than <b>SHRegGetUSValue</b>, as the key is only opened once.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegQueryUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegQueryUSValueW">
    <summary>
      <para>Retrieves the type and data for a specified name associated with an open registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey, or one of the following predefined values. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the <b>null</b>-terminated string that contains the name of the value to be queried.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD*</b></para>
      <para>A pointer to the variable that sets or receives the key's value type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID*</b></para>
      <para>A pointer to the buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD*</b></para>
      <para>A pointer to  the variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>pvData</i>.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>The variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegQueryUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="pvDefaultData">
      <para>Type: <b>LPVOID*</b></para>
      <para>A pointer to the default data.</para>
    </param>
    <param name="dwDefaultDataSize">
      <para>Type: <b>DWORD</b></para>
      <para>The length, in bytes, of the default data.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>When <i>fIgnoreHKCU</i> is set to <b>TRUE</b>, <b>SHRegQueryUSValue</b> returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>. When set to <b>FALSE</b>, <b>SHRegQueryUSValue</b> first tries to return the value from the key under <b>HKEY_CURRENT_USER</b>. However, if the key is not found under <b>HKEY_CURRENT_USER</b>, the value returns from the key under <b>HKEY_LOCAL_MACHINE</b>. If neither key is present, or if an error occurs and <i>dwDefaultDataSize</i> is nonzero, then the default data is copied to <i>pvData</i> and ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no way of distinguishing which value copies to <i>pvData</i>. To prevent the use of default data, set <i>pvDefaultData</i> to <b>NULL</b> and <i>dwDefaultDataSize</i> to zero.</para>
      <para>If you only need to read a single value, <see cref="SHRegGetUSValue" /> will both open the key and return the value. To use <b>SHRegQueryUSValue</b>, you must first open the key with <see cref="SHRegOpenUSKey" />. However, once the key is opened, you can use <b>SHRegQueryUSValue</b> as many times as necessary. If you need to retrieve more than one value from the same key, using multiple calls to <b>SHRegQueryUSValue</b> is usually more efficient than <b>SHRegGetUSValue</b>, as the key is only opened once.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegQueryUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegQueryUSValue">
    <summary>
      <para>Retrieves the type and data for a specified name associated with an open registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey, or one of the following predefined values. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the <b>null</b>-terminated string that contains the name of the value to be queried.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD*</b></para>
      <para>A pointer to the variable that sets or receives the key's value type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID*</b></para>
      <para>A pointer to the buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD*</b></para>
      <para>A pointer to  the variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>pvData</i>.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>The variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegQueryUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="pvDefaultData">
      <para>Type: <b>LPVOID*</b></para>
      <para>A pointer to the default data.</para>
    </param>
    <param name="dwDefaultDataSize">
      <para>Type: <b>DWORD</b></para>
      <para>The length, in bytes, of the default data.</para>
      <h5>- hUSKey.HKEY_CLASSES_ROOT</h5>
      <h5>- hUSKey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hUSKey.HKEY_CURRENT_USER</h5>
      <h5>- hUSKey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hUSKey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hUSKey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>When <i>fIgnoreHKCU</i> is set to <b>TRUE</b>, <b>SHRegQueryUSValue</b> returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>. When set to <b>FALSE</b>, <b>SHRegQueryUSValue</b> first tries to return the value from the key under <b>HKEY_CURRENT_USER</b>. However, if the key is not found under <b>HKEY_CURRENT_USER</b>, the value returns from the key under <b>HKEY_LOCAL_MACHINE</b>. If neither key is present, or if an error occurs and <i>dwDefaultDataSize</i> is nonzero, then the default data is copied to <i>pvData</i> and ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no way of distinguishing which value copies to <i>pvData</i>. To prevent the use of default data, set <i>pvDefaultData</i> to <b>NULL</b> and <i>dwDefaultDataSize</i> to zero.</para>
      <para>If you only need to read a single value, <see cref="SHRegGetUSValue" /> will both open the key and return the value. To use <b>SHRegQueryUSValue</b>, you must first open the key with <see cref="SHRegOpenUSKey" />. However, once the key is opened, you can use <b>SHRegQueryUSValue</b> as many times as necessary. If you need to retrieve more than one value from the same key, using multiple calls to <b>SHRegQueryUSValue</b> is usually more efficient than <b>SHRegGetUSValue</b>, as the key is only opened once.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegQueryUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegQueryUSValueA">
    <summary>
      <para>Retrieves the type and data for a specified name associated with an open registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey, or one of the following predefined values. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the <b>null</b>-terminated string that contains the name of the value to be queried.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD*</b></para>
      <para>A pointer to the variable that sets or receives the key's value type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID*</b></para>
      <para>A pointer to the buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD*</b></para>
      <para>A pointer to  the variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>pvData</i>.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>The variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegQueryUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="pvDefaultData">
      <para>Type: <b>LPVOID*</b></para>
      <para>A pointer to the default data.</para>
    </param>
    <param name="dwDefaultDataSize">
      <para>Type: <b>DWORD</b></para>
      <para>The length, in bytes, of the default data.</para>
      <h5>- hUSKey.HKEY_CLASSES_ROOT</h5>
      <h5>- hUSKey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hUSKey.HKEY_CURRENT_USER</h5>
      <h5>- hUSKey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hUSKey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hUSKey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>When <i>fIgnoreHKCU</i> is set to <b>TRUE</b>, <b>SHRegQueryUSValue</b> returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>. When set to <b>FALSE</b>, <b>SHRegQueryUSValue</b> first tries to return the value from the key under <b>HKEY_CURRENT_USER</b>. However, if the key is not found under <b>HKEY_CURRENT_USER</b>, the value returns from the key under <b>HKEY_LOCAL_MACHINE</b>. If neither key is present, or if an error occurs and <i>dwDefaultDataSize</i> is nonzero, then the default data is copied to <i>pvData</i> and ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no way of distinguishing which value copies to <i>pvData</i>. To prevent the use of default data, set <i>pvDefaultData</i> to <b>NULL</b> and <i>dwDefaultDataSize</i> to zero.</para>
      <para>If you only need to read a single value, <see cref="SHRegGetUSValue" /> will both open the key and return the value. To use <b>SHRegQueryUSValue</b>, you must first open the key with <see cref="SHRegOpenUSKey" />. However, once the key is opened, you can use <b>SHRegQueryUSValue</b> as many times as necessary. If you need to retrieve more than one value from the same key, using multiple calls to <b>SHRegQueryUSValue</b> is usually more efficient than <b>SHRegGetUSValue</b>, as the key is only opened once.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegQueryUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegQueryUSValueW">
    <summary>
      <para>Retrieves the type and data for a specified name associated with an open registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey, or one of the following predefined values. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the <b>null</b>-terminated string that contains the name of the value to be queried.</para>
    </param>
    <param name="pdwType">
      <para>Type: <b>LPDWORD*</b></para>
      <para>A pointer to the variable that sets or receives the key's value type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>. This parameter can be <b>NULL</b>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID*</b></para>
      <para>A pointer to the buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.</para>
    </param>
    <param name="pcbData">
      <para>Type: <b>LPDWORD*</b></para>
      <para>A pointer to  the variable that specifies the size, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>pvData</i>.</para>
    </param>
    <param name="fIgnoreHKCU">
      <para>Type: <b>BOOL</b></para>
      <para>The variable that specifies which key to look under. When set to <b>TRUE</b>, <b>SHRegQueryUSValue</b> ignores <b>HKEY_CURRENT_USER</b> and returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="pvDefaultData">
      <para>Type: <b>LPVOID*</b></para>
      <para>A pointer to the default data.</para>
    </param>
    <param name="dwDefaultDataSize">
      <para>Type: <b>DWORD</b></para>
      <para>The length, in bytes, of the default data.</para>
      <h5>- hUSKey.HKEY_CLASSES_ROOT</h5>
      <h5>- hUSKey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hUSKey.HKEY_CURRENT_USER</h5>
      <h5>- hUSKey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hUSKey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hUSKey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>When <i>fIgnoreHKCU</i> is set to <b>TRUE</b>, <b>SHRegQueryUSValue</b> returns the value from the key under <b>HKEY_LOCAL_MACHINE</b>. When set to <b>FALSE</b>, <b>SHRegQueryUSValue</b> first tries to return the value from the key under <b>HKEY_CURRENT_USER</b>. However, if the key is not found under <b>HKEY_CURRENT_USER</b>, the value returns from the key under <b>HKEY_LOCAL_MACHINE</b>. If neither key is present, or if an error occurs and <i>dwDefaultDataSize</i> is nonzero, then the default data is copied to <i>pvData</i> and ERROR_SUCCESS returns. ERROR_SUCCESS returns for both default and non-default data, and there is no way of distinguishing which value copies to <i>pvData</i>. To prevent the use of default data, set <i>pvDefaultData</i> to <b>NULL</b> and <i>dwDefaultDataSize</i> to zero.</para>
      <para>If you only need to read a single value, <see cref="SHRegGetUSValue" /> will both open the key and return the value. To use <b>SHRegQueryUSValue</b>, you must first open the key with <see cref="SHRegOpenUSKey" />. However, once the key is opened, you can use <b>SHRegQueryUSValue</b> as many times as necessary. If you need to retrieve more than one value from the same key, using multiple calls to <b>SHRegQueryUSValue</b> is usually more efficient than <b>SHRegGetUSValue</b>, as the key is only opened once.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegQueryUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegSetPath">
    <summary>
      <para>Takes a file path, replaces folder names with environment strings, and places the resulting string in the registry.</para>
    </summary>
    <param name="hKey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to a key that is currently open, or a registry root key.</para>
    </param>
    <param name="pcszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the name of an existing subkey. If the subkey does not exist, <b>SHRegSetPath</b> will fail.</para>
    </param>
    <param name="pcszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the value to hold the path string.</para>
    </param>
    <param name="pcszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with a fully qualified file path.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a Windows error code otherwise.</para>
    </returns>
    <remarks>
      <para>For Windows 2000, <b>SHRegSetPath</b> uses <see cref="PathUnExpandEnvStrings" /> to convert folder names to their corresponding environment string. If any environment variables were substituted, the registry value will be set with the <b>REG_EXPAND_SZ</b> data type. Otherwise, it will be set with the <b>REG_SZ</b> data type.</para>
      <para>The following folder paths will be replaced by their equivalent environment string.</para>
      <list type="table">
        <listheader>
          <description>Folder</description>
          <description>Environment string</description>
        </listheader>
        <item>
          <description>The current user's profile folder</description>
          <description>%USERPROFILE%
</description>
        </item>
        <item>
          <description>The All Users profile folder</description>
          <description>%ALLUSERSPROFILE%
</description>
        </item>
        <item>
          <description>The Program Files folder</description>
          <description>%ProgramFiles%
</description>
        </item>
        <item>
          <description>The system root folder</description>
          <description>%SystemRoot%
</description>
        </item>
        <item>
          <description>The system drive letter</description>
          <description>%SystemDrive%
</description>
        </item>
      </list>
      <para>
        <b>Note</b>  %USERPROFILE% is relative to the user making the call. This function does not work if the user is being impersonated from a service.</para>
      <para>The environment variables listed in the above table might not all be set on any particular system. If an environment variable is not set, it will not be unexpanded. In particular, none of these variables are set for the default environment of Windows 95 or Windows 98. The %ProgramFiles% variable is new for Windows 2000, and will typically not be set on Microsoft Windows NT 4.0 systems.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegSetPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegSetPathA">
    <summary>
      <para>Takes a file path, replaces folder names with environment strings, and places the resulting string in the registry.</para>
    </summary>
    <param name="hKey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to a key that is currently open, or a registry root key.</para>
    </param>
    <param name="pcszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the name of an existing subkey. If the subkey does not exist, <b>SHRegSetPath</b> will fail.</para>
    </param>
    <param name="pcszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the value to hold the path string.</para>
    </param>
    <param name="pcszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with a fully qualified file path.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a Windows error code otherwise.</para>
    </returns>
    <remarks>
      <para>For Windows 2000, <b>SHRegSetPath</b> uses <see cref="PathUnExpandEnvStrings" /> to convert folder names to their corresponding environment string. If any environment variables were substituted, the registry value will be set with the <b>REG_EXPAND_SZ</b> data type. Otherwise, it will be set with the <b>REG_SZ</b> data type.</para>
      <para>The following folder paths will be replaced by their equivalent environment string.</para>
      <list type="table">
        <listheader>
          <description>Folder</description>
          <description>Environment string</description>
        </listheader>
        <item>
          <description>The current user's profile folder</description>
          <description>%USERPROFILE%
</description>
        </item>
        <item>
          <description>The All Users profile folder</description>
          <description>%ALLUSERSPROFILE%
</description>
        </item>
        <item>
          <description>The Program Files folder</description>
          <description>%ProgramFiles%
</description>
        </item>
        <item>
          <description>The system root folder</description>
          <description>%SystemRoot%
</description>
        </item>
        <item>
          <description>The system drive letter</description>
          <description>%SystemDrive%
</description>
        </item>
      </list>
      <para>
        <b>Note</b>  %USERPROFILE% is relative to the user making the call. This function does not work if the user is being impersonated from a service.</para>
      <para>The environment variables listed in the above table might not all be set on any particular system. If an environment variable is not set, it will not be unexpanded. In particular, none of these variables are set for the default environment of Windows 95 or Windows 98. The %ProgramFiles% variable is new for Windows 2000, and will typically not be set on Microsoft Windows NT 4.0 systems.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegSetPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegSetPathW">
    <summary>
      <para>Takes a file path, replaces folder names with environment strings, and places the resulting string in the registry.</para>
    </summary>
    <param name="hKey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to a key that is currently open, or a registry root key.</para>
    </param>
    <param name="pcszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the name of an existing subkey. If the subkey does not exist, <b>SHRegSetPath</b> will fail.</para>
    </param>
    <param name="pcszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the value to hold the path string.</para>
    </param>
    <param name="pcszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with a fully qualified file path.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a Windows error code otherwise.</para>
    </returns>
    <remarks>
      <para>For Windows 2000, <b>SHRegSetPath</b> uses <see cref="PathUnExpandEnvStrings" /> to convert folder names to their corresponding environment string. If any environment variables were substituted, the registry value will be set with the <b>REG_EXPAND_SZ</b> data type. Otherwise, it will be set with the <b>REG_SZ</b> data type.</para>
      <para>The following folder paths will be replaced by their equivalent environment string.</para>
      <list type="table">
        <listheader>
          <description>Folder</description>
          <description>Environment string</description>
        </listheader>
        <item>
          <description>The current user's profile folder</description>
          <description>%USERPROFILE%
</description>
        </item>
        <item>
          <description>The All Users profile folder</description>
          <description>%ALLUSERSPROFILE%
</description>
        </item>
        <item>
          <description>The Program Files folder</description>
          <description>%ProgramFiles%
</description>
        </item>
        <item>
          <description>The system root folder</description>
          <description>%SystemRoot%
</description>
        </item>
        <item>
          <description>The system drive letter</description>
          <description>%SystemDrive%
</description>
        </item>
      </list>
      <para>
        <b>Note</b>  %USERPROFILE% is relative to the user making the call. This function does not work if the user is being impersonated from a service.</para>
      <para>The environment variables listed in the above table might not all be set on any particular system. If an environment variable is not set, it will not be unexpanded. In particular, none of these variables are set for the default environment of Windows 95 or Windows 98. The %ProgramFiles% variable is new for Windows 2000, and will typically not be set on Microsoft Windows NT 4.0 systems.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegSetPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegSetPath">
    <summary>
      <para>Takes a file path, replaces folder names with environment strings, and places the resulting string in the registry.</para>
    </summary>
    <param name="hKey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to a key that is currently open, or a registry root key.</para>
    </param>
    <param name="pcszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the name of an existing subkey. If the subkey does not exist, <b>SHRegSetPath</b> will fail.</para>
    </param>
    <param name="pcszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the value to hold the path string.</para>
    </param>
    <param name="pcszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with a fully qualified file path.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a Windows error code otherwise.</para>
    </returns>
    <remarks>
      <para>For Windows 2000, <b>SHRegSetPath</b> uses <see cref="PathUnExpandEnvStrings" /> to convert folder names to their corresponding environment string. If any environment variables were substituted, the registry value will be set with the <b>REG_EXPAND_SZ</b> data type. Otherwise, it will be set with the <b>REG_SZ</b> data type.</para>
      <para>The following folder paths will be replaced by their equivalent environment string.</para>
      <list type="table">
        <listheader>
          <description>Folder</description>
          <description>Environment string</description>
        </listheader>
        <item>
          <description>The current user's profile folder</description>
          <description>%USERPROFILE%
</description>
        </item>
        <item>
          <description>The All Users profile folder</description>
          <description>%ALLUSERSPROFILE%
</description>
        </item>
        <item>
          <description>The Program Files folder</description>
          <description>%ProgramFiles%
</description>
        </item>
        <item>
          <description>The system root folder</description>
          <description>%SystemRoot%
</description>
        </item>
        <item>
          <description>The system drive letter</description>
          <description>%SystemDrive%
</description>
        </item>
      </list>
      <para>
        <b>Note</b>  %USERPROFILE% is relative to the user making the call. This function does not work if the user is being impersonated from a service.</para>
      <para>The environment variables listed in the above table might not all be set on any particular system. If an environment variable is not set, it will not be unexpanded. In particular, none of these variables are set for the default environment of Windows 95 or Windows 98. The %ProgramFiles% variable is new for Windows 2000, and will typically not be set on Microsoft Windows NT 4.0 systems.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegSetPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegSetPathA">
    <summary>
      <para>Takes a file path, replaces folder names with environment strings, and places the resulting string in the registry.</para>
    </summary>
    <param name="hKey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to a key that is currently open, or a registry root key.</para>
    </param>
    <param name="pcszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the name of an existing subkey. If the subkey does not exist, <b>SHRegSetPath</b> will fail.</para>
    </param>
    <param name="pcszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the value to hold the path string.</para>
    </param>
    <param name="pcszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with a fully qualified file path.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a Windows error code otherwise.</para>
    </returns>
    <remarks>
      <para>For Windows 2000, <b>SHRegSetPath</b> uses <see cref="PathUnExpandEnvStrings" /> to convert folder names to their corresponding environment string. If any environment variables were substituted, the registry value will be set with the <b>REG_EXPAND_SZ</b> data type. Otherwise, it will be set with the <b>REG_SZ</b> data type.</para>
      <para>The following folder paths will be replaced by their equivalent environment string.</para>
      <list type="table">
        <listheader>
          <description>Folder</description>
          <description>Environment string</description>
        </listheader>
        <item>
          <description>The current user's profile folder</description>
          <description>%USERPROFILE%
</description>
        </item>
        <item>
          <description>The All Users profile folder</description>
          <description>%ALLUSERSPROFILE%
</description>
        </item>
        <item>
          <description>The Program Files folder</description>
          <description>%ProgramFiles%
</description>
        </item>
        <item>
          <description>The system root folder</description>
          <description>%SystemRoot%
</description>
        </item>
        <item>
          <description>The system drive letter</description>
          <description>%SystemDrive%
</description>
        </item>
      </list>
      <para>
        <b>Note</b>  %USERPROFILE% is relative to the user making the call. This function does not work if the user is being impersonated from a service.</para>
      <para>The environment variables listed in the above table might not all be set on any particular system. If an environment variable is not set, it will not be unexpanded. In particular, none of these variables are set for the default environment of Windows 95 or Windows 98. The %ProgramFiles% variable is new for Windows 2000, and will typically not be set on Microsoft Windows NT 4.0 systems.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegSetPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegSetPathW">
    <summary>
      <para>Takes a file path, replaces folder names with environment strings, and places the resulting string in the registry.</para>
    </summary>
    <param name="hKey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to a key that is currently open, or a registry root key.</para>
    </param>
    <param name="pcszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the name of an existing subkey. If the subkey does not exist, <b>SHRegSetPath</b> will fail.</para>
    </param>
    <param name="pcszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the value to hold the path string.</para>
    </param>
    <param name="pcszPath">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with a fully qualified file path.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a Windows error code otherwise.</para>
    </returns>
    <remarks>
      <para>For Windows 2000, <b>SHRegSetPath</b> uses <see cref="PathUnExpandEnvStrings" /> to convert folder names to their corresponding environment string. If any environment variables were substituted, the registry value will be set with the <b>REG_EXPAND_SZ</b> data type. Otherwise, it will be set with the <b>REG_SZ</b> data type.</para>
      <para>The following folder paths will be replaced by their equivalent environment string.</para>
      <list type="table">
        <listheader>
          <description>Folder</description>
          <description>Environment string</description>
        </listheader>
        <item>
          <description>The current user's profile folder</description>
          <description>%USERPROFILE%
</description>
        </item>
        <item>
          <description>The All Users profile folder</description>
          <description>%ALLUSERSPROFILE%
</description>
        </item>
        <item>
          <description>The Program Files folder</description>
          <description>%ProgramFiles%
</description>
        </item>
        <item>
          <description>The system root folder</description>
          <description>%SystemRoot%
</description>
        </item>
        <item>
          <description>The system drive letter</description>
          <description>%SystemDrive%
</description>
        </item>
      </list>
      <para>
        <b>Note</b>  %USERPROFILE% is relative to the user making the call. This function does not work if the user is being impersonated from a service.</para>
      <para>The environment variables listed in the above table might not all be set on any particular system. If an environment variable is not set, it will not be unexpanded. In particular, none of these variables are set for the default environment of Windows 95 or Windows 98. The %ProgramFiles% variable is new for Windows 2000, and will typically not be set on Microsoft Windows NT 4.0 systems.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegSetPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegSetUSValue">
    <summary>
      <para>Sets a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that specifies the name of the value.</para>
    </param>
    <param name="dwType">
      <para>Type: <b>DWORD</b></para>
      <para>Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID*</b></para>
      <para>Apointer to a null-terminated string that contains the value to be set for the specified key.</para>
    </param>
    <param name="cbData">
      <para>Type: <b>DWORD</b></para>
      <para>Length, in bytes, of the string pointed to by the <i>pvData</i> parameter, not including the terminating null character.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags indicating where the data should be written.</para>
      <h4>SHREGSET_HKCU</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b> if empty.</para>
      <h4>SHREGSET_FORCE_HKCU</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b>.</para>
      <h4>SHREGSET_HKLM</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b> if empty.</para>
      <h4>SHREGSET_FORCE_HKLM</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b>.</para>
      <h4>SHREGSET_DEFAULT</h4>
      <para>Equivalent to (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>This function opens the key each time it is used. If your code involves setting a series of values in the same key, it is more efficient to open the key once with <see cref="SHRegOpenUSKey" /> and then use <see cref="SHRegWriteUSValue" /> to write the data.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegSetUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegSetUSValueA">
    <summary>
      <para>Sets a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that specifies the name of the value.</para>
    </param>
    <param name="dwType">
      <para>Type: <b>DWORD</b></para>
      <para>Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID*</b></para>
      <para>Apointer to a null-terminated string that contains the value to be set for the specified key.</para>
    </param>
    <param name="cbData">
      <para>Type: <b>DWORD</b></para>
      <para>Length, in bytes, of the string pointed to by the <i>pvData</i> parameter, not including the terminating null character.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags indicating where the data should be written.</para>
      <h4>SHREGSET_HKCU</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b> if empty.</para>
      <h4>SHREGSET_FORCE_HKCU</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b>.</para>
      <h4>SHREGSET_HKLM</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b> if empty.</para>
      <h4>SHREGSET_FORCE_HKLM</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b>.</para>
      <h4>SHREGSET_DEFAULT</h4>
      <para>Equivalent to (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>This function opens the key each time it is used. If your code involves setting a series of values in the same key, it is more efficient to open the key once with <see cref="SHRegOpenUSKey" /> and then use <see cref="SHRegWriteUSValue" /> to write the data.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegSetUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegSetUSValueW">
    <summary>
      <para>Sets a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that specifies the name of the value.</para>
    </param>
    <param name="dwType">
      <para>Type: <b>DWORD</b></para>
      <para>Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID*</b></para>
      <para>Apointer to a null-terminated string that contains the value to be set for the specified key.</para>
    </param>
    <param name="cbData">
      <para>Type: <b>DWORD</b></para>
      <para>Length, in bytes, of the string pointed to by the <i>pvData</i> parameter, not including the terminating null character.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags indicating where the data should be written.</para>
      <h4>SHREGSET_HKCU</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b> if empty.</para>
      <h4>SHREGSET_FORCE_HKCU</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b>.</para>
      <h4>SHREGSET_HKLM</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b> if empty.</para>
      <h4>SHREGSET_FORCE_HKLM</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b>.</para>
      <h4>SHREGSET_DEFAULT</h4>
      <para>Equivalent to (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>This function opens the key each time it is used. If your code involves setting a series of values in the same key, it is more efficient to open the key once with <see cref="SHRegOpenUSKey" /> and then use <see cref="SHRegWriteUSValue" /> to write the data.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegSetUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegSetUSValue">
    <summary>
      <para>Sets a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pwzSubKey">
      <para>TBD</para>
    </param>
    <param name="pwzValue">
      <para>TBD</para>
    </param>
    <param name="dwType">
      <para>Type: <b>DWORD</b></para>
      <para>Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID*</b></para>
      <para>Apointer to a null-terminated string that contains the value to be set for the specified key.</para>
    </param>
    <param name="cbData">
      <para>Type: <b>DWORD</b></para>
      <para>Length, in bytes, of the string pointed to by the <i>pvData</i> parameter, not including the terminating null character.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags indicating where the data should be written.</para>
      <h4>SHREGSET_HKCU</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b> if empty.</para>
      <h4>SHREGSET_FORCE_HKCU</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b>.</para>
      <h4>SHREGSET_HKLM</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b> if empty.</para>
      <h4>SHREGSET_FORCE_HKLM</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b>.</para>
      <h4>SHREGSET_DEFAULT</h4>
      <para>Equivalent to (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <param name="dwFlags.SHREGSET_DEFAULT">
      <para>Equivalent to (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <param name="dwFlags.SHREGSET_FORCE_HKCU">
      <para>Write to <b>HKEY_CURRENT_USER</b>.</para>
    </param>
    <param name="dwFlags.SHREGSET_FORCE_HKLM">
      <para>Write to <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="dwFlags.SHREGSET_HKCU">
      <para>Write to <b>HKEY_CURRENT_USER</b> if empty.</para>
    </param>
    <param name="dwFlags.SHREGSET_HKLM">
      <para>Write to <b>HKEY_LOCAL_MACHINE</b> if empty.</para>
      <h4>- pszSubKey [in]</h4>
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey.</para>
      <h4>- pszValue [in]</h4>
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that specifies the name of the value.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>This function opens the key each time it is used. If your code involves setting a series of values in the same key, it is more efficient to open the key once with <see cref="SHRegOpenUSKey" /> and then use <see cref="SHRegWriteUSValue" /> to write the data.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegSetUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegSetUSValueA">
    <summary>
      <para>Sets a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pwzSubKey">
      <para>TBD</para>
    </param>
    <param name="pwzValue">
      <para>TBD</para>
    </param>
    <param name="dwType">
      <para>Type: <b>DWORD</b></para>
      <para>Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID*</b></para>
      <para>Apointer to a null-terminated string that contains the value to be set for the specified key.</para>
    </param>
    <param name="cbData">
      <para>Type: <b>DWORD</b></para>
      <para>Length, in bytes, of the string pointed to by the <i>pvData</i> parameter, not including the terminating null character.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags indicating where the data should be written.</para>
      <h4>SHREGSET_HKCU</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b> if empty.</para>
      <h4>SHREGSET_FORCE_HKCU</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b>.</para>
      <h4>SHREGSET_HKLM</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b> if empty.</para>
      <h4>SHREGSET_FORCE_HKLM</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b>.</para>
      <h4>SHREGSET_DEFAULT</h4>
      <para>Equivalent to (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <param name="dwFlags.SHREGSET_DEFAULT">
      <para>Equivalent to (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <param name="dwFlags.SHREGSET_FORCE_HKCU">
      <para>Write to <b>HKEY_CURRENT_USER</b>.</para>
    </param>
    <param name="dwFlags.SHREGSET_FORCE_HKLM">
      <para>Write to <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="dwFlags.SHREGSET_HKCU">
      <para>Write to <b>HKEY_CURRENT_USER</b> if empty.</para>
    </param>
    <param name="dwFlags.SHREGSET_HKLM">
      <para>Write to <b>HKEY_LOCAL_MACHINE</b> if empty.</para>
      <h4>- pszSubKey [in]</h4>
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey.</para>
      <h4>- pszValue [in]</h4>
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that specifies the name of the value.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>This function opens the key each time it is used. If your code involves setting a series of values in the same key, it is more efficient to open the key once with <see cref="SHRegOpenUSKey" /> and then use <see cref="SHRegWriteUSValue" /> to write the data.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegSetUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegSetUSValueW">
    <summary>
      <para>Sets a registry subkey value in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="pwzSubKey">
      <para>TBD</para>
    </param>
    <param name="pwzValue">
      <para>TBD</para>
    </param>
    <param name="dwType">
      <para>Type: <b>DWORD</b></para>
      <para>Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPVOID*</b></para>
      <para>Apointer to a null-terminated string that contains the value to be set for the specified key.</para>
    </param>
    <param name="cbData">
      <para>Type: <b>DWORD</b></para>
      <para>Length, in bytes, of the string pointed to by the <i>pvData</i> parameter, not including the terminating null character.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags indicating where the data should be written.</para>
      <h4>SHREGSET_HKCU</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b> if empty.</para>
      <h4>SHREGSET_FORCE_HKCU</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b>.</para>
      <h4>SHREGSET_HKLM</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b> if empty.</para>
      <h4>SHREGSET_FORCE_HKLM</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b>.</para>
      <h4>SHREGSET_DEFAULT</h4>
      <para>Equivalent to (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <param name="dwFlags.SHREGSET_DEFAULT">
      <para>Equivalent to (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <param name="dwFlags.SHREGSET_FORCE_HKCU">
      <para>Write to <b>HKEY_CURRENT_USER</b>.</para>
    </param>
    <param name="dwFlags.SHREGSET_FORCE_HKLM">
      <para>Write to <b>HKEY_LOCAL_MACHINE</b>.</para>
    </param>
    <param name="dwFlags.SHREGSET_HKCU">
      <para>Write to <b>HKEY_CURRENT_USER</b> if empty.</para>
    </param>
    <param name="dwFlags.SHREGSET_HKLM">
      <para>Write to <b>HKEY_LOCAL_MACHINE</b> if empty.</para>
      <h4>- pszSubKey [in]</h4>
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string with the name of the subkey.</para>
      <h4>- pszValue [in]</h4>
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that specifies the name of the value.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>This function opens the key each time it is used. If your code involves setting a series of values in the same key, it is more efficient to open the key once with <see cref="SHRegOpenUSKey" /> and then use <see cref="SHRegWriteUSValue" /> to write the data.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegSetUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHRegSetValue">
    <summary>
      <para>Not supported.</para>
      <para>Sets a registry value.</para>
      <para>Use <see cref="RegSetValue" /> in its place.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <para></para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <para></para>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <para></para>
      <h4>HKEY_CURRENT_USER</h4>
      <para></para>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <para></para>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <para></para>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCWSTR</b></para>
      <para>A pointer to a null-terminated string that specifies the relative path from <i>hkey</i> to the subkey from which to retrieve the value. This parameter can be <b>NULL</b> or an empty string, in which case the data is retrieved from the <i>hkey</i> location.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCWSTR</b></para>
      <para>A pointer to a null-terminated string that contains the name of the value. This parameter can be <b>NULL</b> or an empty string, in which case the data is retrieved from the Default value.</para>
    </param>
    <param name="srrfFlags">
      <para>Type: <b><a href="https://docs.microsoft.com//windows/desktop/shell/srrf">SRRF</a></b></para>
      <para>One or more of the <a href="https://docs.microsoft.com//windows/desktop/shell/srrf">SRRF</a> flags that restricts the data to be set. At least one type restriction (SRRF_RT) value must be specified.</para>
    </param>
    <param name="dwType">
      <para>Type: <b>DWORD</b></para>
      <para>The <b>DWORD</b> that indicates the type of data stored in the value to be set. When using default values, the input <i>dwType</i> is the type of the default value. For possible values, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>. If the SRRF_NOEXPAND flag is not set, REG_EXPAND_SZ types are automatically expanded and returned as REG_SZ. If type information is not required, this parameter can be <b>NULL</b>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPCVOID</b></para>
      <para>A pointer to a buffer that contains the value's data. This parameter can be <b>NULL</b> if the data is not needed.</para>
    </param>
    <param name="cbData">
      <para>Type: <b>DWORD</b></para>
      <para>The size of the source data buffer <i>pvData</i>, in bytes. This value can be <b>NULL</b> only if <i>pvData</i> is <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>LONG</b></para>
      <para>Returns ERROR_SUCCESS if successful, or a nonzero error code defined in Winerror.h otherwise. You can use the <see cref="FormatMessage" /> function with the <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to retrieve a generic description of the error.</para>
    </returns>
    <seealso cref="RegSetKeyValue" />
  </member>
  <member name="Windows.SHRegWriteUSValue">
    <summary>
      <para>Writes a value to a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that specifies the name of the value. This value is an entry in the subkey specified by <i>hUSKey</i>. If a value with this name is not already present in the subkey, it will be added.</para>
      <para>If this parameter is <b>NULL</b> or an empty string, the function sets the type and data for the subkey's Default value.</para>
    </param>
    <param name="dwType">
      <para>Type: <b>DWORD</b></para>
      <para>The type of the data to be stored in the value specified by <i>pszValue</i>. One of the following registry value types defined in Winnt.h and Wdm.h.</para>
      <h4>REG_NONE (0x00000000)</h4>
      <h4>REG_SZ (0x00000001)</h4>
      <h4>REG_EXPAND_SZ (0x00000002)</h4>
      <h4>REG_BINARY (0x00000003)</h4>
      <h4>REG_DWORD (0x00000004)</h4>
      <h4>REG_DWORD_LITTLE_ENDIAN (0x00000004)</h4>
      <h4>REG_DWORD_BIG_ENDIAN (0x00000005)</h4>
      <h4>REG_LINK (0x00000006)</h4>
      <h4>REG_MULTI_SZ (0x00000007)</h4>
      <h4>REG_RESOURCE_LIST (0x00000008)</h4>
      <h4>REG_FULL_RESOURCE_DESCRIPTOR (0x00000009)</h4>
      <h4>REG_RESOURCE_REQUIREMENTS_LIST (0x0000000A)</h4>
      <h4>REG_QWORD (0x0000000B)</h4>
      <h4>REG_QWORD_LITTLE_ENDIAN (0x0000000B)</h4>
    </param>
    <param name="pvData">
      <para>Type: <b>const void*</b></para>
      <para>A pointer to the data to be set for the value specified by <i>pszValue</i>. For string-based types, such as REG_SZ, the string must be null-terminated. With the REG_MULTI_SZ data type, the string must be terminated with two null characters. A backslash in a path must be preceded by another backslash as an escape character. For example, specify "C:\mydir\myfile" to store the string "C:\mydir\myfile".</para>
    </param>
    <param name="cbData">
      <para>Type: <b>DWORD</b></para>
      <para>The size, in bytes, of the data pointed to by the <i>pvData</i> parameter. If the data is of type REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, <i>cbData</i> must include the size of the terminating null character or characters.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that indicate the subtree to which the data should be written. One or more of the following values:</para>
      <h4>SHREGSET_HKCU (0x00000001)</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b> only if a value of the name specified in <i>pszValue</i> does not currently exist under the specified subkey.</para>
      <h4>SHREGSET_FORCE_HKCU (0x00000002)</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b>. If a value of the name specified in <i>pszValue</i> already exists, it will be overwritten.</para>
      <h4>SHREGSET_HKLM (0x00000004)</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b> only if a value of the name specified in <i>pszValue</i> does not currently exist under the specified subkey..</para>
      <h4>SHREGSET_FORCE_HKLM (0x00000008)</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b>. If a value of the name specified in <i>pszValue</i> already exists, it will be overwritten.</para>
      <h4>SHREGSET_DEFAULT (0x00000006)</h4>
      <para>Equivalent to (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>To use <b>SHRegWriteUSValue</b>, you must first open the key with <see cref="SHRegOpenUSKey" />. Once the key is opened, you can use <b>SHRegWriteUSValue</b> as many times as necessary.</para>
      <para>If you only need to write a single value, you should use <see cref="SHRegSetUSValue" />, which both opens the key and writes the value.</para>
      <para>If you need to write more than one value on the same key, multiple calls to <b>SHRegWriteUSValue</b> are usually more efficient than <see cref="SHRegSetUSValue" />, because the key is only opened once.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegWriteUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-value-types">Registry Value Types</seealso>
  </member>
  <member name="Windows.SHRegWriteUSValueA">
    <summary>
      <para>Writes a value to a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that specifies the name of the value. This value is an entry in the subkey specified by <i>hUSKey</i>. If a value with this name is not already present in the subkey, it will be added.</para>
      <para>If this parameter is <b>NULL</b> or an empty string, the function sets the type and data for the subkey's Default value.</para>
    </param>
    <param name="dwType">
      <para>Type: <b>DWORD</b></para>
      <para>The type of the data to be stored in the value specified by <i>pszValue</i>. One of the following registry value types defined in Winnt.h and Wdm.h.</para>
      <h4>REG_NONE (0x00000000)</h4>
      <h4>REG_SZ (0x00000001)</h4>
      <h4>REG_EXPAND_SZ (0x00000002)</h4>
      <h4>REG_BINARY (0x00000003)</h4>
      <h4>REG_DWORD (0x00000004)</h4>
      <h4>REG_DWORD_LITTLE_ENDIAN (0x00000004)</h4>
      <h4>REG_DWORD_BIG_ENDIAN (0x00000005)</h4>
      <h4>REG_LINK (0x00000006)</h4>
      <h4>REG_MULTI_SZ (0x00000007)</h4>
      <h4>REG_RESOURCE_LIST (0x00000008)</h4>
      <h4>REG_FULL_RESOURCE_DESCRIPTOR (0x00000009)</h4>
      <h4>REG_RESOURCE_REQUIREMENTS_LIST (0x0000000A)</h4>
      <h4>REG_QWORD (0x0000000B)</h4>
      <h4>REG_QWORD_LITTLE_ENDIAN (0x0000000B)</h4>
    </param>
    <param name="pvData">
      <para>Type: <b>const void*</b></para>
      <para>A pointer to the data to be set for the value specified by <i>pszValue</i>. For string-based types, such as REG_SZ, the string must be null-terminated. With the REG_MULTI_SZ data type, the string must be terminated with two null characters. A backslash in a path must be preceded by another backslash as an escape character. For example, specify "C:\mydir\myfile" to store the string "C:\mydir\myfile".</para>
    </param>
    <param name="cbData">
      <para>Type: <b>DWORD</b></para>
      <para>The size, in bytes, of the data pointed to by the <i>pvData</i> parameter. If the data is of type REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, <i>cbData</i> must include the size of the terminating null character or characters.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that indicate the subtree to which the data should be written. One or more of the following values:</para>
      <h4>SHREGSET_HKCU (0x00000001)</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b> only if a value of the name specified in <i>pszValue</i> does not currently exist under the specified subkey.</para>
      <h4>SHREGSET_FORCE_HKCU (0x00000002)</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b>. If a value of the name specified in <i>pszValue</i> already exists, it will be overwritten.</para>
      <h4>SHREGSET_HKLM (0x00000004)</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b> only if a value of the name specified in <i>pszValue</i> does not currently exist under the specified subkey..</para>
      <h4>SHREGSET_FORCE_HKLM (0x00000008)</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b>. If a value of the name specified in <i>pszValue</i> already exists, it will be overwritten.</para>
      <h4>SHREGSET_DEFAULT (0x00000006)</h4>
      <para>Equivalent to (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>To use <b>SHRegWriteUSValue</b>, you must first open the key with <see cref="SHRegOpenUSKey" />. Once the key is opened, you can use <b>SHRegWriteUSValue</b> as many times as necessary.</para>
      <para>If you only need to write a single value, you should use <see cref="SHRegSetUSValue" />, which both opens the key and writes the value.</para>
      <para>If you need to write more than one value on the same key, multiple calls to <b>SHRegWriteUSValue</b> are usually more efficient than <see cref="SHRegSetUSValue" />, because the key is only opened once.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegWriteUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-value-types">Registry Value Types</seealso>
  </member>
  <member name="Windows.SHRegWriteUSValueW">
    <summary>
      <para>Writes a value to a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that specifies the name of the value. This value is an entry in the subkey specified by <i>hUSKey</i>. If a value with this name is not already present in the subkey, it will be added.</para>
      <para>If this parameter is <b>NULL</b> or an empty string, the function sets the type and data for the subkey's Default value.</para>
    </param>
    <param name="dwType">
      <para>Type: <b>DWORD</b></para>
      <para>The type of the data to be stored in the value specified by <i>pszValue</i>. One of the following registry value types defined in Winnt.h and Wdm.h.</para>
      <h4>REG_NONE (0x00000000)</h4>
      <h4>REG_SZ (0x00000001)</h4>
      <h4>REG_EXPAND_SZ (0x00000002)</h4>
      <h4>REG_BINARY (0x00000003)</h4>
      <h4>REG_DWORD (0x00000004)</h4>
      <h4>REG_DWORD_LITTLE_ENDIAN (0x00000004)</h4>
      <h4>REG_DWORD_BIG_ENDIAN (0x00000005)</h4>
      <h4>REG_LINK (0x00000006)</h4>
      <h4>REG_MULTI_SZ (0x00000007)</h4>
      <h4>REG_RESOURCE_LIST (0x00000008)</h4>
      <h4>REG_FULL_RESOURCE_DESCRIPTOR (0x00000009)</h4>
      <h4>REG_RESOURCE_REQUIREMENTS_LIST (0x0000000A)</h4>
      <h4>REG_QWORD (0x0000000B)</h4>
      <h4>REG_QWORD_LITTLE_ENDIAN (0x0000000B)</h4>
    </param>
    <param name="pvData">
      <para>Type: <b>const void*</b></para>
      <para>A pointer to the data to be set for the value specified by <i>pszValue</i>. For string-based types, such as REG_SZ, the string must be null-terminated. With the REG_MULTI_SZ data type, the string must be terminated with two null characters. A backslash in a path must be preceded by another backslash as an escape character. For example, specify "C:\mydir\myfile" to store the string "C:\mydir\myfile".</para>
    </param>
    <param name="cbData">
      <para>Type: <b>DWORD</b></para>
      <para>The size, in bytes, of the data pointed to by the <i>pvData</i> parameter. If the data is of type REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, <i>cbData</i> must include the size of the terminating null character or characters.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that indicate the subtree to which the data should be written. One or more of the following values:</para>
      <h4>SHREGSET_HKCU (0x00000001)</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b> only if a value of the name specified in <i>pszValue</i> does not currently exist under the specified subkey.</para>
      <h4>SHREGSET_FORCE_HKCU (0x00000002)</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b>. If a value of the name specified in <i>pszValue</i> already exists, it will be overwritten.</para>
      <h4>SHREGSET_HKLM (0x00000004)</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b> only if a value of the name specified in <i>pszValue</i> does not currently exist under the specified subkey..</para>
      <h4>SHREGSET_FORCE_HKLM (0x00000008)</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b>. If a value of the name specified in <i>pszValue</i> already exists, it will be overwritten.</para>
      <h4>SHREGSET_DEFAULT (0x00000006)</h4>
      <para>Equivalent to (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>To use <b>SHRegWriteUSValue</b>, you must first open the key with <see cref="SHRegOpenUSKey" />. Once the key is opened, you can use <b>SHRegWriteUSValue</b> as many times as necessary.</para>
      <para>If you only need to write a single value, you should use <see cref="SHRegSetUSValue" />, which both opens the key and writes the value.</para>
      <para>If you need to write more than one value on the same key, multiple calls to <b>SHRegWriteUSValue</b> are usually more efficient than <see cref="SHRegSetUSValue" />, because the key is only opened once.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegWriteUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-value-types">Registry Value Types</seealso>
  </member>
  <member name="Windows.SHRegWriteUSValue">
    <summary>
      <para>Writes a value to a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pwzValue">
      <para>TBD</para>
    </param>
    <param name="dwType">
      <para>Type: <b>DWORD</b></para>
      <para>The type of the data to be stored in the value specified by <i>pszValue</i>. One of the following registry value types defined in Winnt.h and Wdm.h.</para>
      <h4>REG_NONE (0x00000000)</h4>
      <h4>REG_SZ (0x00000001)</h4>
      <h4>REG_EXPAND_SZ (0x00000002)</h4>
      <h4>REG_BINARY (0x00000003)</h4>
      <h4>REG_DWORD (0x00000004)</h4>
      <h4>REG_DWORD_LITTLE_ENDIAN (0x00000004)</h4>
      <h4>REG_DWORD_BIG_ENDIAN (0x00000005)</h4>
      <h4>REG_LINK (0x00000006)</h4>
      <h4>REG_MULTI_SZ (0x00000007)</h4>
      <h4>REG_RESOURCE_LIST (0x00000008)</h4>
      <h4>REG_FULL_RESOURCE_DESCRIPTOR (0x00000009)</h4>
      <h4>REG_RESOURCE_REQUIREMENTS_LIST (0x0000000A)</h4>
      <h4>REG_QWORD (0x0000000B)</h4>
      <h4>REG_QWORD_LITTLE_ENDIAN (0x0000000B)</h4>
    </param>
    <param name="pvData">
      <para>Type: <b>const void*</b></para>
      <para>A pointer to the data to be set for the value specified by <i>pszValue</i>. For string-based types, such as REG_SZ, the string must be null-terminated. With the REG_MULTI_SZ data type, the string must be terminated with two null characters. A backslash in a path must be preceded by another backslash as an escape character. For example, specify "C:\mydir\myfile" to store the string "C:\mydir\myfile".</para>
    </param>
    <param name="cbData">
      <para>Type: <b>DWORD</b></para>
      <para>The size, in bytes, of the data pointed to by the <i>pvData</i> parameter. If the data is of type REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, <i>cbData</i> must include the size of the terminating null character or characters.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that indicate the subtree to which the data should be written. One or more of the following values:</para>
      <h4>SHREGSET_HKCU (0x00000001)</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b> only if a value of the name specified in <i>pszValue</i> does not currently exist under the specified subkey.</para>
      <h4>SHREGSET_FORCE_HKCU (0x00000002)</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b>. If a value of the name specified in <i>pszValue</i> already exists, it will be overwritten.</para>
      <h4>SHREGSET_HKLM (0x00000004)</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b> only if a value of the name specified in <i>pszValue</i> does not currently exist under the specified subkey..</para>
      <h4>SHREGSET_FORCE_HKLM (0x00000008)</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b>. If a value of the name specified in <i>pszValue</i> already exists, it will be overwritten.</para>
      <h4>SHREGSET_DEFAULT (0x00000006)</h4>
      <para>Equivalent to (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <param name="dwFlags.SHREGSET_DEFAULT (0x00000006)">
      <para>Equivalent to (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <param name="dwFlags.SHREGSET_FORCE_HKCU (0x00000002)">
      <para>Write to <b>HKEY_CURRENT_USER</b>. If a value of the name specified in <i>pszValue</i> already exists, it will be overwritten.</para>
    </param>
    <param name="dwFlags.SHREGSET_FORCE_HKLM (0x00000008)">
      <para>Write to <b>HKEY_LOCAL_MACHINE</b>. If a value of the name specified in <i>pszValue</i> already exists, it will be overwritten.</para>
    </param>
    <param name="dwFlags.SHREGSET_HKCU (0x00000001)">
      <para>Write to <b>HKEY_CURRENT_USER</b> only if a value of the name specified in <i>pszValue</i> does not currently exist under the specified subkey.</para>
    </param>
    <param name="dwFlags.SHREGSET_HKLM (0x00000004)">
      <para>Write to <b>HKEY_LOCAL_MACHINE</b> only if a value of the name specified in <i>pszValue</i> does not currently exist under the specified subkey..</para>
    </param>
    <param name="dwType.REG_BINARY (0x00000003)"></param>
    <param name="dwType.REG_DWORD (0x00000004)"></param>
    <param name="dwType.REG_DWORD_BIG_ENDIAN (0x00000005)"></param>
    <param name="dwType.REG_DWORD_LITTLE_ENDIAN (0x00000004)"></param>
    <param name="dwType.REG_EXPAND_SZ (0x00000002)"></param>
    <param name="dwType.REG_FULL_RESOURCE_DESCRIPTOR (0x00000009)"></param>
    <param name="dwType.REG_LINK (0x00000006)"></param>
    <param name="dwType.REG_MULTI_SZ (0x00000007)"></param>
    <param name="dwType.REG_NONE (0x00000000)"></param>
    <param name="dwType.REG_QWORD (0x0000000B)"></param>
    <param name="dwType.REG_QWORD_LITTLE_ENDIAN (0x0000000B)"></param>
    <param name="dwType.REG_RESOURCE_LIST (0x00000008)"></param>
    <param name="dwType.REG_RESOURCE_REQUIREMENTS_LIST (0x0000000A)"></param>
    <param name="dwType.REG_SZ (0x00000001)">
      <h4>- pszValue [in]</h4>
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that specifies the name of the value. This value is an entry in the subkey specified by <i>hUSKey</i>. If a value with this name is not already present in the subkey, it will be added.</para>
      <para>If this parameter is <b>NULL</b> or an empty string, the function sets the type and data for the subkey's Default value.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>To use <b>SHRegWriteUSValue</b>, you must first open the key with <see cref="SHRegOpenUSKey" />. Once the key is opened, you can use <b>SHRegWriteUSValue</b> as many times as necessary.</para>
      <para>If you only need to write a single value, you should use <see cref="SHRegSetUSValue" />, which both opens the key and writes the value.</para>
      <para>If you need to write more than one value on the same key, multiple calls to <b>SHRegWriteUSValue</b> are usually more efficient than <see cref="SHRegSetUSValue" />, because the key is only opened once.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegWriteUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-value-types">Registry Value Types</seealso>
  </member>
  <member name="Windows.SHRegWriteUSValueA">
    <summary>
      <para>Writes a value to a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pwzValue">
      <para>TBD</para>
    </param>
    <param name="dwType">
      <para>Type: <b>DWORD</b></para>
      <para>The type of the data to be stored in the value specified by <i>pszValue</i>. One of the following registry value types defined in Winnt.h and Wdm.h.</para>
      <h4>REG_NONE (0x00000000)</h4>
      <h4>REG_SZ (0x00000001)</h4>
      <h4>REG_EXPAND_SZ (0x00000002)</h4>
      <h4>REG_BINARY (0x00000003)</h4>
      <h4>REG_DWORD (0x00000004)</h4>
      <h4>REG_DWORD_LITTLE_ENDIAN (0x00000004)</h4>
      <h4>REG_DWORD_BIG_ENDIAN (0x00000005)</h4>
      <h4>REG_LINK (0x00000006)</h4>
      <h4>REG_MULTI_SZ (0x00000007)</h4>
      <h4>REG_RESOURCE_LIST (0x00000008)</h4>
      <h4>REG_FULL_RESOURCE_DESCRIPTOR (0x00000009)</h4>
      <h4>REG_RESOURCE_REQUIREMENTS_LIST (0x0000000A)</h4>
      <h4>REG_QWORD (0x0000000B)</h4>
      <h4>REG_QWORD_LITTLE_ENDIAN (0x0000000B)</h4>
    </param>
    <param name="pvData">
      <para>Type: <b>const void*</b></para>
      <para>A pointer to the data to be set for the value specified by <i>pszValue</i>. For string-based types, such as REG_SZ, the string must be null-terminated. With the REG_MULTI_SZ data type, the string must be terminated with two null characters. A backslash in a path must be preceded by another backslash as an escape character. For example, specify "C:\mydir\myfile" to store the string "C:\mydir\myfile".</para>
    </param>
    <param name="cbData">
      <para>Type: <b>DWORD</b></para>
      <para>The size, in bytes, of the data pointed to by the <i>pvData</i> parameter. If the data is of type REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, <i>cbData</i> must include the size of the terminating null character or characters.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that indicate the subtree to which the data should be written. One or more of the following values:</para>
      <h4>SHREGSET_HKCU (0x00000001)</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b> only if a value of the name specified in <i>pszValue</i> does not currently exist under the specified subkey.</para>
      <h4>SHREGSET_FORCE_HKCU (0x00000002)</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b>. If a value of the name specified in <i>pszValue</i> already exists, it will be overwritten.</para>
      <h4>SHREGSET_HKLM (0x00000004)</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b> only if a value of the name specified in <i>pszValue</i> does not currently exist under the specified subkey..</para>
      <h4>SHREGSET_FORCE_HKLM (0x00000008)</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b>. If a value of the name specified in <i>pszValue</i> already exists, it will be overwritten.</para>
      <h4>SHREGSET_DEFAULT (0x00000006)</h4>
      <para>Equivalent to (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <param name="dwFlags.SHREGSET_DEFAULT (0x00000006)">
      <para>Equivalent to (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <param name="dwFlags.SHREGSET_FORCE_HKCU (0x00000002)">
      <para>Write to <b>HKEY_CURRENT_USER</b>. If a value of the name specified in <i>pszValue</i> already exists, it will be overwritten.</para>
    </param>
    <param name="dwFlags.SHREGSET_FORCE_HKLM (0x00000008)">
      <para>Write to <b>HKEY_LOCAL_MACHINE</b>. If a value of the name specified in <i>pszValue</i> already exists, it will be overwritten.</para>
    </param>
    <param name="dwFlags.SHREGSET_HKCU (0x00000001)">
      <para>Write to <b>HKEY_CURRENT_USER</b> only if a value of the name specified in <i>pszValue</i> does not currently exist under the specified subkey.</para>
    </param>
    <param name="dwFlags.SHREGSET_HKLM (0x00000004)">
      <para>Write to <b>HKEY_LOCAL_MACHINE</b> only if a value of the name specified in <i>pszValue</i> does not currently exist under the specified subkey..</para>
    </param>
    <param name="dwType.REG_BINARY (0x00000003)"></param>
    <param name="dwType.REG_DWORD (0x00000004)"></param>
    <param name="dwType.REG_DWORD_BIG_ENDIAN (0x00000005)"></param>
    <param name="dwType.REG_DWORD_LITTLE_ENDIAN (0x00000004)"></param>
    <param name="dwType.REG_EXPAND_SZ (0x00000002)"></param>
    <param name="dwType.REG_FULL_RESOURCE_DESCRIPTOR (0x00000009)"></param>
    <param name="dwType.REG_LINK (0x00000006)"></param>
    <param name="dwType.REG_MULTI_SZ (0x00000007)"></param>
    <param name="dwType.REG_NONE (0x00000000)"></param>
    <param name="dwType.REG_QWORD (0x0000000B)"></param>
    <param name="dwType.REG_QWORD_LITTLE_ENDIAN (0x0000000B)"></param>
    <param name="dwType.REG_RESOURCE_LIST (0x00000008)"></param>
    <param name="dwType.REG_RESOURCE_REQUIREMENTS_LIST (0x0000000A)"></param>
    <param name="dwType.REG_SZ (0x00000001)">
      <h4>- pszValue [in]</h4>
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that specifies the name of the value. This value is an entry in the subkey specified by <i>hUSKey</i>. If a value with this name is not already present in the subkey, it will be added.</para>
      <para>If this parameter is <b>NULL</b> or an empty string, the function sets the type and data for the subkey's Default value.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>To use <b>SHRegWriteUSValue</b>, you must first open the key with <see cref="SHRegOpenUSKey" />. Once the key is opened, you can use <b>SHRegWriteUSValue</b> as many times as necessary.</para>
      <para>If you only need to write a single value, you should use <see cref="SHRegSetUSValue" />, which both opens the key and writes the value.</para>
      <para>If you need to write more than one value on the same key, multiple calls to <b>SHRegWriteUSValue</b> are usually more efficient than <see cref="SHRegSetUSValue" />, because the key is only opened once.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegWriteUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-value-types">Registry Value Types</seealso>
  </member>
  <member name="Windows.SHRegWriteUSValueW">
    <summary>
      <para>Writes a value to a registry subkey in a user-specific subtree (HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE).</para>
    </summary>
    <param name="hUSKey">
      <para>Type: <b>HUSKEY</b></para>
      <para>A handle to a currently open registry subkey. The subkey must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
      <para>This handle can be obtained through the <see cref="SHRegOpenUSKey" /> function.</para>
    </param>
    <param name="pwzValue">
      <para>TBD</para>
    </param>
    <param name="dwType">
      <para>Type: <b>DWORD</b></para>
      <para>The type of the data to be stored in the value specified by <i>pszValue</i>. One of the following registry value types defined in Winnt.h and Wdm.h.</para>
      <h4>REG_NONE (0x00000000)</h4>
      <h4>REG_SZ (0x00000001)</h4>
      <h4>REG_EXPAND_SZ (0x00000002)</h4>
      <h4>REG_BINARY (0x00000003)</h4>
      <h4>REG_DWORD (0x00000004)</h4>
      <h4>REG_DWORD_LITTLE_ENDIAN (0x00000004)</h4>
      <h4>REG_DWORD_BIG_ENDIAN (0x00000005)</h4>
      <h4>REG_LINK (0x00000006)</h4>
      <h4>REG_MULTI_SZ (0x00000007)</h4>
      <h4>REG_RESOURCE_LIST (0x00000008)</h4>
      <h4>REG_FULL_RESOURCE_DESCRIPTOR (0x00000009)</h4>
      <h4>REG_RESOURCE_REQUIREMENTS_LIST (0x0000000A)</h4>
      <h4>REG_QWORD (0x0000000B)</h4>
      <h4>REG_QWORD_LITTLE_ENDIAN (0x0000000B)</h4>
    </param>
    <param name="pvData">
      <para>Type: <b>const void*</b></para>
      <para>A pointer to the data to be set for the value specified by <i>pszValue</i>. For string-based types, such as REG_SZ, the string must be null-terminated. With the REG_MULTI_SZ data type, the string must be terminated with two null characters. A backslash in a path must be preceded by another backslash as an escape character. For example, specify "C:\mydir\myfile" to store the string "C:\mydir\myfile".</para>
    </param>
    <param name="cbData">
      <para>Type: <b>DWORD</b></para>
      <para>The size, in bytes, of the data pointed to by the <i>pvData</i> parameter. If the data is of type REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, <i>cbData</i> must include the size of the terminating null character or characters.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that indicate the subtree to which the data should be written. One or more of the following values:</para>
      <h4>SHREGSET_HKCU (0x00000001)</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b> only if a value of the name specified in <i>pszValue</i> does not currently exist under the specified subkey.</para>
      <h4>SHREGSET_FORCE_HKCU (0x00000002)</h4>
      <para>Write to <b>HKEY_CURRENT_USER</b>. If a value of the name specified in <i>pszValue</i> already exists, it will be overwritten.</para>
      <h4>SHREGSET_HKLM (0x00000004)</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b> only if a value of the name specified in <i>pszValue</i> does not currently exist under the specified subkey..</para>
      <h4>SHREGSET_FORCE_HKLM (0x00000008)</h4>
      <para>Write to <b>HKEY_LOCAL_MACHINE</b>. If a value of the name specified in <i>pszValue</i> already exists, it will be overwritten.</para>
      <h4>SHREGSET_DEFAULT (0x00000006)</h4>
      <para>Equivalent to (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <param name="dwFlags.SHREGSET_DEFAULT (0x00000006)">
      <para>Equivalent to (<b>SHREGSET_FORCE_HKCU</b> | <b>SHREGSET_HKLM</b>).</para>
    </param>
    <param name="dwFlags.SHREGSET_FORCE_HKCU (0x00000002)">
      <para>Write to <b>HKEY_CURRENT_USER</b>. If a value of the name specified in <i>pszValue</i> already exists, it will be overwritten.</para>
    </param>
    <param name="dwFlags.SHREGSET_FORCE_HKLM (0x00000008)">
      <para>Write to <b>HKEY_LOCAL_MACHINE</b>. If a value of the name specified in <i>pszValue</i> already exists, it will be overwritten.</para>
    </param>
    <param name="dwFlags.SHREGSET_HKCU (0x00000001)">
      <para>Write to <b>HKEY_CURRENT_USER</b> only if a value of the name specified in <i>pszValue</i> does not currently exist under the specified subkey.</para>
    </param>
    <param name="dwFlags.SHREGSET_HKLM (0x00000004)">
      <para>Write to <b>HKEY_LOCAL_MACHINE</b> only if a value of the name specified in <i>pszValue</i> does not currently exist under the specified subkey..</para>
    </param>
    <param name="dwType.REG_BINARY (0x00000003)"></param>
    <param name="dwType.REG_DWORD (0x00000004)"></param>
    <param name="dwType.REG_DWORD_BIG_ENDIAN (0x00000005)"></param>
    <param name="dwType.REG_DWORD_LITTLE_ENDIAN (0x00000004)"></param>
    <param name="dwType.REG_EXPAND_SZ (0x00000002)"></param>
    <param name="dwType.REG_FULL_RESOURCE_DESCRIPTOR (0x00000009)"></param>
    <param name="dwType.REG_LINK (0x00000006)"></param>
    <param name="dwType.REG_MULTI_SZ (0x00000007)"></param>
    <param name="dwType.REG_NONE (0x00000000)"></param>
    <param name="dwType.REG_QWORD (0x0000000B)"></param>
    <param name="dwType.REG_QWORD_LITTLE_ENDIAN (0x0000000B)"></param>
    <param name="dwType.REG_RESOURCE_LIST (0x00000008)"></param>
    <param name="dwType.REG_RESOURCE_REQUIREMENTS_LIST (0x0000000A)"></param>
    <param name="dwType.REG_SZ (0x00000001)">
      <h4>- pszValue [in]</h4>
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string that specifies the name of the value. This value is an entry in the subkey specified by <i>hUSKey</i>. If a value with this name is not already present in the subkey, it will be added.</para>
      <para>If this parameter is <b>NULL</b> or an empty string, the function sets the type and data for the subkey's Default value.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <para>To use <b>SHRegWriteUSValue</b>, you must first open the key with <see cref="SHRegOpenUSKey" />. Once the key is opened, you can use <b>SHRegWriteUSValue</b> as many times as necessary.</para>
      <para>If you only need to write a single value, you should use <see cref="SHRegSetUSValue" />, which both opens the key and writes the value.</para>
      <para>If you need to write more than one value on the same key, multiple calls to <b>SHRegWriteUSValue</b> are usually more efficient than <see cref="SHRegSetUSValue" />, because the key is only opened once.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHRegWriteUSValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/SysInfo/registry-value-types">Registry Value Types</seealso>
  </member>
  <member name="Windows.SHReleaseThreadRef">
    <summary>
      <para>Releases a thread reference before the thread procedure returns.</para>
    </summary>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <seealso cref="SHCreateThread" />
    <seealso cref="SHCreateThreadRef" />
    <seealso cref="SHGetThreadRef" />
    <seealso cref="SHSetThreadRef" />
  </member>
  <member name="Windows.SHSetThreadRef">
    <summary>
      <para>Stores a per-thread reference to a Component Object Model (COM) object. This allows the caller to control the thread's lifetime so that it can ensure that Windows won't shut down the thread before the caller is ready.</para>
    </summary>
    <param name="punk">
      <para>Type: <b><see cref="IUnknown" />*</b></para>
      <para>A pointer to the <see cref="IUnknown" /> of the object for which you want to store a reference. This value can be <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>Use <see cref="SHGetThreadRef" /> to retrieve the <see cref="IUnknown" /> pointer.</para>
    </remarks>
    <seealso cref="SHCreateThread" />
    <seealso cref="SHCreateThreadRef" />
    <seealso cref="SHGetThreadRef" />
    <seealso cref="SHReleaseThreadRef" />
  </member>
  <member name="Windows.SHSetValue">
    <summary>
      <para>Sets the value of a registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string that specifies the name of the subkey with which a value is associated. This can be <b>NULL</b> or a pointer to an empty string. In this case, the value is added to the key identified by the <i>hkey</i> parameter.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string that specifies the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="dwType">
      <para>Type: <b>DWORD</b></para>
      <para>Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPCVOID</b></para>
      <para>Pointer to a buffer that contains the data to set for the specified value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="cbData">
      <para>Type: <b>DWORD</b></para>
      <para>Length, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. If the data is a null-terminated string, this length includes the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHSetValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHSetValueA">
    <summary>
      <para>Sets the value of a registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string that specifies the name of the subkey with which a value is associated. This can be <b>NULL</b> or a pointer to an empty string. In this case, the value is added to the key identified by the <i>hkey</i> parameter.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string that specifies the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="dwType">
      <para>Type: <b>DWORD</b></para>
      <para>Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPCVOID</b></para>
      <para>Pointer to a buffer that contains the data to set for the specified value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="cbData">
      <para>Type: <b>DWORD</b></para>
      <para>Length, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. If the data is a null-terminated string, this length includes the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHSetValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHSetValueW">
    <summary>
      <para>Sets the value of a registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string that specifies the name of the subkey with which a value is associated. This can be <b>NULL</b> or a pointer to an empty string. In this case, the value is added to the key identified by the <i>hkey</i> parameter.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string that specifies the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="dwType">
      <para>Type: <b>DWORD</b></para>
      <para>Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPCVOID</b></para>
      <para>Pointer to a buffer that contains the data to set for the specified value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="cbData">
      <para>Type: <b>DWORD</b></para>
      <para>Length, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. If the data is a null-terminated string, this length includes the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHSetValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHSetValue">
    <summary>
      <para>Sets the value of a registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string that specifies the name of the subkey with which a value is associated. This can be <b>NULL</b> or a pointer to an empty string. In this case, the value is added to the key identified by the <i>hkey</i> parameter.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string that specifies the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="dwType">
      <para>Type: <b>DWORD</b></para>
      <para>Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPCVOID</b></para>
      <para>Pointer to a buffer that contains the data to set for the specified value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="cbData">
      <para>Type: <b>DWORD</b></para>
      <para>Length, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. If the data is a null-terminated string, this length includes the terminating null character.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHSetValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHSetValueA">
    <summary>
      <para>Sets the value of a registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string that specifies the name of the subkey with which a value is associated. This can be <b>NULL</b> or a pointer to an empty string. In this case, the value is added to the key identified by the <i>hkey</i> parameter.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string that specifies the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="dwType">
      <para>Type: <b>DWORD</b></para>
      <para>Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPCVOID</b></para>
      <para>Pointer to a buffer that contains the data to set for the specified value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="cbData">
      <para>Type: <b>DWORD</b></para>
      <para>Length, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. If the data is a null-terminated string, this length includes the terminating null character.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHSetValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHSetValueW">
    <summary>
      <para>Sets the value of a registry key.</para>
    </summary>
    <param name="hkey">
      <para>Type: <b>HKEY</b></para>
      <para>A handle to the currently open key, or any of the following predefined values.</para>
      <h4>HKEY_CLASSES_ROOT</h4>
      <h4>HKEY_CURRENT_CONFIG</h4>
      <h4>HKEY_CURRENT_USER</h4>
      <h4>HKEY_LOCAL_MACHINE</h4>
      <h4>HKEY_PERFORMANCE_DATA</h4>
      <h4>HKEY_USERS</h4>
    </param>
    <param name="pszSubKey">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string that specifies the name of the subkey with which a value is associated. This can be <b>NULL</b> or a pointer to an empty string. In this case, the value is added to the key identified by the <i>hkey</i> parameter.</para>
    </param>
    <param name="pszValue">
      <para>Type: <b>LPCTSTR</b></para>
      <para>The address of a null-terminated string that specifies the value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="dwType">
      <para>Type: <b>DWORD</b></para>
      <para>Type of data to be stored. This parameter must be the <b>REG_SZ</b> type. For more information, see <a href="https://docs.microsoft.com//windows/desktop/shell/hkey-type">Registry Data Types</a>.</para>
    </param>
    <param name="pvData">
      <para>Type: <b>LPCVOID</b></para>
      <para>Pointer to a buffer that contains the data to set for the specified value. This value can be <b>NULL</b>.</para>
    </param>
    <param name="cbData">
      <para>Type: <b>DWORD</b></para>
      <para>Length, in bytes, of the buffer pointed to by the <i>pvData</i> parameter. If the data is a null-terminated string, this length includes the terminating null character.</para>
      <h5>- hkey.HKEY_CLASSES_ROOT</h5>
      <h5>- hkey.HKEY_CURRENT_CONFIG</h5>
      <h5>- hkey.HKEY_CURRENT_USER</h5>
      <h5>- hkey.HKEY_LOCAL_MACHINE</h5>
      <h5>- hkey.HKEY_PERFORMANCE_DATA</h5>
      <h5>- hkey.HKEY_USERS</h5>
    </param>
    <returns>
      <para>Type: <b>LSTATUS</b></para>
      <para>Returns ERROR_SUCCESS if successful; otherwise, a nonzero error code defined in Winerror.h. You can use the <see cref="FormatMessage" /> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to retrieve a generic description of the error.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHSetValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.SHSkipJunction">
    <summary>
      <para>Checks a bind context to see if it is safe to bind to a particular component object.</para>
    </summary>
    <param name="pbc">
      <para>Type: <b><see cref="IBindCtx" />*</b></para>
      <para>A pointer to an <see cref="IBindCtx" /> interface that specifies the bind context you want to check. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pclsid">
      <para>Type: <b>const CLSID*</b></para>
      <para>A pointer to a variable that specifies the <b>CLSID</b> of the object being tested to see if it must be skipped. Typically, this is the CLSID of the object that <see cref="IShellFolder.BindToObject" /> is about to create.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the object specified by <i>pclsid</i> must be skipped, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <para>This function can be used to avoid infinite cycles in namespace binding. For example, a folder shortcut that refers to a folder above it in the namespace tree can produce an infinitely recursive loop.</para>
    </remarks>
  </member>
  <member name="Windows.SHStrDup">
    <summary>
      <para>Makes a copy of a string in newly allocated memory.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the null-terminated string to be copied.</para>
    </param>
    <param name="ppwsz">
      <para>Type: <b>LPTSTR*</b></para>
      <para>A pointer to an allocated Unicode string that contains the result. <b>SHStrDup</b> allocates memory for this string with <see cref="CoTaskMemAlloc" />. You should free the string with <see cref="CoTaskMemFree" /> when it is no longer needed.</para>
      <para>In the case of failure, this value is NULL.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or a COM error value otherwise.</para>
    </returns>
    <remarks>
      <para>This function will take either Unicode or ANSI strings as input, but the copied string is always Unicode.</para>
      <para>This function uses <see cref="CoTaskMemAlloc" /> to allocate memory for the copied string. You must free this memory with <see cref="CoTaskMemFree" /> when it is no longer needed.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHStrDup as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrDup" />
  </member>
  <member name="Windows.SHStrDupA">
    <summary>
      <para>Makes a copy of a string in newly allocated memory.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the null-terminated string to be copied.</para>
    </param>
    <param name="ppwsz">
      <para>Type: <b>LPTSTR*</b></para>
      <para>A pointer to an allocated Unicode string that contains the result. <b>SHStrDup</b> allocates memory for this string with <see cref="CoTaskMemAlloc" />. You should free the string with <see cref="CoTaskMemFree" /> when it is no longer needed.</para>
      <para>In the case of failure, this value is NULL.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or a COM error value otherwise.</para>
    </returns>
    <remarks>
      <para>This function will take either Unicode or ANSI strings as input, but the copied string is always Unicode.</para>
      <para>This function uses <see cref="CoTaskMemAlloc" /> to allocate memory for the copied string. You must free this memory with <see cref="CoTaskMemFree" /> when it is no longer needed.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHStrDup as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrDup" />
  </member>
  <member name="Windows.SHStrDupW">
    <summary>
      <para>Makes a copy of a string in newly allocated memory.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the null-terminated string to be copied.</para>
    </param>
    <param name="ppwsz">
      <para>Type: <b>LPTSTR*</b></para>
      <para>A pointer to an allocated Unicode string that contains the result. <b>SHStrDup</b> allocates memory for this string with <see cref="CoTaskMemAlloc" />. You should free the string with <see cref="CoTaskMemFree" /> when it is no longer needed.</para>
      <para>In the case of failure, this value is NULL.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or a COM error value otherwise.</para>
    </returns>
    <remarks>
      <para>This function will take either Unicode or ANSI strings as input, but the copied string is always Unicode.</para>
      <para>This function uses <see cref="CoTaskMemAlloc" /> to allocate memory for the copied string. You must free this memory with <see cref="CoTaskMemFree" /> when it is no longer needed.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHStrDup as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrDup" />
  </member>
  <member name="Windows.SHStrDup">
    <summary>
      <para>Makes a copy of a string in newly allocated memory.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the null-terminated string to be copied.</para>
    </param>
    <param name="ppwsz">
      <para>Type: <b>LPTSTR*</b></para>
      <para>A pointer to an allocated Unicode string that contains the result. <b>SHStrDup</b> allocates memory for this string with <see cref="CoTaskMemAlloc" />. You should free the string with <see cref="CoTaskMemFree" /> when it is no longer needed.</para>
      <para>In the case of failure, this value is NULL.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or a COM error value otherwise.</para>
    </returns>
    <remarks>
      <para>This function will take either Unicode or ANSI strings as input, but the copied string is always Unicode.</para>
      <para>This function uses <see cref="CoTaskMemAlloc" /> to allocate memory for the copied string. You must free this memory with <see cref="CoTaskMemFree" /> when it is no longer needed.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHStrDup as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrDup" />
  </member>
  <member name="Windows.SHStrDupA">
    <summary>
      <para>Makes a copy of a string in newly allocated memory.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the null-terminated string to be copied.</para>
    </param>
    <param name="ppwsz">
      <para>Type: <b>LPTSTR*</b></para>
      <para>A pointer to an allocated Unicode string that contains the result. <b>SHStrDup</b> allocates memory for this string with <see cref="CoTaskMemAlloc" />. You should free the string with <see cref="CoTaskMemFree" /> when it is no longer needed.</para>
      <para>In the case of failure, this value is NULL.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or a COM error value otherwise.</para>
    </returns>
    <remarks>
      <para>This function will take either Unicode or ANSI strings as input, but the copied string is always Unicode.</para>
      <para>This function uses <see cref="CoTaskMemAlloc" /> to allocate memory for the copied string. You must free this memory with <see cref="CoTaskMemFree" /> when it is no longer needed.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHStrDup as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrDup" />
  </member>
  <member name="Windows.SHStrDupW">
    <summary>
      <para>Makes a copy of a string in newly allocated memory.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the null-terminated string to be copied.</para>
    </param>
    <param name="ppwsz">
      <para>Type: <b>LPTSTR*</b></para>
      <para>A pointer to an allocated Unicode string that contains the result. <b>SHStrDup</b> allocates memory for this string with <see cref="CoTaskMemAlloc" />. You should free the string with <see cref="CoTaskMemFree" /> when it is no longer needed.</para>
      <para>In the case of failure, this value is NULL.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful, or a COM error value otherwise.</para>
    </returns>
    <remarks>
      <para>This function will take either Unicode or ANSI strings as input, but the copied string is always Unicode.</para>
      <para>This function uses <see cref="CoTaskMemAlloc" /> to allocate memory for the copied string. You must free this memory with <see cref="CoTaskMemFree" /> when it is no longer needed.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines SHStrDup as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrDup" />
  </member>
  <member name="Windows.StrCatBuff">
    <summary>
      <para>Copies and appends characters from one string to the end of another.</para>
      <para>
        <b>Note</b>  Do not use. See Remarks for alternative functions.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string. When this function returns successfully, this string contains its original content with the string <i>pszSrc</i> appended.</para>
    </param>
    <param name="pszSrc">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the string to be appended to <i>pszDest</i>.</para>
    </param>
    <param name="cchDestBuffSize">
      <para>Type: <b>int</b></para>
      <para>The size of the buffer, in characters, pointed to by <i>pszDest</i>. This value must be at least the length of the combined string plus the terminating null character. If the buffer is too small to fit the entire string, the string will be truncated.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the destination string.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The final string is not guaranteed to be null-terminated. Consider using one of the following alternatives: <see cref="StringCbCat" />, <see cref="StringCbCatEx" />, <see cref="StringCbCatN" />, <see cref="StringCbCatNEx" />, <see cref="StringCchCat" />, <see cref="StringCchCatEx" />, <see cref="StringCchCatN" />, or <see cref="StringCchCatNEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCatBuff as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCatBuffA">
    <summary>
      <para>Copies and appends characters from one string to the end of another.</para>
      <para>
        <b>Note</b>  Do not use. See Remarks for alternative functions.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string. When this function returns successfully, this string contains its original content with the string <i>pszSrc</i> appended.</para>
    </param>
    <param name="pszSrc">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the string to be appended to <i>pszDest</i>.</para>
    </param>
    <param name="cchDestBuffSize">
      <para>Type: <b>int</b></para>
      <para>The size of the buffer, in characters, pointed to by <i>pszDest</i>. This value must be at least the length of the combined string plus the terminating null character. If the buffer is too small to fit the entire string, the string will be truncated.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the destination string.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The final string is not guaranteed to be null-terminated. Consider using one of the following alternatives: <see cref="StringCbCat" />, <see cref="StringCbCatEx" />, <see cref="StringCbCatN" />, <see cref="StringCbCatNEx" />, <see cref="StringCchCat" />, <see cref="StringCchCatEx" />, <see cref="StringCchCatN" />, or <see cref="StringCchCatNEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCatBuff as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCatBuffW">
    <summary>
      <para>Copies and appends characters from one string to the end of another.</para>
      <para>
        <b>Note</b>  Do not use. See Remarks for alternative functions.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string. When this function returns successfully, this string contains its original content with the string <i>pszSrc</i> appended.</para>
    </param>
    <param name="pszSrc">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the string to be appended to <i>pszDest</i>.</para>
    </param>
    <param name="cchDestBuffSize">
      <para>Type: <b>int</b></para>
      <para>The size of the buffer, in characters, pointed to by <i>pszDest</i>. This value must be at least the length of the combined string plus the terminating null character. If the buffer is too small to fit the entire string, the string will be truncated.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the destination string.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The final string is not guaranteed to be null-terminated. Consider using one of the following alternatives: <see cref="StringCbCat" />, <see cref="StringCbCatEx" />, <see cref="StringCbCatN" />, <see cref="StringCbCatNEx" />, <see cref="StringCchCat" />, <see cref="StringCchCatEx" />, <see cref="StringCchCatN" />, or <see cref="StringCchCatNEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCatBuff as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCatBuff">
    <summary>
      <para>Copies and appends characters from one string to the end of another.</para>
      <para>
        <b>Note</b>  Do not use. See Remarks for alternative functions.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string. When this function returns successfully, this string contains its original content with the string <i>pszSrc</i> appended.</para>
    </param>
    <param name="pszSrc">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the string to be appended to <i>pszDest</i>.</para>
    </param>
    <param name="cchDestBuffSize">
      <para>Type: <b>int</b></para>
      <para>The size of the buffer, in characters, pointed to by <i>pszDest</i>. This value must be at least the length of the combined string plus the terminating null character. If the buffer is too small to fit the entire string, the string will be truncated.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the destination string.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The final string is not guaranteed to be null-terminated. Consider using one of the following alternatives: <see cref="StringCbCat" />, <see cref="StringCbCatEx" />, <see cref="StringCbCatN" />, <see cref="StringCbCatNEx" />, <see cref="StringCchCat" />, <see cref="StringCchCatEx" />, <see cref="StringCchCatN" />, or <see cref="StringCchCatNEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCatBuff as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCatBuffA">
    <summary>
      <para>Copies and appends characters from one string to the end of another.</para>
      <para>
        <b>Note</b>  Do not use. See Remarks for alternative functions.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string. When this function returns successfully, this string contains its original content with the string <i>pszSrc</i> appended.</para>
    </param>
    <param name="pszSrc">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the string to be appended to <i>pszDest</i>.</para>
    </param>
    <param name="cchDestBuffSize">
      <para>Type: <b>int</b></para>
      <para>The size of the buffer, in characters, pointed to by <i>pszDest</i>. This value must be at least the length of the combined string plus the terminating null character. If the buffer is too small to fit the entire string, the string will be truncated.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the destination string.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The final string is not guaranteed to be null-terminated. Consider using one of the following alternatives: <see cref="StringCbCat" />, <see cref="StringCbCatEx" />, <see cref="StringCbCatN" />, <see cref="StringCbCatNEx" />, <see cref="StringCchCat" />, <see cref="StringCchCatEx" />, <see cref="StringCchCatN" />, or <see cref="StringCchCatNEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCatBuff as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCatBuffW">
    <summary>
      <para>Copies and appends characters from one string to the end of another.</para>
      <para>
        <b>Note</b>  Do not use. See Remarks for alternative functions.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string. When this function returns successfully, this string contains its original content with the string <i>pszSrc</i> appended.</para>
    </param>
    <param name="pszSrc">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the string to be appended to <i>pszDest</i>.</para>
    </param>
    <param name="cchDestBuffSize">
      <para>Type: <b>int</b></para>
      <para>The size of the buffer, in characters, pointed to by <i>pszDest</i>. This value must be at least the length of the combined string plus the terminating null character. If the buffer is too small to fit the entire string, the string will be truncated.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the destination string.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The final string is not guaranteed to be null-terminated. Consider using one of the following alternatives: <see cref="StringCbCat" />, <see cref="StringCbCatEx" />, <see cref="StringCbCatN" />, <see cref="StringCbCatNEx" />, <see cref="StringCchCat" />, <see cref="StringCchCatEx" />, <see cref="StringCchCatN" />, or <see cref="StringCchCatNEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCatBuff as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCatChainW">
    <summary>
      <para>Concatenates two Unicode strings. Used when repeated concatenations to the same buffer are required.</para>
    </summary>
    <param name="pszDst">
      <para>Type: <b>PWSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the null-terminated, Unicode string.</para>
    </param>
    <param name="cchDst">
      <para>Type: <b>DWORD</b></para>
      <para>The size of the destination buffer, in characters. This buffer must be of sufficient size to hold both strings as well as a terminating null character. If the buffer is too small, the final string is truncated.</para>
    </param>
    <param name="ichAt">
      <para>Type: <b>DWORD</b></para>
      <para>The offset into the destination buffer at which to begin the append action. If the string is not empty, set this value to -1 to have the current number of filled characters (not including the terminating null character) calculated for you.</para>
    </param>
    <param name="pszSrc">
      <para>Type: <b>PCWSTR</b></para>
      <para>A pointer to the null-terminated Unicode source string.</para>
    </param>
    <returns>
      <para>Type: <b>DWORD</b></para>
      <para>Returns the offset of the null character after the last character added to <i>pszDst</i>.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The final string is not guaranteed to be null-terminated. Consider using one of the following alternatives: <see cref="StringCbCatEx" />, <see cref="StringCbCatNEx" />, <see cref="StringCchCatEx" />, or <see cref="StringCchCatNEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
    </remarks>
  </member>
  <member name="Windows.StrCat">
    <summary>
      <para>Appends one string to another.</para>
      <para>
        <b>Note</b>  Do not use. See Remarks for alternative functions.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string. When this function returns successfully, this string contains its original content with the string <i>psz2</i> appended. This buffer must be large enough to hold both strings and the terminating null character.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string to be appended to <i>psz1</i>.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to <i>psz1</i>, which holds the combined strings.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The first argument, <i>psz1</i>, must be large enough to hold <i>psz2</i> and the closing '\0', otherwise a buffer overrun may occur. Buffer overruns may lead to a denial of service attack against the application if an access violation occurs. In the worst case, a buffer overrun may allow an attacker to inject executable code into your process, especially if <i>psz1</i> is a stack-based buffer. Consider using one of the following alternatives: <see cref="StringCbCat" />, <see cref="StringCbCatEx" />, <see cref="StringCbCatN" />, <see cref="StringCbCatNEx" />, <see cref="StringCchCat" />, <see cref="StringCchCatEx" />, <see cref="StringCchCatN" />, or <see cref="StringCchCatNEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
    </remarks>
  </member>
  <member name="Windows.StrCatW">
    <summary>
      <para>Appends one string to another.</para>
      <para>
        <b>Note</b>  Do not use. See Remarks for alternative functions.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string. When this function returns successfully, this string contains its original content with the string <i>psz2</i> appended. This buffer must be large enough to hold both strings and the terminating null character.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string to be appended to <i>psz1</i>.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to <i>psz1</i>, which holds the combined strings.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The first argument, <i>psz1</i>, must be large enough to hold <i>psz2</i> and the closing '\0', otherwise a buffer overrun may occur. Buffer overruns may lead to a denial of service attack against the application if an access violation occurs. In the worst case, a buffer overrun may allow an attacker to inject executable code into your process, especially if <i>psz1</i> is a stack-based buffer. Consider using one of the following alternatives: <see cref="StringCbCat" />, <see cref="StringCbCatEx" />, <see cref="StringCbCatN" />, <see cref="StringCbCatNEx" />, <see cref="StringCchCat" />, <see cref="StringCchCatEx" />, <see cref="StringCchCatN" />, or <see cref="StringCchCatNEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
    </remarks>
  </member>
  <member name="Windows.StrChr">
    <summary>
      <para>Searches a string for the first occurrence of a character that matches the specified character. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>The address of the string to be searched.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to be used for comparison.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The comparison assumes <i>pszStart</i> points to the start of a null-terminated string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrChr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrChrA">
    <summary>
      <para>Searches a string for the first occurrence of a character that matches the specified character. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>The address of the string to be searched.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to be used for comparison.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The comparison assumes <i>pszStart</i> points to the start of a null-terminated string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrChr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrChrW">
    <summary>
      <para>Searches a string for the first occurrence of a character that matches the specified character. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>The address of the string to be searched.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to be used for comparison.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The comparison assumes <i>pszStart</i> points to the start of a null-terminated string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrChr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrChrI">
    <summary>
      <para>Searches a string for the first occurrence of a character that matches the specified character. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the string to be searched.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to be used for comparison.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The comparison assumes <i>pszStart</i> points to the start of a null-terminated string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrChrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrChrIA">
    <summary>
      <para>Searches a string for the first occurrence of a character that matches the specified character. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the string to be searched.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to be used for comparison.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The comparison assumes <i>pszStart</i> points to the start of a null-terminated string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrChrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrChrIW">
    <summary>
      <para>Searches a string for the first occurrence of a character that matches the specified character. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the string to be searched.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to be used for comparison.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The comparison assumes <i>pszStart</i> points to the start of a null-terminated string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrChrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrChrI">
    <summary>
      <para>Searches a string for the first occurrence of a character that matches the specified character. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the string to be searched.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to be used for comparison.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The comparison assumes <i>pszStart</i> points to the start of a null-terminated string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrChrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrChrIA">
    <summary>
      <para>Searches a string for the first occurrence of a character that matches the specified character. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the string to be searched.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to be used for comparison.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The comparison assumes <i>pszStart</i> points to the start of a null-terminated string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrChrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrChrIW">
    <summary>
      <para>Searches a string for the first occurrence of a character that matches the specified character. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the string to be searched.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to be used for comparison.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The comparison assumes <i>pszStart</i> points to the start of a null-terminated string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrChrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrChrNIW">
    <summary>
      <para>Searches a string for the first occurrence of a specified character. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PCWSTR</b></para>
      <para>A pointer to the string to be searched.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>WCHAR</b></para>
      <para>The character to be used for comparison.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>UINT</b></para>
      <para>The maximum number of characters to search.</para>
    </param>
    <returns>
      <para>Type: <b>PWSTR</b></para>
      <para>Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <para>
        <b>StrChrNIW</b> searches for <i>wMatch</i> from <i>pszStart</i> to <i>pszStart</i> + <i>cchMax</i>, or until a <b>NULL</b> character is encountered.</para>
      <para>To help ensure optimal performance, <i>pszStart</i> should be word-aligned.</para>
    </remarks>
    <seealso cref="StrChr" />
    <seealso cref="StrChrI" />
  </member>
  <member name="Windows.StrChrNW">
    <summary>
      <para>Searches a string for the first occurrence of a specified character. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PWSTR</b></para>
      <para>A pointer to the string to be searched.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>WCHAR</b></para>
      <para>The character to be used for comparison.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>UINT</b></para>
      <para>The maximum number of characters to search.</para>
    </param>
    <returns>
      <para>Type: <b>PWSTR</b></para>
      <para>Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <para>
        <b>StrChrNW</b> searches for <i>wMatch</i> from <i>pszStart</i> to <i>pszStart</i> + <i>cchMax</i>, or until a <b>NULL</b> character is encountered.</para>
      <para>To help ensure optimal performance, <i>pszStart</i> should be word-aligned.</para>
    </remarks>
    <seealso cref="StrChr" />
    <seealso cref="StrChrI" />
  </member>
  <member name="Windows.StrChr">
    <summary>
      <para>Searches a string for the first occurrence of a character that matches the specified character. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>The address of the string to be searched.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to be used for comparison.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The comparison assumes <i>pszStart</i> points to the start of a null-terminated string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrChr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrChrA">
    <summary>
      <para>Searches a string for the first occurrence of a character that matches the specified character. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>The address of the string to be searched.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to be used for comparison.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The comparison assumes <i>pszStart</i> points to the start of a null-terminated string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrChr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrChrW">
    <summary>
      <para>Searches a string for the first occurrence of a character that matches the specified character. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>The address of the string to be searched.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to be used for comparison.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the character in the string if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The comparison assumes <i>pszStart</i> points to the start of a null-terminated string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrChr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCmpC">
    <summary>
      <para>Compares strings using C run-time (ASCII) collation rules. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i>.</para>
    </returns>
    <remarks>
      <para>It is strongly recommended that you use the <see cref="CompareString" /> function in place of this function. <b>StrCmpC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.</para>
      <para>This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, if <i>lpStr1</i>="abczb" and <i>lpStr2</i>="abcdefg", <b>StrCmpC</b> determines that the first unequal character is at position four ("z" in <i>lpStr1</i> and "d" in <i>lpStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".</para>
      <para>For those versions of Windows that do not include <b>StrCmpC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpCA</b> is ordinal 155 and <b>StrCmpCW</b> is ordinal 156.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
  </member>
  <member name="Windows.StrCmpCA">
    <summary>
      <para>Compares strings using C run-time (ASCII) collation rules. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i>.</para>
    </returns>
    <remarks>
      <para>It is strongly recommended that you use the <see cref="CompareString" /> function in place of this function. <b>StrCmpC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.</para>
      <para>This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, if <i>lpStr1</i>="abczb" and <i>lpStr2</i>="abcdefg", <b>StrCmpC</b> determines that the first unequal character is at position four ("z" in <i>lpStr1</i> and "d" in <i>lpStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".</para>
      <para>For those versions of Windows that do not include <b>StrCmpC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpCA</b> is ordinal 155 and <b>StrCmpCW</b> is ordinal 156.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
  </member>
  <member name="Windows.StrCmpCW">
    <summary>
      <para>Compares strings using C run-time (ASCII) collation rules. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i>.</para>
    </returns>
    <remarks>
      <para>It is strongly recommended that you use the <see cref="CompareString" /> function in place of this function. <b>StrCmpC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.</para>
      <para>This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, if <i>lpStr1</i>="abczb" and <i>lpStr2</i>="abcdefg", <b>StrCmpC</b> determines that the first unequal character is at position four ("z" in <i>lpStr1</i> and "d" in <i>lpStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".</para>
      <para>For those versions of Windows that do not include <b>StrCmpC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpCA</b> is ordinal 155 and <b>StrCmpCW</b> is ordinal 156.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
  </member>
  <member name="Windows.StrCmpC">
    <summary>
      <para>Compares strings using C run-time (ASCII) collation rules. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i>.</para>
    </returns>
    <remarks>
      <para>It is strongly recommended that you use the <see cref="CompareString" /> function in place of this function. <b>StrCmpC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.</para>
      <para>This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, if <i>lpStr1</i>="abczb" and <i>lpStr2</i>="abcdefg", <b>StrCmpC</b> determines that the first unequal character is at position four ("z" in <i>lpStr1</i> and "d" in <i>lpStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".</para>
      <para>For those versions of Windows that do not include <b>StrCmpC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpCA</b> is ordinal 155 and <b>StrCmpCW</b> is ordinal 156.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
  </member>
  <member name="Windows.StrCmpCA">
    <summary>
      <para>Compares strings using C run-time (ASCII) collation rules. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i>.</para>
    </returns>
    <remarks>
      <para>It is strongly recommended that you use the <see cref="CompareString" /> function in place of this function. <b>StrCmpC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.</para>
      <para>This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, if <i>lpStr1</i>="abczb" and <i>lpStr2</i>="abcdefg", <b>StrCmpC</b> determines that the first unequal character is at position four ("z" in <i>lpStr1</i> and "d" in <i>lpStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".</para>
      <para>For those versions of Windows that do not include <b>StrCmpC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpCA</b> is ordinal 155 and <b>StrCmpCW</b> is ordinal 156.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
  </member>
  <member name="Windows.StrCmpCW">
    <summary>
      <para>Compares strings using C run-time (ASCII) collation rules. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i>.</para>
    </returns>
    <remarks>
      <para>It is strongly recommended that you use the <see cref="CompareString" /> function in place of this function. <b>StrCmpC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.</para>
      <para>This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, if <i>lpStr1</i>="abczb" and <i>lpStr2</i>="abcdefg", <b>StrCmpC</b> determines that the first unequal character is at position four ("z" in <i>lpStr1</i> and "d" in <i>lpStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".</para>
      <para>For those versions of Windows that do not include <b>StrCmpC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpCA</b> is ordinal 155 and <b>StrCmpCW</b> is ordinal 156.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
  </member>
  <member name="Windows.StrCmpIC">
    <summary>
      <para>Compares two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i></para>
    </returns>
    <remarks>
      <para>It is strongly recommended that you use <see cref="CompareString" /> in place of this function. <b>StrCmpIC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with double-byte character set (DBCS) data.</para>
      <para>Uppercase characters are converted to lowercase characters before comparing, and the return value is based on comparing the converted values.  This function returns the difference in value of the first unequal characters it encounters, or zero if they are all equal. For example, if <i>lpStr1</i>="abczb" and <i>lpStr2</i>="abcdefg", <b>StrCmpIC</b> determines that "abczb" is greater than "abcdefg" and returns z - d.</para>
      <para>For those versions of Windows that do not include <b>StrCmpIC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpICA</b> is ordinal 157 and <b>StrCmpICW</b> is ordinal 158.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
  </member>
  <member name="Windows.StrCmpICA">
    <summary>
      <para>Compares two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i></para>
    </returns>
    <remarks>
      <para>It is strongly recommended that you use <see cref="CompareString" /> in place of this function. <b>StrCmpIC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with double-byte character set (DBCS) data.</para>
      <para>Uppercase characters are converted to lowercase characters before comparing, and the return value is based on comparing the converted values.  This function returns the difference in value of the first unequal characters it encounters, or zero if they are all equal. For example, if <i>lpStr1</i>="abczb" and <i>lpStr2</i>="abcdefg", <b>StrCmpIC</b> determines that "abczb" is greater than "abcdefg" and returns z - d.</para>
      <para>For those versions of Windows that do not include <b>StrCmpIC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpICA</b> is ordinal 157 and <b>StrCmpICW</b> is ordinal 158.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
  </member>
  <member name="Windows.StrCmpICW">
    <summary>
      <para>Compares two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i></para>
    </returns>
    <remarks>
      <para>It is strongly recommended that you use <see cref="CompareString" /> in place of this function. <b>StrCmpIC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with double-byte character set (DBCS) data.</para>
      <para>Uppercase characters are converted to lowercase characters before comparing, and the return value is based on comparing the converted values.  This function returns the difference in value of the first unequal characters it encounters, or zero if they are all equal. For example, if <i>lpStr1</i>="abczb" and <i>lpStr2</i>="abcdefg", <b>StrCmpIC</b> determines that "abczb" is greater than "abcdefg" and returns z - d.</para>
      <para>For those versions of Windows that do not include <b>StrCmpIC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpICA</b> is ordinal 157 and <b>StrCmpICW</b> is ordinal 158.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
  </member>
  <member name="Windows.StrCmpIC">
    <summary>
      <para>Compares two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i></para>
    </returns>
    <remarks>
      <para>It is strongly recommended that you use <see cref="CompareString" /> in place of this function. <b>StrCmpIC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with double-byte character set (DBCS) data.</para>
      <para>Uppercase characters are converted to lowercase characters before comparing, and the return value is based on comparing the converted values.  This function returns the difference in value of the first unequal characters it encounters, or zero if they are all equal. For example, if <i>lpStr1</i>="abczb" and <i>lpStr2</i>="abcdefg", <b>StrCmpIC</b> determines that "abczb" is greater than "abcdefg" and returns z - d.</para>
      <para>For those versions of Windows that do not include <b>StrCmpIC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpICA</b> is ordinal 157 and <b>StrCmpICW</b> is ordinal 158.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
  </member>
  <member name="Windows.StrCmpICA">
    <summary>
      <para>Compares two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i></para>
    </returns>
    <remarks>
      <para>It is strongly recommended that you use <see cref="CompareString" /> in place of this function. <b>StrCmpIC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with double-byte character set (DBCS) data.</para>
      <para>Uppercase characters are converted to lowercase characters before comparing, and the return value is based on comparing the converted values.  This function returns the difference in value of the first unequal characters it encounters, or zero if they are all equal. For example, if <i>lpStr1</i>="abczb" and <i>lpStr2</i>="abcdefg", <b>StrCmpIC</b> determines that "abczb" is greater than "abcdefg" and returns z - d.</para>
      <para>For those versions of Windows that do not include <b>StrCmpIC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpICA</b> is ordinal 157 and <b>StrCmpICW</b> is ordinal 158.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
  </member>
  <member name="Windows.StrCmpICW">
    <summary>
      <para>Compares two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>lpStr1</i> is alphabetically greater than that pointed to by <i>lpStr2</i>. Returns a negative value if the string pointed to by <i>lpStr1</i> is alphabetically less than that pointed to by <i>lpStr2</i></para>
    </returns>
    <remarks>
      <para>It is strongly recommended that you use <see cref="CompareString" /> in place of this function. <b>StrCmpIC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with double-byte character set (DBCS) data.</para>
      <para>Uppercase characters are converted to lowercase characters before comparing, and the return value is based on comparing the converted values.  This function returns the difference in value of the first unequal characters it encounters, or zero if they are all equal. For example, if <i>lpStr1</i>="abczb" and <i>lpStr2</i>="abcdefg", <b>StrCmpIC</b> determines that "abczb" is greater than "abcdefg" and returns z - d.</para>
      <para>For those versions of Windows that do not include <b>StrCmpIC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpICA</b> is ordinal 157 and <b>StrCmpICW</b> is ordinal 158.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
  </member>
  <member name="Windows.StrCmpI">
    <summary>
      <para>Compares two strings to determine if they are the same. The comparison is not case-sensitive.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>psz1</i> is greater than that pointed to by <i>psz2</i>. Returns a negative value if the string pointed to by <i>psz1</i> is less than that pointed to by <i>psz2</i>.</para>
    </returns>
  </member>
  <member name="Windows.StrCmpIW">
    <summary>
      <para>Compares two strings to determine if they are the same. The comparison is not case-sensitive.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>psz1</i> is greater than that pointed to by <i>psz2</i>. Returns a negative value if the string pointed to by <i>psz1</i> is less than that pointed to by <i>psz2</i>.</para>
    </returns>
  </member>
  <member name="Windows.StrCmpLogicalW">
    <summary>
      <para>Compares two Unicode strings. Digits in the strings are considered as numerical content rather than text. This test is not case-sensitive.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCWSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCWSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <list type="bullet">
        <item>
          <description>Returns zero if the strings are identical.</description>
        </item>
        <item>
          <description>Returns 1 if the string pointed to by <i>psz1</i> has a greater value than that pointed to by <i>psz2</i>.</description>
        </item>
        <item>
          <description>Returns -1 if the string pointed to by <i>psz1</i> has a lesser value than that pointed to by <i>psz2</i>.</description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>This function's ordering schema differs somewhat from <see cref="StrCmpI" />, which also compares strings without regard to case sensitivity. Considering digits by their numerical value—as <b>StrCmpLogicalW</b> does—strings are ordered as follows:</para>
      <code>2string
3string
20string
st2ring
st3ring
st20ring
string2
string3
string20
</code>
      <para>
        <b>StrCmpI</b> considers digits in the string only as text so that those same strings are ordered as follows:</para>
      <code>20string
2string
3string
st20ring
st2ring
st3ring
string2
string20
string3
</code>
      <para>
        <b>Note</b>  Behavior of this function, and therefore the results it returns, can change from release to release. It should not be used for canonical sorting applications.</para>
    </remarks>
  </member>
  <member name="Windows.StrCmpN">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is case-sensitive. The <b>StrNCmp</b> macro differs from this function in name only.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpN as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCmpNA">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is case-sensitive. The <b>StrNCmp</b> macro differs from this function in name only.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpN as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCmpNW">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is case-sensitive. The <b>StrNCmp</b> macro differs from this function in name only.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpN as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCmpNC">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically greater than the string taken from that pointed to by <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.</para>
    </returns>
    <remarks>
      <para>Note that <b>StrCmpNC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.</para>
      <para>This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, suppose that <i>pszStr1</i>="abczb", <i>pszStr2</i>="abcdefg", and you are comparing the first four characters from each. <b>StrCmpNC</b> determines that the first unequal character is at position four ("z" in <i>pszStr1</i> and "d" in <i>pszStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".</para>
      <para>For those versions of Windows that do not include <b>StrCmpNC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpNCA</b> is ordinal 151 and <b>StrCmpNCW</b> is ordinal 152.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpNC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="StrCmpC" />
    <seealso cref="StrCmpN" />
  </member>
  <member name="Windows.StrCmpNCA">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically greater than the string taken from that pointed to by <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.</para>
    </returns>
    <remarks>
      <para>Note that <b>StrCmpNC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.</para>
      <para>This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, suppose that <i>pszStr1</i>="abczb", <i>pszStr2</i>="abcdefg", and you are comparing the first four characters from each. <b>StrCmpNC</b> determines that the first unequal character is at position four ("z" in <i>pszStr1</i> and "d" in <i>pszStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".</para>
      <para>For those versions of Windows that do not include <b>StrCmpNC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpNCA</b> is ordinal 151 and <b>StrCmpNCW</b> is ordinal 152.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpNC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="StrCmpC" />
    <seealso cref="StrCmpN" />
  </member>
  <member name="Windows.StrCmpNCW">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically greater than the string taken from that pointed to by <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.</para>
    </returns>
    <remarks>
      <para>Note that <b>StrCmpNC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.</para>
      <para>This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, suppose that <i>pszStr1</i>="abczb", <i>pszStr2</i>="abcdefg", and you are comparing the first four characters from each. <b>StrCmpNC</b> determines that the first unequal character is at position four ("z" in <i>pszStr1</i> and "d" in <i>pszStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".</para>
      <para>For those versions of Windows that do not include <b>StrCmpNC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpNCA</b> is ordinal 151 and <b>StrCmpNCW</b> is ordinal 152.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpNC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="StrCmpC" />
    <seealso cref="StrCmpN" />
  </member>
  <member name="Windows.StrCmpNC">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically greater than the string taken from that pointed to by <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.</para>
    </returns>
    <remarks>
      <para>Note that <b>StrCmpNC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.</para>
      <para>This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, suppose that <i>pszStr1</i>="abczb", <i>pszStr2</i>="abcdefg", and you are comparing the first four characters from each. <b>StrCmpNC</b> determines that the first unequal character is at position four ("z" in <i>pszStr1</i> and "d" in <i>pszStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".</para>
      <para>For those versions of Windows that do not include <b>StrCmpNC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpNCA</b> is ordinal 151 and <b>StrCmpNCW</b> is ordinal 152.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpNC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="StrCmpC" />
    <seealso cref="StrCmpN" />
  </member>
  <member name="Windows.StrCmpNCA">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically greater than the string taken from that pointed to by <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.</para>
    </returns>
    <remarks>
      <para>Note that <b>StrCmpNC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.</para>
      <para>This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, suppose that <i>pszStr1</i>="abczb", <i>pszStr2</i>="abcdefg", and you are comparing the first four characters from each. <b>StrCmpNC</b> determines that the first unequal character is at position four ("z" in <i>pszStr1</i> and "d" in <i>pszStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".</para>
      <para>For those versions of Windows that do not include <b>StrCmpNC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpNCA</b> is ordinal 151 and <b>StrCmpNCW</b> is ordinal 152.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpNC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="StrCmpC" />
    <seealso cref="StrCmpN" />
  </member>
  <member name="Windows.StrCmpNCW">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically greater than the string taken from that pointed to by <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.</para>
    </returns>
    <remarks>
      <para>Note that <b>StrCmpNC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.</para>
      <para>This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, suppose that <i>pszStr1</i>="abczb", <i>pszStr2</i>="abcdefg", and you are comparing the first four characters from each. <b>StrCmpNC</b> determines that the first unequal character is at position four ("z" in <i>pszStr1</i> and "d" in <i>pszStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".</para>
      <para>For those versions of Windows that do not include <b>StrCmpNC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpNCA</b> is ordinal 151 and <b>StrCmpNCW</b> is ordinal 152.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpNC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="StrCmpC" />
    <seealso cref="StrCmpN" />
  </member>
  <member name="Windows.StrCmpNI">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is not case-sensitive. The <b>StrNCmpI</b> macro differs from this function in name only.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpNI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCmpNIA">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is not case-sensitive. The <b>StrNCmpI</b> macro differs from this function in name only.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpNI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCmpNIW">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is not case-sensitive. The <b>StrNCmpI</b> macro differs from this function in name only.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpNI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCmpNIC">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically greater the string taken from that pointed to by <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.</para>
    </returns>
    <remarks>
      <para>Note that <b>StrCmpNIC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.</para>
      <para>This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, suppose that <i>pszStr1</i>="abczb", <i>pszStr2</i>="abcdefg", and you are comparing the first four characters from each. <b>StrCmpNIC</b> determines that the first unequal character is at position four ("z" in <i>pszStr1</i> and "d" in <i>pszStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".</para>
      <para>For those versions of Windows that do not include <b>StrCmpNIC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpNICA</b> is ordinal 153 and <b>StrCmpNICW</b> is ordinal 154.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpNIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="StrCmpIC" />
    <seealso cref="StrCmpNI" />
  </member>
  <member name="Windows.StrCmpNICA">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically greater the string taken from that pointed to by <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.</para>
    </returns>
    <remarks>
      <para>Note that <b>StrCmpNIC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.</para>
      <para>This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, suppose that <i>pszStr1</i>="abczb", <i>pszStr2</i>="abcdefg", and you are comparing the first four characters from each. <b>StrCmpNIC</b> determines that the first unequal character is at position four ("z" in <i>pszStr1</i> and "d" in <i>pszStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".</para>
      <para>For those versions of Windows that do not include <b>StrCmpNIC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpNICA</b> is ordinal 153 and <b>StrCmpNICW</b> is ordinal 154.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpNIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="StrCmpIC" />
    <seealso cref="StrCmpNI" />
  </member>
  <member name="Windows.StrCmpNICW">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically greater the string taken from that pointed to by <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.</para>
    </returns>
    <remarks>
      <para>Note that <b>StrCmpNIC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.</para>
      <para>This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, suppose that <i>pszStr1</i>="abczb", <i>pszStr2</i>="abcdefg", and you are comparing the first four characters from each. <b>StrCmpNIC</b> determines that the first unequal character is at position four ("z" in <i>pszStr1</i> and "d" in <i>pszStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".</para>
      <para>For those versions of Windows that do not include <b>StrCmpNIC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpNICA</b> is ordinal 153 and <b>StrCmpNICW</b> is ordinal 154.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpNIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="StrCmpIC" />
    <seealso cref="StrCmpNI" />
  </member>
  <member name="Windows.StrCmpNIC">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically greater the string taken from that pointed to by <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.</para>
    </returns>
    <remarks>
      <para>Note that <b>StrCmpNIC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.</para>
      <para>This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, suppose that <i>pszStr1</i>="abczb", <i>pszStr2</i>="abcdefg", and you are comparing the first four characters from each. <b>StrCmpNIC</b> determines that the first unequal character is at position four ("z" in <i>pszStr1</i> and "d" in <i>pszStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".</para>
      <para>For those versions of Windows that do not include <b>StrCmpNIC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpNICA</b> is ordinal 153 and <b>StrCmpNICW</b> is ordinal 154.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpNIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="StrCmpIC" />
    <seealso cref="StrCmpNI" />
  </member>
  <member name="Windows.StrCmpNICA">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically greater the string taken from that pointed to by <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.</para>
    </returns>
    <remarks>
      <para>Note that <b>StrCmpNIC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.</para>
      <para>This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, suppose that <i>pszStr1</i>="abczb", <i>pszStr2</i>="abcdefg", and you are comparing the first four characters from each. <b>StrCmpNIC</b> determines that the first unequal character is at position four ("z" in <i>pszStr1</i> and "d" in <i>pszStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".</para>
      <para>For those versions of Windows that do not include <b>StrCmpNIC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpNICA</b> is ordinal 153 and <b>StrCmpNICW</b> is ordinal 154.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpNIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="StrCmpIC" />
    <seealso cref="StrCmpNI" />
  </member>
  <member name="Windows.StrCmpNICW">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings using C run-time (ASCII) collation rules. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStr1">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszStr2">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the substrings are identical. Returns a positive value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically greater the string taken from that pointed to by <i>pszStr2</i>. Returns a negative value if the string taken from that pointed to by <i>pszStr1</i> is alphabetically less than the string taken from that pointed to by <i>pszStr2</i>.</para>
    </returns>
    <remarks>
      <para>Note that <b>StrCmpNIC</b> was designed for comparing canonical strings. These strings are not localized and consist only of characters below ASCII value 128. Therefore, it will not function correctly with a double-byte character set (DBCS) or other multiple-character data.</para>
      <para>This function locates the first unequal characters and returns a positive number if the character from the first string is greater than the character from the second, a negative number if it is less, or zero if they are equal. For example, suppose that <i>pszStr1</i>="abczb", <i>pszStr2</i>="abcdefg", and you are comparing the first four characters from each. <b>StrCmpNIC</b> determines that the first unequal character is at position four ("z" in <i>pszStr1</i> and "d" in <i>pszStr2</i>) and returns a positive value since the ASCII code for "z" is greater than the ASCII code for "d".</para>
      <para>For those versions of Windows that do not include <b>StrCmpNIC</b> in Shlwapi.h, this function's individual ANSI or Unicode version must be called directly from Shlwapi.dll. <b>StrCmpNICA</b> is ordinal 153 and <b>StrCmpNICW</b> is ordinal 154.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpNIC as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="CompareString" />
    <seealso cref="StrCmpIC" />
    <seealso cref="StrCmpNI" />
  </member>
  <member name="Windows.StrCmpNI">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is not case-sensitive. The <b>StrNCmpI</b> macro differs from this function in name only.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpNI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCmpNIA">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is not case-sensitive. The <b>StrNCmpI</b> macro differs from this function in name only.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpNI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCmpNIW">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is not case-sensitive. The <b>StrNCmpI</b> macro differs from this function in name only.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpNI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCmpN">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is case-sensitive. The <b>StrNCmp</b> macro differs from this function in name only.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpN as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCmpNA">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is case-sensitive. The <b>StrNCmp</b> macro differs from this function in name only.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpN as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCmpNW">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings to determine if they are the same. The comparison is case-sensitive. The <b>StrNCmp</b> macro differs from this function in name only.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are greater than those from the string pointed to by <i>psz2</i>. It returns a negative value if the first <i>nChar</i> characters of the string pointed to by <i>psz1</i> are less than those from the string pointed to by <i>psz2</i>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCmpN as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCmp">
    <summary>
      <para>Compares two strings to determine if they are the same. The comparison is case-sensitive.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>psz1</i> is greater than that pointed to by <i>psz2</i>. Returns a negative value if the string pointed to by <i>psz1</i> is less than that pointed to by <i>psz2</i>.</para>
    </returns>
  </member>
  <member name="Windows.StrCmpW">
    <summary>
      <para>Compares two strings to determine if they are the same. The comparison is case-sensitive.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the strings are identical. Returns a positive value if the string pointed to by <i>psz1</i> is greater than that pointed to by <i>psz2</i>. Returns a negative value if the string pointed to by <i>psz1</i> is less than that pointed to by <i>psz2</i>.</para>
    </returns>
  </member>
  <member name="Windows.StrCpyN">
    <summary>
      <para>Copies a specified number of characters from the beginning of one string to another.
<b>Note</b>  Do not use this function or the <b>StrNCpy</b> macro. See Remarks for alternative functions.</para>
    </summary>
    <param name="pszDst">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the copied string. This buffer must be of sufficient size to hold the copied characters. This string is not guaranteed to be null-terminated.</para>
    </param>
    <param name="pszSrc">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated source string.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be copied, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to <i>pszDst</i>.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The copied string is not guaranteed to be null-terminated.  Consider using one of the following alternatives. <see cref="StringCbCopy" />, <see cref="StringCbCopyEx" />, <see cref="StringCbCopyN" />, <see cref="StringCbCopyNEx" />, <see cref="StringCchCopy" />, <see cref="StringCchCopyEx" />, <see cref="StringCchCopyN" />, <see cref="StringCchCopyNEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
    </remarks>
  </member>
  <member name="Windows.StrCpyNW">
    <summary>
      <para>Copies a specified number of characters from the beginning of one string to another.
<b>Note</b>  Do not use this function or the <b>StrNCpy</b> macro. See Remarks for alternative functions.</para>
    </summary>
    <param name="pszDst">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the copied string. This buffer must be of sufficient size to hold the copied characters. This string is not guaranteed to be null-terminated.</para>
    </param>
    <param name="pszSrc">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated source string.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be copied, including the terminating null character.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to <i>pszDst</i>.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The copied string is not guaranteed to be null-terminated.  Consider using one of the following alternatives. <see cref="StringCbCopy" />, <see cref="StringCbCopyEx" />, <see cref="StringCbCopyN" />, <see cref="StringCbCopyNEx" />, <see cref="StringCchCopy" />, <see cref="StringCchCopyEx" />, <see cref="StringCchCopyN" />, <see cref="StringCchCopyNEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
    </remarks>
  </member>
  <member name="Windows.StrCpy">
    <summary>
      <para>Copies one string to another.</para>
      <para>
        <b>Note</b>  Do not use. See Remarks for alternative functions.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the copied string. This string is not guaranteed to be null-terminated.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated source string.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to <i>psz1</i>.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The first argument, <i>psz1</i>, must be large enough to hold <i>psz2</i> and the closing '\0', otherwise a buffer overrun may occur. Buffer overruns may lead to a denial of service attack against the application if an access violation occurs. In the worst case, a buffer overrun may allow an attacker to inject executable code into your process, especially if <i>psz1</i> is a stack-based buffer. Consider using one of the following alternatives: <see cref="StringCbCopy" />, <see cref="StringCbCopyEx" />, <see cref="StringCbCopyN" />, <see cref="StringCbCopyNEx" />, <see cref="StringCchCopy" />, <see cref="StringCchCopyEx" />, <see cref="StringCchCopyN" />, or <see cref="StringCchCopyNEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
    </remarks>
  </member>
  <member name="Windows.StrCpyW">
    <summary>
      <para>Copies one string to another.</para>
      <para>
        <b>Note</b>  Do not use. See Remarks for alternative functions.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the copied string. This string is not guaranteed to be null-terminated.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated source string.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to <i>psz1</i>.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The first argument, <i>psz1</i>, must be large enough to hold <i>psz2</i> and the closing '\0', otherwise a buffer overrun may occur. Buffer overruns may lead to a denial of service attack against the application if an access violation occurs. In the worst case, a buffer overrun may allow an attacker to inject executable code into your process, especially if <i>psz1</i> is a stack-based buffer. Consider using one of the following alternatives: <see cref="StringCbCopy" />, <see cref="StringCbCopyEx" />, <see cref="StringCbCopyN" />, <see cref="StringCbCopyNEx" />, <see cref="StringCchCopy" />, <see cref="StringCchCopyEx" />, <see cref="StringCchCopyN" />, or <see cref="StringCchCopyNEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
    </remarks>
  </member>
  <member name="Windows.StrCSpn">
    <summary>
      <para>Searches a string for the first occurrence of any of a group of characters. The search method is case-sensitive, and the terminating <b>NULL</b> character is included within the search pattern match.</para>
    </summary>
    <param name="pszStr">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the characters to search for.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>, or the length of <i>pszStr</i> if no match is found.</para>
    </returns>
    <remarks>
      <para>The return value of this function is equal to the length of the initial substring in <i>pszStr</i> that does not include any characters from <i>pszSet</i>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCSpn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCSpnA">
    <summary>
      <para>Searches a string for the first occurrence of any of a group of characters. The search method is case-sensitive, and the terminating <b>NULL</b> character is included within the search pattern match.</para>
    </summary>
    <param name="pszStr">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the characters to search for.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>, or the length of <i>pszStr</i> if no match is found.</para>
    </returns>
    <remarks>
      <para>The return value of this function is equal to the length of the initial substring in <i>pszStr</i> that does not include any characters from <i>pszSet</i>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCSpn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCSpnW">
    <summary>
      <para>Searches a string for the first occurrence of any of a group of characters. The search method is case-sensitive, and the terminating <b>NULL</b> character is included within the search pattern match.</para>
    </summary>
    <param name="pszStr">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the characters to search for.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>, or the length of <i>pszStr</i> if no match is found.</para>
    </returns>
    <remarks>
      <para>The return value of this function is equal to the length of the initial substring in <i>pszStr</i> that does not include any characters from <i>pszSet</i>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCSpn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCSpnI">
    <summary>
      <para>Searches a string for the first occurrence of any of a group of characters. The search method is not case-sensitive, and the terminating <b>NULL</b> character is included within the search pattern match.</para>
    </summary>
    <param name="pszStr">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the characters to search for.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>, or the length of <i>pszStr</i> if no match is found.</para>
    </returns>
    <remarks>
      <para>The return value of this function is equal to the length of the initial substring in <i>pszStr</i> that does not include any characters from <i>pszSet</i>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCSpnI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCSpnIA">
    <summary>
      <para>Searches a string for the first occurrence of any of a group of characters. The search method is not case-sensitive, and the terminating <b>NULL</b> character is included within the search pattern match.</para>
    </summary>
    <param name="pszStr">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the characters to search for.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>, or the length of <i>pszStr</i> if no match is found.</para>
    </returns>
    <remarks>
      <para>The return value of this function is equal to the length of the initial substring in <i>pszStr</i> that does not include any characters from <i>pszSet</i>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCSpnI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCSpnIW">
    <summary>
      <para>Searches a string for the first occurrence of any of a group of characters. The search method is not case-sensitive, and the terminating <b>NULL</b> character is included within the search pattern match.</para>
    </summary>
    <param name="pszStr">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the characters to search for.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>, or the length of <i>pszStr</i> if no match is found.</para>
    </returns>
    <remarks>
      <para>The return value of this function is equal to the length of the initial substring in <i>pszStr</i> that does not include any characters from <i>pszSet</i>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCSpnI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCSpnI">
    <summary>
      <para>Searches a string for the first occurrence of any of a group of characters. The search method is not case-sensitive, and the terminating <b>NULL</b> character is included within the search pattern match.</para>
    </summary>
    <param name="pszStr">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the characters to search for.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>, or the length of <i>pszStr</i> if no match is found.</para>
    </returns>
    <remarks>
      <para>The return value of this function is equal to the length of the initial substring in <i>pszStr</i> that does not include any characters from <i>pszSet</i>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCSpnI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCSpnIA">
    <summary>
      <para>Searches a string for the first occurrence of any of a group of characters. The search method is not case-sensitive, and the terminating <b>NULL</b> character is included within the search pattern match.</para>
    </summary>
    <param name="pszStr">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the characters to search for.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>, or the length of <i>pszStr</i> if no match is found.</para>
    </returns>
    <remarks>
      <para>The return value of this function is equal to the length of the initial substring in <i>pszStr</i> that does not include any characters from <i>pszSet</i>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCSpnI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCSpnIW">
    <summary>
      <para>Searches a string for the first occurrence of any of a group of characters. The search method is not case-sensitive, and the terminating <b>NULL</b> character is included within the search pattern match.</para>
    </summary>
    <param name="pszStr">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the characters to search for.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>, or the length of <i>pszStr</i> if no match is found.</para>
    </returns>
    <remarks>
      <para>The return value of this function is equal to the length of the initial substring in <i>pszStr</i> that does not include any characters from <i>pszSet</i>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCSpnI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCSpn">
    <summary>
      <para>Searches a string for the first occurrence of any of a group of characters. The search method is case-sensitive, and the terminating <b>NULL</b> character is included within the search pattern match.</para>
    </summary>
    <param name="pszStr">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the characters to search for.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>, or the length of <i>pszStr</i> if no match is found.</para>
    </returns>
    <remarks>
      <para>The return value of this function is equal to the length of the initial substring in <i>pszStr</i> that does not include any characters from <i>pszSet</i>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCSpn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCSpnA">
    <summary>
      <para>Searches a string for the first occurrence of any of a group of characters. The search method is case-sensitive, and the terminating <b>NULL</b> character is included within the search pattern match.</para>
    </summary>
    <param name="pszStr">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the characters to search for.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>, or the length of <i>pszStr</i> if no match is found.</para>
    </returns>
    <remarks>
      <para>The return value of this function is equal to the length of the initial substring in <i>pszStr</i> that does not include any characters from <i>pszSet</i>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCSpn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrCSpnW">
    <summary>
      <para>Searches a string for the first occurrence of any of a group of characters. The search method is case-sensitive, and the terminating <b>NULL</b> character is included within the search pattern match.</para>
    </summary>
    <param name="pszStr">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the characters to search for.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the index of the first occurrence in <i>pszStr</i> of any character from <i>pszSet</i>, or the length of <i>pszStr</i> if no match is found.</para>
    </returns>
    <remarks>
      <para>The return value of this function is equal to the length of the initial substring in <i>pszStr</i> that does not include any characters from <i>pszSet</i>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrCSpn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrDup">
    <summary>
      <para>Duplicates a string.</para>
    </summary>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a constant <b>null</b>-terminated character string.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the string that was copied, or <b>NULL</b> if the string cannot be copied.</para>
    </returns>
    <remarks>
      <para>
        <b>StrDup</b> will allocate storage the size of the original string. If storage allocation is successful, the original string is copied to the duplicate string.</para>
      <para>This function uses <see cref="LocalAlloc" /> to allocate storage space for the copy of the string. The calling application must free this memory by calling the <see cref="LocalFree" /> function on the pointer returned by the call to <b>StrDup</b>.</para>
      <h4>Examples</h4>
      <para>This simple console application illustrates the use of <b>StrDup</b>.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;shlwapi.h&gt;
#include &lt;stdio.h&gt;

void main(void)
{
   char buffer[] = "This is the buffer text";
   char *newstring;

   // Note: Never use an unbounded %s format specifier in printf.
   printf("Original: %25s\n", buffer);

   newstring = StrDup(buffer);
   if (newstring != NULL)
   {
       printf("Copy:     %25s\n", newstring);
       LocalFree(newstring);
   }
}

OUTPUT:
- - - - - -
Original: This is the buffer text
Copy:     This is the buffer text
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrDup as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrDupA">
    <summary>
      <para>Duplicates a string.</para>
    </summary>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a constant <b>null</b>-terminated character string.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the string that was copied, or <b>NULL</b> if the string cannot be copied.</para>
    </returns>
    <remarks>
      <para>
        <b>StrDup</b> will allocate storage the size of the original string. If storage allocation is successful, the original string is copied to the duplicate string.</para>
      <para>This function uses <see cref="LocalAlloc" /> to allocate storage space for the copy of the string. The calling application must free this memory by calling the <see cref="LocalFree" /> function on the pointer returned by the call to <b>StrDup</b>.</para>
      <h4>Examples</h4>
      <para>This simple console application illustrates the use of <b>StrDup</b>.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;shlwapi.h&gt;
#include &lt;stdio.h&gt;

void main(void)
{
   char buffer[] = "This is the buffer text";
   char *newstring;

   // Note: Never use an unbounded %s format specifier in printf.
   printf("Original: %25s\n", buffer);

   newstring = StrDup(buffer);
   if (newstring != NULL)
   {
       printf("Copy:     %25s\n", newstring);
       LocalFree(newstring);
   }
}

OUTPUT:
- - - - - -
Original: This is the buffer text
Copy:     This is the buffer text
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrDup as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrDupW">
    <summary>
      <para>Duplicates a string.</para>
    </summary>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a constant <b>null</b>-terminated character string.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the string that was copied, or <b>NULL</b> if the string cannot be copied.</para>
    </returns>
    <remarks>
      <para>
        <b>StrDup</b> will allocate storage the size of the original string. If storage allocation is successful, the original string is copied to the duplicate string.</para>
      <para>This function uses <see cref="LocalAlloc" /> to allocate storage space for the copy of the string. The calling application must free this memory by calling the <see cref="LocalFree" /> function on the pointer returned by the call to <b>StrDup</b>.</para>
      <h4>Examples</h4>
      <para>This simple console application illustrates the use of <b>StrDup</b>.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;shlwapi.h&gt;
#include &lt;stdio.h&gt;

void main(void)
{
   char buffer[] = "This is the buffer text";
   char *newstring;

   // Note: Never use an unbounded %s format specifier in printf.
   printf("Original: %25s\n", buffer);

   newstring = StrDup(buffer);
   if (newstring != NULL)
   {
       printf("Copy:     %25s\n", newstring);
       LocalFree(newstring);
   }
}

OUTPUT:
- - - - - -
Original: This is the buffer text
Copy:     This is the buffer text
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrDup as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrDup">
    <summary>
      <para>Duplicates a string.</para>
    </summary>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a constant <b>null</b>-terminated character string.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the string that was copied, or <b>NULL</b> if the string cannot be copied.</para>
    </returns>
    <remarks>
      <para>
        <b>StrDup</b> will allocate storage the size of the original string. If storage allocation is successful, the original string is copied to the duplicate string.</para>
      <para>This function uses <see cref="LocalAlloc" /> to allocate storage space for the copy of the string. The calling application must free this memory by calling the <see cref="LocalFree" /> function on the pointer returned by the call to <b>StrDup</b>.</para>
      <h4>Examples</h4>
      <para>This simple console application illustrates the use of <b>StrDup</b>.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;shlwapi.h&gt;
#include &lt;stdio.h&gt;

void main(void)
{
   char buffer[] = "This is the buffer text";
   char *newstring;

   // Note: Never use an unbounded %s format specifier in printf.
   printf("Original: %25s\n", buffer);

   newstring = StrDup(buffer);
   if (newstring != NULL)
   {
       printf("Copy:     %25s\n", newstring);
       LocalFree(newstring);
   }
}

OUTPUT:
- - - - - -
Original: This is the buffer text
Copy:     This is the buffer text
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrDup as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrDupA">
    <summary>
      <para>Duplicates a string.</para>
    </summary>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a constant <b>null</b>-terminated character string.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the string that was copied, or <b>NULL</b> if the string cannot be copied.</para>
    </returns>
    <remarks>
      <para>
        <b>StrDup</b> will allocate storage the size of the original string. If storage allocation is successful, the original string is copied to the duplicate string.</para>
      <para>This function uses <see cref="LocalAlloc" /> to allocate storage space for the copy of the string. The calling application must free this memory by calling the <see cref="LocalFree" /> function on the pointer returned by the call to <b>StrDup</b>.</para>
      <h4>Examples</h4>
      <para>This simple console application illustrates the use of <b>StrDup</b>.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;shlwapi.h&gt;
#include &lt;stdio.h&gt;

void main(void)
{
   char buffer[] = "This is the buffer text";
   char *newstring;

   // Note: Never use an unbounded %s format specifier in printf.
   printf("Original: %25s\n", buffer);

   newstring = StrDup(buffer);
   if (newstring != NULL)
   {
       printf("Copy:     %25s\n", newstring);
       LocalFree(newstring);
   }
}

OUTPUT:
- - - - - -
Original: This is the buffer text
Copy:     This is the buffer text
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrDup as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrDupW">
    <summary>
      <para>Duplicates a string.</para>
    </summary>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a constant <b>null</b>-terminated character string.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the string that was copied, or <b>NULL</b> if the string cannot be copied.</para>
    </returns>
    <remarks>
      <para>
        <b>StrDup</b> will allocate storage the size of the original string. If storage allocation is successful, the original string is copied to the duplicate string.</para>
      <para>This function uses <see cref="LocalAlloc" /> to allocate storage space for the copy of the string. The calling application must free this memory by calling the <see cref="LocalFree" /> function on the pointer returned by the call to <b>StrDup</b>.</para>
      <h4>Examples</h4>
      <para>This simple console application illustrates the use of <b>StrDup</b>.</para>
      <code>#include &lt;windows.h&gt;
#include &lt;shlwapi.h&gt;
#include &lt;stdio.h&gt;

void main(void)
{
   char buffer[] = "This is the buffer text";
   char *newstring;

   // Note: Never use an unbounded %s format specifier in printf.
   printf("Original: %25s\n", buffer);

   newstring = StrDup(buffer);
   if (newstring != NULL)
   {
       printf("Copy:     %25s\n", newstring);
       LocalFree(newstring);
   }
}

OUTPUT:
- - - - - -
Original: This is the buffer text
Copy:     This is the buffer text
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrDup as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrFormatByteSize64">
    <summary>
      <para>Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or gigabytes, depending on the size.</para>
    </summary>
    <param name="qdw">
      <para>Type: <b>LONGLONG</b></para>
      <para>The numeric value to be converted.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>PSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted number.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of the buffer pointed to by <i>pszBuf</i>, in characters.</para>
    </param>
    <returns>
      <para>Type: <b>PSTR</b></para>
      <para>Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.</para>
    </returns>
    <remarks>
      <para>
        <b>StrFormatByteSize64</b> can be used for either ANSI or Unicode characters. However, while <b>StrFormatByteSize64A</b> can be called directly, <b>StrFormatByteSize64W</b> is not defined. When <b>StrFormatByteSize64</b> is called with a Unicode value, <see cref="StrFormatByteSizeW" /> is used.</para>
      <para>In Windows 10, size is reported in base 10 rather than  base 2. For example, 1 KB is 1000 bytes rather than 1024.</para>
      <para>The following table illustrates how this function converts a numeric value into a text string.</para>
      <list type="table">
        <listheader>
          <description>Numeric value</description>
          <description>Text string</description>
        </listheader>
        <item>
          <description>532</description>
          <description>532 bytes</description>
        </item>
        <item>
          <description>1340</description>
          <description>1.30 KB</description>
        </item>
        <item>
          <description>23506</description>
          <description>23.5 KB</description>
        </item>
        <item>
          <description>2400016</description>
          <description>2.40 MB</description>
        </item>
        <item>
          <description>2400000000</description>
          <description>2.4 GB</description>
        </item>
      </list>
    </remarks>
    <seealso cref="StrFormatByteSizeA" />
    <seealso cref="StrFormatByteSizeW" />
  </member>
  <member name="Windows.StrFormatByteSize64A">
    <summary>
      <para>Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or gigabytes, depending on the size.</para>
    </summary>
    <param name="qdw">
      <para>Type: <b>LONGLONG</b></para>
      <para>The numeric value to be converted.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>PSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted number.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of the buffer pointed to by <i>pszBuf</i>, in characters.</para>
    </param>
    <returns>
      <para>Type: <b>PSTR</b></para>
      <para>Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.</para>
    </returns>
    <remarks>
      <para>
        <b>StrFormatByteSize64</b> can be used for either ANSI or Unicode characters. However, while <b>StrFormatByteSize64A</b> can be called directly, <b>StrFormatByteSize64W</b> is not defined. When <b>StrFormatByteSize64</b> is called with a Unicode value, <see cref="StrFormatByteSizeW" /> is used.</para>
      <para>In Windows 10, size is reported in base 10 rather than  base 2. For example, 1 KB is 1000 bytes rather than 1024.</para>
      <para>The following table illustrates how this function converts a numeric value into a text string.</para>
      <list type="table">
        <listheader>
          <description>Numeric value</description>
          <description>Text string</description>
        </listheader>
        <item>
          <description>532</description>
          <description>532 bytes</description>
        </item>
        <item>
          <description>1340</description>
          <description>1.30 KB</description>
        </item>
        <item>
          <description>23506</description>
          <description>23.5 KB</description>
        </item>
        <item>
          <description>2400016</description>
          <description>2.40 MB</description>
        </item>
        <item>
          <description>2400000000</description>
          <description>2.4 GB</description>
        </item>
      </list>
    </remarks>
    <seealso cref="StrFormatByteSizeA" />
    <seealso cref="StrFormatByteSizeW" />
  </member>
  <member name="Windows.StrFormatByteSizeA">
    <summary>
      <para>Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or gigabytes, depending on the size. Differs from <see cref="StrFormatByteSizeW" /> in one parameter type.</para>
    </summary>
    <param name="dw">
      <para>Type: <b>DWORD</b></para>
      <para>The numeric value to be converted.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>PSTR</b></para>
      <para>A pointer to a buffer that receives the converted string.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of the buffer pointed to by <i>pszBuf</i>, in characters.</para>
    </param>
    <returns>
      <para>Type: <b>PSTR</b></para>
      <para>Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.</para>
    </returns>
    <remarks>
      <para>The first parameter of this function has a different type for the ANSI and Unicode versions. If your numeric value is a <b>DWORD</b>, you can use <b>StrFormatByteSize</b> with text macros for both cases. The compiler will cast the numerical value to a <b>LONGLONG</b> for the Unicode case. If your numerical value is a <b>LONGLONG</b>, you should use <see cref="StrFormatByteSizeW" /> explicitly.</para>
      <para>In Windows 10, size is reported in base 10 rather than  base 2. For example, 1 KB is 1000 bytes rather than 1024.</para>
      <para>The following table illustrates how this function converts a numeric value into a text string.</para>
      <list type="table">
        <listheader>
          <description>Numeric value</description>
          <description>Text string</description>
        </listheader>
        <item>
          <description>532</description>
          <description>532 bytes</description>
        </item>
        <item>
          <description>1340</description>
          <description>1.30 KB</description>
        </item>
        <item>
          <description>23506</description>
          <description>22.9 KB</description>
        </item>
        <item>
          <description>2400016</description>
          <description>2.28 MB</description>
        </item>
        <item>
          <description>2400000000</description>
          <description>2.23 GB</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrFormatByteSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrFormatByteSize64" />
    <seealso cref="StrFormatByteSizeEx" />
    <seealso cref="StrFormatByteSizeW" />
  </member>
  <member name="Windows.StrFormatByteSizeEx">
    <summary>
      <para>Converts a numeric value into a string that represents the number in bytes, kilobytes, megabytes, or gigabytes, depending on the size. Extends <see cref="StrFormatByteSizeW" /> by offering the option to round to the nearest displayed digit or to discard undisplayed digits.</para>
    </summary>
    <param name="ull">
      <para>Type: <b>ULONGLONG</b></para>
      <para>The numeric value to be converted.</para>
    </param>
    <param name="flags">
      <para>Type: <b><see cref="SFBS_FLAGS" /></b></para>
      <para>One of the <see cref="SFBS_FLAGS" /> enumeration values that specifies whether to round or truncate undisplayed digits. This value cannot be NULL.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>PWSTR</b></para>
      <para>A pointer to a buffer that receives the converted string.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of the buffer pointed to by <i>pszBuf</i>, in characters.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>The following table illustrates how this function converts a numeric value into a text string in relation to the passed flag.</para>
      <list type="table">
        <listheader>
          <description>Numeric value</description>
          <description>Flag</description>
          <description>Text string</description>
        </listheader>
        <item>
          <description>2147483647</description>
          <description>SFBS_FLAGS_ROUND_TO_NEAREST_DISPLAYED_DIGIT</description>
          <description>2.00 GB</description>
        </item>
        <item>
          <description>2147483647</description>
          <description>SFBS_FLAGS_TRUNCATE_UNDISPLAYED_DECIMAL_DIGITS</description>
          <description>1.99 GB</description>
        </item>
      </list>
      <para>In Windows 10, size is reported in base 10 rather than  base 2. For example, 1 KB is 1000 bytes rather than 1024.</para>
    </remarks>
    <seealso cref="StrFormatByteSize64" />
    <seealso cref="StrFormatByteSizeA" />
    <seealso cref="StrFormatByteSizeW" />
  </member>
  <member name="Windows.StrFormatByteSizeW">
    <summary>
      <para>Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or gigabytes, depending on the size. Differs from <see cref="StrFormatByteSizeA" /> in one parameter type.</para>
    </summary>
    <param name="qdw">
      <para>Type: <b>LONGLONG</b></para>
      <para>The numeric value to be converted.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>PWSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted number.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of the buffer pointed to by <i>pszBuf</i>, in characters.</para>
    </param>
    <returns>
      <para>Type: <b>PWSTR</b></para>
      <para>Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.</para>
    </returns>
    <remarks>
      <para>The first parameter of this function has different types for the ANSI and Unicode versions. If your numeric value is a <b>DWORD</b>, you can use <b>StrFormatByteSize</b> with text macros for both cases. The compiler will cast the numerical value to a <b>LONGLONG</b> for the Unicode case. If your numerical value is a <b>LONGLONG</b>, you should use <b>StrFormatByteSizeW</b> explicitly.</para>
      <para>In Windows 10, size is reported in base 10 rather than  base 2. For example, 1 KB is 1000 bytes rather than 1024.</para>
      <para>The following table illustrates how this function converts a numeric value into a text string.</para>
      <list type="table">
        <listheader>
          <description>Numeric value</description>
          <description>Text string</description>
        </listheader>
        <item>
          <description>532</description>
          <description>532 bytes</description>
        </item>
        <item>
          <description>1340</description>
          <description>1.30 KB</description>
        </item>
        <item>
          <description>23506</description>
          <description>22.9 KB</description>
        </item>
        <item>
          <description>2400016</description>
          <description>2.28 MB</description>
        </item>
        <item>
          <description>2400000000</description>
          <description>2.23 GB</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrFormatByteSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrFormatByteSize64" />
    <seealso cref="StrFormatByteSizeA" />
    <seealso cref="StrFormatByteSizeEx" />
  </member>
  <member name="Windows.StrFormatKBSize">
    <summary>
      <para>Converts a numeric value into a string that represents the number expressed as a size value in kilobytes.</para>
    </summary>
    <param name="qdw">
      <para>Type: <b>LONGLONG</b></para>
      <para>The numeric value to be converted.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted number.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of <i>pszBuf</i>, in characters.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.</para>
    </returns>
    <remarks>
      <para>In Windows 10, size is reported in base 10 rather than  base 2. For example, 1 KB is 1000 bytes rather than 1024.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrFormatKBSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrFormatByteSizeA" />
    <seealso cref="StrFormatByteSizeW" />
  </member>
  <member name="Windows.StrFormatKBSizeA">
    <summary>
      <para>Converts a numeric value into a string that represents the number expressed as a size value in kilobytes.</para>
    </summary>
    <param name="qdw">
      <para>Type: <b>LONGLONG</b></para>
      <para>The numeric value to be converted.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted number.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of <i>pszBuf</i>, in characters.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.</para>
    </returns>
    <remarks>
      <para>In Windows 10, size is reported in base 10 rather than  base 2. For example, 1 KB is 1000 bytes rather than 1024.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrFormatKBSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrFormatByteSizeA" />
    <seealso cref="StrFormatByteSizeW" />
  </member>
  <member name="Windows.StrFormatKBSizeW">
    <summary>
      <para>Converts a numeric value into a string that represents the number expressed as a size value in kilobytes.</para>
    </summary>
    <param name="qdw">
      <para>Type: <b>LONGLONG</b></para>
      <para>The numeric value to be converted.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted number.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of <i>pszBuf</i>, in characters.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.</para>
    </returns>
    <remarks>
      <para>In Windows 10, size is reported in base 10 rather than  base 2. For example, 1 KB is 1000 bytes rather than 1024.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrFormatKBSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrFormatByteSizeA" />
    <seealso cref="StrFormatByteSizeW" />
  </member>
  <member name="Windows.StrFormatKBSize">
    <summary>
      <para>Converts a numeric value into a string that represents the number expressed as a size value in kilobytes.</para>
    </summary>
    <param name="qdw">
      <para>Type: <b>LONGLONG</b></para>
      <para>The numeric value to be converted.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted number.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of <i>pszBuf</i>, in characters.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.</para>
    </returns>
    <remarks>
      <para>In Windows 10, size is reported in base 10 rather than  base 2. For example, 1 KB is 1000 bytes rather than 1024.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrFormatKBSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrFormatByteSizeA" />
    <seealso cref="StrFormatByteSizeW" />
  </member>
  <member name="Windows.StrFormatKBSizeA">
    <summary>
      <para>Converts a numeric value into a string that represents the number expressed as a size value in kilobytes.</para>
    </summary>
    <param name="qdw">
      <para>Type: <b>LONGLONG</b></para>
      <para>The numeric value to be converted.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted number.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of <i>pszBuf</i>, in characters.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.</para>
    </returns>
    <remarks>
      <para>In Windows 10, size is reported in base 10 rather than  base 2. For example, 1 KB is 1000 bytes rather than 1024.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrFormatKBSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrFormatByteSizeA" />
    <seealso cref="StrFormatByteSizeW" />
  </member>
  <member name="Windows.StrFormatKBSizeW">
    <summary>
      <para>Converts a numeric value into a string that represents the number expressed as a size value in kilobytes.</para>
    </summary>
    <param name="qdw">
      <para>Type: <b>LONGLONG</b></para>
      <para>The numeric value to be converted.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted number.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of <i>pszBuf</i>, in characters.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the converted string, or <b>NULL</b> if the conversion fails.</para>
    </returns>
    <remarks>
      <para>In Windows 10, size is reported in base 10 rather than  base 2. For example, 1 KB is 1000 bytes rather than 1024.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrFormatKBSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrFormatByteSizeA" />
    <seealso cref="StrFormatByteSizeW" />
  </member>
  <member name="Windows.StrFromTimeInterval">
    <summary>
      <para>Converts a time interval, specified in milliseconds, to a string.</para>
    </summary>
    <param name="pszOut">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted number.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>UINT</b></para>
      <para>The size of <i>pszOut</i>, in characters. If <i>cchMax</i> is set to zero, <b>StrFromTimeInterval</b> will return the minimum size of the character buffer needed to hold the converted string. In this case, <i>pszOut</i> will not contain the converted string.</para>
    </param>
    <param name="dwTimeMS">
      <para>Type: <b>DWORD</b></para>
      <para>The time interval, in milliseconds.</para>
    </param>
    <param name="digits">
      <para>Type: <b>int</b></para>
      <para>The maximum number of significant digits to be represented in <i>pszOut</i>. Some examples are:</para>
      <list type="table">
        <listheader>
          <description>dwTimeMS</description>
          <description>digits</description>
          <description>pszOut</description>
        </listheader>
        <item>
          <description>34000</description>
          <description>3</description>
          <description>34 sec</description>
        </item>
        <item>
          <description>34000</description>
          <description>2</description>
          <description>34 sec</description>
        </item>
        <item>
          <description>34000</description>
          <description>1</description>
          <description>30 sec</description>
        </item>
        <item>
          <description>74000</description>
          <description>3</description>
          <description>1 min 14 sec</description>
        </item>
        <item>
          <description>74000</description>
          <description>2</description>
          <description>1 min 10 sec</description>
        </item>
        <item>
          <description>74000</description>
          <description>1</description>
          <description>1 min</description>
        </item>
      </list>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the number of characters in <i>pszOut</i>, excluding the terminating <b>NULL</b> character.</para>
    </returns>
    <remarks>
      <para>The time value returned in <i>pszOut</i> will always be in the form <i>hh</i> hours <i>mm</i> minutes <i>ss</i> seconds. Times that exceed twenty four hours are not converted to days or months. Fractions of seconds are ignored.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
    char TimeString[256];
    char *pszOut;
    pszOut = TimeString;

    cout &lt;&lt; "The return value from the call to"
         &lt;&lt; "\nthe function StrFromTimeInterval will"
         &lt;&lt; "\nreturn the number of elements in the buffer: " &lt;&lt; endl;

    cout &lt;&lt; "\nThe return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 34000,30);

    cout &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;

    cout &lt;&lt; "The return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 74000,3);

    cout &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;

    cout &lt;&lt; "The return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 74000,2);

    cout &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;

    cout &lt;&lt; "The return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 74000,1)
         &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;
}

OUTPUT:
- - - - -
The return value from the call to
the function StrFromTimeInterval will
return the number of elements in the buffer:

The return from StrFromTimeInterval is 7
The contents of the TimeString Buffer  34 sec
The return from StrFromTimeInterval is 13
The contents of the TimeString Buffer  1 min 14 sec
The return from StrFromTimeInterval is 13
The contents of the TimeString Buffer  1 min 10 sec
The return from StrFromTimeInterval is 6
The contents of the TimeString Buffer  1 min
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrFromTimeInterval as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrFromTimeIntervalA">
    <summary>
      <para>Converts a time interval, specified in milliseconds, to a string.</para>
    </summary>
    <param name="pszOut">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted number.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>UINT</b></para>
      <para>The size of <i>pszOut</i>, in characters. If <i>cchMax</i> is set to zero, <b>StrFromTimeInterval</b> will return the minimum size of the character buffer needed to hold the converted string. In this case, <i>pszOut</i> will not contain the converted string.</para>
    </param>
    <param name="dwTimeMS">
      <para>Type: <b>DWORD</b></para>
      <para>The time interval, in milliseconds.</para>
    </param>
    <param name="digits">
      <para>Type: <b>int</b></para>
      <para>The maximum number of significant digits to be represented in <i>pszOut</i>. Some examples are:</para>
      <list type="table">
        <listheader>
          <description>dwTimeMS</description>
          <description>digits</description>
          <description>pszOut</description>
        </listheader>
        <item>
          <description>34000</description>
          <description>3</description>
          <description>34 sec</description>
        </item>
        <item>
          <description>34000</description>
          <description>2</description>
          <description>34 sec</description>
        </item>
        <item>
          <description>34000</description>
          <description>1</description>
          <description>30 sec</description>
        </item>
        <item>
          <description>74000</description>
          <description>3</description>
          <description>1 min 14 sec</description>
        </item>
        <item>
          <description>74000</description>
          <description>2</description>
          <description>1 min 10 sec</description>
        </item>
        <item>
          <description>74000</description>
          <description>1</description>
          <description>1 min</description>
        </item>
      </list>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the number of characters in <i>pszOut</i>, excluding the terminating <b>NULL</b> character.</para>
    </returns>
    <remarks>
      <para>The time value returned in <i>pszOut</i> will always be in the form <i>hh</i> hours <i>mm</i> minutes <i>ss</i> seconds. Times that exceed twenty four hours are not converted to days or months. Fractions of seconds are ignored.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
    char TimeString[256];
    char *pszOut;
    pszOut = TimeString;

    cout &lt;&lt; "The return value from the call to"
         &lt;&lt; "\nthe function StrFromTimeInterval will"
         &lt;&lt; "\nreturn the number of elements in the buffer: " &lt;&lt; endl;

    cout &lt;&lt; "\nThe return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 34000,30);

    cout &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;

    cout &lt;&lt; "The return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 74000,3);

    cout &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;

    cout &lt;&lt; "The return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 74000,2);

    cout &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;

    cout &lt;&lt; "The return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 74000,1)
         &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;
}

OUTPUT:
- - - - -
The return value from the call to
the function StrFromTimeInterval will
return the number of elements in the buffer:

The return from StrFromTimeInterval is 7
The contents of the TimeString Buffer  34 sec
The return from StrFromTimeInterval is 13
The contents of the TimeString Buffer  1 min 14 sec
The return from StrFromTimeInterval is 13
The contents of the TimeString Buffer  1 min 10 sec
The return from StrFromTimeInterval is 6
The contents of the TimeString Buffer  1 min
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrFromTimeInterval as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrFromTimeIntervalW">
    <summary>
      <para>Converts a time interval, specified in milliseconds, to a string.</para>
    </summary>
    <param name="pszOut">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted number.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>UINT</b></para>
      <para>The size of <i>pszOut</i>, in characters. If <i>cchMax</i> is set to zero, <b>StrFromTimeInterval</b> will return the minimum size of the character buffer needed to hold the converted string. In this case, <i>pszOut</i> will not contain the converted string.</para>
    </param>
    <param name="dwTimeMS">
      <para>Type: <b>DWORD</b></para>
      <para>The time interval, in milliseconds.</para>
    </param>
    <param name="digits">
      <para>Type: <b>int</b></para>
      <para>The maximum number of significant digits to be represented in <i>pszOut</i>. Some examples are:</para>
      <list type="table">
        <listheader>
          <description>dwTimeMS</description>
          <description>digits</description>
          <description>pszOut</description>
        </listheader>
        <item>
          <description>34000</description>
          <description>3</description>
          <description>34 sec</description>
        </item>
        <item>
          <description>34000</description>
          <description>2</description>
          <description>34 sec</description>
        </item>
        <item>
          <description>34000</description>
          <description>1</description>
          <description>30 sec</description>
        </item>
        <item>
          <description>74000</description>
          <description>3</description>
          <description>1 min 14 sec</description>
        </item>
        <item>
          <description>74000</description>
          <description>2</description>
          <description>1 min 10 sec</description>
        </item>
        <item>
          <description>74000</description>
          <description>1</description>
          <description>1 min</description>
        </item>
      </list>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the number of characters in <i>pszOut</i>, excluding the terminating <b>NULL</b> character.</para>
    </returns>
    <remarks>
      <para>The time value returned in <i>pszOut</i> will always be in the form <i>hh</i> hours <i>mm</i> minutes <i>ss</i> seconds. Times that exceed twenty four hours are not converted to days or months. Fractions of seconds are ignored.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
    char TimeString[256];
    char *pszOut;
    pszOut = TimeString;

    cout &lt;&lt; "The return value from the call to"
         &lt;&lt; "\nthe function StrFromTimeInterval will"
         &lt;&lt; "\nreturn the number of elements in the buffer: " &lt;&lt; endl;

    cout &lt;&lt; "\nThe return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 34000,30);

    cout &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;

    cout &lt;&lt; "The return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 74000,3);

    cout &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;

    cout &lt;&lt; "The return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 74000,2);

    cout &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;

    cout &lt;&lt; "The return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 74000,1)
         &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;
}

OUTPUT:
- - - - -
The return value from the call to
the function StrFromTimeInterval will
return the number of elements in the buffer:

The return from StrFromTimeInterval is 7
The contents of the TimeString Buffer  34 sec
The return from StrFromTimeInterval is 13
The contents of the TimeString Buffer  1 min 14 sec
The return from StrFromTimeInterval is 13
The contents of the TimeString Buffer  1 min 10 sec
The return from StrFromTimeInterval is 6
The contents of the TimeString Buffer  1 min
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrFromTimeInterval as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrFromTimeInterval">
    <summary>
      <para>Converts a time interval, specified in milliseconds, to a string.</para>
    </summary>
    <param name="pszOut">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted number.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>UINT</b></para>
      <para>The size of <i>pszOut</i>, in characters. If <i>cchMax</i> is set to zero, <b>StrFromTimeInterval</b> will return the minimum size of the character buffer needed to hold the converted string. In this case, <i>pszOut</i> will not contain the converted string.</para>
    </param>
    <param name="dwTimeMS">
      <para>Type: <b>DWORD</b></para>
      <para>The time interval, in milliseconds.</para>
    </param>
    <param name="digits">
      <para>Type: <b>int</b></para>
      <para>The maximum number of significant digits to be represented in <i>pszOut</i>. Some examples are:</para>
      <list type="table">
        <listheader>
          <description>dwTimeMS</description>
          <description>digits</description>
          <description>pszOut</description>
        </listheader>
        <item>
          <description>34000</description>
          <description>3</description>
          <description>34 sec</description>
        </item>
        <item>
          <description>34000</description>
          <description>2</description>
          <description>34 sec</description>
        </item>
        <item>
          <description>34000</description>
          <description>1</description>
          <description>30 sec</description>
        </item>
        <item>
          <description>74000</description>
          <description>3</description>
          <description>1 min 14 sec</description>
        </item>
        <item>
          <description>74000</description>
          <description>2</description>
          <description>1 min 10 sec</description>
        </item>
        <item>
          <description>74000</description>
          <description>1</description>
          <description>1 min</description>
        </item>
      </list>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the number of characters in <i>pszOut</i>, excluding the terminating <b>NULL</b> character.</para>
    </returns>
    <remarks>
      <para>The time value returned in <i>pszOut</i> will always be in the form <i>hh</i> hours <i>mm</i> minutes <i>ss</i> seconds. Times that exceed twenty four hours are not converted to days or months. Fractions of seconds are ignored.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
    char TimeString[256];
    char *pszOut;
    pszOut = TimeString;

    cout &lt;&lt; "The return value from the call to"
         &lt;&lt; "\nthe function StrFromTimeInterval will"
         &lt;&lt; "\nreturn the number of elements in the buffer: " &lt;&lt; endl;

    cout &lt;&lt; "\nThe return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 34000,30);

    cout &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;

    cout &lt;&lt; "The return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 74000,3);

    cout &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;

    cout &lt;&lt; "The return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 74000,2);

    cout &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;

    cout &lt;&lt; "The return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 74000,1)
         &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;
}

OUTPUT:
- - - - -
The return value from the call to
the function StrFromTimeInterval will
return the number of elements in the buffer:

The return from StrFromTimeInterval is 7
The contents of the TimeString Buffer  34 sec
The return from StrFromTimeInterval is 13
The contents of the TimeString Buffer  1 min 14 sec
The return from StrFromTimeInterval is 13
The contents of the TimeString Buffer  1 min 10 sec
The return from StrFromTimeInterval is 6
The contents of the TimeString Buffer  1 min
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrFromTimeInterval as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrFromTimeIntervalA">
    <summary>
      <para>Converts a time interval, specified in milliseconds, to a string.</para>
    </summary>
    <param name="pszOut">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted number.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>UINT</b></para>
      <para>The size of <i>pszOut</i>, in characters. If <i>cchMax</i> is set to zero, <b>StrFromTimeInterval</b> will return the minimum size of the character buffer needed to hold the converted string. In this case, <i>pszOut</i> will not contain the converted string.</para>
    </param>
    <param name="dwTimeMS">
      <para>Type: <b>DWORD</b></para>
      <para>The time interval, in milliseconds.</para>
    </param>
    <param name="digits">
      <para>Type: <b>int</b></para>
      <para>The maximum number of significant digits to be represented in <i>pszOut</i>. Some examples are:</para>
      <list type="table">
        <listheader>
          <description>dwTimeMS</description>
          <description>digits</description>
          <description>pszOut</description>
        </listheader>
        <item>
          <description>34000</description>
          <description>3</description>
          <description>34 sec</description>
        </item>
        <item>
          <description>34000</description>
          <description>2</description>
          <description>34 sec</description>
        </item>
        <item>
          <description>34000</description>
          <description>1</description>
          <description>30 sec</description>
        </item>
        <item>
          <description>74000</description>
          <description>3</description>
          <description>1 min 14 sec</description>
        </item>
        <item>
          <description>74000</description>
          <description>2</description>
          <description>1 min 10 sec</description>
        </item>
        <item>
          <description>74000</description>
          <description>1</description>
          <description>1 min</description>
        </item>
      </list>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the number of characters in <i>pszOut</i>, excluding the terminating <b>NULL</b> character.</para>
    </returns>
    <remarks>
      <para>The time value returned in <i>pszOut</i> will always be in the form <i>hh</i> hours <i>mm</i> minutes <i>ss</i> seconds. Times that exceed twenty four hours are not converted to days or months. Fractions of seconds are ignored.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
    char TimeString[256];
    char *pszOut;
    pszOut = TimeString;

    cout &lt;&lt; "The return value from the call to"
         &lt;&lt; "\nthe function StrFromTimeInterval will"
         &lt;&lt; "\nreturn the number of elements in the buffer: " &lt;&lt; endl;

    cout &lt;&lt; "\nThe return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 34000,30);

    cout &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;

    cout &lt;&lt; "The return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 74000,3);

    cout &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;

    cout &lt;&lt; "The return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 74000,2);

    cout &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;

    cout &lt;&lt; "The return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 74000,1)
         &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;
}

OUTPUT:
- - - - -
The return value from the call to
the function StrFromTimeInterval will
return the number of elements in the buffer:

The return from StrFromTimeInterval is 7
The contents of the TimeString Buffer  34 sec
The return from StrFromTimeInterval is 13
The contents of the TimeString Buffer  1 min 14 sec
The return from StrFromTimeInterval is 13
The contents of the TimeString Buffer  1 min 10 sec
The return from StrFromTimeInterval is 6
The contents of the TimeString Buffer  1 min
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrFromTimeInterval as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrFromTimeIntervalW">
    <summary>
      <para>Converts a time interval, specified in milliseconds, to a string.</para>
    </summary>
    <param name="pszOut">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted number.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>UINT</b></para>
      <para>The size of <i>pszOut</i>, in characters. If <i>cchMax</i> is set to zero, <b>StrFromTimeInterval</b> will return the minimum size of the character buffer needed to hold the converted string. In this case, <i>pszOut</i> will not contain the converted string.</para>
    </param>
    <param name="dwTimeMS">
      <para>Type: <b>DWORD</b></para>
      <para>The time interval, in milliseconds.</para>
    </param>
    <param name="digits">
      <para>Type: <b>int</b></para>
      <para>The maximum number of significant digits to be represented in <i>pszOut</i>. Some examples are:</para>
      <list type="table">
        <listheader>
          <description>dwTimeMS</description>
          <description>digits</description>
          <description>pszOut</description>
        </listheader>
        <item>
          <description>34000</description>
          <description>3</description>
          <description>34 sec</description>
        </item>
        <item>
          <description>34000</description>
          <description>2</description>
          <description>34 sec</description>
        </item>
        <item>
          <description>34000</description>
          <description>1</description>
          <description>30 sec</description>
        </item>
        <item>
          <description>74000</description>
          <description>3</description>
          <description>1 min 14 sec</description>
        </item>
        <item>
          <description>74000</description>
          <description>2</description>
          <description>1 min 10 sec</description>
        </item>
        <item>
          <description>74000</description>
          <description>1</description>
          <description>1 min</description>
        </item>
      </list>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the number of characters in <i>pszOut</i>, excluding the terminating <b>NULL</b> character.</para>
    </returns>
    <remarks>
      <para>The time value returned in <i>pszOut</i> will always be in the form <i>hh</i> hours <i>mm</i> minutes <i>ss</i> seconds. Times that exceed twenty four hours are not converted to days or months. Fractions of seconds are ignored.</para>
      <h4>Examples</h4>
      <code>#include &lt;windows.h&gt;
#include &lt;iostream.h&gt;
#include "Shlwapi.h"

void main(void)
{
    char TimeString[256];
    char *pszOut;
    pszOut = TimeString;

    cout &lt;&lt; "The return value from the call to"
         &lt;&lt; "\nthe function StrFromTimeInterval will"
         &lt;&lt; "\nreturn the number of elements in the buffer: " &lt;&lt; endl;

    cout &lt;&lt; "\nThe return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 34000,30);

    cout &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;

    cout &lt;&lt; "The return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 74000,3);

    cout &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;

    cout &lt;&lt; "The return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 74000,2);

    cout &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;

    cout &lt;&lt; "The return from StrFromTimeInterval is "
         &lt;&lt; StrFromTimeInterval(pszOut,30, 74000,1)
         &lt;&lt; "\nThe contents of the TimeString Buffer " &lt;&lt; pszOut &lt;&lt; endl;
}

OUTPUT:
- - - - -
The return value from the call to
the function StrFromTimeInterval will
return the number of elements in the buffer:

The return from StrFromTimeInterval is 7
The contents of the TimeString Buffer  34 sec
The return from StrFromTimeInterval is 13
The contents of the TimeString Buffer  1 min 14 sec
The return from StrFromTimeInterval is 13
The contents of the TimeString Buffer  1 min 10 sec
The return from StrFromTimeInterval is 6
The contents of the TimeString Buffer  1 min
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrFromTimeInterval as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrIsIntlEqual">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings to determine if they are equal.</para>
    </summary>
    <param name="fCaseSens">
      <para>Type: <b>BOOL</b></para>
      <para>The case sensitivity of the comparison. If this value is nonzero, the comparison is case-sensitive. If this value is zero, the comparison is not case-sensitive.</para>
    </param>
    <param name="pszString1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszString2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if the first <i>nChar</i> characters from the two strings are equal; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>You can set case sensitivity with the <b>StrIntlEqN</b> and <b>StrIntlEqNI</b> macros. <b>StrIntlEqN</b> performs a case-sensitive comparison, and <b>StrIntlEqNI</b> performs a case-insensitive comparison.</para>
      <para>The syntax of the two macros is:</para>
      <code>#define StrIntlEqN(s1, s2, nChar) StrIsIntlEqual(TRUE, s1, s2, nChar)
#define StrIntlEqNI(s1, s2, nChar) StrIsIntlEqual(FALSE, s1, s2, nChar)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrIsIntlEqual as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrIsIntlEqualA">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings to determine if they are equal.</para>
    </summary>
    <param name="fCaseSens">
      <para>Type: <b>BOOL</b></para>
      <para>The case sensitivity of the comparison. If this value is nonzero, the comparison is case-sensitive. If this value is zero, the comparison is not case-sensitive.</para>
    </param>
    <param name="pszString1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszString2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if the first <i>nChar</i> characters from the two strings are equal; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>You can set case sensitivity with the <b>StrIntlEqN</b> and <b>StrIntlEqNI</b> macros. <b>StrIntlEqN</b> performs a case-sensitive comparison, and <b>StrIntlEqNI</b> performs a case-insensitive comparison.</para>
      <para>The syntax of the two macros is:</para>
      <code>#define StrIntlEqN(s1, s2, nChar) StrIsIntlEqual(TRUE, s1, s2, nChar)
#define StrIntlEqNI(s1, s2, nChar) StrIsIntlEqual(FALSE, s1, s2, nChar)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrIsIntlEqual as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrIsIntlEqualW">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings to determine if they are equal.</para>
    </summary>
    <param name="fCaseSens">
      <para>Type: <b>BOOL</b></para>
      <para>The case sensitivity of the comparison. If this value is nonzero, the comparison is case-sensitive. If this value is zero, the comparison is not case-sensitive.</para>
    </param>
    <param name="pszString1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszString2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if the first <i>nChar</i> characters from the two strings are equal; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>You can set case sensitivity with the <b>StrIntlEqN</b> and <b>StrIntlEqNI</b> macros. <b>StrIntlEqN</b> performs a case-sensitive comparison, and <b>StrIntlEqNI</b> performs a case-insensitive comparison.</para>
      <para>The syntax of the two macros is:</para>
      <code>#define StrIntlEqN(s1, s2, nChar) StrIsIntlEqual(TRUE, s1, s2, nChar)
#define StrIntlEqNI(s1, s2, nChar) StrIsIntlEqual(FALSE, s1, s2, nChar)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrIsIntlEqual as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrIsIntlEqual">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings to determine if they are equal.</para>
    </summary>
    <param name="fCaseSens">
      <para>Type: <b>BOOL</b></para>
      <para>The case sensitivity of the comparison. If this value is nonzero, the comparison is case-sensitive. If this value is zero, the comparison is not case-sensitive.</para>
    </param>
    <param name="pszString1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszString2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if the first <i>nChar</i> characters from the two strings are equal; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>You can set case sensitivity with the <b>StrIntlEqN</b> and <b>StrIntlEqNI</b> macros. <b>StrIntlEqN</b> performs a case-sensitive comparison, and <b>StrIntlEqNI</b> performs a case-insensitive comparison.</para>
      <para>The syntax of the two macros is:</para>
      <code>#define StrIntlEqN(s1, s2, nChar) StrIsIntlEqual(TRUE, s1, s2, nChar)
#define StrIntlEqNI(s1, s2, nChar) StrIsIntlEqual(FALSE, s1, s2, nChar)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrIsIntlEqual as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrIsIntlEqualA">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings to determine if they are equal.</para>
    </summary>
    <param name="fCaseSens">
      <para>Type: <b>BOOL</b></para>
      <para>The case sensitivity of the comparison. If this value is nonzero, the comparison is case-sensitive. If this value is zero, the comparison is not case-sensitive.</para>
    </param>
    <param name="pszString1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszString2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if the first <i>nChar</i> characters from the two strings are equal; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>You can set case sensitivity with the <b>StrIntlEqN</b> and <b>StrIntlEqNI</b> macros. <b>StrIntlEqN</b> performs a case-sensitive comparison, and <b>StrIntlEqNI</b> performs a case-insensitive comparison.</para>
      <para>The syntax of the two macros is:</para>
      <code>#define StrIntlEqN(s1, s2, nChar) StrIsIntlEqual(TRUE, s1, s2, nChar)
#define StrIntlEqNI(s1, s2, nChar) StrIsIntlEqual(FALSE, s1, s2, nChar)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrIsIntlEqual as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrIsIntlEqualW">
    <summary>
      <para>Compares a specified number of characters from the beginning of two strings to determine if they are equal.</para>
    </summary>
    <param name="fCaseSens">
      <para>Type: <b>BOOL</b></para>
      <para>The case sensitivity of the comparison. If this value is nonzero, the comparison is case-sensitive. If this value is zero, the comparison is not case-sensitive.</para>
    </param>
    <param name="pszString1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the first null-terminated string to be compared.</para>
    </param>
    <param name="pszString2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the second null-terminated string to be compared.</para>
    </param>
    <param name="nChar">
      <para>Type: <b>int</b></para>
      <para>The number of characters from the beginning of each string to be compared.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if the first <i>nChar</i> characters from the two strings are equal; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>You can set case sensitivity with the <b>StrIntlEqN</b> and <b>StrIntlEqNI</b> macros. <b>StrIntlEqN</b> performs a case-sensitive comparison, and <b>StrIntlEqNI</b> performs a case-insensitive comparison.</para>
      <para>The syntax of the two macros is:</para>
      <code>#define StrIntlEqN(s1, s2, nChar) StrIsIntlEqual(TRUE, s1, s2, nChar)
#define StrIntlEqNI(s1, s2, nChar) StrIsIntlEqual(FALSE, s1, s2, nChar)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrIsIntlEqual as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrNCat">
    <summary>
      <para>Appends a specified number of characters from the beginning of one string to the end of another.</para>
      <para>
        <b>Note</b>  Do not use this function or the <b>StrCatN</b> macro. See Remarks for alternative functions.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string to which the function appends the characters from <i>psz2</i>. It must be large enough to hold the combined strings plus the terminating null character.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be appended.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be appended to <i>psz1</i> from the beginning of <i>psz2</i>.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to <i>psz1</i>, which holds the combined string.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The first argument, <i>psz1</i>, must be large enough to hold <i>psz2</i> and the closing '\0', otherwise a buffer overrun may occur. Buffer overruns may lead to a denial of service attack against the application if an access violation occurs. In the worst case, a buffer overrun may allow an attacker to inject executable code into your process, especially if <i>psz1</i> is a stack-based buffer. Be aware that the last argument, <i>cchMax</i>, is the number of characters to copy into <i>psz1</i>, not necessarily the size of the <i>psz1</i> in bytes. Consider using one of the following alternatives. <see cref="StringCbCat" />, <see cref="StringCbCatEx" />, <see cref="StringCbCatN" />, <see cref="StringCbCatNEx" />, <see cref="StringCchCat" />, <see cref="StringCchCatEx" />, <see cref="StringCchCatN" />, or <see cref="StringCchCatNEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrNCat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrNCatA">
    <summary>
      <para>Appends a specified number of characters from the beginning of one string to the end of another.</para>
      <para>
        <b>Note</b>  Do not use this function or the <b>StrCatN</b> macro. See Remarks for alternative functions.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string to which the function appends the characters from <i>psz2</i>. It must be large enough to hold the combined strings plus the terminating null character.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be appended.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be appended to <i>psz1</i> from the beginning of <i>psz2</i>.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to <i>psz1</i>, which holds the combined string.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The first argument, <i>psz1</i>, must be large enough to hold <i>psz2</i> and the closing '\0', otherwise a buffer overrun may occur. Buffer overruns may lead to a denial of service attack against the application if an access violation occurs. In the worst case, a buffer overrun may allow an attacker to inject executable code into your process, especially if <i>psz1</i> is a stack-based buffer. Be aware that the last argument, <i>cchMax</i>, is the number of characters to copy into <i>psz1</i>, not necessarily the size of the <i>psz1</i> in bytes. Consider using one of the following alternatives. <see cref="StringCbCat" />, <see cref="StringCbCatEx" />, <see cref="StringCbCatN" />, <see cref="StringCbCatNEx" />, <see cref="StringCchCat" />, <see cref="StringCchCatEx" />, <see cref="StringCchCatN" />, or <see cref="StringCchCatNEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrNCat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrNCatW">
    <summary>
      <para>Appends a specified number of characters from the beginning of one string to the end of another.</para>
      <para>
        <b>Note</b>  Do not use this function or the <b>StrCatN</b> macro. See Remarks for alternative functions.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string to which the function appends the characters from <i>psz2</i>. It must be large enough to hold the combined strings plus the terminating null character.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be appended.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be appended to <i>psz1</i> from the beginning of <i>psz2</i>.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to <i>psz1</i>, which holds the combined string.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The first argument, <i>psz1</i>, must be large enough to hold <i>psz2</i> and the closing '\0', otherwise a buffer overrun may occur. Buffer overruns may lead to a denial of service attack against the application if an access violation occurs. In the worst case, a buffer overrun may allow an attacker to inject executable code into your process, especially if <i>psz1</i> is a stack-based buffer. Be aware that the last argument, <i>cchMax</i>, is the number of characters to copy into <i>psz1</i>, not necessarily the size of the <i>psz1</i> in bytes. Consider using one of the following alternatives. <see cref="StringCbCat" />, <see cref="StringCbCatEx" />, <see cref="StringCbCatN" />, <see cref="StringCbCatNEx" />, <see cref="StringCchCat" />, <see cref="StringCchCatEx" />, <see cref="StringCchCatN" />, or <see cref="StringCchCatNEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrNCat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrNCat">
    <summary>
      <para>Appends a specified number of characters from the beginning of one string to the end of another.</para>
      <para>
        <b>Note</b>  Do not use this function or the <b>StrCatN</b> macro. See Remarks for alternative functions.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string to which the function appends the characters from <i>psz2</i>. It must be large enough to hold the combined strings plus the terminating null character.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be appended.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be appended to <i>psz1</i> from the beginning of <i>psz2</i>.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to <i>psz1</i>, which holds the combined string.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The first argument, <i>psz1</i>, must be large enough to hold <i>psz2</i> and the closing '\0', otherwise a buffer overrun may occur. Buffer overruns may lead to a denial of service attack against the application if an access violation occurs. In the worst case, a buffer overrun may allow an attacker to inject executable code into your process, especially if <i>psz1</i> is a stack-based buffer. Be aware that the last argument, <i>cchMax</i>, is the number of characters to copy into <i>psz1</i>, not necessarily the size of the <i>psz1</i> in bytes. Consider using one of the following alternatives. <see cref="StringCbCat" />, <see cref="StringCbCatEx" />, <see cref="StringCbCatN" />, <see cref="StringCbCatNEx" />, <see cref="StringCchCat" />, <see cref="StringCchCatEx" />, <see cref="StringCchCatN" />, or <see cref="StringCchCatNEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrNCat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrNCatA">
    <summary>
      <para>Appends a specified number of characters from the beginning of one string to the end of another.</para>
      <para>
        <b>Note</b>  Do not use this function or the <b>StrCatN</b> macro. See Remarks for alternative functions.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string to which the function appends the characters from <i>psz2</i>. It must be large enough to hold the combined strings plus the terminating null character.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be appended.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be appended to <i>psz1</i> from the beginning of <i>psz2</i>.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to <i>psz1</i>, which holds the combined string.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The first argument, <i>psz1</i>, must be large enough to hold <i>psz2</i> and the closing '\0', otherwise a buffer overrun may occur. Buffer overruns may lead to a denial of service attack against the application if an access violation occurs. In the worst case, a buffer overrun may allow an attacker to inject executable code into your process, especially if <i>psz1</i> is a stack-based buffer. Be aware that the last argument, <i>cchMax</i>, is the number of characters to copy into <i>psz1</i>, not necessarily the size of the <i>psz1</i> in bytes. Consider using one of the following alternatives. <see cref="StringCbCat" />, <see cref="StringCbCatEx" />, <see cref="StringCbCatN" />, <see cref="StringCbCatNEx" />, <see cref="StringCchCat" />, <see cref="StringCchCatEx" />, <see cref="StringCchCatN" />, or <see cref="StringCchCatNEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrNCat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrNCatW">
    <summary>
      <para>Appends a specified number of characters from the beginning of one string to the end of another.</para>
      <para>
        <b>Note</b>  Do not use this function or the <b>StrCatN</b> macro. See Remarks for alternative functions.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string to which the function appends the characters from <i>psz2</i>. It must be large enough to hold the combined strings plus the terminating null character.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be appended.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>int</b></para>
      <para>The number of characters to be appended to <i>psz1</i> from the beginning of <i>psz2</i>.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to <i>psz1</i>, which holds the combined string.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The first argument, <i>psz1</i>, must be large enough to hold <i>psz2</i> and the closing '\0', otherwise a buffer overrun may occur. Buffer overruns may lead to a denial of service attack against the application if an access violation occurs. In the worst case, a buffer overrun may allow an attacker to inject executable code into your process, especially if <i>psz1</i> is a stack-based buffer. Be aware that the last argument, <i>cchMax</i>, is the number of characters to copy into <i>psz1</i>, not necessarily the size of the <i>psz1</i> in bytes. Consider using one of the following alternatives. <see cref="StringCbCat" />, <see cref="StringCbCatEx" />, <see cref="StringCbCatN" />, <see cref="StringCbCatNEx" />, <see cref="StringCchCat" />, <see cref="StringCchCatEx" />, <see cref="StringCchCatN" />, or <see cref="StringCchCatNEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrNCat as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrPBrk">
    <summary>
      <para>Searches a string for the first occurrence of a character contained in a specified buffer. This search does not include the terminating null character.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated character buffer that contains the characters for which to search.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address in <i>psz</i> of the first occurrence of a character contained in the buffer at <i>pszSet</i>, or <b>NULL</b> if no match is found.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrPBrk as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrPBrkA">
    <summary>
      <para>Searches a string for the first occurrence of a character contained in a specified buffer. This search does not include the terminating null character.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated character buffer that contains the characters for which to search.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address in <i>psz</i> of the first occurrence of a character contained in the buffer at <i>pszSet</i>, or <b>NULL</b> if no match is found.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrPBrk as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrPBrkW">
    <summary>
      <para>Searches a string for the first occurrence of a character contained in a specified buffer. This search does not include the terminating null character.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated character buffer that contains the characters for which to search.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address in <i>psz</i> of the first occurrence of a character contained in the buffer at <i>pszSet</i>, or <b>NULL</b> if no match is found.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrPBrk as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrPBrk">
    <summary>
      <para>Searches a string for the first occurrence of a character contained in a specified buffer. This search does not include the terminating null character.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated character buffer that contains the characters for which to search.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address in <i>psz</i> of the first occurrence of a character contained in the buffer at <i>pszSet</i>, or <b>NULL</b> if no match is found.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrPBrk as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrPBrkA">
    <summary>
      <para>Searches a string for the first occurrence of a character contained in a specified buffer. This search does not include the terminating null character.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated character buffer that contains the characters for which to search.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address in <i>psz</i> of the first occurrence of a character contained in the buffer at <i>pszSet</i>, or <b>NULL</b> if no match is found.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrPBrk as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrPBrkW">
    <summary>
      <para>Searches a string for the first occurrence of a character contained in a specified buffer. This search does not include the terminating null character.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated character buffer that contains the characters for which to search.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address in <i>psz</i> of the first occurrence of a character contained in the buffer at <i>pszSet</i>, or <b>NULL</b> if no match is found.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrPBrk as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrRChr">
    <summary>
      <para>Searches a string for the last occurrence of a specified character. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszEnd">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to <b>NULL</b> to search the entire string.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the last occurrence of the character in the string, if successful, or <b>NULL</b> if not.</para>
    </returns>
    <remarks>
      <para>The comparison assumes that <i>pszEnd</i> points to the end of the string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRChr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrRChrA">
    <summary>
      <para>Searches a string for the last occurrence of a specified character. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszEnd">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to <b>NULL</b> to search the entire string.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the last occurrence of the character in the string, if successful, or <b>NULL</b> if not.</para>
    </returns>
    <remarks>
      <para>The comparison assumes that <i>pszEnd</i> points to the end of the string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRChr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrRChrW">
    <summary>
      <para>Searches a string for the last occurrence of a specified character. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszEnd">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to <b>NULL</b> to search the entire string.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the last occurrence of the character in the string, if successful, or <b>NULL</b> if not.</para>
    </returns>
    <remarks>
      <para>The comparison assumes that <i>pszEnd</i> points to the end of the string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRChr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrRChrI">
    <summary>
      <para>Searches a string for the last occurrence of a specified character. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszEnd">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to <b>NULL</b> to search the entire string.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the last occurrence of the character in the string, if successful, or <b>NULL</b> if not.</para>
    </returns>
    <remarks>
      <para>The comparison assumes that <i>pszEnd</i> points to the end of the string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRChrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrRChrIA">
    <summary>
      <para>Searches a string for the last occurrence of a specified character. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszEnd">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to <b>NULL</b> to search the entire string.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the last occurrence of the character in the string, if successful, or <b>NULL</b> if not.</para>
    </returns>
    <remarks>
      <para>The comparison assumes that <i>pszEnd</i> points to the end of the string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRChrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrRChrIW">
    <summary>
      <para>Searches a string for the last occurrence of a specified character. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszEnd">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to <b>NULL</b> to search the entire string.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the last occurrence of the character in the string, if successful, or <b>NULL</b> if not.</para>
    </returns>
    <remarks>
      <para>The comparison assumes that <i>pszEnd</i> points to the end of the string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRChrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrRChrI">
    <summary>
      <para>Searches a string for the last occurrence of a specified character. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszEnd">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to <b>NULL</b> to search the entire string.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the last occurrence of the character in the string, if successful, or <b>NULL</b> if not.</para>
    </returns>
    <remarks>
      <para>The comparison assumes that <i>pszEnd</i> points to the end of the string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRChrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrRChrIA">
    <summary>
      <para>Searches a string for the last occurrence of a specified character. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszEnd">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to <b>NULL</b> to search the entire string.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the last occurrence of the character in the string, if successful, or <b>NULL</b> if not.</para>
    </returns>
    <remarks>
      <para>The comparison assumes that <i>pszEnd</i> points to the end of the string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRChrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrRChrIW">
    <summary>
      <para>Searches a string for the last occurrence of a specified character. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszEnd">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to <b>NULL</b> to search the entire string.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the last occurrence of the character in the string, if successful, or <b>NULL</b> if not.</para>
    </returns>
    <remarks>
      <para>The comparison assumes that <i>pszEnd</i> points to the end of the string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRChrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrRChr">
    <summary>
      <para>Searches a string for the last occurrence of a specified character. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszEnd">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to <b>NULL</b> to search the entire string.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the last occurrence of the character in the string, if successful, or <b>NULL</b> if not.</para>
    </returns>
    <remarks>
      <para>The comparison assumes that <i>pszEnd</i> points to the end of the string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRChr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrRChrA">
    <summary>
      <para>Searches a string for the last occurrence of a specified character. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszEnd">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to <b>NULL</b> to search the entire string.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the last occurrence of the character in the string, if successful, or <b>NULL</b> if not.</para>
    </returns>
    <remarks>
      <para>The comparison assumes that <i>pszEnd</i> points to the end of the string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRChr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrRChrW">
    <summary>
      <para>Searches a string for the last occurrence of a specified character. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszStart">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be searched.</para>
    </param>
    <param name="pszEnd">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer into the source string that defines the range of the search. Set <i>pszEnd</i> to point to a character in the string and the search will stop with the preceding character. Set <i>pszEnd</i> to <b>NULL</b> to search the entire string.</para>
    </param>
    <param name="wMatch">
      <para>Type: <b>TCHAR</b></para>
      <para>The character to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns a pointer to the last occurrence of the character in the string, if successful, or <b>NULL</b> if not.</para>
    </returns>
    <remarks>
      <para>The comparison assumes that <i>pszEnd</i> points to the end of the string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRChr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrRetToBSTR">
    <summary>
      <para>Accepts a <see cref="STRRET" /> structure returned by <see cref="IShellFolder.GetDisplayNameOf" /> that contains or points to a string, and returns that string as a <a href="https://docs.microsoft.com//previous-versions/windows/desktop/automat/bstr">BSTR</a>.</para>
    </summary>
    <param name="pstr">
      <para>Type: <b><see cref="STRRET" />*</b></para>
      <para>A pointer to a <see cref="STRRET" /> structure. When the function returns, this pointer is longer valid.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to an <see cref="ITEMIDLIST" /> that uniquely identifies a file object or subfolder relative to the parent folder. This value can be <b>NULL</b>.</para>
    </param>
    <param name="pbstr">
      <para>Type: <b><a href="https://docs.microsoft.com//previous-versions/windows/desktop/automat/bstr">BSTR</a>*</b></para>
      <para>A pointer to a variable of type <a href="https://docs.microsoft.com//previous-versions/windows/desktop/automat/bstr">BSTR</a> that receives the converted string.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>If the <i>uType</i> member of the <see cref="STRRET" /> structure pointed to by <i>pstr</i> is set to <b>STRRET_WSTR</b>, the <i>pOleStr</i> member of that structure is freed on return.</para>
    </remarks>
    <seealso cref="IShellFolder.GetDisplayNameOf" />
    <seealso cref="StrRetToBuf" />
    <seealso cref="StrRetToStr" />
  </member>
  <member name="Windows.StrRetToBuf">
    <summary>
      <para>Converts an <see cref="STRRET" /> structure returned by <see cref="IShellFolder.GetDisplayNameOf" /> to a string, and places the result in a buffer.</para>
    </summary>
    <param name="pstr">
      <para>Type: <b><see cref="STRRET" />*</b></para>
      <para>A pointer to the <see cref="STRRET" /> structure. When the function returns, this pointer will no longer be valid.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to the item's <see cref="ITEMIDLIST" /> structure.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A buffer to hold the display name. It will be returned as a null-terminated string. If <i>cchBuf</i> is too small, the name will be truncated to fit.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of <i>pszBuf</i>, in characters. If <i>cchBuf</i> is too small, the string will be truncated to fit.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>If the <b>uType</b> member of the structure pointed to by <i>pstr</i> is set to <b>STRRET_WSTR</b>, the <b>pOleStr</b> member of that structure will be freed on return.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRetToBuf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrRetToStr" />
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/consts-enums-flags">StrRetToStrN</seealso>
  </member>
  <member name="Windows.StrRetToBufA">
    <summary>
      <para>Converts an <see cref="STRRET" /> structure returned by <see cref="IShellFolder.GetDisplayNameOf" /> to a string, and places the result in a buffer.</para>
    </summary>
    <param name="pstr">
      <para>Type: <b><see cref="STRRET" />*</b></para>
      <para>A pointer to the <see cref="STRRET" /> structure. When the function returns, this pointer will no longer be valid.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to the item's <see cref="ITEMIDLIST" /> structure.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A buffer to hold the display name. It will be returned as a null-terminated string. If <i>cchBuf</i> is too small, the name will be truncated to fit.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of <i>pszBuf</i>, in characters. If <i>cchBuf</i> is too small, the string will be truncated to fit.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>If the <b>uType</b> member of the structure pointed to by <i>pstr</i> is set to <b>STRRET_WSTR</b>, the <b>pOleStr</b> member of that structure will be freed on return.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRetToBuf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrRetToStr" />
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/consts-enums-flags">StrRetToStrN</seealso>
  </member>
  <member name="Windows.StrRetToBufW">
    <summary>
      <para>Converts an <see cref="STRRET" /> structure returned by <see cref="IShellFolder.GetDisplayNameOf" /> to a string, and places the result in a buffer.</para>
    </summary>
    <param name="pstr">
      <para>Type: <b><see cref="STRRET" />*</b></para>
      <para>A pointer to the <see cref="STRRET" /> structure. When the function returns, this pointer will no longer be valid.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to the item's <see cref="ITEMIDLIST" /> structure.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A buffer to hold the display name. It will be returned as a null-terminated string. If <i>cchBuf</i> is too small, the name will be truncated to fit.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of <i>pszBuf</i>, in characters. If <i>cchBuf</i> is too small, the string will be truncated to fit.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>If the <b>uType</b> member of the structure pointed to by <i>pstr</i> is set to <b>STRRET_WSTR</b>, the <b>pOleStr</b> member of that structure will be freed on return.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRetToBuf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrRetToStr" />
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/consts-enums-flags">StrRetToStrN</seealso>
  </member>
  <member name="Windows.StrRetToBuf">
    <summary>
      <para>Converts an <see cref="STRRET" /> structure returned by <see cref="IShellFolder.GetDisplayNameOf" /> to a string, and places the result in a buffer.</para>
    </summary>
    <param name="pstr">
      <para>Type: <b><see cref="STRRET" />*</b></para>
      <para>A pointer to the <see cref="STRRET" /> structure. When the function returns, this pointer will no longer be valid.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to the item's <see cref="ITEMIDLIST" /> structure.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A buffer to hold the display name. It will be returned as a null-terminated string. If <i>cchBuf</i> is too small, the name will be truncated to fit.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of <i>pszBuf</i>, in characters. If <i>cchBuf</i> is too small, the string will be truncated to fit.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>If the <b>uType</b> member of the structure pointed to by <i>pstr</i> is set to <b>STRRET_WSTR</b>, the <b>pOleStr</b> member of that structure will be freed on return.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRetToBuf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrRetToStr" />
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/consts-enums-flags">StrRetToStrN</seealso>
  </member>
  <member name="Windows.StrRetToBufA">
    <summary>
      <para>Converts an <see cref="STRRET" /> structure returned by <see cref="IShellFolder.GetDisplayNameOf" /> to a string, and places the result in a buffer.</para>
    </summary>
    <param name="pstr">
      <para>Type: <b><see cref="STRRET" />*</b></para>
      <para>A pointer to the <see cref="STRRET" /> structure. When the function returns, this pointer will no longer be valid.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to the item's <see cref="ITEMIDLIST" /> structure.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A buffer to hold the display name. It will be returned as a null-terminated string. If <i>cchBuf</i> is too small, the name will be truncated to fit.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of <i>pszBuf</i>, in characters. If <i>cchBuf</i> is too small, the string will be truncated to fit.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>If the <b>uType</b> member of the structure pointed to by <i>pstr</i> is set to <b>STRRET_WSTR</b>, the <b>pOleStr</b> member of that structure will be freed on return.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRetToBuf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrRetToStr" />
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/consts-enums-flags">StrRetToStrN</seealso>
  </member>
  <member name="Windows.StrRetToBufW">
    <summary>
      <para>Converts an <see cref="STRRET" /> structure returned by <see cref="IShellFolder.GetDisplayNameOf" /> to a string, and places the result in a buffer.</para>
    </summary>
    <param name="pstr">
      <para>Type: <b><see cref="STRRET" />*</b></para>
      <para>A pointer to the <see cref="STRRET" /> structure. When the function returns, this pointer will no longer be valid.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to the item's <see cref="ITEMIDLIST" /> structure.</para>
    </param>
    <param name="pszBuf">
      <para>Type: <b>LPTSTR</b></para>
      <para>A buffer to hold the display name. It will be returned as a null-terminated string. If <i>cchBuf</i> is too small, the name will be truncated to fit.</para>
    </param>
    <param name="cchBuf">
      <para>Type: <b>UINT</b></para>
      <para>The size of <i>pszBuf</i>, in characters. If <i>cchBuf</i> is too small, the string will be truncated to fit.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>If the <b>uType</b> member of the structure pointed to by <i>pstr</i> is set to <b>STRRET_WSTR</b>, the <b>pOleStr</b> member of that structure will be freed on return.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRetToBuf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrRetToStr" />
    <seealso href="https://docs.microsoft.com//windows/desktop/shell/consts-enums-flags">StrRetToStrN</seealso>
  </member>
  <member name="Windows.StrRetToStr">
    <summary>
      <para>Takes an <see cref="STRRET" /> structure returned by <see cref="IShellFolder.GetDisplayNameOf" /> and returns a pointer to an allocated string containing the display name.</para>
    </summary>
    <param name="pstr">
      <para>Type: <b><see cref="STRRET" />*</b></para>
      <para>A pointer to the <see cref="STRRET" /> structure. When the function returns, this pointer will no longer be valid.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to the item's <see cref="ITEMIDLIST" /> structure. This value can be <b>NULL</b>.</para>
    </param>
    <param name="ppsz">
      <para>Type: <b>LPTSTR*</b></para>
      <para>A pointer to an allocated string containing the result. <b>StrRetToStr</b> allocates memory for this string with <see cref="CoTaskMemAlloc" />. You should free the string with <see cref="CoTaskMemFree" /> when it is no longer needed.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRetToStr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrRetToBuf" />
  </member>
  <member name="Windows.StrRetToStrA">
    <summary>
      <para>Takes an <see cref="STRRET" /> structure returned by <see cref="IShellFolder.GetDisplayNameOf" /> and returns a pointer to an allocated string containing the display name.</para>
    </summary>
    <param name="pstr">
      <para>Type: <b><see cref="STRRET" />*</b></para>
      <para>A pointer to the <see cref="STRRET" /> structure. When the function returns, this pointer will no longer be valid.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to the item's <see cref="ITEMIDLIST" /> structure. This value can be <b>NULL</b>.</para>
    </param>
    <param name="ppsz">
      <para>Type: <b>LPTSTR*</b></para>
      <para>A pointer to an allocated string containing the result. <b>StrRetToStr</b> allocates memory for this string with <see cref="CoTaskMemAlloc" />. You should free the string with <see cref="CoTaskMemFree" /> when it is no longer needed.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRetToStr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrRetToBuf" />
  </member>
  <member name="Windows.StrRetToStrW">
    <summary>
      <para>Takes an <see cref="STRRET" /> structure returned by <see cref="IShellFolder.GetDisplayNameOf" /> and returns a pointer to an allocated string containing the display name.</para>
    </summary>
    <param name="pstr">
      <para>Type: <b><see cref="STRRET" />*</b></para>
      <para>A pointer to the <see cref="STRRET" /> structure. When the function returns, this pointer will no longer be valid.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to the item's <see cref="ITEMIDLIST" /> structure. This value can be <b>NULL</b>.</para>
    </param>
    <param name="ppsz">
      <para>Type: <b>LPTSTR*</b></para>
      <para>A pointer to an allocated string containing the result. <b>StrRetToStr</b> allocates memory for this string with <see cref="CoTaskMemAlloc" />. You should free the string with <see cref="CoTaskMemFree" /> when it is no longer needed.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRetToStr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrRetToBuf" />
  </member>
  <member name="Windows.StrRetToStr">
    <summary>
      <para>Takes an <see cref="STRRET" /> structure returned by <see cref="IShellFolder.GetDisplayNameOf" /> and returns a pointer to an allocated string containing the display name.</para>
    </summary>
    <param name="pstr">
      <para>Type: <b><see cref="STRRET" />*</b></para>
      <para>A pointer to the <see cref="STRRET" /> structure. When the function returns, this pointer will no longer be valid.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to the item's <see cref="ITEMIDLIST" /> structure. This value can be <b>NULL</b>.</para>
    </param>
    <param name="ppsz">
      <para>Type: <b>LPTSTR*</b></para>
      <para>A pointer to an allocated string containing the result. <b>StrRetToStr</b> allocates memory for this string with <see cref="CoTaskMemAlloc" />. You should free the string with <see cref="CoTaskMemFree" /> when it is no longer needed.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRetToStr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrRetToBuf" />
  </member>
  <member name="Windows.StrRetToStrA">
    <summary>
      <para>Takes an <see cref="STRRET" /> structure returned by <see cref="IShellFolder.GetDisplayNameOf" /> and returns a pointer to an allocated string containing the display name.</para>
    </summary>
    <param name="pstr">
      <para>Type: <b><see cref="STRRET" />*</b></para>
      <para>A pointer to the <see cref="STRRET" /> structure. When the function returns, this pointer will no longer be valid.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to the item's <see cref="ITEMIDLIST" /> structure. This value can be <b>NULL</b>.</para>
    </param>
    <param name="ppsz">
      <para>Type: <b>LPTSTR*</b></para>
      <para>A pointer to an allocated string containing the result. <b>StrRetToStr</b> allocates memory for this string with <see cref="CoTaskMemAlloc" />. You should free the string with <see cref="CoTaskMemFree" /> when it is no longer needed.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRetToStr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrRetToBuf" />
  </member>
  <member name="Windows.StrRetToStrW">
    <summary>
      <para>Takes an <see cref="STRRET" /> structure returned by <see cref="IShellFolder.GetDisplayNameOf" /> and returns a pointer to an allocated string containing the display name.</para>
    </summary>
    <param name="pstr">
      <para>Type: <b><see cref="STRRET" />*</b></para>
      <para>A pointer to the <see cref="STRRET" /> structure. When the function returns, this pointer will no longer be valid.</para>
    </param>
    <param name="pidl">
      <para>Type: <b>PCUITEMID_CHILD</b></para>
      <para>A pointer to the item's <see cref="ITEMIDLIST" /> structure. This value can be <b>NULL</b>.</para>
    </param>
    <param name="ppsz">
      <para>Type: <b>LPTSTR*</b></para>
      <para>A pointer to an allocated string containing the result. <b>StrRetToStr</b> allocates memory for this string with <see cref="CoTaskMemAlloc" />. You should free the string with <see cref="CoTaskMemFree" /> when it is no longer needed.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRetToStr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrRetToBuf" />
  </member>
  <member name="Windows.StrRStrI">
    <summary>
      <para>Searches for the last occurrence of a specified substring within a string. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszSource">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated source string.</para>
    </param>
    <param name="pszLast">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer into the source string that defines the range of the search. Set <i>pszLast</i> to point to a character in the source string, and the search will stop with the preceding character. Set <i>pszLast</i> to <b>NULL</b> to search the entire source string.</para>
    </param>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the substring to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the last occurrence of the substring if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRStrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrRStrIA">
    <summary>
      <para>Searches for the last occurrence of a specified substring within a string. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszSource">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated source string.</para>
    </param>
    <param name="pszLast">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer into the source string that defines the range of the search. Set <i>pszLast</i> to point to a character in the source string, and the search will stop with the preceding character. Set <i>pszLast</i> to <b>NULL</b> to search the entire source string.</para>
    </param>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the substring to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the last occurrence of the substring if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRStrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrRStrIW">
    <summary>
      <para>Searches for the last occurrence of a specified substring within a string. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszSource">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated source string.</para>
    </param>
    <param name="pszLast">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer into the source string that defines the range of the search. Set <i>pszLast</i> to point to a character in the source string, and the search will stop with the preceding character. Set <i>pszLast</i> to <b>NULL</b> to search the entire source string.</para>
    </param>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the substring to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the last occurrence of the substring if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRStrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrRStrI">
    <summary>
      <para>Searches for the last occurrence of a specified substring within a string. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszSource">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated source string.</para>
    </param>
    <param name="pszLast">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer into the source string that defines the range of the search. Set <i>pszLast</i> to point to a character in the source string, and the search will stop with the preceding character. Set <i>pszLast</i> to <b>NULL</b> to search the entire source string.</para>
    </param>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the substring to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the last occurrence of the substring if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRStrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrRStrIA">
    <summary>
      <para>Searches for the last occurrence of a specified substring within a string. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszSource">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated source string.</para>
    </param>
    <param name="pszLast">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer into the source string that defines the range of the search. Set <i>pszLast</i> to point to a character in the source string, and the search will stop with the preceding character. Set <i>pszLast</i> to <b>NULL</b> to search the entire source string.</para>
    </param>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the substring to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the last occurrence of the substring if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRStrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrRStrIW">
    <summary>
      <para>Searches for the last occurrence of a specified substring within a string. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszSource">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated source string.</para>
    </param>
    <param name="pszLast">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer into the source string that defines the range of the search. Set <i>pszLast</i> to point to a character in the source string, and the search will stop with the preceding character. Set <i>pszLast</i> to <b>NULL</b> to search the entire source string.</para>
    </param>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the substring to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the last occurrence of the substring if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrRStrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrSpn">
    <summary>
      <para>Obtains the length of a substring within a string that consists entirely of characters contained in a specified buffer.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string that is to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated character buffer that contains the set of characters for which to search.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the length, in characters, of the matching string or zero if no match is found.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrSpn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrSpnA">
    <summary>
      <para>Obtains the length of a substring within a string that consists entirely of characters contained in a specified buffer.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string that is to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated character buffer that contains the set of characters for which to search.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the length, in characters, of the matching string or zero if no match is found.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrSpn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrSpnW">
    <summary>
      <para>Obtains the length of a substring within a string that consists entirely of characters contained in a specified buffer.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string that is to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated character buffer that contains the set of characters for which to search.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the length, in characters, of the matching string or zero if no match is found.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrSpn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrSpn">
    <summary>
      <para>Obtains the length of a substring within a string that consists entirely of characters contained in a specified buffer.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string that is to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated character buffer that contains the set of characters for which to search.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the length, in characters, of the matching string or zero if no match is found.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrSpn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrSpnA">
    <summary>
      <para>Obtains the length of a substring within a string that consists entirely of characters contained in a specified buffer.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string that is to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated character buffer that contains the set of characters for which to search.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the length, in characters, of the matching string or zero if no match is found.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrSpn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrSpnW">
    <summary>
      <para>Obtains the length of a substring within a string that consists entirely of characters contained in a specified buffer.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string that is to be searched.</para>
    </param>
    <param name="pszSet">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated character buffer that contains the set of characters for which to search.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the length, in characters, of the matching string or zero if no match is found.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrSpn as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrStr">
    <summary>
      <para>Finds the first occurrence of a substring within a string. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszFirst">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to search.</para>
    </param>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the substring to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrStr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrStrA">
    <summary>
      <para>Finds the first occurrence of a substring within a string. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszFirst">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to search.</para>
    </param>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the substring to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrStr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrStrW">
    <summary>
      <para>Finds the first occurrence of a substring within a string. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszFirst">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to search.</para>
    </param>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the substring to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrStr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrStrI">
    <summary>
      <para>Finds the first occurrence of a substring within a string. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszFirst">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string being searched.</para>
    </param>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the substring to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrStrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrStrIA">
    <summary>
      <para>Finds the first occurrence of a substring within a string. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszFirst">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string being searched.</para>
    </param>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the substring to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrStrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrStrIW">
    <summary>
      <para>Finds the first occurrence of a substring within a string. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszFirst">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string being searched.</para>
    </param>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the substring to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrStrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrStrI">
    <summary>
      <para>Finds the first occurrence of a substring within a string. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszFirst">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string being searched.</para>
    </param>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the substring to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrStrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrStrIA">
    <summary>
      <para>Finds the first occurrence of a substring within a string. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszFirst">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string being searched.</para>
    </param>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the substring to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrStrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrStrIW">
    <summary>
      <para>Finds the first occurrence of a substring within a string. The comparison is not case-sensitive.</para>
    </summary>
    <param name="pszFirst">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string being searched.</para>
    </param>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the substring to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrStrI as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrStrNIW">
    <summary>
      <para>Finds the first occurrence of a substring within a string. The comparison is case-insensitive.</para>
    </summary>
    <param name="pszFirst">
      <para>Type: <b>PWSTR</b></para>
      <para>A pointer to the null-terminated, Unicode string that is being searched.</para>
    </param>
    <param name="pszSrch">
      <para>Type: <b>PCWSTR</b></para>
      <para>A pointer to the null-terminated, Unicode substring that is being searched for.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>UINT</b></para>
      <para>The maximum number of characters from the beginning of the searched string in which to search for the substring.</para>
    </param>
    <returns>
      <para>Type: <b>PWSTR</b></para>
      <para>Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.</para>
    </returns>
  </member>
  <member name="Windows.StrStrNW">
    <summary>
      <para>Finds the first occurrence of a substring within a string. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszFirst">
      <para>Type: <b>PWSTR</b></para>
      <para>A pointer to the null-terminated, Unicode string that is being searched.</para>
    </param>
    <param name="pszSrch">
      <para>Type: <b>PCWSTR</b></para>
      <para>A pointer to the null-terminated, Unicode substring that is being searched for.</para>
    </param>
    <param name="cchMax">
      <para>Type: <b>UINT</b></para>
      <para>The maximum number of characters from the beginning of the searched string in which to search for the substring.</para>
    </param>
    <returns>
      <para>Type: <b>PWSTR</b></para>
      <para>Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.</para>
    </returns>
  </member>
  <member name="Windows.StrStr">
    <summary>
      <para>Finds the first occurrence of a substring within a string. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszFirst">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to search.</para>
    </param>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the substring to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrStr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrStrA">
    <summary>
      <para>Finds the first occurrence of a substring within a string. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszFirst">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to search.</para>
    </param>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the substring to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrStr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrStrW">
    <summary>
      <para>Finds the first occurrence of a substring within a string. The comparison is case-sensitive.</para>
    </summary>
    <param name="pszFirst">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to search.</para>
    </param>
    <param name="pszSrch">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the substring to search for.</para>
    </param>
    <returns>
      <para>Type: <b>PTSTR</b></para>
      <para>Returns the address of the first occurrence of the matching substring if successful, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrStr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrToInt64Ex">
    <summary>
      <para>Converts a string representing a decimal or hexadecimal value to a 64-bit integer.</para>
    </summary>
    <param name="pszString">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the <b>null</b>-terminated string to be converted. For further details concerning the valid forms of the string, see the Remarks section.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>STIF_FLAGS</b></para>
      <para>One of the following values that specify how <i>pszString</i> should be parsed for its conversion to a 64-bit integer.</para>
      <h4>STIF_DEFAULT</h4>
      <para>The string at <i>pszString</i> contains the representation of a decimal value.</para>
      <h4>STIF_SUPPORT_HEX</h4>
      <para>The string at <i>pszString</i> contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal representations, the characters A-F are case-insensitive.</para>
    </param>
    <param name="pllRet">
      <para>Type: <b>LONGLONG*</b></para>
      <para>A pointer to a variable of type <b>LONGLONG</b> that receives the 64-bit integer value of the converted string. For instance, in the case of the string "123", the integer pointed to by this value receives the value 123.</para>
      <para>If this function returns <b>FALSE</b>, this value is undefined.</para>
      <para>If the value returned is too large to be contained in a variable of type <b>LONGLONG</b>, this parameter contains the 64 low-order bits of the value. Any high-order bits beyond that are lost.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The string pointed to by the <i>pszString</i> parameter must have one of the following forms to be parsed successfully.</para>
      <list type="bullet">
        <item>
          <description>This form is accepted as a decimal value under either flag.
<code>(optional white space)(optional sign)(one or more decimal digits)
</code></description>
        </item>
        <item>
          <description>These forms are required for hexadecimal values when the STIF_SUPPORT_HEX flag is passed.
<code>(optional white space)(optional sign)0x(one or more hexadecimal digits)
</code><code>(optional white space)(optional sign)0X(one or more hexadecimal digits)
</code></description>
        </item>
      </list>
      <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
      <para>
        <b>Note</b>  If the value is parsed as hexadecimal, the optional sign is ignored, even if it is a '-' character. For example, the string "-0x1" is parsed as 1 instead of -1.</para>
      <para>If the string pointed to by <i>pszString</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid hexadecimal string "0x00am123", <b>StrToInt64Ex</b> only recognizes "0x00a", converts it to the integer value 10, and returns <b>TRUE</b>.</para>
      <para>If <i>pllRet</i> is <b>NULL</b>, the function returns <b>TRUE</b> if the string can be converted, even though it does not perform the conversion.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrToInt64Ex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrToInt64ExA">
    <summary>
      <para>Converts a string representing a decimal or hexadecimal value to a 64-bit integer.</para>
    </summary>
    <param name="pszString">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the <b>null</b>-terminated string to be converted. For further details concerning the valid forms of the string, see the Remarks section.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>STIF_FLAGS</b></para>
      <para>One of the following values that specify how <i>pszString</i> should be parsed for its conversion to a 64-bit integer.</para>
      <h4>STIF_DEFAULT</h4>
      <para>The string at <i>pszString</i> contains the representation of a decimal value.</para>
      <h4>STIF_SUPPORT_HEX</h4>
      <para>The string at <i>pszString</i> contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal representations, the characters A-F are case-insensitive.</para>
    </param>
    <param name="pllRet">
      <para>Type: <b>LONGLONG*</b></para>
      <para>A pointer to a variable of type <b>LONGLONG</b> that receives the 64-bit integer value of the converted string. For instance, in the case of the string "123", the integer pointed to by this value receives the value 123.</para>
      <para>If this function returns <b>FALSE</b>, this value is undefined.</para>
      <para>If the value returned is too large to be contained in a variable of type <b>LONGLONG</b>, this parameter contains the 64 low-order bits of the value. Any high-order bits beyond that are lost.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The string pointed to by the <i>pszString</i> parameter must have one of the following forms to be parsed successfully.</para>
      <list type="bullet">
        <item>
          <description>This form is accepted as a decimal value under either flag.
<code>(optional white space)(optional sign)(one or more decimal digits)
</code></description>
        </item>
        <item>
          <description>These forms are required for hexadecimal values when the STIF_SUPPORT_HEX flag is passed.
<code>(optional white space)(optional sign)0x(one or more hexadecimal digits)
</code><code>(optional white space)(optional sign)0X(one or more hexadecimal digits)
</code></description>
        </item>
      </list>
      <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
      <para>
        <b>Note</b>  If the value is parsed as hexadecimal, the optional sign is ignored, even if it is a '-' character. For example, the string "-0x1" is parsed as 1 instead of -1.</para>
      <para>If the string pointed to by <i>pszString</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid hexadecimal string "0x00am123", <b>StrToInt64Ex</b> only recognizes "0x00a", converts it to the integer value 10, and returns <b>TRUE</b>.</para>
      <para>If <i>pllRet</i> is <b>NULL</b>, the function returns <b>TRUE</b> if the string can be converted, even though it does not perform the conversion.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrToInt64Ex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrToInt64ExW">
    <summary>
      <para>Converts a string representing a decimal or hexadecimal value to a 64-bit integer.</para>
    </summary>
    <param name="pszString">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the <b>null</b>-terminated string to be converted. For further details concerning the valid forms of the string, see the Remarks section.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>STIF_FLAGS</b></para>
      <para>One of the following values that specify how <i>pszString</i> should be parsed for its conversion to a 64-bit integer.</para>
      <h4>STIF_DEFAULT</h4>
      <para>The string at <i>pszString</i> contains the representation of a decimal value.</para>
      <h4>STIF_SUPPORT_HEX</h4>
      <para>The string at <i>pszString</i> contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal representations, the characters A-F are case-insensitive.</para>
    </param>
    <param name="pllRet">
      <para>Type: <b>LONGLONG*</b></para>
      <para>A pointer to a variable of type <b>LONGLONG</b> that receives the 64-bit integer value of the converted string. For instance, in the case of the string "123", the integer pointed to by this value receives the value 123.</para>
      <para>If this function returns <b>FALSE</b>, this value is undefined.</para>
      <para>If the value returned is too large to be contained in a variable of type <b>LONGLONG</b>, this parameter contains the 64 low-order bits of the value. Any high-order bits beyond that are lost.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The string pointed to by the <i>pszString</i> parameter must have one of the following forms to be parsed successfully.</para>
      <list type="bullet">
        <item>
          <description>This form is accepted as a decimal value under either flag.
<code>(optional white space)(optional sign)(one or more decimal digits)
</code></description>
        </item>
        <item>
          <description>These forms are required for hexadecimal values when the STIF_SUPPORT_HEX flag is passed.
<code>(optional white space)(optional sign)0x(one or more hexadecimal digits)
</code><code>(optional white space)(optional sign)0X(one or more hexadecimal digits)
</code></description>
        </item>
      </list>
      <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
      <para>
        <b>Note</b>  If the value is parsed as hexadecimal, the optional sign is ignored, even if it is a '-' character. For example, the string "-0x1" is parsed as 1 instead of -1.</para>
      <para>If the string pointed to by <i>pszString</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid hexadecimal string "0x00am123", <b>StrToInt64Ex</b> only recognizes "0x00a", converts it to the integer value 10, and returns <b>TRUE</b>.</para>
      <para>If <i>pllRet</i> is <b>NULL</b>, the function returns <b>TRUE</b> if the string can be converted, even though it does not perform the conversion.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrToInt64Ex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrToInt64Ex">
    <summary>
      <para>Converts a string representing a decimal or hexadecimal value to a 64-bit integer.</para>
    </summary>
    <param name="pszString">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the <b>null</b>-terminated string to be converted. For further details concerning the valid forms of the string, see the Remarks section.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>STIF_FLAGS</b></para>
      <para>One of the following values that specify how <i>pszString</i> should be parsed for its conversion to a 64-bit integer.</para>
      <h4>STIF_DEFAULT</h4>
      <para>The string at <i>pszString</i> contains the representation of a decimal value.</para>
      <h4>STIF_SUPPORT_HEX</h4>
      <para>The string at <i>pszString</i> contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal representations, the characters A-F are case-insensitive.</para>
    </param>
    <param name="pllRet">
      <para>Type: <b>LONGLONG*</b></para>
      <para>A pointer to a variable of type <b>LONGLONG</b> that receives the 64-bit integer value of the converted string. For instance, in the case of the string "123", the integer pointed to by this value receives the value 123.</para>
      <para>If this function returns <b>FALSE</b>, this value is undefined.</para>
      <para>If the value returned is too large to be contained in a variable of type <b>LONGLONG</b>, this parameter contains the 64 low-order bits of the value. Any high-order bits beyond that are lost.</para>
      <h5>- dwFlags.STIF_DEFAULT</h5>
      <para>The string at <i>pszString</i> contains the representation of a decimal value.</para>
      <h5>- dwFlags.STIF_SUPPORT_HEX</h5>
      <para>The string at <i>pszString</i> contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal representations, the characters A-F are case-insensitive.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The string pointed to by the <i>pszString</i> parameter must have one of the following forms to be parsed successfully.</para>
      <list type="bullet">
        <item>
          <description>This form is accepted as a decimal value under either flag.
<code>(optional white space)(optional sign)(one or more decimal digits)
</code></description>
        </item>
        <item>
          <description>These forms are required for hexadecimal values when the STIF_SUPPORT_HEX flag is passed.
<code>(optional white space)(optional sign)0x(one or more hexadecimal digits)
</code><code>(optional white space)(optional sign)0X(one or more hexadecimal digits)
</code></description>
        </item>
      </list>
      <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
      <para>
        <b>Note</b>  If the value is parsed as hexadecimal, the optional sign is ignored, even if it is a '-' character. For example, the string "-0x1" is parsed as 1 instead of -1.</para>
      <para>If the string pointed to by <i>pszString</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid hexadecimal string "0x00am123", <b>StrToInt64Ex</b> only recognizes "0x00a", converts it to the integer value 10, and returns <b>TRUE</b>.</para>
      <para>If <i>pllRet</i> is <b>NULL</b>, the function returns <b>TRUE</b> if the string can be converted, even though it does not perform the conversion.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrToInt64Ex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrToInt64ExA">
    <summary>
      <para>Converts a string representing a decimal or hexadecimal value to a 64-bit integer.</para>
    </summary>
    <param name="pszString">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the <b>null</b>-terminated string to be converted. For further details concerning the valid forms of the string, see the Remarks section.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>STIF_FLAGS</b></para>
      <para>One of the following values that specify how <i>pszString</i> should be parsed for its conversion to a 64-bit integer.</para>
      <h4>STIF_DEFAULT</h4>
      <para>The string at <i>pszString</i> contains the representation of a decimal value.</para>
      <h4>STIF_SUPPORT_HEX</h4>
      <para>The string at <i>pszString</i> contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal representations, the characters A-F are case-insensitive.</para>
    </param>
    <param name="pllRet">
      <para>Type: <b>LONGLONG*</b></para>
      <para>A pointer to a variable of type <b>LONGLONG</b> that receives the 64-bit integer value of the converted string. For instance, in the case of the string "123", the integer pointed to by this value receives the value 123.</para>
      <para>If this function returns <b>FALSE</b>, this value is undefined.</para>
      <para>If the value returned is too large to be contained in a variable of type <b>LONGLONG</b>, this parameter contains the 64 low-order bits of the value. Any high-order bits beyond that are lost.</para>
      <h5>- dwFlags.STIF_DEFAULT</h5>
      <para>The string at <i>pszString</i> contains the representation of a decimal value.</para>
      <h5>- dwFlags.STIF_SUPPORT_HEX</h5>
      <para>The string at <i>pszString</i> contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal representations, the characters A-F are case-insensitive.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The string pointed to by the <i>pszString</i> parameter must have one of the following forms to be parsed successfully.</para>
      <list type="bullet">
        <item>
          <description>This form is accepted as a decimal value under either flag.
<code>(optional white space)(optional sign)(one or more decimal digits)
</code></description>
        </item>
        <item>
          <description>These forms are required for hexadecimal values when the STIF_SUPPORT_HEX flag is passed.
<code>(optional white space)(optional sign)0x(one or more hexadecimal digits)
</code><code>(optional white space)(optional sign)0X(one or more hexadecimal digits)
</code></description>
        </item>
      </list>
      <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
      <para>
        <b>Note</b>  If the value is parsed as hexadecimal, the optional sign is ignored, even if it is a '-' character. For example, the string "-0x1" is parsed as 1 instead of -1.</para>
      <para>If the string pointed to by <i>pszString</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid hexadecimal string "0x00am123", <b>StrToInt64Ex</b> only recognizes "0x00a", converts it to the integer value 10, and returns <b>TRUE</b>.</para>
      <para>If <i>pllRet</i> is <b>NULL</b>, the function returns <b>TRUE</b> if the string can be converted, even though it does not perform the conversion.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrToInt64Ex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrToInt64ExW">
    <summary>
      <para>Converts a string representing a decimal or hexadecimal value to a 64-bit integer.</para>
    </summary>
    <param name="pszString">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the <b>null</b>-terminated string to be converted. For further details concerning the valid forms of the string, see the Remarks section.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>STIF_FLAGS</b></para>
      <para>One of the following values that specify how <i>pszString</i> should be parsed for its conversion to a 64-bit integer.</para>
      <h4>STIF_DEFAULT</h4>
      <para>The string at <i>pszString</i> contains the representation of a decimal value.</para>
      <h4>STIF_SUPPORT_HEX</h4>
      <para>The string at <i>pszString</i> contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal representations, the characters A-F are case-insensitive.</para>
    </param>
    <param name="pllRet">
      <para>Type: <b>LONGLONG*</b></para>
      <para>A pointer to a variable of type <b>LONGLONG</b> that receives the 64-bit integer value of the converted string. For instance, in the case of the string "123", the integer pointed to by this value receives the value 123.</para>
      <para>If this function returns <b>FALSE</b>, this value is undefined.</para>
      <para>If the value returned is too large to be contained in a variable of type <b>LONGLONG</b>, this parameter contains the 64 low-order bits of the value. Any high-order bits beyond that are lost.</para>
      <h5>- dwFlags.STIF_DEFAULT</h5>
      <para>The string at <i>pszString</i> contains the representation of a decimal value.</para>
      <h5>- dwFlags.STIF_SUPPORT_HEX</h5>
      <para>The string at <i>pszString</i> contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal representations, the characters A-F are case-insensitive.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The string pointed to by the <i>pszString</i> parameter must have one of the following forms to be parsed successfully.</para>
      <list type="bullet">
        <item>
          <description>This form is accepted as a decimal value under either flag.
<code>(optional white space)(optional sign)(one or more decimal digits)
</code></description>
        </item>
        <item>
          <description>These forms are required for hexadecimal values when the STIF_SUPPORT_HEX flag is passed.
<code>(optional white space)(optional sign)0x(one or more hexadecimal digits)
</code><code>(optional white space)(optional sign)0X(one or more hexadecimal digits)
</code></description>
        </item>
      </list>
      <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
      <para>
        <b>Note</b>  If the value is parsed as hexadecimal, the optional sign is ignored, even if it is a '-' character. For example, the string "-0x1" is parsed as 1 instead of -1.</para>
      <para>If the string pointed to by <i>pszString</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid hexadecimal string "0x00am123", <b>StrToInt64Ex</b> only recognizes "0x00a", converts it to the integer value 10, and returns <b>TRUE</b>.</para>
      <para>If <i>pllRet</i> is <b>NULL</b>, the function returns <b>TRUE</b> if the string can be converted, even though it does not perform the conversion.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrToInt64Ex as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrToInt">
    <summary>
      <para>Converts a string that represents a decimal value to an integer. The <b>StrToLong</b> macro is identical to this function.</para>
    </summary>
    <param name="pszSrc">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be converted. A valid string representing a decimal value contains only the characters 0-9 and must have the following form to be parsed successfully.</para>
      <code>(optional white space)(optional sign)(one or more decimal digits)
</code>
      <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the <b>int</b> value represented by <i>pszSrc</i>. For instance, the string "123" returns the integer value 123.</para>
    </returns>
    <remarks>
      <para>If the string pointed to by <i>pszSrc</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid decimal string "12b34", <b>StrToInt</b> only recognizes "12" and returns that integer value.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrToInt as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrToIntEx" />
  </member>
  <member name="Windows.StrToIntA">
    <summary>
      <para>Converts a string that represents a decimal value to an integer. The <b>StrToLong</b> macro is identical to this function.</para>
    </summary>
    <param name="pszSrc">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be converted. A valid string representing a decimal value contains only the characters 0-9 and must have the following form to be parsed successfully.</para>
      <code>(optional white space)(optional sign)(one or more decimal digits)
</code>
      <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the <b>int</b> value represented by <i>pszSrc</i>. For instance, the string "123" returns the integer value 123.</para>
    </returns>
    <remarks>
      <para>If the string pointed to by <i>pszSrc</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid decimal string "12b34", <b>StrToInt</b> only recognizes "12" and returns that integer value.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrToInt as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrToIntEx" />
  </member>
  <member name="Windows.StrToIntW">
    <summary>
      <para>Converts a string that represents a decimal value to an integer. The <b>StrToLong</b> macro is identical to this function.</para>
    </summary>
    <param name="pszSrc">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be converted. A valid string representing a decimal value contains only the characters 0-9 and must have the following form to be parsed successfully.</para>
      <code>(optional white space)(optional sign)(one or more decimal digits)
</code>
      <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the <b>int</b> value represented by <i>pszSrc</i>. For instance, the string "123" returns the integer value 123.</para>
    </returns>
    <remarks>
      <para>If the string pointed to by <i>pszSrc</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid decimal string "12b34", <b>StrToInt</b> only recognizes "12" and returns that integer value.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrToInt as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrToIntEx" />
  </member>
  <member name="Windows.StrToIntEx">
    <summary>
      <para>Converts a string representing a decimal or hexadecimal number to an integer.</para>
    </summary>
    <param name="pszString">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be converted. For further details concerning the valid forms of the string, see the Remarks section.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>STIF_FLAGS</b></para>
      <para>One of the following values that specify how <i>pszString</i> should be parsed for its conversion to an integer.</para>
      <h4>STIF_DEFAULT</h4>
      <para>The string at <i>pszString</i> contains the representation of a decimal value.</para>
      <h4>STIF_SUPPORT_HEX</h4>
      <para>The string at <i>pszString</i> contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal representations, the characters A-F are case-insensitive.</para>
    </param>
    <param name="piRet">
      <para>Type: <b>int*</b></para>
      <para>A pointer to an <b>int</b> that receives the converted string. For instance, in the case of the string "123", the integer pointed to by this value receives the integer value 123.</para>
      <para>If this function returns <b>FALSE</b>, this value is undefined.</para>
      <para>If the value returned is too large to be contained in a variable of type <b>int</b>, this parameter contains the 32 low-order bits of the value. Any high-order bits beyond that are lost.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The string pointed to by the <i>pszString</i> parameter must have one of the following forms to be parsed successfully.</para>
      <list type="bullet">
        <item>
          <description>This form is accepted as a decimal value under either flag.
<code>(optional white space)(optional sign)(one or more decimal digits)
</code></description>
        </item>
        <item>
          <description>These forms are required for hexadecimal values when the STIF_SUPPORT_HEX flag is passed.
<code>(optional white space)(optional sign)0x(one or more hexadecimal digits)
</code><code>(optional white space)(optional sign)0X(one or more hexadecimal digits)
</code></description>
        </item>
      </list>
      <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
      <para>
        <b>Note</b>  If the value is parsed as hexadecimal, the optional sign is ignored, even if it is a '-' character. For example, the string "-0x1" is parsed as 1 instead of -1.</para>
      <para>If the string pointed to by <i>pszString</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid hexadecimal string "0x00am123", <b>StrToIntEx</b> only recognizes "0x00a", converts it to the integer value 10, and returns <b>TRUE</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrToIntEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrToIntExA">
    <summary>
      <para>Converts a string representing a decimal or hexadecimal number to an integer.</para>
    </summary>
    <param name="pszString">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be converted. For further details concerning the valid forms of the string, see the Remarks section.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>STIF_FLAGS</b></para>
      <para>One of the following values that specify how <i>pszString</i> should be parsed for its conversion to an integer.</para>
      <h4>STIF_DEFAULT</h4>
      <para>The string at <i>pszString</i> contains the representation of a decimal value.</para>
      <h4>STIF_SUPPORT_HEX</h4>
      <para>The string at <i>pszString</i> contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal representations, the characters A-F are case-insensitive.</para>
    </param>
    <param name="piRet">
      <para>Type: <b>int*</b></para>
      <para>A pointer to an <b>int</b> that receives the converted string. For instance, in the case of the string "123", the integer pointed to by this value receives the integer value 123.</para>
      <para>If this function returns <b>FALSE</b>, this value is undefined.</para>
      <para>If the value returned is too large to be contained in a variable of type <b>int</b>, this parameter contains the 32 low-order bits of the value. Any high-order bits beyond that are lost.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The string pointed to by the <i>pszString</i> parameter must have one of the following forms to be parsed successfully.</para>
      <list type="bullet">
        <item>
          <description>This form is accepted as a decimal value under either flag.
<code>(optional white space)(optional sign)(one or more decimal digits)
</code></description>
        </item>
        <item>
          <description>These forms are required for hexadecimal values when the STIF_SUPPORT_HEX flag is passed.
<code>(optional white space)(optional sign)0x(one or more hexadecimal digits)
</code><code>(optional white space)(optional sign)0X(one or more hexadecimal digits)
</code></description>
        </item>
      </list>
      <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
      <para>
        <b>Note</b>  If the value is parsed as hexadecimal, the optional sign is ignored, even if it is a '-' character. For example, the string "-0x1" is parsed as 1 instead of -1.</para>
      <para>If the string pointed to by <i>pszString</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid hexadecimal string "0x00am123", <b>StrToIntEx</b> only recognizes "0x00a", converts it to the integer value 10, and returns <b>TRUE</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrToIntEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrToIntExW">
    <summary>
      <para>Converts a string representing a decimal or hexadecimal number to an integer.</para>
    </summary>
    <param name="pszString">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be converted. For further details concerning the valid forms of the string, see the Remarks section.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>STIF_FLAGS</b></para>
      <para>One of the following values that specify how <i>pszString</i> should be parsed for its conversion to an integer.</para>
      <h4>STIF_DEFAULT</h4>
      <para>The string at <i>pszString</i> contains the representation of a decimal value.</para>
      <h4>STIF_SUPPORT_HEX</h4>
      <para>The string at <i>pszString</i> contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal representations, the characters A-F are case-insensitive.</para>
    </param>
    <param name="piRet">
      <para>Type: <b>int*</b></para>
      <para>A pointer to an <b>int</b> that receives the converted string. For instance, in the case of the string "123", the integer pointed to by this value receives the integer value 123.</para>
      <para>If this function returns <b>FALSE</b>, this value is undefined.</para>
      <para>If the value returned is too large to be contained in a variable of type <b>int</b>, this parameter contains the 32 low-order bits of the value. Any high-order bits beyond that are lost.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The string pointed to by the <i>pszString</i> parameter must have one of the following forms to be parsed successfully.</para>
      <list type="bullet">
        <item>
          <description>This form is accepted as a decimal value under either flag.
<code>(optional white space)(optional sign)(one or more decimal digits)
</code></description>
        </item>
        <item>
          <description>These forms are required for hexadecimal values when the STIF_SUPPORT_HEX flag is passed.
<code>(optional white space)(optional sign)0x(one or more hexadecimal digits)
</code><code>(optional white space)(optional sign)0X(one or more hexadecimal digits)
</code></description>
        </item>
      </list>
      <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
      <para>
        <b>Note</b>  If the value is parsed as hexadecimal, the optional sign is ignored, even if it is a '-' character. For example, the string "-0x1" is parsed as 1 instead of -1.</para>
      <para>If the string pointed to by <i>pszString</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid hexadecimal string "0x00am123", <b>StrToIntEx</b> only recognizes "0x00a", converts it to the integer value 10, and returns <b>TRUE</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrToIntEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrToIntEx">
    <summary>
      <para>Converts a string representing a decimal or hexadecimal number to an integer.</para>
    </summary>
    <param name="pszString">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be converted. For further details concerning the valid forms of the string, see the Remarks section.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>STIF_FLAGS</b></para>
      <para>One of the following values that specify how <i>pszString</i> should be parsed for its conversion to an integer.</para>
      <h4>STIF_DEFAULT</h4>
      <para>The string at <i>pszString</i> contains the representation of a decimal value.</para>
      <h4>STIF_SUPPORT_HEX</h4>
      <para>The string at <i>pszString</i> contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal representations, the characters A-F are case-insensitive.</para>
    </param>
    <param name="piRet">
      <para>Type: <b>int*</b></para>
      <para>A pointer to an <b>int</b> that receives the converted string. For instance, in the case of the string "123", the integer pointed to by this value receives the integer value 123.</para>
      <para>If this function returns <b>FALSE</b>, this value is undefined.</para>
      <para>If the value returned is too large to be contained in a variable of type <b>int</b>, this parameter contains the 32 low-order bits of the value. Any high-order bits beyond that are lost.</para>
      <h5>- dwFlags.STIF_DEFAULT</h5>
      <para>The string at <i>pszString</i> contains the representation of a decimal value.</para>
      <h5>- dwFlags.STIF_SUPPORT_HEX</h5>
      <para>The string at <i>pszString</i> contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal representations, the characters A-F are case-insensitive.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The string pointed to by the <i>pszString</i> parameter must have one of the following forms to be parsed successfully.</para>
      <list type="bullet">
        <item>
          <description>This form is accepted as a decimal value under either flag.
<code>(optional white space)(optional sign)(one or more decimal digits)
</code></description>
        </item>
        <item>
          <description>These forms are required for hexadecimal values when the STIF_SUPPORT_HEX flag is passed.
<code>(optional white space)(optional sign)0x(one or more hexadecimal digits)
</code><code>(optional white space)(optional sign)0X(one or more hexadecimal digits)
</code></description>
        </item>
      </list>
      <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
      <para>
        <b>Note</b>  If the value is parsed as hexadecimal, the optional sign is ignored, even if it is a '-' character. For example, the string "-0x1" is parsed as 1 instead of -1.</para>
      <para>If the string pointed to by <i>pszString</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid hexadecimal string "0x00am123", <b>StrToIntEx</b> only recognizes "0x00a", converts it to the integer value 10, and returns <b>TRUE</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrToIntEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrToIntExA">
    <summary>
      <para>Converts a string representing a decimal or hexadecimal number to an integer.</para>
    </summary>
    <param name="pszString">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be converted. For further details concerning the valid forms of the string, see the Remarks section.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>STIF_FLAGS</b></para>
      <para>One of the following values that specify how <i>pszString</i> should be parsed for its conversion to an integer.</para>
      <h4>STIF_DEFAULT</h4>
      <para>The string at <i>pszString</i> contains the representation of a decimal value.</para>
      <h4>STIF_SUPPORT_HEX</h4>
      <para>The string at <i>pszString</i> contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal representations, the characters A-F are case-insensitive.</para>
    </param>
    <param name="piRet">
      <para>Type: <b>int*</b></para>
      <para>A pointer to an <b>int</b> that receives the converted string. For instance, in the case of the string "123", the integer pointed to by this value receives the integer value 123.</para>
      <para>If this function returns <b>FALSE</b>, this value is undefined.</para>
      <para>If the value returned is too large to be contained in a variable of type <b>int</b>, this parameter contains the 32 low-order bits of the value. Any high-order bits beyond that are lost.</para>
      <h5>- dwFlags.STIF_DEFAULT</h5>
      <para>The string at <i>pszString</i> contains the representation of a decimal value.</para>
      <h5>- dwFlags.STIF_SUPPORT_HEX</h5>
      <para>The string at <i>pszString</i> contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal representations, the characters A-F are case-insensitive.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The string pointed to by the <i>pszString</i> parameter must have one of the following forms to be parsed successfully.</para>
      <list type="bullet">
        <item>
          <description>This form is accepted as a decimal value under either flag.
<code>(optional white space)(optional sign)(one or more decimal digits)
</code></description>
        </item>
        <item>
          <description>These forms are required for hexadecimal values when the STIF_SUPPORT_HEX flag is passed.
<code>(optional white space)(optional sign)0x(one or more hexadecimal digits)
</code><code>(optional white space)(optional sign)0X(one or more hexadecimal digits)
</code></description>
        </item>
      </list>
      <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
      <para>
        <b>Note</b>  If the value is parsed as hexadecimal, the optional sign is ignored, even if it is a '-' character. For example, the string "-0x1" is parsed as 1 instead of -1.</para>
      <para>If the string pointed to by <i>pszString</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid hexadecimal string "0x00am123", <b>StrToIntEx</b> only recognizes "0x00a", converts it to the integer value 10, and returns <b>TRUE</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrToIntEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrToIntExW">
    <summary>
      <para>Converts a string representing a decimal or hexadecimal number to an integer.</para>
    </summary>
    <param name="pszString">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be converted. For further details concerning the valid forms of the string, see the Remarks section.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>STIF_FLAGS</b></para>
      <para>One of the following values that specify how <i>pszString</i> should be parsed for its conversion to an integer.</para>
      <h4>STIF_DEFAULT</h4>
      <para>The string at <i>pszString</i> contains the representation of a decimal value.</para>
      <h4>STIF_SUPPORT_HEX</h4>
      <para>The string at <i>pszString</i> contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal representations, the characters A-F are case-insensitive.</para>
    </param>
    <param name="piRet">
      <para>Type: <b>int*</b></para>
      <para>A pointer to an <b>int</b> that receives the converted string. For instance, in the case of the string "123", the integer pointed to by this value receives the integer value 123.</para>
      <para>If this function returns <b>FALSE</b>, this value is undefined.</para>
      <para>If the value returned is too large to be contained in a variable of type <b>int</b>, this parameter contains the 32 low-order bits of the value. Any high-order bits beyond that are lost.</para>
      <h5>- dwFlags.STIF_DEFAULT</h5>
      <para>The string at <i>pszString</i> contains the representation of a decimal value.</para>
      <h5>- dwFlags.STIF_SUPPORT_HEX</h5>
      <para>The string at <i>pszString</i> contains the representation of either a decimal or hexadecimal value. Note that in hexadecimal representations, the characters A-F are case-insensitive.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns <b>TRUE</b> if the string is converted; otherwise <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <para>The string pointed to by the <i>pszString</i> parameter must have one of the following forms to be parsed successfully.</para>
      <list type="bullet">
        <item>
          <description>This form is accepted as a decimal value under either flag.
<code>(optional white space)(optional sign)(one or more decimal digits)
</code></description>
        </item>
        <item>
          <description>These forms are required for hexadecimal values when the STIF_SUPPORT_HEX flag is passed.
<code>(optional white space)(optional sign)0x(one or more hexadecimal digits)
</code><code>(optional white space)(optional sign)0X(one or more hexadecimal digits)
</code></description>
        </item>
      </list>
      <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
      <para>
        <b>Note</b>  If the value is parsed as hexadecimal, the optional sign is ignored, even if it is a '-' character. For example, the string "-0x1" is parsed as 1 instead of -1.</para>
      <para>If the string pointed to by <i>pszString</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid hexadecimal string "0x00am123", <b>StrToIntEx</b> only recognizes "0x00a", converts it to the integer value 10, and returns <b>TRUE</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrToIntEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrToInt">
    <summary>
      <para>Converts a string that represents a decimal value to an integer. The <b>StrToLong</b> macro is identical to this function.</para>
    </summary>
    <param name="pszSrc">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be converted. A valid string representing a decimal value contains only the characters 0-9 and must have the following form to be parsed successfully.</para>
      <code>(optional white space)(optional sign)(one or more decimal digits)
</code>
      <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the <b>int</b> value represented by <i>pszSrc</i>. For instance, the string "123" returns the integer value 123.</para>
    </returns>
    <remarks>
      <para>If the string pointed to by <i>pszSrc</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid decimal string "12b34", <b>StrToInt</b> only recognizes "12" and returns that integer value.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrToInt as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrToIntEx" />
  </member>
  <member name="Windows.StrToIntA">
    <summary>
      <para>Converts a string that represents a decimal value to an integer. The <b>StrToLong</b> macro is identical to this function.</para>
    </summary>
    <param name="pszSrc">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be converted. A valid string representing a decimal value contains only the characters 0-9 and must have the following form to be parsed successfully.</para>
      <code>(optional white space)(optional sign)(one or more decimal digits)
</code>
      <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the <b>int</b> value represented by <i>pszSrc</i>. For instance, the string "123" returns the integer value 123.</para>
    </returns>
    <remarks>
      <para>If the string pointed to by <i>pszSrc</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid decimal string "12b34", <b>StrToInt</b> only recognizes "12" and returns that integer value.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrToInt as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrToIntEx" />
  </member>
  <member name="Windows.StrToIntW">
    <summary>
      <para>Converts a string that represents a decimal value to an integer. The <b>StrToLong</b> macro is identical to this function.</para>
    </summary>
    <param name="pszSrc">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to the null-terminated string to be converted. A valid string representing a decimal value contains only the characters 0-9 and must have the following form to be parsed successfully.</para>
      <code>(optional white space)(optional sign)(one or more decimal digits)
</code>
      <para>The optional sign can be the character '-' or '+'; if omitted, the sign is assumed to be positive.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the <b>int</b> value represented by <i>pszSrc</i>. For instance, the string "123" returns the integer value 123.</para>
    </returns>
    <remarks>
      <para>If the string pointed to by <i>pszSrc</i> contains an invalid character, that character is considered the end of the string to be converted and the remainder is ignored. For instance, given the invalid decimal string "12b34", <b>StrToInt</b> only recognizes "12" and returns that integer value.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrToInt as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrToIntEx" />
  </member>
  <member name="Windows.StrTrim">
    <summary>
      <para>Removes specified leading and trailing characters from a string.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be trimmed. When this function returns successfully, <i>psz</i> receives the trimmed string.</para>
    </param>
    <param name="pszTrimChars">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the characters to trim from <i>psz</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if any characters were removed; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrTrim as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrTrimA">
    <summary>
      <para>Removes specified leading and trailing characters from a string.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be trimmed. When this function returns successfully, <i>psz</i> receives the trimmed string.</para>
    </param>
    <param name="pszTrimChars">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the characters to trim from <i>psz</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if any characters were removed; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrTrim as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrTrimW">
    <summary>
      <para>Removes specified leading and trailing characters from a string.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be trimmed. When this function returns successfully, <i>psz</i> receives the trimmed string.</para>
    </param>
    <param name="pszTrimChars">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the characters to trim from <i>psz</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if any characters were removed; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrTrim as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrTrim">
    <summary>
      <para>Removes specified leading and trailing characters from a string.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be trimmed. When this function returns successfully, <i>psz</i> receives the trimmed string.</para>
    </param>
    <param name="pszTrimChars">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the characters to trim from <i>psz</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if any characters were removed; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrTrim as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrTrimA">
    <summary>
      <para>Removes specified leading and trailing characters from a string.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be trimmed. When this function returns successfully, <i>psz</i> receives the trimmed string.</para>
    </param>
    <param name="pszTrimChars">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the characters to trim from <i>psz</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if any characters were removed; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrTrim as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.StrTrimW">
    <summary>
      <para>Removes specified leading and trailing characters from a string.</para>
    </summary>
    <param name="psz">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to the null-terminated string to be trimmed. When this function returns successfully, <i>psz</i> receives the trimmed string.</para>
    </param>
    <param name="pszTrimChars">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string that contains the characters to trim from <i>psz</i>.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>
        <b>TRUE</b> if any characters were removed; otherwise, <b>FALSE</b>.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines StrTrim as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlApplyScheme">
    <summary>
      <para>Determines a scheme for a specified URL string, and returns a string with an appropriate prefix.</para>
    </summary>
    <param name="pszIn">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives a null-terminated string set to the URL specified by <i>pszIn</i> and converted to the standard <i>scheme</i>://<i>URL_string</i> format.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>The address of a value set to the number of characters in the <i>pszOut</i> buffer. When the function returns, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that specify how to determine the scheme. The following flags can be combined.</para>
      <h4>URL_APPLY_DEFAULT</h4>
      <para>Apply the default scheme if <b>UrlApplyScheme</b> can't determine one. The default prefix is stored in the registry but is typically "http".</para>
      <h4>URL_APPLY_GUESSSCHEME</h4>
      <para>Attempt to determine the scheme by examining <i>pszIn</i>.</para>
      <h4>URL_APPLY_GUESSFILE</h4>
      <para>Attempt to determine a file URL from <i>pszIn</i>.</para>
      <h4>URL_APPLY_FORCEAPPLY</h4>
      <para>Force <b>UrlApplyScheme</b> to determine a scheme for pszIn.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns a standard COM return value, including the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>A scheme was determined. pszOut points to a string containing the URL with the scheme's prefix. The value of <i>pcchOut</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b> character.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>There were no errors, but no prefix was prepended.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_POINTER</b>
            </para>
          </description>
          <description>
            <para>The buffer was too small. The value of <i>pcchOut</i> is set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If the URL has a valid scheme, the string will not be modified. However, almost any combination of two or more characters followed by a colon will be parsed as a scheme. Valid characters include some common punctuation marks, such as ".". If your input string fits this description, <b>UrlApplyScheme</b> may treat it as valid and not apply a scheme. To force the function to apply a scheme to a URL, set the <b>URL_APPLY_FORCEAPPLY</b> and <b>URL_APPLY_DEFAULT</b> flags in <i>dwFlags</i>. This combination of flags forces the function to apply a scheme to the URL. Typically, the function will not be able to determine a valid scheme. The second flag guarantees that, if no valid scheme can be determined, the function will apply the default scheme to the URL.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlApplyScheme as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlApplySchemeA">
    <summary>
      <para>Determines a scheme for a specified URL string, and returns a string with an appropriate prefix.</para>
    </summary>
    <param name="pszIn">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives a null-terminated string set to the URL specified by <i>pszIn</i> and converted to the standard <i>scheme</i>://<i>URL_string</i> format.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>The address of a value set to the number of characters in the <i>pszOut</i> buffer. When the function returns, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that specify how to determine the scheme. The following flags can be combined.</para>
      <h4>URL_APPLY_DEFAULT</h4>
      <para>Apply the default scheme if <b>UrlApplyScheme</b> can't determine one. The default prefix is stored in the registry but is typically "http".</para>
      <h4>URL_APPLY_GUESSSCHEME</h4>
      <para>Attempt to determine the scheme by examining <i>pszIn</i>.</para>
      <h4>URL_APPLY_GUESSFILE</h4>
      <para>Attempt to determine a file URL from <i>pszIn</i>.</para>
      <h4>URL_APPLY_FORCEAPPLY</h4>
      <para>Force <b>UrlApplyScheme</b> to determine a scheme for pszIn.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns a standard COM return value, including the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>A scheme was determined. pszOut points to a string containing the URL with the scheme's prefix. The value of <i>pcchOut</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b> character.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>There were no errors, but no prefix was prepended.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_POINTER</b>
            </para>
          </description>
          <description>
            <para>The buffer was too small. The value of <i>pcchOut</i> is set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If the URL has a valid scheme, the string will not be modified. However, almost any combination of two or more characters followed by a colon will be parsed as a scheme. Valid characters include some common punctuation marks, such as ".". If your input string fits this description, <b>UrlApplyScheme</b> may treat it as valid and not apply a scheme. To force the function to apply a scheme to a URL, set the <b>URL_APPLY_FORCEAPPLY</b> and <b>URL_APPLY_DEFAULT</b> flags in <i>dwFlags</i>. This combination of flags forces the function to apply a scheme to the URL. Typically, the function will not be able to determine a valid scheme. The second flag guarantees that, if no valid scheme can be determined, the function will apply the default scheme to the URL.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlApplyScheme as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlApplySchemeW">
    <summary>
      <para>Determines a scheme for a specified URL string, and returns a string with an appropriate prefix.</para>
    </summary>
    <param name="pszIn">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives a null-terminated string set to the URL specified by <i>pszIn</i> and converted to the standard <i>scheme</i>://<i>URL_string</i> format.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>The address of a value set to the number of characters in the <i>pszOut</i> buffer. When the function returns, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that specify how to determine the scheme. The following flags can be combined.</para>
      <h4>URL_APPLY_DEFAULT</h4>
      <para>Apply the default scheme if <b>UrlApplyScheme</b> can't determine one. The default prefix is stored in the registry but is typically "http".</para>
      <h4>URL_APPLY_GUESSSCHEME</h4>
      <para>Attempt to determine the scheme by examining <i>pszIn</i>.</para>
      <h4>URL_APPLY_GUESSFILE</h4>
      <para>Attempt to determine a file URL from <i>pszIn</i>.</para>
      <h4>URL_APPLY_FORCEAPPLY</h4>
      <para>Force <b>UrlApplyScheme</b> to determine a scheme for pszIn.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns a standard COM return value, including the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>A scheme was determined. pszOut points to a string containing the URL with the scheme's prefix. The value of <i>pcchOut</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b> character.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>There were no errors, but no prefix was prepended.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_POINTER</b>
            </para>
          </description>
          <description>
            <para>The buffer was too small. The value of <i>pcchOut</i> is set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If the URL has a valid scheme, the string will not be modified. However, almost any combination of two or more characters followed by a colon will be parsed as a scheme. Valid characters include some common punctuation marks, such as ".". If your input string fits this description, <b>UrlApplyScheme</b> may treat it as valid and not apply a scheme. To force the function to apply a scheme to a URL, set the <b>URL_APPLY_FORCEAPPLY</b> and <b>URL_APPLY_DEFAULT</b> flags in <i>dwFlags</i>. This combination of flags forces the function to apply a scheme to the URL. Typically, the function will not be able to determine a valid scheme. The second flag guarantees that, if no valid scheme can be determined, the function will apply the default scheme to the URL.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlApplyScheme as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlApplyScheme">
    <summary>
      <para>Determines a scheme for a specified URL string, and returns a string with an appropriate prefix.</para>
    </summary>
    <param name="pszIn">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives a null-terminated string set to the URL specified by <i>pszIn</i> and converted to the standard <i>scheme</i>://<i>URL_string</i> format.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>The address of a value set to the number of characters in the <i>pszOut</i> buffer. When the function returns, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that specify how to determine the scheme. The following flags can be combined.</para>
      <h4>URL_APPLY_DEFAULT</h4>
      <para>Apply the default scheme if <b>UrlApplyScheme</b> can't determine one. The default prefix is stored in the registry but is typically "http".</para>
      <h4>URL_APPLY_GUESSSCHEME</h4>
      <para>Attempt to determine the scheme by examining <i>pszIn</i>.</para>
      <h4>URL_APPLY_GUESSFILE</h4>
      <para>Attempt to determine a file URL from <i>pszIn</i>.</para>
      <h4>URL_APPLY_FORCEAPPLY</h4>
      <para>Force <b>UrlApplyScheme</b> to determine a scheme for pszIn.</para>
      <h5>- dwFlags.URL_APPLY_DEFAULT</h5>
      <para>Apply the default scheme if <b>UrlApplyScheme</b> can't determine one. The default prefix is stored in the registry but is typically "http".</para>
      <h5>- dwFlags.URL_APPLY_FORCEAPPLY</h5>
      <para>Force <b>UrlApplyScheme</b> to determine a scheme for pszIn.</para>
      <h5>- dwFlags.URL_APPLY_GUESSFILE</h5>
      <para>Attempt to determine a file URL from <i>pszIn</i>.</para>
      <h5>- dwFlags.URL_APPLY_GUESSSCHEME</h5>
      <para>Attempt to determine the scheme by examining <i>pszIn</i>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns a standard COM return value, including the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>A scheme was determined. pszOut points to a string containing the URL with the scheme's prefix. The value of <i>pcchOut</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b> character.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>There were no errors, but no prefix was prepended.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_POINTER</b>
            </para>
          </description>
          <description>
            <para>The buffer was too small. The value of <i>pcchOut</i> is set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If the URL has a valid scheme, the string will not be modified. However, almost any combination of two or more characters followed by a colon will be parsed as a scheme. Valid characters include some common punctuation marks, such as ".". If your input string fits this description, <b>UrlApplyScheme</b> may treat it as valid and not apply a scheme. To force the function to apply a scheme to a URL, set the <b>URL_APPLY_FORCEAPPLY</b> and <b>URL_APPLY_DEFAULT</b> flags in <i>dwFlags</i>. This combination of flags forces the function to apply a scheme to the URL. Typically, the function will not be able to determine a valid scheme. The second flag guarantees that, if no valid scheme can be determined, the function will apply the default scheme to the URL.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlApplyScheme as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlApplySchemeA">
    <summary>
      <para>Determines a scheme for a specified URL string, and returns a string with an appropriate prefix.</para>
    </summary>
    <param name="pszIn">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives a null-terminated string set to the URL specified by <i>pszIn</i> and converted to the standard <i>scheme</i>://<i>URL_string</i> format.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>The address of a value set to the number of characters in the <i>pszOut</i> buffer. When the function returns, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that specify how to determine the scheme. The following flags can be combined.</para>
      <h4>URL_APPLY_DEFAULT</h4>
      <para>Apply the default scheme if <b>UrlApplyScheme</b> can't determine one. The default prefix is stored in the registry but is typically "http".</para>
      <h4>URL_APPLY_GUESSSCHEME</h4>
      <para>Attempt to determine the scheme by examining <i>pszIn</i>.</para>
      <h4>URL_APPLY_GUESSFILE</h4>
      <para>Attempt to determine a file URL from <i>pszIn</i>.</para>
      <h4>URL_APPLY_FORCEAPPLY</h4>
      <para>Force <b>UrlApplyScheme</b> to determine a scheme for pszIn.</para>
      <h5>- dwFlags.URL_APPLY_DEFAULT</h5>
      <para>Apply the default scheme if <b>UrlApplyScheme</b> can't determine one. The default prefix is stored in the registry but is typically "http".</para>
      <h5>- dwFlags.URL_APPLY_FORCEAPPLY</h5>
      <para>Force <b>UrlApplyScheme</b> to determine a scheme for pszIn.</para>
      <h5>- dwFlags.URL_APPLY_GUESSFILE</h5>
      <para>Attempt to determine a file URL from <i>pszIn</i>.</para>
      <h5>- dwFlags.URL_APPLY_GUESSSCHEME</h5>
      <para>Attempt to determine the scheme by examining <i>pszIn</i>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns a standard COM return value, including the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>A scheme was determined. pszOut points to a string containing the URL with the scheme's prefix. The value of <i>pcchOut</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b> character.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>There were no errors, but no prefix was prepended.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_POINTER</b>
            </para>
          </description>
          <description>
            <para>The buffer was too small. The value of <i>pcchOut</i> is set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If the URL has a valid scheme, the string will not be modified. However, almost any combination of two or more characters followed by a colon will be parsed as a scheme. Valid characters include some common punctuation marks, such as ".". If your input string fits this description, <b>UrlApplyScheme</b> may treat it as valid and not apply a scheme. To force the function to apply a scheme to a URL, set the <b>URL_APPLY_FORCEAPPLY</b> and <b>URL_APPLY_DEFAULT</b> flags in <i>dwFlags</i>. This combination of flags forces the function to apply a scheme to the URL. Typically, the function will not be able to determine a valid scheme. The second flag guarantees that, if no valid scheme can be determined, the function will apply the default scheme to the URL.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlApplyScheme as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlApplySchemeW">
    <summary>
      <para>Determines a scheme for a specified URL string, and returns a string with an appropriate prefix.</para>
    </summary>
    <param name="pszIn">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives a null-terminated string set to the URL specified by <i>pszIn</i> and converted to the standard <i>scheme</i>://<i>URL_string</i> format.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>The address of a value set to the number of characters in the <i>pszOut</i> buffer. When the function returns, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that specify how to determine the scheme. The following flags can be combined.</para>
      <h4>URL_APPLY_DEFAULT</h4>
      <para>Apply the default scheme if <b>UrlApplyScheme</b> can't determine one. The default prefix is stored in the registry but is typically "http".</para>
      <h4>URL_APPLY_GUESSSCHEME</h4>
      <para>Attempt to determine the scheme by examining <i>pszIn</i>.</para>
      <h4>URL_APPLY_GUESSFILE</h4>
      <para>Attempt to determine a file URL from <i>pszIn</i>.</para>
      <h4>URL_APPLY_FORCEAPPLY</h4>
      <para>Force <b>UrlApplyScheme</b> to determine a scheme for pszIn.</para>
      <h5>- dwFlags.URL_APPLY_DEFAULT</h5>
      <para>Apply the default scheme if <b>UrlApplyScheme</b> can't determine one. The default prefix is stored in the registry but is typically "http".</para>
      <h5>- dwFlags.URL_APPLY_FORCEAPPLY</h5>
      <para>Force <b>UrlApplyScheme</b> to determine a scheme for pszIn.</para>
      <h5>- dwFlags.URL_APPLY_GUESSFILE</h5>
      <para>Attempt to determine a file URL from <i>pszIn</i>.</para>
      <h5>- dwFlags.URL_APPLY_GUESSSCHEME</h5>
      <para>Attempt to determine the scheme by examining <i>pszIn</i>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns a standard COM return value, including the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <para>A scheme was determined. pszOut points to a string containing the URL with the scheme's prefix. The value of <i>pcchOut</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b> character.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>S_FALSE</b>
            </para>
          </description>
          <description>
            <para>There were no errors, but no prefix was prepended.</para>
          </description>
        </item>
        <item>
          <description>
            <para>
              <b>E_POINTER</b>
            </para>
          </description>
          <description>
            <para>The buffer was too small. The value of <i>pcchOut</i> is set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>If the URL has a valid scheme, the string will not be modified. However, almost any combination of two or more characters followed by a colon will be parsed as a scheme. Valid characters include some common punctuation marks, such as ".". If your input string fits this description, <b>UrlApplyScheme</b> may treat it as valid and not apply a scheme. To force the function to apply a scheme to a URL, set the <b>URL_APPLY_FORCEAPPLY</b> and <b>URL_APPLY_DEFAULT</b> flags in <i>dwFlags</i>. This combination of flags forces the function to apply a scheme to the URL. Typically, the function will not be able to determine a valid scheme. The second flag guarantees that, if no valid scheme can be determined, the function will apply the default scheme to the URL.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlApplyScheme as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlCanonicalize">
    <summary>
      <para>Converts a URL string into canonical form.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL string. If the string does not refer to a file, it must include a valid scheme such as "http://".</para>
    </param>
    <param name="pszCanonicalized">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted URL as a null-terminated string.</para>
    </param>
    <param name="pcchCanonicalized">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, is set to the number of characters in the <i>pszCanonicalized</i> buffer.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that specify how the URL is converted to canonical form. The following flags can be combined.</para>
      <h4>URL_UNESCAPE (0x10000000)</h4>
      <para>Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for "?" and "#" are not un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.</para>
      <h4>URL_ESCAPE_UNSAFE (0x20000000)</h4>
      <para>Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered during transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, [, ], and ') characters. This flag applies to all URLs, including opaque URLs.</para>
      <h4>URL_PLUGGABLE_PROTOCOL (0x40000000)</h4>
      <para>Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to standard protocols such as ftp, http, gopher, and so on. If this flag is set, <see cref="UrlCombine" /> does not simplify URLs, so there is no need to also set <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_ESCAPE_SPACES_ONLY (0x04000000)</h4>
      <para>Replace only spaces with escape sequences. This flag takes precedence over <b>URL_ESCAPE_UNSAFE</b>, but does not apply to opaque URLs.</para>
      <h4>URL_DONT_SIMPLIFY (0x08000000)</h4>
      <para>Treat "/./" and "/../" in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.</para>
      <h4>URL_NO_META (0x08000000)</h4>
      <para>Defined to be the same as <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_ESCAPE_PERCENT (0x00001000)</h4>
      <para>Convert any occurrence of "%" to its escape sequence.</para>
      <h4>URL_ESCAPE_AS_UTF8 (0x00040000)</h4>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This function performs such tasks as replacing unsafe characters with their escape sequences and collapsing sequences like ".....".</para>
      <para>If a URL string contains "/../" or "/./", <b>UrlCanonicalize</b> treats the characters as indicating navigation in the URL hierarchy. The function simplifies the URLs before combining them. For instance "/hello/cruel/../world" is simplified to "/hello/world". Exceptions to this default behavior occur in these cases:</para>
      <list type="bullet">
        <item>
          <description>If the <b>URL_DONT_SIMPLIFY</b> flag is set in <i>dwFlags</i>, the function does not simplify URLs. In this case, "/hello/cruel/../world" is left as it is.</description>
        </item>
        <item>
          <description>If "/../" or "/./" is the first segment in the path (for example, "http://domain/../path1/path2/file.htm"), <b>UrlCanonicalize</b> outputs the path exactly as it was input.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCanonicalize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinInet/handling-uniform-resource-locators">Handling Uniform Resource Locators</seealso>
  </member>
  <member name="Windows.UrlCanonicalizeA">
    <summary>
      <para>Converts a URL string into canonical form.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL string. If the string does not refer to a file, it must include a valid scheme such as "http://".</para>
    </param>
    <param name="pszCanonicalized">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted URL as a null-terminated string.</para>
    </param>
    <param name="pcchCanonicalized">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, is set to the number of characters in the <i>pszCanonicalized</i> buffer.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that specify how the URL is converted to canonical form. The following flags can be combined.</para>
      <h4>URL_UNESCAPE (0x10000000)</h4>
      <para>Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for "?" and "#" are not un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.</para>
      <h4>URL_ESCAPE_UNSAFE (0x20000000)</h4>
      <para>Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered during transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, [, ], and ') characters. This flag applies to all URLs, including opaque URLs.</para>
      <h4>URL_PLUGGABLE_PROTOCOL (0x40000000)</h4>
      <para>Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to standard protocols such as ftp, http, gopher, and so on. If this flag is set, <see cref="UrlCombine" /> does not simplify URLs, so there is no need to also set <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_ESCAPE_SPACES_ONLY (0x04000000)</h4>
      <para>Replace only spaces with escape sequences. This flag takes precedence over <b>URL_ESCAPE_UNSAFE</b>, but does not apply to opaque URLs.</para>
      <h4>URL_DONT_SIMPLIFY (0x08000000)</h4>
      <para>Treat "/./" and "/../" in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.</para>
      <h4>URL_NO_META (0x08000000)</h4>
      <para>Defined to be the same as <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_ESCAPE_PERCENT (0x00001000)</h4>
      <para>Convert any occurrence of "%" to its escape sequence.</para>
      <h4>URL_ESCAPE_AS_UTF8 (0x00040000)</h4>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This function performs such tasks as replacing unsafe characters with their escape sequences and collapsing sequences like ".....".</para>
      <para>If a URL string contains "/../" or "/./", <b>UrlCanonicalize</b> treats the characters as indicating navigation in the URL hierarchy. The function simplifies the URLs before combining them. For instance "/hello/cruel/../world" is simplified to "/hello/world". Exceptions to this default behavior occur in these cases:</para>
      <list type="bullet">
        <item>
          <description>If the <b>URL_DONT_SIMPLIFY</b> flag is set in <i>dwFlags</i>, the function does not simplify URLs. In this case, "/hello/cruel/../world" is left as it is.</description>
        </item>
        <item>
          <description>If "/../" or "/./" is the first segment in the path (for example, "http://domain/../path1/path2/file.htm"), <b>UrlCanonicalize</b> outputs the path exactly as it was input.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCanonicalize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinInet/handling-uniform-resource-locators">Handling Uniform Resource Locators</seealso>
  </member>
  <member name="Windows.UrlCanonicalizeW">
    <summary>
      <para>Converts a URL string into canonical form.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL string. If the string does not refer to a file, it must include a valid scheme such as "http://".</para>
    </param>
    <param name="pszCanonicalized">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted URL as a null-terminated string.</para>
    </param>
    <param name="pcchCanonicalized">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, is set to the number of characters in the <i>pszCanonicalized</i> buffer.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that specify how the URL is converted to canonical form. The following flags can be combined.</para>
      <h4>URL_UNESCAPE (0x10000000)</h4>
      <para>Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for "?" and "#" are not un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.</para>
      <h4>URL_ESCAPE_UNSAFE (0x20000000)</h4>
      <para>Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered during transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, [, ], and ') characters. This flag applies to all URLs, including opaque URLs.</para>
      <h4>URL_PLUGGABLE_PROTOCOL (0x40000000)</h4>
      <para>Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to standard protocols such as ftp, http, gopher, and so on. If this flag is set, <see cref="UrlCombine" /> does not simplify URLs, so there is no need to also set <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_ESCAPE_SPACES_ONLY (0x04000000)</h4>
      <para>Replace only spaces with escape sequences. This flag takes precedence over <b>URL_ESCAPE_UNSAFE</b>, but does not apply to opaque URLs.</para>
      <h4>URL_DONT_SIMPLIFY (0x08000000)</h4>
      <para>Treat "/./" and "/../" in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.</para>
      <h4>URL_NO_META (0x08000000)</h4>
      <para>Defined to be the same as <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_ESCAPE_PERCENT (0x00001000)</h4>
      <para>Convert any occurrence of "%" to its escape sequence.</para>
      <h4>URL_ESCAPE_AS_UTF8 (0x00040000)</h4>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This function performs such tasks as replacing unsafe characters with their escape sequences and collapsing sequences like ".....".</para>
      <para>If a URL string contains "/../" or "/./", <b>UrlCanonicalize</b> treats the characters as indicating navigation in the URL hierarchy. The function simplifies the URLs before combining them. For instance "/hello/cruel/../world" is simplified to "/hello/world". Exceptions to this default behavior occur in these cases:</para>
      <list type="bullet">
        <item>
          <description>If the <b>URL_DONT_SIMPLIFY</b> flag is set in <i>dwFlags</i>, the function does not simplify URLs. In this case, "/hello/cruel/../world" is left as it is.</description>
        </item>
        <item>
          <description>If "/../" or "/./" is the first segment in the path (for example, "http://domain/../path1/path2/file.htm"), <b>UrlCanonicalize</b> outputs the path exactly as it was input.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCanonicalize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinInet/handling-uniform-resource-locators">Handling Uniform Resource Locators</seealso>
  </member>
  <member name="Windows.UrlCanonicalize">
    <summary>
      <para>Converts a URL string into canonical form.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL string. If the string does not refer to a file, it must include a valid scheme such as "http://".</para>
    </param>
    <param name="pszCanonicalized">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted URL as a null-terminated string.</para>
    </param>
    <param name="pcchCanonicalized">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, is set to the number of characters in the <i>pszCanonicalized</i> buffer.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that specify how the URL is converted to canonical form. The following flags can be combined.</para>
      <h4>URL_UNESCAPE (0x10000000)</h4>
      <para>Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for "?" and "#" are not un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.</para>
      <h4>URL_ESCAPE_UNSAFE (0x20000000)</h4>
      <para>Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered during transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, [, ], and ') characters. This flag applies to all URLs, including opaque URLs.</para>
      <h4>URL_PLUGGABLE_PROTOCOL (0x40000000)</h4>
      <para>Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to standard protocols such as ftp, http, gopher, and so on. If this flag is set, <see cref="UrlCombine" /> does not simplify URLs, so there is no need to also set <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_ESCAPE_SPACES_ONLY (0x04000000)</h4>
      <para>Replace only spaces with escape sequences. This flag takes precedence over <b>URL_ESCAPE_UNSAFE</b>, but does not apply to opaque URLs.</para>
      <h4>URL_DONT_SIMPLIFY (0x08000000)</h4>
      <para>Treat "/./" and "/../" in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.</para>
      <h4>URL_NO_META (0x08000000)</h4>
      <para>Defined to be the same as <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_ESCAPE_PERCENT (0x00001000)</h4>
      <para>Convert any occurrence of "%" to its escape sequence.</para>
      <h4>URL_ESCAPE_AS_UTF8 (0x00040000)</h4>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h5>- dwFlags.URL_DONT_SIMPLIFY (0x08000000)</h5>
      <para>Treat "/./" and "/../" in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.</para>
      <h5>- dwFlags.URL_ESCAPE_AS_UTF8 (0x00040000)</h5>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h5>- dwFlags.URL_ESCAPE_PERCENT (0x00001000)</h5>
      <para>Convert any occurrence of "%" to its escape sequence.</para>
      <h5>- dwFlags.URL_ESCAPE_SPACES_ONLY (0x04000000)</h5>
      <para>Replace only spaces with escape sequences. This flag takes precedence over <b>URL_ESCAPE_UNSAFE</b>, but does not apply to opaque URLs.</para>
      <h5>- dwFlags.URL_ESCAPE_UNSAFE (0x20000000)</h5>
      <para>Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered during transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, [, ], and ') characters. This flag applies to all URLs, including opaque URLs.</para>
      <h5>- dwFlags.URL_NO_META (0x08000000)</h5>
      <para>Defined to be the same as <b>URL_DONT_SIMPLIFY</b>.</para>
      <h5>- dwFlags.URL_PLUGGABLE_PROTOCOL (0x40000000)</h5>
      <para>Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to standard protocols such as ftp, http, gopher, and so on. If this flag is set, <see cref="UrlCombine" /> does not simplify URLs, so there is no need to also set <b>URL_DONT_SIMPLIFY</b>.</para>
      <h5>- dwFlags.URL_UNESCAPE (0x10000000)</h5>
      <para>Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for "?" and "#" are not un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This function performs such tasks as replacing unsafe characters with their escape sequences and collapsing sequences like ".....".</para>
      <para>If a URL string contains "/../" or "/./", <b>UrlCanonicalize</b> treats the characters as indicating navigation in the URL hierarchy. The function simplifies the URLs before combining them. For instance "/hello/cruel/../world" is simplified to "/hello/world". Exceptions to this default behavior occur in these cases:</para>
      <list type="bullet">
        <item>
          <description>If the <b>URL_DONT_SIMPLIFY</b> flag is set in <i>dwFlags</i>, the function does not simplify URLs. In this case, "/hello/cruel/../world" is left as it is.</description>
        </item>
        <item>
          <description>If "/../" or "/./" is the first segment in the path (for example, "http://domain/../path1/path2/file.htm"), <b>UrlCanonicalize</b> outputs the path exactly as it was input.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCanonicalize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinInet/handling-uniform-resource-locators">Handling Uniform Resource Locators</seealso>
  </member>
  <member name="Windows.UrlCanonicalizeA">
    <summary>
      <para>Converts a URL string into canonical form.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL string. If the string does not refer to a file, it must include a valid scheme such as "http://".</para>
    </param>
    <param name="pszCanonicalized">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted URL as a null-terminated string.</para>
    </param>
    <param name="pcchCanonicalized">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, is set to the number of characters in the <i>pszCanonicalized</i> buffer.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that specify how the URL is converted to canonical form. The following flags can be combined.</para>
      <h4>URL_UNESCAPE (0x10000000)</h4>
      <para>Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for "?" and "#" are not un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.</para>
      <h4>URL_ESCAPE_UNSAFE (0x20000000)</h4>
      <para>Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered during transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, [, ], and ') characters. This flag applies to all URLs, including opaque URLs.</para>
      <h4>URL_PLUGGABLE_PROTOCOL (0x40000000)</h4>
      <para>Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to standard protocols such as ftp, http, gopher, and so on. If this flag is set, <see cref="UrlCombine" /> does not simplify URLs, so there is no need to also set <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_ESCAPE_SPACES_ONLY (0x04000000)</h4>
      <para>Replace only spaces with escape sequences. This flag takes precedence over <b>URL_ESCAPE_UNSAFE</b>, but does not apply to opaque URLs.</para>
      <h4>URL_DONT_SIMPLIFY (0x08000000)</h4>
      <para>Treat "/./" and "/../" in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.</para>
      <h4>URL_NO_META (0x08000000)</h4>
      <para>Defined to be the same as <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_ESCAPE_PERCENT (0x00001000)</h4>
      <para>Convert any occurrence of "%" to its escape sequence.</para>
      <h4>URL_ESCAPE_AS_UTF8 (0x00040000)</h4>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h5>- dwFlags.URL_DONT_SIMPLIFY (0x08000000)</h5>
      <para>Treat "/./" and "/../" in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.</para>
      <h5>- dwFlags.URL_ESCAPE_AS_UTF8 (0x00040000)</h5>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h5>- dwFlags.URL_ESCAPE_PERCENT (0x00001000)</h5>
      <para>Convert any occurrence of "%" to its escape sequence.</para>
      <h5>- dwFlags.URL_ESCAPE_SPACES_ONLY (0x04000000)</h5>
      <para>Replace only spaces with escape sequences. This flag takes precedence over <b>URL_ESCAPE_UNSAFE</b>, but does not apply to opaque URLs.</para>
      <h5>- dwFlags.URL_ESCAPE_UNSAFE (0x20000000)</h5>
      <para>Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered during transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, [, ], and ') characters. This flag applies to all URLs, including opaque URLs.</para>
      <h5>- dwFlags.URL_NO_META (0x08000000)</h5>
      <para>Defined to be the same as <b>URL_DONT_SIMPLIFY</b>.</para>
      <h5>- dwFlags.URL_PLUGGABLE_PROTOCOL (0x40000000)</h5>
      <para>Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to standard protocols such as ftp, http, gopher, and so on. If this flag is set, <see cref="UrlCombine" /> does not simplify URLs, so there is no need to also set <b>URL_DONT_SIMPLIFY</b>.</para>
      <h5>- dwFlags.URL_UNESCAPE (0x10000000)</h5>
      <para>Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for "?" and "#" are not un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This function performs such tasks as replacing unsafe characters with their escape sequences and collapsing sequences like ".....".</para>
      <para>If a URL string contains "/../" or "/./", <b>UrlCanonicalize</b> treats the characters as indicating navigation in the URL hierarchy. The function simplifies the URLs before combining them. For instance "/hello/cruel/../world" is simplified to "/hello/world". Exceptions to this default behavior occur in these cases:</para>
      <list type="bullet">
        <item>
          <description>If the <b>URL_DONT_SIMPLIFY</b> flag is set in <i>dwFlags</i>, the function does not simplify URLs. In this case, "/hello/cruel/../world" is left as it is.</description>
        </item>
        <item>
          <description>If "/../" or "/./" is the first segment in the path (for example, "http://domain/../path1/path2/file.htm"), <b>UrlCanonicalize</b> outputs the path exactly as it was input.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCanonicalize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinInet/handling-uniform-resource-locators">Handling Uniform Resource Locators</seealso>
  </member>
  <member name="Windows.UrlCanonicalizeW">
    <summary>
      <para>Converts a URL string into canonical form.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains a URL string. If the string does not refer to a file, it must include a valid scheme such as "http://".</para>
    </param>
    <param name="pszCanonicalized">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the converted URL as a null-terminated string.</para>
    </param>
    <param name="pcchCanonicalized">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, is set to the number of characters in the <i>pszCanonicalized</i> buffer.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that specify how the URL is converted to canonical form. The following flags can be combined.</para>
      <h4>URL_UNESCAPE (0x10000000)</h4>
      <para>Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for "?" and "#" are not un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.</para>
      <h4>URL_ESCAPE_UNSAFE (0x20000000)</h4>
      <para>Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered during transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, [, ], and ') characters. This flag applies to all URLs, including opaque URLs.</para>
      <h4>URL_PLUGGABLE_PROTOCOL (0x40000000)</h4>
      <para>Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to standard protocols such as ftp, http, gopher, and so on. If this flag is set, <see cref="UrlCombine" /> does not simplify URLs, so there is no need to also set <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_ESCAPE_SPACES_ONLY (0x04000000)</h4>
      <para>Replace only spaces with escape sequences. This flag takes precedence over <b>URL_ESCAPE_UNSAFE</b>, but does not apply to opaque URLs.</para>
      <h4>URL_DONT_SIMPLIFY (0x08000000)</h4>
      <para>Treat "/./" and "/../" in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.</para>
      <h4>URL_NO_META (0x08000000)</h4>
      <para>Defined to be the same as <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_ESCAPE_PERCENT (0x00001000)</h4>
      <para>Convert any occurrence of "%" to its escape sequence.</para>
      <h4>URL_ESCAPE_AS_UTF8 (0x00040000)</h4>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h5>- dwFlags.URL_DONT_SIMPLIFY (0x08000000)</h5>
      <para>Treat "/./" and "/../" in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.</para>
      <h5>- dwFlags.URL_ESCAPE_AS_UTF8 (0x00040000)</h5>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h5>- dwFlags.URL_ESCAPE_PERCENT (0x00001000)</h5>
      <para>Convert any occurrence of "%" to its escape sequence.</para>
      <h5>- dwFlags.URL_ESCAPE_SPACES_ONLY (0x04000000)</h5>
      <para>Replace only spaces with escape sequences. This flag takes precedence over <b>URL_ESCAPE_UNSAFE</b>, but does not apply to opaque URLs.</para>
      <h5>- dwFlags.URL_ESCAPE_UNSAFE (0x20000000)</h5>
      <para>Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered during transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, [, ], and ') characters. This flag applies to all URLs, including opaque URLs.</para>
      <h5>- dwFlags.URL_NO_META (0x08000000)</h5>
      <para>Defined to be the same as <b>URL_DONT_SIMPLIFY</b>.</para>
      <h5>- dwFlags.URL_PLUGGABLE_PROTOCOL (0x40000000)</h5>
      <para>Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to standard protocols such as ftp, http, gopher, and so on. If this flag is set, <see cref="UrlCombine" /> does not simplify URLs, so there is no need to also set <b>URL_DONT_SIMPLIFY</b>.</para>
      <h5>- dwFlags.URL_UNESCAPE (0x10000000)</h5>
      <para>Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for "?" and "#" are not un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>This function performs such tasks as replacing unsafe characters with their escape sequences and collapsing sequences like ".....".</para>
      <para>If a URL string contains "/../" or "/./", <b>UrlCanonicalize</b> treats the characters as indicating navigation in the URL hierarchy. The function simplifies the URLs before combining them. For instance "/hello/cruel/../world" is simplified to "/hello/world". Exceptions to this default behavior occur in these cases:</para>
      <list type="bullet">
        <item>
          <description>If the <b>URL_DONT_SIMPLIFY</b> flag is set in <i>dwFlags</i>, the function does not simplify URLs. In this case, "/hello/cruel/../world" is left as it is.</description>
        </item>
        <item>
          <description>If "/../" or "/./" is the first segment in the path (for example, "http://domain/../path1/path2/file.htm"), <b>UrlCanonicalize</b> outputs the path exactly as it was input.</description>
        </item>
      </list>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCanonicalize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinInet/handling-uniform-resource-locators">Handling Uniform Resource Locators</seealso>
  </member>
  <member name="Windows.UrlCombine">
    <summary>
      <para>When provided with a relative URL and its base, returns a URL in canonical form.</para>
    </summary>
    <param name="pszBase">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the base URL.</para>
    </param>
    <param name="pszRelative">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the relative URL.</para>
    </param>
    <param name="pszCombined">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives a null-terminated string that contains the combined URL.</para>
    </param>
    <param name="pcchCombined">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, is set to the number of characters in the <i>pszCombined</i> buffer. When the function returns successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that specify how the URL is converted to canonical form. The following flags can be combined.</para>
      <h4>URL_DONT_SIMPLIFY (0x08000000)</h4>
      <para>Treat '/./' and '/../' in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.</para>
      <h4>URL_ESCAPE_PERCENT (0x00001000)</h4>
      <para>Convert any occurrence of '%' to its escape sequence.</para>
      <h4>URL_ESCAPE_SPACES_ONLY (0x04000000)</h4>
      <para>Replace only spaces with escape sequences. This flag takes precedence over <b>URL_ESCAPE_UNSAFE</b>, but does not apply to opaque URLs.</para>
      <h4>URL_ESCAPE_UNSAFE (0x20000000)</h4>
      <para>Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered during transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, ~, [, ], and ') characters. This flag applies to all URLs, including opaque URLs.</para>
      <h4>URL_NO_META</h4>
      <para>Defined to be the same as <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_PLUGGABLE_PROTOCOL (0x40000000)</h4>
      <para>Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to standard protocols such as ftp, http, gopher, and so on. If this flag is set, <b>UrlCombine</b> does not simplify URLs, so there is no need to also set <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_UNESCAPE (0x10000000)</h4>
      <para>Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for '?' and '#' are not un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.</para>
      <h4>URL_ESCAPE_AS_UTF8 (0x00040000)</h4>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns standard COM error codes, including the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <i>pszCombined</i> points to a string that contains the combined URLs. The value of <i>pcchCombined</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b> character.
</description>
        </item>
        <item>
          <description>
            <para>
              <b>E_POINTER</b>
            </para>
          </description>
          <description>
            <para>The buffer was too small. The value of <i>pcchCombined</i> is set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Items between slashes are treated as hierarchical identifiers; the last item specifies the document itself. You must enter a slash (/) after the document name to append more items; otherwise, <b>UrlCombine</b> exchanges one document for another. For example:</para>
      <code>
hRetVal = UrlCombine(TEXT("http://xyz/test/abc"),
                     TEXT("bar"),
                     lpszCombined,
                     &amp;amp;amp;amp;amp;amp;dwLength, 0);
</code>
      <para>The preceding code returns the URL http://xyz/test/bar. If you want the combined URL to be http://xyz/test/abc/bar, use the following call to <b>UrlCombine</b>.</para>
      <code>
hRetVal = UrlCombine(TEXT("http://xyz/test/abc/"),
                     TEXT("bar"),
                     lpszCombined,
                     &amp;amp;amp;amp;amp;amp;dwLength, 0);
</code>
      <para>If a URL string contains '/../' or '/./', <b>UrlCombine</b> usually treats the characters as if they indicated navigation in the URL hierarchy. The function simplifies the URLs before combining them. For instance, "/hello/cruel/../world" is simplified to "/hello/world". If the <b>URL_DONT_SIMPLIFY</b> flag is set in <i>dwFlags</i>, the function does not simplify URLs. In this case, "/hello/cruel/../world" is left as it is.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCombine as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinInet/handling-uniform-resource-locators">Handling Uniform Resource Locators</seealso>
    <seealso cref="UrlCanonicalize" />
  </member>
  <member name="Windows.UrlCombineA">
    <summary>
      <para>When provided with a relative URL and its base, returns a URL in canonical form.</para>
    </summary>
    <param name="pszBase">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the base URL.</para>
    </param>
    <param name="pszRelative">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the relative URL.</para>
    </param>
    <param name="pszCombined">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives a null-terminated string that contains the combined URL.</para>
    </param>
    <param name="pcchCombined">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, is set to the number of characters in the <i>pszCombined</i> buffer. When the function returns successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that specify how the URL is converted to canonical form. The following flags can be combined.</para>
      <h4>URL_DONT_SIMPLIFY (0x08000000)</h4>
      <para>Treat '/./' and '/../' in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.</para>
      <h4>URL_ESCAPE_PERCENT (0x00001000)</h4>
      <para>Convert any occurrence of '%' to its escape sequence.</para>
      <h4>URL_ESCAPE_SPACES_ONLY (0x04000000)</h4>
      <para>Replace only spaces with escape sequences. This flag takes precedence over <b>URL_ESCAPE_UNSAFE</b>, but does not apply to opaque URLs.</para>
      <h4>URL_ESCAPE_UNSAFE (0x20000000)</h4>
      <para>Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered during transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, ~, [, ], and ') characters. This flag applies to all URLs, including opaque URLs.</para>
      <h4>URL_NO_META</h4>
      <para>Defined to be the same as <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_PLUGGABLE_PROTOCOL (0x40000000)</h4>
      <para>Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to standard protocols such as ftp, http, gopher, and so on. If this flag is set, <b>UrlCombine</b> does not simplify URLs, so there is no need to also set <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_UNESCAPE (0x10000000)</h4>
      <para>Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for '?' and '#' are not un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.</para>
      <h4>URL_ESCAPE_AS_UTF8 (0x00040000)</h4>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns standard COM error codes, including the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <i>pszCombined</i> points to a string that contains the combined URLs. The value of <i>pcchCombined</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b> character.
</description>
        </item>
        <item>
          <description>
            <para>
              <b>E_POINTER</b>
            </para>
          </description>
          <description>
            <para>The buffer was too small. The value of <i>pcchCombined</i> is set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Items between slashes are treated as hierarchical identifiers; the last item specifies the document itself. You must enter a slash (/) after the document name to append more items; otherwise, <b>UrlCombine</b> exchanges one document for another. For example:</para>
      <code>
hRetVal = UrlCombine(TEXT("http://xyz/test/abc"),
                     TEXT("bar"),
                     lpszCombined,
                     &amp;amp;amp;amp;amp;amp;dwLength, 0);
</code>
      <para>The preceding code returns the URL http://xyz/test/bar. If you want the combined URL to be http://xyz/test/abc/bar, use the following call to <b>UrlCombine</b>.</para>
      <code>
hRetVal = UrlCombine(TEXT("http://xyz/test/abc/"),
                     TEXT("bar"),
                     lpszCombined,
                     &amp;amp;amp;amp;amp;amp;dwLength, 0);
</code>
      <para>If a URL string contains '/../' or '/./', <b>UrlCombine</b> usually treats the characters as if they indicated navigation in the URL hierarchy. The function simplifies the URLs before combining them. For instance, "/hello/cruel/../world" is simplified to "/hello/world". If the <b>URL_DONT_SIMPLIFY</b> flag is set in <i>dwFlags</i>, the function does not simplify URLs. In this case, "/hello/cruel/../world" is left as it is.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCombine as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinInet/handling-uniform-resource-locators">Handling Uniform Resource Locators</seealso>
    <seealso cref="UrlCanonicalize" />
  </member>
  <member name="Windows.UrlCombineW">
    <summary>
      <para>When provided with a relative URL and its base, returns a URL in canonical form.</para>
    </summary>
    <param name="pszBase">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the base URL.</para>
    </param>
    <param name="pszRelative">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the relative URL.</para>
    </param>
    <param name="pszCombined">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives a null-terminated string that contains the combined URL.</para>
    </param>
    <param name="pcchCombined">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, is set to the number of characters in the <i>pszCombined</i> buffer. When the function returns successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that specify how the URL is converted to canonical form. The following flags can be combined.</para>
      <h4>URL_DONT_SIMPLIFY (0x08000000)</h4>
      <para>Treat '/./' and '/../' in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.</para>
      <h4>URL_ESCAPE_PERCENT (0x00001000)</h4>
      <para>Convert any occurrence of '%' to its escape sequence.</para>
      <h4>URL_ESCAPE_SPACES_ONLY (0x04000000)</h4>
      <para>Replace only spaces with escape sequences. This flag takes precedence over <b>URL_ESCAPE_UNSAFE</b>, but does not apply to opaque URLs.</para>
      <h4>URL_ESCAPE_UNSAFE (0x20000000)</h4>
      <para>Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered during transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, ~, [, ], and ') characters. This flag applies to all URLs, including opaque URLs.</para>
      <h4>URL_NO_META</h4>
      <para>Defined to be the same as <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_PLUGGABLE_PROTOCOL (0x40000000)</h4>
      <para>Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to standard protocols such as ftp, http, gopher, and so on. If this flag is set, <b>UrlCombine</b> does not simplify URLs, so there is no need to also set <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_UNESCAPE (0x10000000)</h4>
      <para>Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for '?' and '#' are not un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.</para>
      <h4>URL_ESCAPE_AS_UTF8 (0x00040000)</h4>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns standard COM error codes, including the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <i>pszCombined</i> points to a string that contains the combined URLs. The value of <i>pcchCombined</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b> character.
</description>
        </item>
        <item>
          <description>
            <para>
              <b>E_POINTER</b>
            </para>
          </description>
          <description>
            <para>The buffer was too small. The value of <i>pcchCombined</i> is set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Items between slashes are treated as hierarchical identifiers; the last item specifies the document itself. You must enter a slash (/) after the document name to append more items; otherwise, <b>UrlCombine</b> exchanges one document for another. For example:</para>
      <code>
hRetVal = UrlCombine(TEXT("http://xyz/test/abc"),
                     TEXT("bar"),
                     lpszCombined,
                     &amp;amp;amp;amp;amp;amp;dwLength, 0);
</code>
      <para>The preceding code returns the URL http://xyz/test/bar. If you want the combined URL to be http://xyz/test/abc/bar, use the following call to <b>UrlCombine</b>.</para>
      <code>
hRetVal = UrlCombine(TEXT("http://xyz/test/abc/"),
                     TEXT("bar"),
                     lpszCombined,
                     &amp;amp;amp;amp;amp;amp;dwLength, 0);
</code>
      <para>If a URL string contains '/../' or '/./', <b>UrlCombine</b> usually treats the characters as if they indicated navigation in the URL hierarchy. The function simplifies the URLs before combining them. For instance, "/hello/cruel/../world" is simplified to "/hello/world". If the <b>URL_DONT_SIMPLIFY</b> flag is set in <i>dwFlags</i>, the function does not simplify URLs. In this case, "/hello/cruel/../world" is left as it is.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCombine as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinInet/handling-uniform-resource-locators">Handling Uniform Resource Locators</seealso>
    <seealso cref="UrlCanonicalize" />
  </member>
  <member name="Windows.UrlCombine">
    <summary>
      <para>When provided with a relative URL and its base, returns a URL in canonical form.</para>
    </summary>
    <param name="pszBase">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the base URL.</para>
    </param>
    <param name="pszRelative">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the relative URL.</para>
    </param>
    <param name="pszCombined">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives a null-terminated string that contains the combined URL.</para>
    </param>
    <param name="pcchCombined">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, is set to the number of characters in the <i>pszCombined</i> buffer. When the function returns successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that specify how the URL is converted to canonical form. The following flags can be combined.</para>
      <h4>URL_DONT_SIMPLIFY (0x08000000)</h4>
      <para>Treat '/./' and '/../' in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.</para>
      <h4>URL_ESCAPE_PERCENT (0x00001000)</h4>
      <para>Convert any occurrence of '%' to its escape sequence.</para>
      <h4>URL_ESCAPE_SPACES_ONLY (0x04000000)</h4>
      <para>Replace only spaces with escape sequences. This flag takes precedence over <b>URL_ESCAPE_UNSAFE</b>, but does not apply to opaque URLs.</para>
      <h4>URL_ESCAPE_UNSAFE (0x20000000)</h4>
      <para>Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered during transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, ~, [, ], and ') characters. This flag applies to all URLs, including opaque URLs.</para>
      <h4>URL_NO_META</h4>
      <para>Defined to be the same as <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_PLUGGABLE_PROTOCOL (0x40000000)</h4>
      <para>Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to standard protocols such as ftp, http, gopher, and so on. If this flag is set, <b>UrlCombine</b> does not simplify URLs, so there is no need to also set <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_UNESCAPE (0x10000000)</h4>
      <para>Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for '?' and '#' are not un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.</para>
      <h4>URL_ESCAPE_AS_UTF8 (0x00040000)</h4>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h5>- dwFlags.URL_DONT_SIMPLIFY (0x08000000)</h5>
      <para>Treat '/./' and '/../' in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.</para>
      <h5>- dwFlags.URL_ESCAPE_AS_UTF8 (0x00040000)</h5>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h5>- dwFlags.URL_ESCAPE_PERCENT (0x00001000)</h5>
      <para>Convert any occurrence of '%' to its escape sequence.</para>
      <h5>- dwFlags.URL_ESCAPE_SPACES_ONLY (0x04000000)</h5>
      <para>Replace only spaces with escape sequences. This flag takes precedence over <b>URL_ESCAPE_UNSAFE</b>, but does not apply to opaque URLs.</para>
      <h5>- dwFlags.URL_ESCAPE_UNSAFE (0x20000000)</h5>
      <para>Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered during transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, ~, [, ], and ') characters. This flag applies to all URLs, including opaque URLs.</para>
      <h5>- dwFlags.URL_NO_META</h5>
      <para>Defined to be the same as <b>URL_DONT_SIMPLIFY</b>.</para>
      <h5>- dwFlags.URL_PLUGGABLE_PROTOCOL (0x40000000)</h5>
      <para>Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to standard protocols such as ftp, http, gopher, and so on. If this flag is set, <b>UrlCombine</b> does not simplify URLs, so there is no need to also set <b>URL_DONT_SIMPLIFY</b>.</para>
      <h5>- dwFlags.URL_UNESCAPE (0x10000000)</h5>
      <para>Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for '?' and '#' are not un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns standard COM error codes, including the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <i>pszCombined</i> points to a string that contains the combined URLs. The value of <i>pcchCombined</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b> character.
</description>
        </item>
        <item>
          <description>
            <para>
              <b>E_POINTER</b>
            </para>
          </description>
          <description>
            <para>The buffer was too small. The value of <i>pcchCombined</i> is set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Items between slashes are treated as hierarchical identifiers; the last item specifies the document itself. You must enter a slash (/) after the document name to append more items; otherwise, <b>UrlCombine</b> exchanges one document for another. For example:</para>
      <code>
hRetVal = UrlCombine(TEXT("http://xyz/test/abc"),
                     TEXT("bar"),
                     lpszCombined,
                     &amp;amp;amp;amp;amp;amp;dwLength, 0);
</code>
      <para>The preceding code returns the URL http://xyz/test/bar. If you want the combined URL to be http://xyz/test/abc/bar, use the following call to <b>UrlCombine</b>.</para>
      <code>
hRetVal = UrlCombine(TEXT("http://xyz/test/abc/"),
                     TEXT("bar"),
                     lpszCombined,
                     &amp;amp;amp;amp;amp;amp;dwLength, 0);
</code>
      <para>If a URL string contains '/../' or '/./', <b>UrlCombine</b> usually treats the characters as if they indicated navigation in the URL hierarchy. The function simplifies the URLs before combining them. For instance, "/hello/cruel/../world" is simplified to "/hello/world". If the <b>URL_DONT_SIMPLIFY</b> flag is set in <i>dwFlags</i>, the function does not simplify URLs. In this case, "/hello/cruel/../world" is left as it is.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCombine as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinInet/handling-uniform-resource-locators">Handling Uniform Resource Locators</seealso>
    <seealso cref="UrlCanonicalize" />
  </member>
  <member name="Windows.UrlCombineA">
    <summary>
      <para>When provided with a relative URL and its base, returns a URL in canonical form.</para>
    </summary>
    <param name="pszBase">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the base URL.</para>
    </param>
    <param name="pszRelative">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the relative URL.</para>
    </param>
    <param name="pszCombined">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives a null-terminated string that contains the combined URL.</para>
    </param>
    <param name="pcchCombined">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, is set to the number of characters in the <i>pszCombined</i> buffer. When the function returns successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that specify how the URL is converted to canonical form. The following flags can be combined.</para>
      <h4>URL_DONT_SIMPLIFY (0x08000000)</h4>
      <para>Treat '/./' and '/../' in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.</para>
      <h4>URL_ESCAPE_PERCENT (0x00001000)</h4>
      <para>Convert any occurrence of '%' to its escape sequence.</para>
      <h4>URL_ESCAPE_SPACES_ONLY (0x04000000)</h4>
      <para>Replace only spaces with escape sequences. This flag takes precedence over <b>URL_ESCAPE_UNSAFE</b>, but does not apply to opaque URLs.</para>
      <h4>URL_ESCAPE_UNSAFE (0x20000000)</h4>
      <para>Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered during transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, ~, [, ], and ') characters. This flag applies to all URLs, including opaque URLs.</para>
      <h4>URL_NO_META</h4>
      <para>Defined to be the same as <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_PLUGGABLE_PROTOCOL (0x40000000)</h4>
      <para>Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to standard protocols such as ftp, http, gopher, and so on. If this flag is set, <b>UrlCombine</b> does not simplify URLs, so there is no need to also set <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_UNESCAPE (0x10000000)</h4>
      <para>Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for '?' and '#' are not un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.</para>
      <h4>URL_ESCAPE_AS_UTF8 (0x00040000)</h4>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h5>- dwFlags.URL_DONT_SIMPLIFY (0x08000000)</h5>
      <para>Treat '/./' and '/../' in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.</para>
      <h5>- dwFlags.URL_ESCAPE_AS_UTF8 (0x00040000)</h5>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h5>- dwFlags.URL_ESCAPE_PERCENT (0x00001000)</h5>
      <para>Convert any occurrence of '%' to its escape sequence.</para>
      <h5>- dwFlags.URL_ESCAPE_SPACES_ONLY (0x04000000)</h5>
      <para>Replace only spaces with escape sequences. This flag takes precedence over <b>URL_ESCAPE_UNSAFE</b>, but does not apply to opaque URLs.</para>
      <h5>- dwFlags.URL_ESCAPE_UNSAFE (0x20000000)</h5>
      <para>Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered during transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, ~, [, ], and ') characters. This flag applies to all URLs, including opaque URLs.</para>
      <h5>- dwFlags.URL_NO_META</h5>
      <para>Defined to be the same as <b>URL_DONT_SIMPLIFY</b>.</para>
      <h5>- dwFlags.URL_PLUGGABLE_PROTOCOL (0x40000000)</h5>
      <para>Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to standard protocols such as ftp, http, gopher, and so on. If this flag is set, <b>UrlCombine</b> does not simplify URLs, so there is no need to also set <b>URL_DONT_SIMPLIFY</b>.</para>
      <h5>- dwFlags.URL_UNESCAPE (0x10000000)</h5>
      <para>Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for '?' and '#' are not un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns standard COM error codes, including the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <i>pszCombined</i> points to a string that contains the combined URLs. The value of <i>pcchCombined</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b> character.
</description>
        </item>
        <item>
          <description>
            <para>
              <b>E_POINTER</b>
            </para>
          </description>
          <description>
            <para>The buffer was too small. The value of <i>pcchCombined</i> is set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Items between slashes are treated as hierarchical identifiers; the last item specifies the document itself. You must enter a slash (/) after the document name to append more items; otherwise, <b>UrlCombine</b> exchanges one document for another. For example:</para>
      <code>
hRetVal = UrlCombine(TEXT("http://xyz/test/abc"),
                     TEXT("bar"),
                     lpszCombined,
                     &amp;amp;amp;amp;amp;amp;dwLength, 0);
</code>
      <para>The preceding code returns the URL http://xyz/test/bar. If you want the combined URL to be http://xyz/test/abc/bar, use the following call to <b>UrlCombine</b>.</para>
      <code>
hRetVal = UrlCombine(TEXT("http://xyz/test/abc/"),
                     TEXT("bar"),
                     lpszCombined,
                     &amp;amp;amp;amp;amp;amp;dwLength, 0);
</code>
      <para>If a URL string contains '/../' or '/./', <b>UrlCombine</b> usually treats the characters as if they indicated navigation in the URL hierarchy. The function simplifies the URLs before combining them. For instance, "/hello/cruel/../world" is simplified to "/hello/world". If the <b>URL_DONT_SIMPLIFY</b> flag is set in <i>dwFlags</i>, the function does not simplify URLs. In this case, "/hello/cruel/../world" is left as it is.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCombine as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinInet/handling-uniform-resource-locators">Handling Uniform Resource Locators</seealso>
    <seealso cref="UrlCanonicalize" />
  </member>
  <member name="Windows.UrlCombineW">
    <summary>
      <para>When provided with a relative URL and its base, returns a URL in canonical form.</para>
    </summary>
    <param name="pszBase">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the base URL.</para>
    </param>
    <param name="pszRelative">
      <para>Type: <b>PCTSTR</b></para>
      <para>A pointer to a null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the relative URL.</para>
    </param>
    <param name="pszCombined">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives a null-terminated string that contains the combined URL.</para>
    </param>
    <param name="pcchCombined">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, is set to the number of characters in the <i>pszCombined</i> buffer. When the function returns successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that specify how the URL is converted to canonical form. The following flags can be combined.</para>
      <h4>URL_DONT_SIMPLIFY (0x08000000)</h4>
      <para>Treat '/./' and '/../' in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.</para>
      <h4>URL_ESCAPE_PERCENT (0x00001000)</h4>
      <para>Convert any occurrence of '%' to its escape sequence.</para>
      <h4>URL_ESCAPE_SPACES_ONLY (0x04000000)</h4>
      <para>Replace only spaces with escape sequences. This flag takes precedence over <b>URL_ESCAPE_UNSAFE</b>, but does not apply to opaque URLs.</para>
      <h4>URL_ESCAPE_UNSAFE (0x20000000)</h4>
      <para>Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered during transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, ~, [, ], and ') characters. This flag applies to all URLs, including opaque URLs.</para>
      <h4>URL_NO_META</h4>
      <para>Defined to be the same as <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_PLUGGABLE_PROTOCOL (0x40000000)</h4>
      <para>Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to standard protocols such as ftp, http, gopher, and so on. If this flag is set, <b>UrlCombine</b> does not simplify URLs, so there is no need to also set <b>URL_DONT_SIMPLIFY</b>.</para>
      <h4>URL_UNESCAPE (0x10000000)</h4>
      <para>Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for '?' and '#' are not un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.</para>
      <h4>URL_ESCAPE_AS_UTF8 (0x00040000)</h4>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h5>- dwFlags.URL_DONT_SIMPLIFY (0x08000000)</h5>
      <para>Treat '/./' and '/../' in a URL string as literal characters, not as shorthand for navigation. See Remarks for further discussion.</para>
      <h5>- dwFlags.URL_ESCAPE_AS_UTF8 (0x00040000)</h5>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h5>- dwFlags.URL_ESCAPE_PERCENT (0x00001000)</h5>
      <para>Convert any occurrence of '%' to its escape sequence.</para>
      <h5>- dwFlags.URL_ESCAPE_SPACES_ONLY (0x04000000)</h5>
      <para>Replace only spaces with escape sequences. This flag takes precedence over <b>URL_ESCAPE_UNSAFE</b>, but does not apply to opaque URLs.</para>
      <h5>- dwFlags.URL_ESCAPE_UNSAFE (0x20000000)</h5>
      <para>Replace unsafe characters with their escape sequences. Unsafe characters are those characters that may be altered during transport across the Internet, and include the (&lt;, &gt;, ", #, {, }, |, , ^, ~, [, ], and ') characters. This flag applies to all URLs, including opaque URLs.</para>
      <h5>- dwFlags.URL_NO_META</h5>
      <para>Defined to be the same as <b>URL_DONT_SIMPLIFY</b>.</para>
      <h5>- dwFlags.URL_PLUGGABLE_PROTOCOL (0x40000000)</h5>
      <para>Combine URLs with client-defined pluggable protocols, according to the W3C specification. This flag does not apply to standard protocols such as ftp, http, gopher, and so on. If this flag is set, <b>UrlCombine</b> does not simplify URLs, so there is no need to also set <b>URL_DONT_SIMPLIFY</b>.</para>
      <h5>- dwFlags.URL_UNESCAPE (0x10000000)</h5>
      <para>Un-escape any escape sequences that the URLs contain, with two exceptions. The escape sequences for '?' and '#' are not un-escaped. If one of the URL_ESCAPE_XXX flags is also set, the two URLs are first un-escaped, then combined, then escaped.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns standard COM error codes, including the following.</para>
      <list type="table">
        <listheader>
          <description>Return code</description>
          <description>Description</description>
        </listheader>
        <item>
          <description>
            <para>
              <b>S_OK</b>
            </para>
          </description>
          <description>
            <i>pszCombined</i> points to a string that contains the combined URLs. The value of <i>pcchCombined</i> is set to the number of characters in the string, not counting the terminating <b>NULL</b> character.
</description>
        </item>
        <item>
          <description>
            <para>
              <b>E_POINTER</b>
            </para>
          </description>
          <description>
            <para>The buffer was too small. The value of <i>pcchCombined</i> is set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character.</para>
          </description>
        </item>
      </list>
    </returns>
    <remarks>
      <para>Items between slashes are treated as hierarchical identifiers; the last item specifies the document itself. You must enter a slash (/) after the document name to append more items; otherwise, <b>UrlCombine</b> exchanges one document for another. For example:</para>
      <code>
hRetVal = UrlCombine(TEXT("http://xyz/test/abc"),
                     TEXT("bar"),
                     lpszCombined,
                     &amp;amp;amp;amp;amp;amp;dwLength, 0);
</code>
      <para>The preceding code returns the URL http://xyz/test/bar. If you want the combined URL to be http://xyz/test/abc/bar, use the following call to <b>UrlCombine</b>.</para>
      <code>
hRetVal = UrlCombine(TEXT("http://xyz/test/abc/"),
                     TEXT("bar"),
                     lpszCombined,
                     &amp;amp;amp;amp;amp;amp;dwLength, 0);
</code>
      <para>If a URL string contains '/../' or '/./', <b>UrlCombine</b> usually treats the characters as if they indicated navigation in the URL hierarchy. The function simplifies the URLs before combining them. For instance, "/hello/cruel/../world" is simplified to "/hello/world". If the <b>URL_DONT_SIMPLIFY</b> flag is set in <i>dwFlags</i>, the function does not simplify URLs. In this case, "/hello/cruel/../world" is left as it is.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCombine as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinInet/handling-uniform-resource-locators">Handling Uniform Resource Locators</seealso>
    <seealso cref="UrlCanonicalize" />
  </member>
  <member name="Windows.UrlCompare">
    <summary>
      <para>Makes a case-sensitive comparison of two URL strings.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the first URL.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the second URL.</para>
    </param>
    <param name="fIgnoreSlash">
      <para>Type: <b>BOOL</b></para>
      <para>A value that is set to <b>TRUE</b> to have <b>UrlCompare</b> ignore a trailing '/' character on either or both URLs.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the two strings are equal. The function will also return zero if <i>fIgnoreSlash</i> is set to <b>TRUE</b> and one of the strings has a trailing '' character. The function returns a negative integer if the string pointed to by <i>psz1</i> is less than the string pointed to by <i>psz2</i>. Otherwise, it returns a positive integer.</para>
    </returns>
    <remarks>
      <para>For best results, you should first canonicalize the URLs with <see cref="UrlCanonicalize" />. Then, compare the canonicalized URLs with <b>UrlCompare</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCompare as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrCmp" />
  </member>
  <member name="Windows.UrlCompareA">
    <summary>
      <para>Makes a case-sensitive comparison of two URL strings.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the first URL.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the second URL.</para>
    </param>
    <param name="fIgnoreSlash">
      <para>Type: <b>BOOL</b></para>
      <para>A value that is set to <b>TRUE</b> to have <b>UrlCompare</b> ignore a trailing '/' character on either or both URLs.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the two strings are equal. The function will also return zero if <i>fIgnoreSlash</i> is set to <b>TRUE</b> and one of the strings has a trailing '' character. The function returns a negative integer if the string pointed to by <i>psz1</i> is less than the string pointed to by <i>psz2</i>. Otherwise, it returns a positive integer.</para>
    </returns>
    <remarks>
      <para>For best results, you should first canonicalize the URLs with <see cref="UrlCanonicalize" />. Then, compare the canonicalized URLs with <b>UrlCompare</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCompare as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrCmp" />
  </member>
  <member name="Windows.UrlCompareW">
    <summary>
      <para>Makes a case-sensitive comparison of two URL strings.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the first URL.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the second URL.</para>
    </param>
    <param name="fIgnoreSlash">
      <para>Type: <b>BOOL</b></para>
      <para>A value that is set to <b>TRUE</b> to have <b>UrlCompare</b> ignore a trailing '/' character on either or both URLs.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the two strings are equal. The function will also return zero if <i>fIgnoreSlash</i> is set to <b>TRUE</b> and one of the strings has a trailing '' character. The function returns a negative integer if the string pointed to by <i>psz1</i> is less than the string pointed to by <i>psz2</i>. Otherwise, it returns a positive integer.</para>
    </returns>
    <remarks>
      <para>For best results, you should first canonicalize the URLs with <see cref="UrlCanonicalize" />. Then, compare the canonicalized URLs with <b>UrlCompare</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCompare as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrCmp" />
  </member>
  <member name="Windows.UrlCompare">
    <summary>
      <para>Makes a case-sensitive comparison of two URL strings.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the first URL.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the second URL.</para>
    </param>
    <param name="fIgnoreSlash">
      <para>Type: <b>BOOL</b></para>
      <para>A value that is set to <b>TRUE</b> to have <b>UrlCompare</b> ignore a trailing '/' character on either or both URLs.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the two strings are equal. The function will also return zero if <i>fIgnoreSlash</i> is set to <b>TRUE</b> and one of the strings has a trailing '' character. The function returns a negative integer if the string pointed to by <i>psz1</i> is less than the string pointed to by <i>psz2</i>. Otherwise, it returns a positive integer.</para>
    </returns>
    <remarks>
      <para>For best results, you should first canonicalize the URLs with <see cref="UrlCanonicalize" />. Then, compare the canonicalized URLs with <b>UrlCompare</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCompare as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrCmp" />
  </member>
  <member name="Windows.UrlCompareA">
    <summary>
      <para>Makes a case-sensitive comparison of two URL strings.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the first URL.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the second URL.</para>
    </param>
    <param name="fIgnoreSlash">
      <para>Type: <b>BOOL</b></para>
      <para>A value that is set to <b>TRUE</b> to have <b>UrlCompare</b> ignore a trailing '/' character on either or both URLs.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the two strings are equal. The function will also return zero if <i>fIgnoreSlash</i> is set to <b>TRUE</b> and one of the strings has a trailing '' character. The function returns a negative integer if the string pointed to by <i>psz1</i> is less than the string pointed to by <i>psz2</i>. Otherwise, it returns a positive integer.</para>
    </returns>
    <remarks>
      <para>For best results, you should first canonicalize the URLs with <see cref="UrlCanonicalize" />. Then, compare the canonicalized URLs with <b>UrlCompare</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCompare as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrCmp" />
  </member>
  <member name="Windows.UrlCompareW">
    <summary>
      <para>Makes a case-sensitive comparison of two URL strings.</para>
    </summary>
    <param name="psz1">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the first URL.</para>
    </param>
    <param name="psz2">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the second URL.</para>
    </param>
    <param name="fIgnoreSlash">
      <para>Type: <b>BOOL</b></para>
      <para>A value that is set to <b>TRUE</b> to have <b>UrlCompare</b> ignore a trailing '/' character on either or both URLs.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns zero if the two strings are equal. The function will also return zero if <i>fIgnoreSlash</i> is set to <b>TRUE</b> and one of the strings has a trailing '' character. The function returns a negative integer if the string pointed to by <i>psz1</i> is less than the string pointed to by <i>psz2</i>. Otherwise, it returns a positive integer.</para>
    </returns>
    <remarks>
      <para>For best results, you should first canonicalize the URLs with <see cref="UrlCanonicalize" />. Then, compare the canonicalized URLs with <b>UrlCompare</b>.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCompare as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="StrCmp" />
  </member>
  <member name="Windows.UrlCreateFromPath">
    <summary>
      <para>Converts a Microsoft MS-DOS path to a canonicalized URL.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the MS-DOS path.</para>
    </param>
    <param name="pszUrl">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the URL.</para>
    </param>
    <param name="pcchUrl">
      <para>Type: <b>DWORD*</b></para>
      <para>The number of characters in <i>pszUrl</i>.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Set this parameter to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_FALSE if <i>pszPath</i> is already in URL format. In this case, <i>pszPath</i> will simply be copied to <i>pszUrl</i>. Otherwise, it returns S_OK if successful or a standard COM error value if not.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  <b>UrlCreateFromPath</b> does not support extended paths. These are paths that include the extended-length path prefix "\?".</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCreateFromPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlCreateFromPathA">
    <summary>
      <para>Converts a Microsoft MS-DOS path to a canonicalized URL.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the MS-DOS path.</para>
    </param>
    <param name="pszUrl">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the URL.</para>
    </param>
    <param name="pcchUrl">
      <para>Type: <b>DWORD*</b></para>
      <para>The number of characters in <i>pszUrl</i>.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Set this parameter to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_FALSE if <i>pszPath</i> is already in URL format. In this case, <i>pszPath</i> will simply be copied to <i>pszUrl</i>. Otherwise, it returns S_OK if successful or a standard COM error value if not.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  <b>UrlCreateFromPath</b> does not support extended paths. These are paths that include the extended-length path prefix "\?".</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCreateFromPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlCreateFromPathW">
    <summary>
      <para>Converts a Microsoft MS-DOS path to a canonicalized URL.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the MS-DOS path.</para>
    </param>
    <param name="pszUrl">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the URL.</para>
    </param>
    <param name="pcchUrl">
      <para>Type: <b>DWORD*</b></para>
      <para>The number of characters in <i>pszUrl</i>.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Set this parameter to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_FALSE if <i>pszPath</i> is already in URL format. In this case, <i>pszPath</i> will simply be copied to <i>pszUrl</i>. Otherwise, it returns S_OK if successful or a standard COM error value if not.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  <b>UrlCreateFromPath</b> does not support extended paths. These are paths that include the extended-length path prefix "\?".</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCreateFromPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlCreateFromPath">
    <summary>
      <para>Converts a Microsoft MS-DOS path to a canonicalized URL.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the MS-DOS path.</para>
    </param>
    <param name="pszUrl">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the URL.</para>
    </param>
    <param name="pcchUrl">
      <para>Type: <b>DWORD*</b></para>
      <para>The number of characters in <i>pszUrl</i>.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Set this parameter to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_FALSE if <i>pszPath</i> is already in URL format. In this case, <i>pszPath</i> will simply be copied to <i>pszUrl</i>. Otherwise, it returns S_OK if successful or a standard COM error value if not.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  <b>UrlCreateFromPath</b> does not support extended paths. These are paths that include the extended-length path prefix "\?".</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCreateFromPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlCreateFromPathA">
    <summary>
      <para>Converts a Microsoft MS-DOS path to a canonicalized URL.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the MS-DOS path.</para>
    </param>
    <param name="pszUrl">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the URL.</para>
    </param>
    <param name="pcchUrl">
      <para>Type: <b>DWORD*</b></para>
      <para>The number of characters in <i>pszUrl</i>.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Set this parameter to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_FALSE if <i>pszPath</i> is already in URL format. In this case, <i>pszPath</i> will simply be copied to <i>pszUrl</i>. Otherwise, it returns S_OK if successful or a standard COM error value if not.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  <b>UrlCreateFromPath</b> does not support extended paths. These are paths that include the extended-length path prefix "\?".</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCreateFromPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlCreateFromPathW">
    <summary>
      <para>Converts a Microsoft MS-DOS path to a canonicalized URL.</para>
    </summary>
    <param name="pszPath">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the MS-DOS path.</para>
    </param>
    <param name="pszUrl">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the URL.</para>
    </param>
    <param name="pcchUrl">
      <para>Type: <b>DWORD*</b></para>
      <para>The number of characters in <i>pszUrl</i>.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Reserved. Set this parameter to <b>NULL</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_FALSE if <i>pszPath</i> is already in URL format. In this case, <i>pszPath</i> will simply be copied to <i>pszUrl</i>. Otherwise, it returns S_OK if successful or a standard COM error value if not.</para>
    </returns>
    <remarks>
      <para>
        <b>Note</b>  <b>UrlCreateFromPath</b> does not support extended paths. These are paths that include the extended-length path prefix "\?".</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlCreateFromPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlEscape">
    <summary>
      <para>Converts characters or surrogate pairs in a URL that might be altered during transport across the Internet ("unsafe" characters) into their corresponding escape sequences. Surrogate pairs are characters between U+10000 to U+10FFFF (in UTF-32)  or between DC00 to DFFF (in UTF-16).</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length <b>INTERNET_MAX_URL_LENGTH</b> that contains a full or partial URL, as appropriate for the value in <i>dwFlags</i>.</para>
    </param>
    <param name="pszEscaped">
      <para>Type: <b>PTSTR</b></para>
      <para>The buffer that receives the converted string, with the unsafe characters converted to their escape sequences.</para>
    </param>
    <param name="pcchEscaped">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a <b>DWORD</b> value that, on entry, contains the number of characters in the <i>pszEscaped</i> buffer. Before calling <b>UrlEscape</b>, the calling application must set the value referenced by <i>pcchEscaped</i> to the size of the buffer. When this function returns successfully, the value receives the number of characters written to the buffer, not including the terminating <b>NULL</b> character.</para>
      <para>If an E_POINTER error code is returned, the buffer was too small to hold the result, and the value referenced by <i>pcchEscaped</i> is set to the required number of characters in the buffer. If any other errors are returned, the value referenced by <i>pcchEscaped</i> is undefined.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that indicate which portion of the URL is being provided in <i>pszURL</i> and which characters in that string should be converted to their escape sequences. The following flags are defined.</para>
      <h4>URL_DONT_ESCAPE_EXTRA_INFO (0x02000000)</h4>
      <para>Used only in conjunction with <b>URL_ESCAPE_SPACES_ONLY</b> to prevent the conversion of characters in the query (the portion of the URL following the first # or ? character encountered in the string). This flag should not be used alone, nor combined with <b>URL_ESCAPE_SEGMENT_ONLY</b>.</para>
      <h4>URL_BROWSER_MODE</h4>
      <para>Defined to be the same as <b>URL_DONT_ESCAPE_EXTRA_INFO</b>.</para>
      <h4>URL_ESCAPE_SPACES_ONLY (0x04000000)</h4>
      <para>Convert only space characters to their escape sequences, including those space characters in the query portion of the URL. Other unsafe characters are not converted to their escape sequences. This flag assumes that <i>pszURL</i> does not contain a full URL. It expects only the portions following the server specification.</para>
      <para>Combine this flag with <b>URL_DONT_ESCAPE_EXTRA_INFO</b> to prevent the conversion of space characters in the query portion of the URL.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_PERCENT</b> or <b>URL_ESCAPE_SEGMENT_ONLY</b>.</para>
      <h4>URL_ESCAPE_PERCENT (0x00001000)</h4>
      <para>Convert any % character found in the segment section of the URL (that section falling between the server specification and the first # or ? character). By default, the % character is not converted to its escape sequence. Other unsafe characters in the segment are also converted normally.</para>
      <para>Combining this flag with <b>URL_ESCAPE_SEGMENT_ONLY</b> includes those % characters in the query portion of the URL. However, as the <b>URL_ESCAPE_SEGMENT_ONLY</b> flag causes the entire string to be considered the segment, any # or ? characters are also converted.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_SPACES_ONLY</b>.</para>
      <h4>URL_ESCAPE_SEGMENT_ONLY (0x00002000)</h4>
      <para>Indicates that <i>pszURL</i> contains only that section of the URL following the server component but preceding the query. All unsafe characters in the string are converted. If a full URL is provided when this flag is set, all unsafe characters in the entire string are converted, including # and ? characters.</para>
      <para>Combine this flag with <b>URL_ESCAPE_PERCENT</b> to include that character in the conversion.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_SPACES_ONLY</b> or <b>URL_DONT_ESCAPE_EXTRA_INFO</b>.</para>
      <h4>URL_ESCAPE_AS_UTF8 (0x00040000)</h4>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h4>URL_ESCAPE_ASCII_URI_COMPONENT (0x00080000)</h4>
      <para>
        <b>Windows 8 and later</b>. Percent-encode all ASCII characters outside of the unreserved set from URI RFC 3986 (a-zA-Z0-9-.~_).</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful. If the <i>pcchEscaped</i> buffer was too small to contain the result, E_POINTER is returned, and the value pointed to by <i>pcchEscaped</i> is set to the required buffer size. Otherwise, a standard error value is returned.</para>
    </returns>
    <remarks>
      <para>For the purposes of this document, a typical URL is divided into three sections: the server, the segment, and the query. For example:</para>
      <code>http://microsoft.com/test.asp?url=/example/abc.asp?frame=true#fragment
</code>
      <para>The server portion is "http://microsoft.com/". The trailing forward slash is considered part of the server portion.</para>
      <para>The segment portion is any part of the path found following the server portion, but before the first # or ? character, in this case simply "test.asp".</para>
      <para>The query portion is the remainder of the path from the first # or ? character (inclusive) to the end. In the example, it is "?url=/example/abc.asp?frame=true#fragment".</para>
      <para>Unsafe characters are those characters that might be altered during transport across the Internet. This function converts unsafe characters into their equivalent "%xy" escape sequences. The following table shows unsafe characters and their escape sequences.</para>
      <list type="table">
        <listheader>
          <description>Character</description>
          <description>Escape Sequence</description>
        </listheader>
        <item>
          <description>^</description>
          <description>%5E</description>
        </item>
        <item>
          <description>&amp;</description>
          <description>%26</description>
        </item>
        <item>
          <description>`</description>
          <description>%60</description>
        </item>
        <item>
          <description>{</description>
          <description>%7B</description>
        </item>
        <item>
          <description>}</description>
          <description>%7D</description>
        </item>
        <item>
          <description>|</description>
          <description>%7C</description>
        </item>
        <item>
          <description>]</description>
          <description>%5D</description>
        </item>
        <item>
          <description>[</description>
          <description>%5B</description>
        </item>
        <item>
          <description>"</description>
          <description>%22</description>
        </item>
        <item>
          <description>&lt;</description>
          <description>%3C</description>
        </item>
        <item>
          <description>&gt;</description>
          <description>%3E</description>
        </item>
        <item>
          <description>\</description>
          <description>%5C</description>
        </item>
      </list>
      <para>Use of the <b>URL_ESCAPE_SEGMENT_ONLY</b> flag also causes the conversion of the # (%23), ? (%3F), and / (%2F) characters.</para>
      <para>By default, <b>UrlEscape</b> ignores any text following a # or ? character. The <b>URL_ESCAPE_SEGMENT_ONLY</b> flag overrides this behavior by regarding the entire string as the segment. The <b>URL_ESCAPE_SPACES_ONLY</b> flag overrides this behavior, but only for space characters.</para>
      <h4>Examples</h4>
      <para>The following examples show the effect of the various flags on a URL. The example URL is not valid but is exaggerated for demonstration purposes.</para>
      <code>
// The full original URL
http://microsoft.com/test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_SPACES_ONLY
// Only space characters are escaped. Other unsafe characters are ignored.
// Note: This flag expects the server portion of the URL to be omitted.
Original = test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment
Result   = test/t%e&lt;s%20t.asp?url=/{ex%%20ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_SPACES_ONLY | URL_DONT_ESCAPE_EXTRA_INFO
// Spaces in the segment are converted into their escape sequences, but
// spaces in the query are not.
Original = test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment
Result   = test/t%e&lt;s%20t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_PERCENT
// Here only the segment and query are supplied and the server component is
// omitted, although that is not required. Only the segment is considered.
// All unsafe characters plus the % character are converted in the segment.
Original = test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment
Result   = test/t%25e%3Cs%20t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_SEGMENT_ONLY
// Note: This flag expects only the segment, omitting the server and query
//       components.
// The / character is escaped as well as the usual unsafe characters.
Original = test/t%e&lt;s t.asp
Result   = test%2Ft%e%3Cs%20t.asp
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlEscape as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinInet/handling-uniform-resource-locators">Handling Uniform Resource Locators</seealso>
  </member>
  <member name="Windows.UrlEscapeA">
    <summary>
      <para>Converts characters or surrogate pairs in a URL that might be altered during transport across the Internet ("unsafe" characters) into their corresponding escape sequences. Surrogate pairs are characters between U+10000 to U+10FFFF (in UTF-32)  or between DC00 to DFFF (in UTF-16).</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length <b>INTERNET_MAX_URL_LENGTH</b> that contains a full or partial URL, as appropriate for the value in <i>dwFlags</i>.</para>
    </param>
    <param name="pszEscaped">
      <para>Type: <b>PTSTR</b></para>
      <para>The buffer that receives the converted string, with the unsafe characters converted to their escape sequences.</para>
    </param>
    <param name="pcchEscaped">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a <b>DWORD</b> value that, on entry, contains the number of characters in the <i>pszEscaped</i> buffer. Before calling <b>UrlEscape</b>, the calling application must set the value referenced by <i>pcchEscaped</i> to the size of the buffer. When this function returns successfully, the value receives the number of characters written to the buffer, not including the terminating <b>NULL</b> character.</para>
      <para>If an E_POINTER error code is returned, the buffer was too small to hold the result, and the value referenced by <i>pcchEscaped</i> is set to the required number of characters in the buffer. If any other errors are returned, the value referenced by <i>pcchEscaped</i> is undefined.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that indicate which portion of the URL is being provided in <i>pszURL</i> and which characters in that string should be converted to their escape sequences. The following flags are defined.</para>
      <h4>URL_DONT_ESCAPE_EXTRA_INFO (0x02000000)</h4>
      <para>Used only in conjunction with <b>URL_ESCAPE_SPACES_ONLY</b> to prevent the conversion of characters in the query (the portion of the URL following the first # or ? character encountered in the string). This flag should not be used alone, nor combined with <b>URL_ESCAPE_SEGMENT_ONLY</b>.</para>
      <h4>URL_BROWSER_MODE</h4>
      <para>Defined to be the same as <b>URL_DONT_ESCAPE_EXTRA_INFO</b>.</para>
      <h4>URL_ESCAPE_SPACES_ONLY (0x04000000)</h4>
      <para>Convert only space characters to their escape sequences, including those space characters in the query portion of the URL. Other unsafe characters are not converted to their escape sequences. This flag assumes that <i>pszURL</i> does not contain a full URL. It expects only the portions following the server specification.</para>
      <para>Combine this flag with <b>URL_DONT_ESCAPE_EXTRA_INFO</b> to prevent the conversion of space characters in the query portion of the URL.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_PERCENT</b> or <b>URL_ESCAPE_SEGMENT_ONLY</b>.</para>
      <h4>URL_ESCAPE_PERCENT (0x00001000)</h4>
      <para>Convert any % character found in the segment section of the URL (that section falling between the server specification and the first # or ? character). By default, the % character is not converted to its escape sequence. Other unsafe characters in the segment are also converted normally.</para>
      <para>Combining this flag with <b>URL_ESCAPE_SEGMENT_ONLY</b> includes those % characters in the query portion of the URL. However, as the <b>URL_ESCAPE_SEGMENT_ONLY</b> flag causes the entire string to be considered the segment, any # or ? characters are also converted.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_SPACES_ONLY</b>.</para>
      <h4>URL_ESCAPE_SEGMENT_ONLY (0x00002000)</h4>
      <para>Indicates that <i>pszURL</i> contains only that section of the URL following the server component but preceding the query. All unsafe characters in the string are converted. If a full URL is provided when this flag is set, all unsafe characters in the entire string are converted, including # and ? characters.</para>
      <para>Combine this flag with <b>URL_ESCAPE_PERCENT</b> to include that character in the conversion.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_SPACES_ONLY</b> or <b>URL_DONT_ESCAPE_EXTRA_INFO</b>.</para>
      <h4>URL_ESCAPE_AS_UTF8 (0x00040000)</h4>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h4>URL_ESCAPE_ASCII_URI_COMPONENT (0x00080000)</h4>
      <para>
        <b>Windows 8 and later</b>. Percent-encode all ASCII characters outside of the unreserved set from URI RFC 3986 (a-zA-Z0-9-.~_).</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful. If the <i>pcchEscaped</i> buffer was too small to contain the result, E_POINTER is returned, and the value pointed to by <i>pcchEscaped</i> is set to the required buffer size. Otherwise, a standard error value is returned.</para>
    </returns>
    <remarks>
      <para>For the purposes of this document, a typical URL is divided into three sections: the server, the segment, and the query. For example:</para>
      <code>http://microsoft.com/test.asp?url=/example/abc.asp?frame=true#fragment
</code>
      <para>The server portion is "http://microsoft.com/". The trailing forward slash is considered part of the server portion.</para>
      <para>The segment portion is any part of the path found following the server portion, but before the first # or ? character, in this case simply "test.asp".</para>
      <para>The query portion is the remainder of the path from the first # or ? character (inclusive) to the end. In the example, it is "?url=/example/abc.asp?frame=true#fragment".</para>
      <para>Unsafe characters are those characters that might be altered during transport across the Internet. This function converts unsafe characters into their equivalent "%xy" escape sequences. The following table shows unsafe characters and their escape sequences.</para>
      <list type="table">
        <listheader>
          <description>Character</description>
          <description>Escape Sequence</description>
        </listheader>
        <item>
          <description>^</description>
          <description>%5E</description>
        </item>
        <item>
          <description>&amp;</description>
          <description>%26</description>
        </item>
        <item>
          <description>`</description>
          <description>%60</description>
        </item>
        <item>
          <description>{</description>
          <description>%7B</description>
        </item>
        <item>
          <description>}</description>
          <description>%7D</description>
        </item>
        <item>
          <description>|</description>
          <description>%7C</description>
        </item>
        <item>
          <description>]</description>
          <description>%5D</description>
        </item>
        <item>
          <description>[</description>
          <description>%5B</description>
        </item>
        <item>
          <description>"</description>
          <description>%22</description>
        </item>
        <item>
          <description>&lt;</description>
          <description>%3C</description>
        </item>
        <item>
          <description>&gt;</description>
          <description>%3E</description>
        </item>
        <item>
          <description>\</description>
          <description>%5C</description>
        </item>
      </list>
      <para>Use of the <b>URL_ESCAPE_SEGMENT_ONLY</b> flag also causes the conversion of the # (%23), ? (%3F), and / (%2F) characters.</para>
      <para>By default, <b>UrlEscape</b> ignores any text following a # or ? character. The <b>URL_ESCAPE_SEGMENT_ONLY</b> flag overrides this behavior by regarding the entire string as the segment. The <b>URL_ESCAPE_SPACES_ONLY</b> flag overrides this behavior, but only for space characters.</para>
      <h4>Examples</h4>
      <para>The following examples show the effect of the various flags on a URL. The example URL is not valid but is exaggerated for demonstration purposes.</para>
      <code>
// The full original URL
http://microsoft.com/test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_SPACES_ONLY
// Only space characters are escaped. Other unsafe characters are ignored.
// Note: This flag expects the server portion of the URL to be omitted.
Original = test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment
Result   = test/t%e&lt;s%20t.asp?url=/{ex%%20ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_SPACES_ONLY | URL_DONT_ESCAPE_EXTRA_INFO
// Spaces in the segment are converted into their escape sequences, but
// spaces in the query are not.
Original = test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment
Result   = test/t%e&lt;s%20t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_PERCENT
// Here only the segment and query are supplied and the server component is
// omitted, although that is not required. Only the segment is considered.
// All unsafe characters plus the % character are converted in the segment.
Original = test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment
Result   = test/t%25e%3Cs%20t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_SEGMENT_ONLY
// Note: This flag expects only the segment, omitting the server and query
//       components.
// The / character is escaped as well as the usual unsafe characters.
Original = test/t%e&lt;s t.asp
Result   = test%2Ft%e%3Cs%20t.asp
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlEscape as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinInet/handling-uniform-resource-locators">Handling Uniform Resource Locators</seealso>
  </member>
  <member name="Windows.UrlEscapeW">
    <summary>
      <para>Converts characters or surrogate pairs in a URL that might be altered during transport across the Internet ("unsafe" characters) into their corresponding escape sequences. Surrogate pairs are characters between U+10000 to U+10FFFF (in UTF-32)  or between DC00 to DFFF (in UTF-16).</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length <b>INTERNET_MAX_URL_LENGTH</b> that contains a full or partial URL, as appropriate for the value in <i>dwFlags</i>.</para>
    </param>
    <param name="pszEscaped">
      <para>Type: <b>PTSTR</b></para>
      <para>The buffer that receives the converted string, with the unsafe characters converted to their escape sequences.</para>
    </param>
    <param name="pcchEscaped">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a <b>DWORD</b> value that, on entry, contains the number of characters in the <i>pszEscaped</i> buffer. Before calling <b>UrlEscape</b>, the calling application must set the value referenced by <i>pcchEscaped</i> to the size of the buffer. When this function returns successfully, the value receives the number of characters written to the buffer, not including the terminating <b>NULL</b> character.</para>
      <para>If an E_POINTER error code is returned, the buffer was too small to hold the result, and the value referenced by <i>pcchEscaped</i> is set to the required number of characters in the buffer. If any other errors are returned, the value referenced by <i>pcchEscaped</i> is undefined.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that indicate which portion of the URL is being provided in <i>pszURL</i> and which characters in that string should be converted to their escape sequences. The following flags are defined.</para>
      <h4>URL_DONT_ESCAPE_EXTRA_INFO (0x02000000)</h4>
      <para>Used only in conjunction with <b>URL_ESCAPE_SPACES_ONLY</b> to prevent the conversion of characters in the query (the portion of the URL following the first # or ? character encountered in the string). This flag should not be used alone, nor combined with <b>URL_ESCAPE_SEGMENT_ONLY</b>.</para>
      <h4>URL_BROWSER_MODE</h4>
      <para>Defined to be the same as <b>URL_DONT_ESCAPE_EXTRA_INFO</b>.</para>
      <h4>URL_ESCAPE_SPACES_ONLY (0x04000000)</h4>
      <para>Convert only space characters to their escape sequences, including those space characters in the query portion of the URL. Other unsafe characters are not converted to their escape sequences. This flag assumes that <i>pszURL</i> does not contain a full URL. It expects only the portions following the server specification.</para>
      <para>Combine this flag with <b>URL_DONT_ESCAPE_EXTRA_INFO</b> to prevent the conversion of space characters in the query portion of the URL.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_PERCENT</b> or <b>URL_ESCAPE_SEGMENT_ONLY</b>.</para>
      <h4>URL_ESCAPE_PERCENT (0x00001000)</h4>
      <para>Convert any % character found in the segment section of the URL (that section falling between the server specification and the first # or ? character). By default, the % character is not converted to its escape sequence. Other unsafe characters in the segment are also converted normally.</para>
      <para>Combining this flag with <b>URL_ESCAPE_SEGMENT_ONLY</b> includes those % characters in the query portion of the URL. However, as the <b>URL_ESCAPE_SEGMENT_ONLY</b> flag causes the entire string to be considered the segment, any # or ? characters are also converted.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_SPACES_ONLY</b>.</para>
      <h4>URL_ESCAPE_SEGMENT_ONLY (0x00002000)</h4>
      <para>Indicates that <i>pszURL</i> contains only that section of the URL following the server component but preceding the query. All unsafe characters in the string are converted. If a full URL is provided when this flag is set, all unsafe characters in the entire string are converted, including # and ? characters.</para>
      <para>Combine this flag with <b>URL_ESCAPE_PERCENT</b> to include that character in the conversion.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_SPACES_ONLY</b> or <b>URL_DONT_ESCAPE_EXTRA_INFO</b>.</para>
      <h4>URL_ESCAPE_AS_UTF8 (0x00040000)</h4>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h4>URL_ESCAPE_ASCII_URI_COMPONENT (0x00080000)</h4>
      <para>
        <b>Windows 8 and later</b>. Percent-encode all ASCII characters outside of the unreserved set from URI RFC 3986 (a-zA-Z0-9-.~_).</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful. If the <i>pcchEscaped</i> buffer was too small to contain the result, E_POINTER is returned, and the value pointed to by <i>pcchEscaped</i> is set to the required buffer size. Otherwise, a standard error value is returned.</para>
    </returns>
    <remarks>
      <para>For the purposes of this document, a typical URL is divided into three sections: the server, the segment, and the query. For example:</para>
      <code>http://microsoft.com/test.asp?url=/example/abc.asp?frame=true#fragment
</code>
      <para>The server portion is "http://microsoft.com/". The trailing forward slash is considered part of the server portion.</para>
      <para>The segment portion is any part of the path found following the server portion, but before the first # or ? character, in this case simply "test.asp".</para>
      <para>The query portion is the remainder of the path from the first # or ? character (inclusive) to the end. In the example, it is "?url=/example/abc.asp?frame=true#fragment".</para>
      <para>Unsafe characters are those characters that might be altered during transport across the Internet. This function converts unsafe characters into their equivalent "%xy" escape sequences. The following table shows unsafe characters and their escape sequences.</para>
      <list type="table">
        <listheader>
          <description>Character</description>
          <description>Escape Sequence</description>
        </listheader>
        <item>
          <description>^</description>
          <description>%5E</description>
        </item>
        <item>
          <description>&amp;</description>
          <description>%26</description>
        </item>
        <item>
          <description>`</description>
          <description>%60</description>
        </item>
        <item>
          <description>{</description>
          <description>%7B</description>
        </item>
        <item>
          <description>}</description>
          <description>%7D</description>
        </item>
        <item>
          <description>|</description>
          <description>%7C</description>
        </item>
        <item>
          <description>]</description>
          <description>%5D</description>
        </item>
        <item>
          <description>[</description>
          <description>%5B</description>
        </item>
        <item>
          <description>"</description>
          <description>%22</description>
        </item>
        <item>
          <description>&lt;</description>
          <description>%3C</description>
        </item>
        <item>
          <description>&gt;</description>
          <description>%3E</description>
        </item>
        <item>
          <description>\</description>
          <description>%5C</description>
        </item>
      </list>
      <para>Use of the <b>URL_ESCAPE_SEGMENT_ONLY</b> flag also causes the conversion of the # (%23), ? (%3F), and / (%2F) characters.</para>
      <para>By default, <b>UrlEscape</b> ignores any text following a # or ? character. The <b>URL_ESCAPE_SEGMENT_ONLY</b> flag overrides this behavior by regarding the entire string as the segment. The <b>URL_ESCAPE_SPACES_ONLY</b> flag overrides this behavior, but only for space characters.</para>
      <h4>Examples</h4>
      <para>The following examples show the effect of the various flags on a URL. The example URL is not valid but is exaggerated for demonstration purposes.</para>
      <code>
// The full original URL
http://microsoft.com/test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_SPACES_ONLY
// Only space characters are escaped. Other unsafe characters are ignored.
// Note: This flag expects the server portion of the URL to be omitted.
Original = test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment
Result   = test/t%e&lt;s%20t.asp?url=/{ex%%20ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_SPACES_ONLY | URL_DONT_ESCAPE_EXTRA_INFO
// Spaces in the segment are converted into their escape sequences, but
// spaces in the query are not.
Original = test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment
Result   = test/t%e&lt;s%20t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_PERCENT
// Here only the segment and query are supplied and the server component is
// omitted, although that is not required. Only the segment is considered.
// All unsafe characters plus the % character are converted in the segment.
Original = test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment
Result   = test/t%25e%3Cs%20t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_SEGMENT_ONLY
// Note: This flag expects only the segment, omitting the server and query
//       components.
// The / character is escaped as well as the usual unsafe characters.
Original = test/t%e&lt;s t.asp
Result   = test%2Ft%e%3Cs%20t.asp
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlEscape as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinInet/handling-uniform-resource-locators">Handling Uniform Resource Locators</seealso>
  </member>
  <member name="Windows.UrlEscapeSpaces">
    <summary>
      <para>A macro that converts space characters into their corresponding escape sequence.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a URL string. If it does not refer to a file, it must include a valid scheme such as "http://".</para>
    </param>
    <param name="pszEscaped">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a null-terminated string containing the string pointed to by <i>pszURL</i>, with space characters converted to their escape sequence.</para>
    </param>
    <param name="pcchEscaped">
      <para>Type: <b>LPDWORD</b></para>
      <para>The number of characters in <i>pszEscaped</i>.</para>
    </param>
    <remarks>
      <para>
        <b>UrlEscapeSpaces</b> is equivalent to the following:</para>
      <code>
UrlCanonicalize(pszUrl,
                pszEscaped,
                pcchEscaped,
                URL_ESCAPE_SPACES_ONLY | URL_DONT_ESCAPE_EXTRA_INFO )

</code>
    </remarks>
    <seealso cref="UrlCanonicalize" />
  </member>
  <member name="Windows.UrlEscape">
    <summary>
      <para>Converts characters or surrogate pairs in a URL that might be altered during transport across the Internet ("unsafe" characters) into their corresponding escape sequences. Surrogate pairs are characters between U+10000 to U+10FFFF (in UTF-32)  or between DC00 to DFFF (in UTF-16).</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length <b>INTERNET_MAX_URL_LENGTH</b> that contains a full or partial URL, as appropriate for the value in <i>dwFlags</i>.</para>
    </param>
    <param name="pszEscaped">
      <para>Type: <b>PTSTR</b></para>
      <para>The buffer that receives the converted string, with the unsafe characters converted to their escape sequences.</para>
    </param>
    <param name="pcchEscaped">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a <b>DWORD</b> value that, on entry, contains the number of characters in the <i>pszEscaped</i> buffer. Before calling <b>UrlEscape</b>, the calling application must set the value referenced by <i>pcchEscaped</i> to the size of the buffer. When this function returns successfully, the value receives the number of characters written to the buffer, not including the terminating <b>NULL</b> character.</para>
      <para>If an E_POINTER error code is returned, the buffer was too small to hold the result, and the value referenced by <i>pcchEscaped</i> is set to the required number of characters in the buffer. If any other errors are returned, the value referenced by <i>pcchEscaped</i> is undefined.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that indicate which portion of the URL is being provided in <i>pszURL</i> and which characters in that string should be converted to their escape sequences. The following flags are defined.</para>
      <h4>URL_DONT_ESCAPE_EXTRA_INFO (0x02000000)</h4>
      <para>Used only in conjunction with <b>URL_ESCAPE_SPACES_ONLY</b> to prevent the conversion of characters in the query (the portion of the URL following the first # or ? character encountered in the string). This flag should not be used alone, nor combined with <b>URL_ESCAPE_SEGMENT_ONLY</b>.</para>
      <h4>URL_BROWSER_MODE</h4>
      <para>Defined to be the same as <b>URL_DONT_ESCAPE_EXTRA_INFO</b>.</para>
      <h4>URL_ESCAPE_SPACES_ONLY (0x04000000)</h4>
      <para>Convert only space characters to their escape sequences, including those space characters in the query portion of the URL. Other unsafe characters are not converted to their escape sequences. This flag assumes that <i>pszURL</i> does not contain a full URL. It expects only the portions following the server specification.</para>
      <para>Combine this flag with <b>URL_DONT_ESCAPE_EXTRA_INFO</b> to prevent the conversion of space characters in the query portion of the URL.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_PERCENT</b> or <b>URL_ESCAPE_SEGMENT_ONLY</b>.</para>
      <h4>URL_ESCAPE_PERCENT (0x00001000)</h4>
      <para>Convert any % character found in the segment section of the URL (that section falling between the server specification and the first # or ? character). By default, the % character is not converted to its escape sequence. Other unsafe characters in the segment are also converted normally.</para>
      <para>Combining this flag with <b>URL_ESCAPE_SEGMENT_ONLY</b> includes those % characters in the query portion of the URL. However, as the <b>URL_ESCAPE_SEGMENT_ONLY</b> flag causes the entire string to be considered the segment, any # or ? characters are also converted.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_SPACES_ONLY</b>.</para>
      <h4>URL_ESCAPE_SEGMENT_ONLY (0x00002000)</h4>
      <para>Indicates that <i>pszURL</i> contains only that section of the URL following the server component but preceding the query. All unsafe characters in the string are converted. If a full URL is provided when this flag is set, all unsafe characters in the entire string are converted, including # and ? characters.</para>
      <para>Combine this flag with <b>URL_ESCAPE_PERCENT</b> to include that character in the conversion.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_SPACES_ONLY</b> or <b>URL_DONT_ESCAPE_EXTRA_INFO</b>.</para>
      <h4>URL_ESCAPE_AS_UTF8 (0x00040000)</h4>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h4>URL_ESCAPE_ASCII_URI_COMPONENT (0x00080000)</h4>
      <para>
        <b>Windows 8 and later</b>. Percent-encode all ASCII characters outside of the unreserved set from URI RFC 3986 (a-zA-Z0-9-.~_).</para>
      <h5>- dwFlags.URL_BROWSER_MODE</h5>
      <para>Defined to be the same as <b>URL_DONT_ESCAPE_EXTRA_INFO</b>.</para>
      <h5>- dwFlags.URL_DONT_ESCAPE_EXTRA_INFO (0x02000000)</h5>
      <para>Used only in conjunction with <b>URL_ESCAPE_SPACES_ONLY</b> to prevent the conversion of characters in the query (the portion of the URL following the first # or ? character encountered in the string). This flag should not be used alone, nor combined with <b>URL_ESCAPE_SEGMENT_ONLY</b>.</para>
      <h5>- dwFlags.URL_ESCAPE_ASCII_URI_COMPONENT (0x00080000)</h5>
      <para>
        <b>Windows 8 and later</b>. Percent-encode all ASCII characters outside of the unreserved set from URI RFC 3986 (a-zA-Z0-9-.~_).</para>
      <h5>- dwFlags.URL_ESCAPE_AS_UTF8 (0x00040000)</h5>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h5>- dwFlags.URL_ESCAPE_PERCENT (0x00001000)</h5>
      <para>Convert any % character found in the segment section of the URL (that section falling between the server specification and the first # or ? character). By default, the % character is not converted to its escape sequence. Other unsafe characters in the segment are also converted normally.</para>
      <para>Combining this flag with <b>URL_ESCAPE_SEGMENT_ONLY</b> includes those % characters in the query portion of the URL. However, as the <b>URL_ESCAPE_SEGMENT_ONLY</b> flag causes the entire string to be considered the segment, any # or ? characters are also converted.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_SPACES_ONLY</b>.</para>
      <h5>- dwFlags.URL_ESCAPE_SEGMENT_ONLY (0x00002000)</h5>
      <para>Indicates that <i>pszURL</i> contains only that section of the URL following the server component but preceding the query. All unsafe characters in the string are converted. If a full URL is provided when this flag is set, all unsafe characters in the entire string are converted, including # and ? characters.</para>
      <para>Combine this flag with <b>URL_ESCAPE_PERCENT</b> to include that character in the conversion.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_SPACES_ONLY</b> or <b>URL_DONT_ESCAPE_EXTRA_INFO</b>.</para>
      <h5>- dwFlags.URL_ESCAPE_SPACES_ONLY (0x04000000)</h5>
      <para>Convert only space characters to their escape sequences, including those space characters in the query portion of the URL. Other unsafe characters are not converted to their escape sequences. This flag assumes that <i>pszURL</i> does not contain a full URL. It expects only the portions following the server specification.</para>
      <para>Combine this flag with <b>URL_DONT_ESCAPE_EXTRA_INFO</b> to prevent the conversion of space characters in the query portion of the URL.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_PERCENT</b> or <b>URL_ESCAPE_SEGMENT_ONLY</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful. If the <i>pcchEscaped</i> buffer was too small to contain the result, E_POINTER is returned, and the value pointed to by <i>pcchEscaped</i> is set to the required buffer size. Otherwise, a standard error value is returned.</para>
    </returns>
    <remarks>
      <para>For the purposes of this document, a typical URL is divided into three sections: the server, the segment, and the query. For example:</para>
      <code>http://microsoft.com/test.asp?url=/example/abc.asp?frame=true#fragment
</code>
      <para>The server portion is "http://microsoft.com/". The trailing forward slash is considered part of the server portion.</para>
      <para>The segment portion is any part of the path found following the server portion, but before the first # or ? character, in this case simply "test.asp".</para>
      <para>The query portion is the remainder of the path from the first # or ? character (inclusive) to the end. In the example, it is "?url=/example/abc.asp?frame=true#fragment".</para>
      <para>Unsafe characters are those characters that might be altered during transport across the Internet. This function converts unsafe characters into their equivalent "%xy" escape sequences. The following table shows unsafe characters and their escape sequences.</para>
      <list type="table">
        <listheader>
          <description>Character</description>
          <description>Escape Sequence</description>
        </listheader>
        <item>
          <description>^</description>
          <description>%5E</description>
        </item>
        <item>
          <description>&amp;</description>
          <description>%26</description>
        </item>
        <item>
          <description>`</description>
          <description>%60</description>
        </item>
        <item>
          <description>{</description>
          <description>%7B</description>
        </item>
        <item>
          <description>}</description>
          <description>%7D</description>
        </item>
        <item>
          <description>|</description>
          <description>%7C</description>
        </item>
        <item>
          <description>]</description>
          <description>%5D</description>
        </item>
        <item>
          <description>[</description>
          <description>%5B</description>
        </item>
        <item>
          <description>"</description>
          <description>%22</description>
        </item>
        <item>
          <description>&lt;</description>
          <description>%3C</description>
        </item>
        <item>
          <description>&gt;</description>
          <description>%3E</description>
        </item>
        <item>
          <description>\</description>
          <description>%5C</description>
        </item>
      </list>
      <para>Use of the <b>URL_ESCAPE_SEGMENT_ONLY</b> flag also causes the conversion of the # (%23), ? (%3F), and / (%2F) characters.</para>
      <para>By default, <b>UrlEscape</b> ignores any text following a # or ? character. The <b>URL_ESCAPE_SEGMENT_ONLY</b> flag overrides this behavior by regarding the entire string as the segment. The <b>URL_ESCAPE_SPACES_ONLY</b> flag overrides this behavior, but only for space characters.</para>
      <h4>Examples</h4>
      <para>The following examples show the effect of the various flags on a URL. The example URL is not valid but is exaggerated for demonstration purposes.</para>
      <code>
// The full original URL
http://microsoft.com/test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_SPACES_ONLY
// Only space characters are escaped. Other unsafe characters are ignored.
// Note: This flag expects the server portion of the URL to be omitted.
Original = test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment
Result   = test/t%e&lt;s%20t.asp?url=/{ex%%20ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_SPACES_ONLY | URL_DONT_ESCAPE_EXTRA_INFO
// Spaces in the segment are converted into their escape sequences, but
// spaces in the query are not.
Original = test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment
Result   = test/t%e&lt;s%20t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_PERCENT
// Here only the segment and query are supplied and the server component is
// omitted, although that is not required. Only the segment is considered.
// All unsafe characters plus the % character are converted in the segment.
Original = test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment
Result   = test/t%25e%3Cs%20t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_SEGMENT_ONLY
// Note: This flag expects only the segment, omitting the server and query
//       components.
// The / character is escaped as well as the usual unsafe characters.
Original = test/t%e&lt;s t.asp
Result   = test%2Ft%e%3Cs%20t.asp
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlEscape as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinInet/handling-uniform-resource-locators">Handling Uniform Resource Locators</seealso>
  </member>
  <member name="Windows.UrlEscapeA">
    <summary>
      <para>Converts characters or surrogate pairs in a URL that might be altered during transport across the Internet ("unsafe" characters) into their corresponding escape sequences. Surrogate pairs are characters between U+10000 to U+10FFFF (in UTF-32)  or between DC00 to DFFF (in UTF-16).</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length <b>INTERNET_MAX_URL_LENGTH</b> that contains a full or partial URL, as appropriate for the value in <i>dwFlags</i>.</para>
    </param>
    <param name="pszEscaped">
      <para>Type: <b>PTSTR</b></para>
      <para>The buffer that receives the converted string, with the unsafe characters converted to their escape sequences.</para>
    </param>
    <param name="pcchEscaped">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a <b>DWORD</b> value that, on entry, contains the number of characters in the <i>pszEscaped</i> buffer. Before calling <b>UrlEscape</b>, the calling application must set the value referenced by <i>pcchEscaped</i> to the size of the buffer. When this function returns successfully, the value receives the number of characters written to the buffer, not including the terminating <b>NULL</b> character.</para>
      <para>If an E_POINTER error code is returned, the buffer was too small to hold the result, and the value referenced by <i>pcchEscaped</i> is set to the required number of characters in the buffer. If any other errors are returned, the value referenced by <i>pcchEscaped</i> is undefined.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that indicate which portion of the URL is being provided in <i>pszURL</i> and which characters in that string should be converted to their escape sequences. The following flags are defined.</para>
      <h4>URL_DONT_ESCAPE_EXTRA_INFO (0x02000000)</h4>
      <para>Used only in conjunction with <b>URL_ESCAPE_SPACES_ONLY</b> to prevent the conversion of characters in the query (the portion of the URL following the first # or ? character encountered in the string). This flag should not be used alone, nor combined with <b>URL_ESCAPE_SEGMENT_ONLY</b>.</para>
      <h4>URL_BROWSER_MODE</h4>
      <para>Defined to be the same as <b>URL_DONT_ESCAPE_EXTRA_INFO</b>.</para>
      <h4>URL_ESCAPE_SPACES_ONLY (0x04000000)</h4>
      <para>Convert only space characters to their escape sequences, including those space characters in the query portion of the URL. Other unsafe characters are not converted to their escape sequences. This flag assumes that <i>pszURL</i> does not contain a full URL. It expects only the portions following the server specification.</para>
      <para>Combine this flag with <b>URL_DONT_ESCAPE_EXTRA_INFO</b> to prevent the conversion of space characters in the query portion of the URL.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_PERCENT</b> or <b>URL_ESCAPE_SEGMENT_ONLY</b>.</para>
      <h4>URL_ESCAPE_PERCENT (0x00001000)</h4>
      <para>Convert any % character found in the segment section of the URL (that section falling between the server specification and the first # or ? character). By default, the % character is not converted to its escape sequence. Other unsafe characters in the segment are also converted normally.</para>
      <para>Combining this flag with <b>URL_ESCAPE_SEGMENT_ONLY</b> includes those % characters in the query portion of the URL. However, as the <b>URL_ESCAPE_SEGMENT_ONLY</b> flag causes the entire string to be considered the segment, any # or ? characters are also converted.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_SPACES_ONLY</b>.</para>
      <h4>URL_ESCAPE_SEGMENT_ONLY (0x00002000)</h4>
      <para>Indicates that <i>pszURL</i> contains only that section of the URL following the server component but preceding the query. All unsafe characters in the string are converted. If a full URL is provided when this flag is set, all unsafe characters in the entire string are converted, including # and ? characters.</para>
      <para>Combine this flag with <b>URL_ESCAPE_PERCENT</b> to include that character in the conversion.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_SPACES_ONLY</b> or <b>URL_DONT_ESCAPE_EXTRA_INFO</b>.</para>
      <h4>URL_ESCAPE_AS_UTF8 (0x00040000)</h4>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h4>URL_ESCAPE_ASCII_URI_COMPONENT (0x00080000)</h4>
      <para>
        <b>Windows 8 and later</b>. Percent-encode all ASCII characters outside of the unreserved set from URI RFC 3986 (a-zA-Z0-9-.~_).</para>
      <h5>- dwFlags.URL_BROWSER_MODE</h5>
      <para>Defined to be the same as <b>URL_DONT_ESCAPE_EXTRA_INFO</b>.</para>
      <h5>- dwFlags.URL_DONT_ESCAPE_EXTRA_INFO (0x02000000)</h5>
      <para>Used only in conjunction with <b>URL_ESCAPE_SPACES_ONLY</b> to prevent the conversion of characters in the query (the portion of the URL following the first # or ? character encountered in the string). This flag should not be used alone, nor combined with <b>URL_ESCAPE_SEGMENT_ONLY</b>.</para>
      <h5>- dwFlags.URL_ESCAPE_ASCII_URI_COMPONENT (0x00080000)</h5>
      <para>
        <b>Windows 8 and later</b>. Percent-encode all ASCII characters outside of the unreserved set from URI RFC 3986 (a-zA-Z0-9-.~_).</para>
      <h5>- dwFlags.URL_ESCAPE_AS_UTF8 (0x00040000)</h5>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h5>- dwFlags.URL_ESCAPE_PERCENT (0x00001000)</h5>
      <para>Convert any % character found in the segment section of the URL (that section falling between the server specification and the first # or ? character). By default, the % character is not converted to its escape sequence. Other unsafe characters in the segment are also converted normally.</para>
      <para>Combining this flag with <b>URL_ESCAPE_SEGMENT_ONLY</b> includes those % characters in the query portion of the URL. However, as the <b>URL_ESCAPE_SEGMENT_ONLY</b> flag causes the entire string to be considered the segment, any # or ? characters are also converted.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_SPACES_ONLY</b>.</para>
      <h5>- dwFlags.URL_ESCAPE_SEGMENT_ONLY (0x00002000)</h5>
      <para>Indicates that <i>pszURL</i> contains only that section of the URL following the server component but preceding the query. All unsafe characters in the string are converted. If a full URL is provided when this flag is set, all unsafe characters in the entire string are converted, including # and ? characters.</para>
      <para>Combine this flag with <b>URL_ESCAPE_PERCENT</b> to include that character in the conversion.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_SPACES_ONLY</b> or <b>URL_DONT_ESCAPE_EXTRA_INFO</b>.</para>
      <h5>- dwFlags.URL_ESCAPE_SPACES_ONLY (0x04000000)</h5>
      <para>Convert only space characters to their escape sequences, including those space characters in the query portion of the URL. Other unsafe characters are not converted to their escape sequences. This flag assumes that <i>pszURL</i> does not contain a full URL. It expects only the portions following the server specification.</para>
      <para>Combine this flag with <b>URL_DONT_ESCAPE_EXTRA_INFO</b> to prevent the conversion of space characters in the query portion of the URL.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_PERCENT</b> or <b>URL_ESCAPE_SEGMENT_ONLY</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful. If the <i>pcchEscaped</i> buffer was too small to contain the result, E_POINTER is returned, and the value pointed to by <i>pcchEscaped</i> is set to the required buffer size. Otherwise, a standard error value is returned.</para>
    </returns>
    <remarks>
      <para>For the purposes of this document, a typical URL is divided into three sections: the server, the segment, and the query. For example:</para>
      <code>http://microsoft.com/test.asp?url=/example/abc.asp?frame=true#fragment
</code>
      <para>The server portion is "http://microsoft.com/". The trailing forward slash is considered part of the server portion.</para>
      <para>The segment portion is any part of the path found following the server portion, but before the first # or ? character, in this case simply "test.asp".</para>
      <para>The query portion is the remainder of the path from the first # or ? character (inclusive) to the end. In the example, it is "?url=/example/abc.asp?frame=true#fragment".</para>
      <para>Unsafe characters are those characters that might be altered during transport across the Internet. This function converts unsafe characters into their equivalent "%xy" escape sequences. The following table shows unsafe characters and their escape sequences.</para>
      <list type="table">
        <listheader>
          <description>Character</description>
          <description>Escape Sequence</description>
        </listheader>
        <item>
          <description>^</description>
          <description>%5E</description>
        </item>
        <item>
          <description>&amp;</description>
          <description>%26</description>
        </item>
        <item>
          <description>`</description>
          <description>%60</description>
        </item>
        <item>
          <description>{</description>
          <description>%7B</description>
        </item>
        <item>
          <description>}</description>
          <description>%7D</description>
        </item>
        <item>
          <description>|</description>
          <description>%7C</description>
        </item>
        <item>
          <description>]</description>
          <description>%5D</description>
        </item>
        <item>
          <description>[</description>
          <description>%5B</description>
        </item>
        <item>
          <description>"</description>
          <description>%22</description>
        </item>
        <item>
          <description>&lt;</description>
          <description>%3C</description>
        </item>
        <item>
          <description>&gt;</description>
          <description>%3E</description>
        </item>
        <item>
          <description>\</description>
          <description>%5C</description>
        </item>
      </list>
      <para>Use of the <b>URL_ESCAPE_SEGMENT_ONLY</b> flag also causes the conversion of the # (%23), ? (%3F), and / (%2F) characters.</para>
      <para>By default, <b>UrlEscape</b> ignores any text following a # or ? character. The <b>URL_ESCAPE_SEGMENT_ONLY</b> flag overrides this behavior by regarding the entire string as the segment. The <b>URL_ESCAPE_SPACES_ONLY</b> flag overrides this behavior, but only for space characters.</para>
      <h4>Examples</h4>
      <para>The following examples show the effect of the various flags on a URL. The example URL is not valid but is exaggerated for demonstration purposes.</para>
      <code>
// The full original URL
http://microsoft.com/test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_SPACES_ONLY
// Only space characters are escaped. Other unsafe characters are ignored.
// Note: This flag expects the server portion of the URL to be omitted.
Original = test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment
Result   = test/t%e&lt;s%20t.asp?url=/{ex%%20ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_SPACES_ONLY | URL_DONT_ESCAPE_EXTRA_INFO
// Spaces in the segment are converted into their escape sequences, but
// spaces in the query are not.
Original = test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment
Result   = test/t%e&lt;s%20t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_PERCENT
// Here only the segment and query are supplied and the server component is
// omitted, although that is not required. Only the segment is considered.
// All unsafe characters plus the % character are converted in the segment.
Original = test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment
Result   = test/t%25e%3Cs%20t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_SEGMENT_ONLY
// Note: This flag expects only the segment, omitting the server and query
//       components.
// The / character is escaped as well as the usual unsafe characters.
Original = test/t%e&lt;s t.asp
Result   = test%2Ft%e%3Cs%20t.asp
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlEscape as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinInet/handling-uniform-resource-locators">Handling Uniform Resource Locators</seealso>
  </member>
  <member name="Windows.UrlEscapeW">
    <summary>
      <para>Converts characters or surrogate pairs in a URL that might be altered during transport across the Internet ("unsafe" characters) into their corresponding escape sequences. Surrogate pairs are characters between U+10000 to U+10FFFF (in UTF-32)  or between DC00 to DFFF (in UTF-16).</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length <b>INTERNET_MAX_URL_LENGTH</b> that contains a full or partial URL, as appropriate for the value in <i>dwFlags</i>.</para>
    </param>
    <param name="pszEscaped">
      <para>Type: <b>PTSTR</b></para>
      <para>The buffer that receives the converted string, with the unsafe characters converted to their escape sequences.</para>
    </param>
    <param name="pcchEscaped">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a <b>DWORD</b> value that, on entry, contains the number of characters in the <i>pszEscaped</i> buffer. Before calling <b>UrlEscape</b>, the calling application must set the value referenced by <i>pcchEscaped</i> to the size of the buffer. When this function returns successfully, the value receives the number of characters written to the buffer, not including the terminating <b>NULL</b> character.</para>
      <para>If an E_POINTER error code is returned, the buffer was too small to hold the result, and the value referenced by <i>pcchEscaped</i> is set to the required number of characters in the buffer. If any other errors are returned, the value referenced by <i>pcchEscaped</i> is undefined.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that indicate which portion of the URL is being provided in <i>pszURL</i> and which characters in that string should be converted to their escape sequences. The following flags are defined.</para>
      <h4>URL_DONT_ESCAPE_EXTRA_INFO (0x02000000)</h4>
      <para>Used only in conjunction with <b>URL_ESCAPE_SPACES_ONLY</b> to prevent the conversion of characters in the query (the portion of the URL following the first # or ? character encountered in the string). This flag should not be used alone, nor combined with <b>URL_ESCAPE_SEGMENT_ONLY</b>.</para>
      <h4>URL_BROWSER_MODE</h4>
      <para>Defined to be the same as <b>URL_DONT_ESCAPE_EXTRA_INFO</b>.</para>
      <h4>URL_ESCAPE_SPACES_ONLY (0x04000000)</h4>
      <para>Convert only space characters to their escape sequences, including those space characters in the query portion of the URL. Other unsafe characters are not converted to their escape sequences. This flag assumes that <i>pszURL</i> does not contain a full URL. It expects only the portions following the server specification.</para>
      <para>Combine this flag with <b>URL_DONT_ESCAPE_EXTRA_INFO</b> to prevent the conversion of space characters in the query portion of the URL.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_PERCENT</b> or <b>URL_ESCAPE_SEGMENT_ONLY</b>.</para>
      <h4>URL_ESCAPE_PERCENT (0x00001000)</h4>
      <para>Convert any % character found in the segment section of the URL (that section falling between the server specification and the first # or ? character). By default, the % character is not converted to its escape sequence. Other unsafe characters in the segment are also converted normally.</para>
      <para>Combining this flag with <b>URL_ESCAPE_SEGMENT_ONLY</b> includes those % characters in the query portion of the URL. However, as the <b>URL_ESCAPE_SEGMENT_ONLY</b> flag causes the entire string to be considered the segment, any # or ? characters are also converted.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_SPACES_ONLY</b>.</para>
      <h4>URL_ESCAPE_SEGMENT_ONLY (0x00002000)</h4>
      <para>Indicates that <i>pszURL</i> contains only that section of the URL following the server component but preceding the query. All unsafe characters in the string are converted. If a full URL is provided when this flag is set, all unsafe characters in the entire string are converted, including # and ? characters.</para>
      <para>Combine this flag with <b>URL_ESCAPE_PERCENT</b> to include that character in the conversion.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_SPACES_ONLY</b> or <b>URL_DONT_ESCAPE_EXTRA_INFO</b>.</para>
      <h4>URL_ESCAPE_AS_UTF8 (0x00040000)</h4>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h4>URL_ESCAPE_ASCII_URI_COMPONENT (0x00080000)</h4>
      <para>
        <b>Windows 8 and later</b>. Percent-encode all ASCII characters outside of the unreserved set from URI RFC 3986 (a-zA-Z0-9-.~_).</para>
      <h5>- dwFlags.URL_BROWSER_MODE</h5>
      <para>Defined to be the same as <b>URL_DONT_ESCAPE_EXTRA_INFO</b>.</para>
      <h5>- dwFlags.URL_DONT_ESCAPE_EXTRA_INFO (0x02000000)</h5>
      <para>Used only in conjunction with <b>URL_ESCAPE_SPACES_ONLY</b> to prevent the conversion of characters in the query (the portion of the URL following the first # or ? character encountered in the string). This flag should not be used alone, nor combined with <b>URL_ESCAPE_SEGMENT_ONLY</b>.</para>
      <h5>- dwFlags.URL_ESCAPE_ASCII_URI_COMPONENT (0x00080000)</h5>
      <para>
        <b>Windows 8 and later</b>. Percent-encode all ASCII characters outside of the unreserved set from URI RFC 3986 (a-zA-Z0-9-.~_).</para>
      <h5>- dwFlags.URL_ESCAPE_AS_UTF8 (0x00040000)</h5>
      <para>
        <b>Windows 7 and later</b>. Percent-encode all non-ASCII characters as their UTF-8 equivalents.</para>
      <h5>- dwFlags.URL_ESCAPE_PERCENT (0x00001000)</h5>
      <para>Convert any % character found in the segment section of the URL (that section falling between the server specification and the first # or ? character). By default, the % character is not converted to its escape sequence. Other unsafe characters in the segment are also converted normally.</para>
      <para>Combining this flag with <b>URL_ESCAPE_SEGMENT_ONLY</b> includes those % characters in the query portion of the URL. However, as the <b>URL_ESCAPE_SEGMENT_ONLY</b> flag causes the entire string to be considered the segment, any # or ? characters are also converted.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_SPACES_ONLY</b>.</para>
      <h5>- dwFlags.URL_ESCAPE_SEGMENT_ONLY (0x00002000)</h5>
      <para>Indicates that <i>pszURL</i> contains only that section of the URL following the server component but preceding the query. All unsafe characters in the string are converted. If a full URL is provided when this flag is set, all unsafe characters in the entire string are converted, including # and ? characters.</para>
      <para>Combine this flag with <b>URL_ESCAPE_PERCENT</b> to include that character in the conversion.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_SPACES_ONLY</b> or <b>URL_DONT_ESCAPE_EXTRA_INFO</b>.</para>
      <h5>- dwFlags.URL_ESCAPE_SPACES_ONLY (0x04000000)</h5>
      <para>Convert only space characters to their escape sequences, including those space characters in the query portion of the URL. Other unsafe characters are not converted to their escape sequences. This flag assumes that <i>pszURL</i> does not contain a full URL. It expects only the portions following the server specification.</para>
      <para>Combine this flag with <b>URL_DONT_ESCAPE_EXTRA_INFO</b> to prevent the conversion of space characters in the query portion of the URL.</para>
      <para>This flag cannot be combined with <b>URL_ESCAPE_PERCENT</b> or <b>URL_ESCAPE_SEGMENT_ONLY</b>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful. If the <i>pcchEscaped</i> buffer was too small to contain the result, E_POINTER is returned, and the value pointed to by <i>pcchEscaped</i> is set to the required buffer size. Otherwise, a standard error value is returned.</para>
    </returns>
    <remarks>
      <para>For the purposes of this document, a typical URL is divided into three sections: the server, the segment, and the query. For example:</para>
      <code>http://microsoft.com/test.asp?url=/example/abc.asp?frame=true#fragment
</code>
      <para>The server portion is "http://microsoft.com/". The trailing forward slash is considered part of the server portion.</para>
      <para>The segment portion is any part of the path found following the server portion, but before the first # or ? character, in this case simply "test.asp".</para>
      <para>The query portion is the remainder of the path from the first # or ? character (inclusive) to the end. In the example, it is "?url=/example/abc.asp?frame=true#fragment".</para>
      <para>Unsafe characters are those characters that might be altered during transport across the Internet. This function converts unsafe characters into their equivalent "%xy" escape sequences. The following table shows unsafe characters and their escape sequences.</para>
      <list type="table">
        <listheader>
          <description>Character</description>
          <description>Escape Sequence</description>
        </listheader>
        <item>
          <description>^</description>
          <description>%5E</description>
        </item>
        <item>
          <description>&amp;</description>
          <description>%26</description>
        </item>
        <item>
          <description>`</description>
          <description>%60</description>
        </item>
        <item>
          <description>{</description>
          <description>%7B</description>
        </item>
        <item>
          <description>}</description>
          <description>%7D</description>
        </item>
        <item>
          <description>|</description>
          <description>%7C</description>
        </item>
        <item>
          <description>]</description>
          <description>%5D</description>
        </item>
        <item>
          <description>[</description>
          <description>%5B</description>
        </item>
        <item>
          <description>"</description>
          <description>%22</description>
        </item>
        <item>
          <description>&lt;</description>
          <description>%3C</description>
        </item>
        <item>
          <description>&gt;</description>
          <description>%3E</description>
        </item>
        <item>
          <description>\</description>
          <description>%5C</description>
        </item>
      </list>
      <para>Use of the <b>URL_ESCAPE_SEGMENT_ONLY</b> flag also causes the conversion of the # (%23), ? (%3F), and / (%2F) characters.</para>
      <para>By default, <b>UrlEscape</b> ignores any text following a # or ? character. The <b>URL_ESCAPE_SEGMENT_ONLY</b> flag overrides this behavior by regarding the entire string as the segment. The <b>URL_ESCAPE_SPACES_ONLY</b> flag overrides this behavior, but only for space characters.</para>
      <h4>Examples</h4>
      <para>The following examples show the effect of the various flags on a URL. The example URL is not valid but is exaggerated for demonstration purposes.</para>
      <code>
// The full original URL
http://microsoft.com/test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_SPACES_ONLY
// Only space characters are escaped. Other unsafe characters are ignored.
// Note: This flag expects the server portion of the URL to be omitted.
Original = test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment
Result   = test/t%e&lt;s%20t.asp?url=/{ex%%20ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_SPACES_ONLY | URL_DONT_ESCAPE_EXTRA_INFO
// Spaces in the segment are converted into their escape sequences, but
// spaces in the query are not.
Original = test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment
Result   = test/t%e&lt;s%20t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_PERCENT
// Here only the segment and query are supplied and the server component is
// omitted, although that is not required. Only the segment is considered.
// All unsafe characters plus the % character are converted in the segment.
Original = test/t%e&lt;s t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment
Result   = test/t%25e%3Cs%20t.asp?url=/{ex% ample&lt;/abc.asp?frame=true#fr%agment

// URL_ESCAPE_SEGMENT_ONLY
// Note: This flag expects only the segment, omitting the server and query
//       components.
// The / character is escaped as well as the usual unsafe characters.
Original = test/t%e&lt;s t.asp
Result   = test%2Ft%e%3Cs%20t.asp
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlEscape as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso href="https://docs.microsoft.com//windows/desktop/WinInet/handling-uniform-resource-locators">Handling Uniform Resource Locators</seealso>
  </member>
  <member name="Windows.UrlGetLocation">
    <summary>
      <para>Retrieves the location from a URL.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the location.</para>
    </param>
    <returns>
      <para>Type: <b>LPCTSTR</b></para>
      <para>Returns a pointer to a null-terminated string with the location, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The location is the segment of the URL starting with a ? or # character. If a file URL has a query string, the returned string includes the query string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlGetLocation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlGetLocationA">
    <summary>
      <para>Retrieves the location from a URL.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the location.</para>
    </param>
    <returns>
      <para>Type: <b>LPCTSTR</b></para>
      <para>Returns a pointer to a null-terminated string with the location, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The location is the segment of the URL starting with a ? or # character. If a file URL has a query string, the returned string includes the query string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlGetLocation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlGetLocationW">
    <summary>
      <para>Retrieves the location from a URL.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the location.</para>
    </param>
    <returns>
      <para>Type: <b>LPCTSTR</b></para>
      <para>Returns a pointer to a null-terminated string with the location, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The location is the segment of the URL starting with a ? or # character. If a file URL has a query string, the returned string includes the query string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlGetLocation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlGetLocation">
    <summary>
      <para>Retrieves the location from a URL.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the location.</para>
    </param>
    <returns>
      <para>Type: <b>LPCTSTR</b></para>
      <para>Returns a pointer to a null-terminated string with the location, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The location is the segment of the URL starting with a ? or # character. If a file URL has a query string, the returned string includes the query string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlGetLocation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlGetLocationA">
    <summary>
      <para>Retrieves the location from a URL.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the location.</para>
    </param>
    <returns>
      <para>Type: <b>LPCTSTR</b></para>
      <para>Returns a pointer to a null-terminated string with the location, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The location is the segment of the URL starting with a ? or # character. If a file URL has a query string, the returned string includes the query string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlGetLocation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlGetLocationW">
    <summary>
      <para>Retrieves the location from a URL.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the location.</para>
    </param>
    <returns>
      <para>Type: <b>LPCTSTR</b></para>
      <para>Returns a pointer to a null-terminated string with the location, or <b>NULL</b> otherwise.</para>
    </returns>
    <remarks>
      <para>The location is the segment of the URL starting with a ? or # character. If a file URL has a query string, the returned string includes the query string.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlGetLocation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlGetPart">
    <summary>
      <para>Accepts a URL string and returns a specified part of that URL.</para>
    </summary>
    <param name="pszIn">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives a null-terminated string with the specified part of the URL.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, is set to the number of characters in the <i>pszOut</i> buffer. When this function returns successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.</para>
    </param>
    <param name="dwPart">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that specify which part of the URL to retrieve. It can have one of the following values.</para>
      <h4>URL_PART_HOSTNAME</h4>
      <para>The host name.</para>
      <h4>URL_PART_PASSWORD</h4>
      <para>The password.</para>
      <h4>URL_PART_PORT</h4>
      <para>The port number.</para>
      <h4>URL_PART_QUERY</h4>
      <para>The query portion of the URL.</para>
      <h4>URL_PART_SCHEME</h4>
      <para>The URL scheme.</para>
      <h4>URL_PART_USERNAME</h4>
      <para>The username.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>A flag that can be set to keep the URL scheme, in addition to the part that is specified by <i>dwPart</i>.</para>
      <h4>URL_PARTFLAG_KEEPSCHEME</h4>
      <para>Keep the URL scheme.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful. The value pointed to by <i>pcchOut</i> will be set to the number of characters written to the output buffer, excluding the terminating <b>NULL</b>. If the buffer was too small, E_POINTER is returned, and the value pointed to by <i>pcchOut</i> will be set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character. Otherwise, a COM error value is returned.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlGetPart as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlGetPartA">
    <summary>
      <para>Accepts a URL string and returns a specified part of that URL.</para>
    </summary>
    <param name="pszIn">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives a null-terminated string with the specified part of the URL.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, is set to the number of characters in the <i>pszOut</i> buffer. When this function returns successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.</para>
    </param>
    <param name="dwPart">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that specify which part of the URL to retrieve. It can have one of the following values.</para>
      <h4>URL_PART_HOSTNAME</h4>
      <para>The host name.</para>
      <h4>URL_PART_PASSWORD</h4>
      <para>The password.</para>
      <h4>URL_PART_PORT</h4>
      <para>The port number.</para>
      <h4>URL_PART_QUERY</h4>
      <para>The query portion of the URL.</para>
      <h4>URL_PART_SCHEME</h4>
      <para>The URL scheme.</para>
      <h4>URL_PART_USERNAME</h4>
      <para>The username.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>A flag that can be set to keep the URL scheme, in addition to the part that is specified by <i>dwPart</i>.</para>
      <h4>URL_PARTFLAG_KEEPSCHEME</h4>
      <para>Keep the URL scheme.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful. The value pointed to by <i>pcchOut</i> will be set to the number of characters written to the output buffer, excluding the terminating <b>NULL</b>. If the buffer was too small, E_POINTER is returned, and the value pointed to by <i>pcchOut</i> will be set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character. Otherwise, a COM error value is returned.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlGetPart as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlGetPartW">
    <summary>
      <para>Accepts a URL string and returns a specified part of that URL.</para>
    </summary>
    <param name="pszIn">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives a null-terminated string with the specified part of the URL.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, is set to the number of characters in the <i>pszOut</i> buffer. When this function returns successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.</para>
    </param>
    <param name="dwPart">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that specify which part of the URL to retrieve. It can have one of the following values.</para>
      <h4>URL_PART_HOSTNAME</h4>
      <para>The host name.</para>
      <h4>URL_PART_PASSWORD</h4>
      <para>The password.</para>
      <h4>URL_PART_PORT</h4>
      <para>The port number.</para>
      <h4>URL_PART_QUERY</h4>
      <para>The query portion of the URL.</para>
      <h4>URL_PART_SCHEME</h4>
      <para>The URL scheme.</para>
      <h4>URL_PART_USERNAME</h4>
      <para>The username.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>A flag that can be set to keep the URL scheme, in addition to the part that is specified by <i>dwPart</i>.</para>
      <h4>URL_PARTFLAG_KEEPSCHEME</h4>
      <para>Keep the URL scheme.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful. The value pointed to by <i>pcchOut</i> will be set to the number of characters written to the output buffer, excluding the terminating <b>NULL</b>. If the buffer was too small, E_POINTER is returned, and the value pointed to by <i>pcchOut</i> will be set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character. Otherwise, a COM error value is returned.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlGetPart as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlGetPart">
    <summary>
      <para>Accepts a URL string and returns a specified part of that URL.</para>
    </summary>
    <param name="pszIn">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives a null-terminated string with the specified part of the URL.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, is set to the number of characters in the <i>pszOut</i> buffer. When this function returns successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.</para>
    </param>
    <param name="dwPart">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that specify which part of the URL to retrieve. It can have one of the following values.</para>
      <h4>URL_PART_HOSTNAME</h4>
      <para>The host name.</para>
      <h4>URL_PART_PASSWORD</h4>
      <para>The password.</para>
      <h4>URL_PART_PORT</h4>
      <para>The port number.</para>
      <h4>URL_PART_QUERY</h4>
      <para>The query portion of the URL.</para>
      <h4>URL_PART_SCHEME</h4>
      <para>The URL scheme.</para>
      <h4>URL_PART_USERNAME</h4>
      <para>The username.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>A flag that can be set to keep the URL scheme, in addition to the part that is specified by <i>dwPart</i>.</para>
      <h4>URL_PARTFLAG_KEEPSCHEME</h4>
      <para>Keep the URL scheme.</para>
      <h5>- dwFlags.URL_PARTFLAG_KEEPSCHEME</h5>
      <para>Keep the URL scheme.</para>
      <h5>- dwPart.URL_PART_HOSTNAME</h5>
      <para>The host name.</para>
      <h5>- dwPart.URL_PART_PASSWORD</h5>
      <para>The password.</para>
      <h5>- dwPart.URL_PART_PORT</h5>
      <para>The port number.</para>
      <h5>- dwPart.URL_PART_QUERY</h5>
      <para>The query portion of the URL.</para>
      <h5>- dwPart.URL_PART_SCHEME</h5>
      <para>The URL scheme.</para>
      <h5>- dwPart.URL_PART_USERNAME</h5>
      <para>The username.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful. The value pointed to by <i>pcchOut</i> will be set to the number of characters written to the output buffer, excluding the terminating <b>NULL</b>. If the buffer was too small, E_POINTER is returned, and the value pointed to by <i>pcchOut</i> will be set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character. Otherwise, a COM error value is returned.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlGetPart as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlGetPartA">
    <summary>
      <para>Accepts a URL string and returns a specified part of that URL.</para>
    </summary>
    <param name="pszIn">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives a null-terminated string with the specified part of the URL.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, is set to the number of characters in the <i>pszOut</i> buffer. When this function returns successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.</para>
    </param>
    <param name="dwPart">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that specify which part of the URL to retrieve. It can have one of the following values.</para>
      <h4>URL_PART_HOSTNAME</h4>
      <para>The host name.</para>
      <h4>URL_PART_PASSWORD</h4>
      <para>The password.</para>
      <h4>URL_PART_PORT</h4>
      <para>The port number.</para>
      <h4>URL_PART_QUERY</h4>
      <para>The query portion of the URL.</para>
      <h4>URL_PART_SCHEME</h4>
      <para>The URL scheme.</para>
      <h4>URL_PART_USERNAME</h4>
      <para>The username.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>A flag that can be set to keep the URL scheme, in addition to the part that is specified by <i>dwPart</i>.</para>
      <h4>URL_PARTFLAG_KEEPSCHEME</h4>
      <para>Keep the URL scheme.</para>
      <h5>- dwFlags.URL_PARTFLAG_KEEPSCHEME</h5>
      <para>Keep the URL scheme.</para>
      <h5>- dwPart.URL_PART_HOSTNAME</h5>
      <para>The host name.</para>
      <h5>- dwPart.URL_PART_PASSWORD</h5>
      <para>The password.</para>
      <h5>- dwPart.URL_PART_PORT</h5>
      <para>The port number.</para>
      <h5>- dwPart.URL_PART_QUERY</h5>
      <para>The query portion of the URL.</para>
      <h5>- dwPart.URL_PART_SCHEME</h5>
      <para>The URL scheme.</para>
      <h5>- dwPart.URL_PART_USERNAME</h5>
      <para>The username.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful. The value pointed to by <i>pcchOut</i> will be set to the number of characters written to the output buffer, excluding the terminating <b>NULL</b>. If the buffer was too small, E_POINTER is returned, and the value pointed to by <i>pcchOut</i> will be set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character. Otherwise, a COM error value is returned.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlGetPart as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlGetPartW">
    <summary>
      <para>Accepts a URL string and returns a specified part of that URL.</para>
    </summary>
    <param name="pszIn">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="pszOut">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives a null-terminated string with the specified part of the URL.</para>
    </param>
    <param name="pcchOut">
      <para>Type: <b>DWORD*</b></para>
      <para>A pointer to a value that, on entry, is set to the number of characters in the <i>pszOut</i> buffer. When this function returns successfully, the value depends on whether the function is successful or returns E_POINTER. For other return values, the value of this parameter is meaningless.</para>
    </param>
    <param name="dwPart">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that specify which part of the URL to retrieve. It can have one of the following values.</para>
      <h4>URL_PART_HOSTNAME</h4>
      <para>The host name.</para>
      <h4>URL_PART_PASSWORD</h4>
      <para>The password.</para>
      <h4>URL_PART_PORT</h4>
      <para>The port number.</para>
      <h4>URL_PART_QUERY</h4>
      <para>The query portion of the URL.</para>
      <h4>URL_PART_SCHEME</h4>
      <para>The URL scheme.</para>
      <h4>URL_PART_USERNAME</h4>
      <para>The username.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>A flag that can be set to keep the URL scheme, in addition to the part that is specified by <i>dwPart</i>.</para>
      <h4>URL_PARTFLAG_KEEPSCHEME</h4>
      <para>Keep the URL scheme.</para>
      <h5>- dwFlags.URL_PARTFLAG_KEEPSCHEME</h5>
      <para>Keep the URL scheme.</para>
      <h5>- dwPart.URL_PART_HOSTNAME</h5>
      <para>The host name.</para>
      <h5>- dwPart.URL_PART_PASSWORD</h5>
      <para>The password.</para>
      <h5>- dwPart.URL_PART_PORT</h5>
      <para>The port number.</para>
      <h5>- dwPart.URL_PART_QUERY</h5>
      <para>The query portion of the URL.</para>
      <h5>- dwPart.URL_PART_SCHEME</h5>
      <para>The URL scheme.</para>
      <h5>- dwPart.URL_PART_USERNAME</h5>
      <para>The username.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful. The value pointed to by <i>pcchOut</i> will be set to the number of characters written to the output buffer, excluding the terminating <b>NULL</b>. If the buffer was too small, E_POINTER is returned, and the value pointed to by <i>pcchOut</i> will be set to the minimum number of characters that the buffer must be able to contain, including the terminating <b>NULL</b> character. Otherwise, a COM error value is returned.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlGetPart as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlHash">
    <summary>
      <para>Hashes a URL string.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="pbHash">
      <para>Type: <b>BYTE*</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the hashed array.</para>
    </param>
    <param name="cbHash">
      <para>Type: <b>DWORD</b></para>
      <para>The number of elements in the array at <i>pbHash</i>. It should be no larger than 256.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>To hash a URL into a single byte, set <i>cbHash</i> = sizeof(BYTE) and <i>pbHash</i> = (LPBYTE)&amp;bHashedValue, where bHashedValue is a one-byte buffer. To hash a URL into a <b>DWORD</b>, set <i>cbHash</i> = sizeof(DWORD) and <i>pbHash</i> = (LPBYTE)&amp;dwHashedValue, where dwHashedValue is a <b>DWORD</b> buffer.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlHash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="HashData" />
  </member>
  <member name="Windows.UrlHashA">
    <summary>
      <para>Hashes a URL string.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="pbHash">
      <para>Type: <b>BYTE*</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the hashed array.</para>
    </param>
    <param name="cbHash">
      <para>Type: <b>DWORD</b></para>
      <para>The number of elements in the array at <i>pbHash</i>. It should be no larger than 256.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>To hash a URL into a single byte, set <i>cbHash</i> = sizeof(BYTE) and <i>pbHash</i> = (LPBYTE)&amp;bHashedValue, where bHashedValue is a one-byte buffer. To hash a URL into a <b>DWORD</b>, set <i>cbHash</i> = sizeof(DWORD) and <i>pbHash</i> = (LPBYTE)&amp;dwHashedValue, where dwHashedValue is a <b>DWORD</b> buffer.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlHash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="HashData" />
  </member>
  <member name="Windows.UrlHashW">
    <summary>
      <para>Hashes a URL string.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="pbHash">
      <para>Type: <b>BYTE*</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the hashed array.</para>
    </param>
    <param name="cbHash">
      <para>Type: <b>DWORD</b></para>
      <para>The number of elements in the array at <i>pbHash</i>. It should be no larger than 256.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>To hash a URL into a single byte, set <i>cbHash</i> = sizeof(BYTE) and <i>pbHash</i> = (LPBYTE)&amp;bHashedValue, where bHashedValue is a one-byte buffer. To hash a URL into a <b>DWORD</b>, set <i>cbHash</i> = sizeof(DWORD) and <i>pbHash</i> = (LPBYTE)&amp;dwHashedValue, where dwHashedValue is a <b>DWORD</b> buffer.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlHash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="HashData" />
  </member>
  <member name="Windows.UrlHash">
    <summary>
      <para>Hashes a URL string.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="pbHash">
      <para>Type: <b>BYTE*</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the hashed array.</para>
    </param>
    <param name="cbHash">
      <para>Type: <b>DWORD</b></para>
      <para>The number of elements in the array at <i>pbHash</i>. It should be no larger than 256.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>To hash a URL into a single byte, set <i>cbHash</i> = sizeof(BYTE) and <i>pbHash</i> = (LPBYTE)&amp;bHashedValue, where bHashedValue is a one-byte buffer. To hash a URL into a <b>DWORD</b>, set <i>cbHash</i> = sizeof(DWORD) and <i>pbHash</i> = (LPBYTE)&amp;dwHashedValue, where dwHashedValue is a <b>DWORD</b> buffer.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlHash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="HashData" />
  </member>
  <member name="Windows.UrlHashA">
    <summary>
      <para>Hashes a URL string.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="pbHash">
      <para>Type: <b>BYTE*</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the hashed array.</para>
    </param>
    <param name="cbHash">
      <para>Type: <b>DWORD</b></para>
      <para>The number of elements in the array at <i>pbHash</i>. It should be no larger than 256.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>To hash a URL into a single byte, set <i>cbHash</i> = sizeof(BYTE) and <i>pbHash</i> = (LPBYTE)&amp;bHashedValue, where bHashedValue is a one-byte buffer. To hash a URL into a <b>DWORD</b>, set <i>cbHash</i> = sizeof(DWORD) and <i>pbHash</i> = (LPBYTE)&amp;dwHashedValue, where dwHashedValue is a <b>DWORD</b> buffer.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlHash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="HashData" />
  </member>
  <member name="Windows.UrlHashW">
    <summary>
      <para>Hashes a URL string.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="pbHash">
      <para>Type: <b>BYTE*</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the hashed array.</para>
    </param>
    <param name="cbHash">
      <para>Type: <b>DWORD</b></para>
      <para>The number of elements in the array at <i>pbHash</i>. It should be no larger than 256.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.</para>
    </returns>
    <remarks>
      <para>To hash a URL into a single byte, set <i>cbHash</i> = sizeof(BYTE) and <i>pbHash</i> = (LPBYTE)&amp;bHashedValue, where bHashedValue is a one-byte buffer. To hash a URL into a <b>DWORD</b>, set <i>cbHash</i> = sizeof(DWORD) and <i>pbHash</i> = (LPBYTE)&amp;dwHashedValue, where dwHashedValue is a <b>DWORD</b> buffer.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlHash as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="HashData" />
  </member>
  <member name="Windows.UrlIs">
    <summary>
      <para>Tests whether a URL is a specified type.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="UrlIs">
      <para>Type: <b>URLIS</b></para>
      <para>The type of URL to be tested for. This parameter can take one of the following values.</para>
      <h4>URLIS_APPLIABLE</h4>
      <para>Attempt to determine a valid scheme for the URL.</para>
      <h4>URLIS_DIRECTORY</h4>
      <para>Does the URL string end with a directory?</para>
      <h4>URLIS_FILEURL</h4>
      <para>Is the URL a file URL?</para>
      <h4>URLIS_HASQUERY</h4>
      <para>Does the URL have an appended query string?</para>
      <h4>URLIS_NOHISTORY</h4>
      <para>Is the URL a URL that is not typically tracked in navigation history?</para>
      <h4>URLIS_OPAQUE</h4>
      <para>Is the URL <see cref="opaque" />?</para>
      <h4>URLIS_URL</h4>
      <para>Is the URL valid?</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>For all but one of the URL types, <b>UrlIs</b> returns <b>TRUE</b> if the URL is the specified type, or <b>FALSE</b> if not.</para>
      <para>If <i>UrlIs</i> is set to <b>URLIS_APPLIABLE</b>, <b>UrlIs</b> will attempt to determine the URL scheme. If the function is able to determine a scheme, it returns <b>TRUE</b>, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlIs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="UrlIsFileUrl" />
    <seealso cref="UrlIsNoHistory" />
    <seealso cref="UrlIsOpaque" />
  </member>
  <member name="Windows.UrlIsA">
    <summary>
      <para>Tests whether a URL is a specified type.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="UrlIs">
      <para>Type: <b>URLIS</b></para>
      <para>The type of URL to be tested for. This parameter can take one of the following values.</para>
      <h4>URLIS_APPLIABLE</h4>
      <para>Attempt to determine a valid scheme for the URL.</para>
      <h4>URLIS_DIRECTORY</h4>
      <para>Does the URL string end with a directory?</para>
      <h4>URLIS_FILEURL</h4>
      <para>Is the URL a file URL?</para>
      <h4>URLIS_HASQUERY</h4>
      <para>Does the URL have an appended query string?</para>
      <h4>URLIS_NOHISTORY</h4>
      <para>Is the URL a URL that is not typically tracked in navigation history?</para>
      <h4>URLIS_OPAQUE</h4>
      <para>Is the URL <see cref="opaque" />?</para>
      <h4>URLIS_URL</h4>
      <para>Is the URL valid?</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>For all but one of the URL types, <b>UrlIs</b> returns <b>TRUE</b> if the URL is the specified type, or <b>FALSE</b> if not.</para>
      <para>If <i>UrlIs</i> is set to <b>URLIS_APPLIABLE</b>, <b>UrlIs</b> will attempt to determine the URL scheme. If the function is able to determine a scheme, it returns <b>TRUE</b>, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlIs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="UrlIsFileUrl" />
    <seealso cref="UrlIsNoHistory" />
    <seealso cref="UrlIsOpaque" />
  </member>
  <member name="Windows.UrlIsW">
    <summary>
      <para>Tests whether a URL is a specified type.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="UrlIs">
      <para>Type: <b>URLIS</b></para>
      <para>The type of URL to be tested for. This parameter can take one of the following values.</para>
      <h4>URLIS_APPLIABLE</h4>
      <para>Attempt to determine a valid scheme for the URL.</para>
      <h4>URLIS_DIRECTORY</h4>
      <para>Does the URL string end with a directory?</para>
      <h4>URLIS_FILEURL</h4>
      <para>Is the URL a file URL?</para>
      <h4>URLIS_HASQUERY</h4>
      <para>Does the URL have an appended query string?</para>
      <h4>URLIS_NOHISTORY</h4>
      <para>Is the URL a URL that is not typically tracked in navigation history?</para>
      <h4>URLIS_OPAQUE</h4>
      <para>Is the URL <see cref="opaque" />?</para>
      <h4>URLIS_URL</h4>
      <para>Is the URL valid?</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>For all but one of the URL types, <b>UrlIs</b> returns <b>TRUE</b> if the URL is the specified type, or <b>FALSE</b> if not.</para>
      <para>If <i>UrlIs</i> is set to <b>URLIS_APPLIABLE</b>, <b>UrlIs</b> will attempt to determine the URL scheme. If the function is able to determine a scheme, it returns <b>TRUE</b>, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlIs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="UrlIsFileUrl" />
    <seealso cref="UrlIsNoHistory" />
    <seealso cref="UrlIsOpaque" />
  </member>
  <member name="Windows.UrlIsFileUrl">
    <summary>
      <para>Tests a URL to determine if it is a file URL.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the URL.</para>
    </param>
    <remarks>
      <para>A file URL has the form "File://
<i>xxx</i>". <b>UrlIsFileUrl</b> is actually one of the following macros, depending on whether ANSI or Unicode is selected.</para>
      <code>
#define  UrlIsFileUrlA(pszURL) UrlIsA(pszURL, URLIS_FILEURL)
#define  UrlIsFileUrlW(pszURL) UrlIsW(pszURL, URLIS_FILEURL)

</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlIsFileUrl as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="UrlIs" />
  </member>
  <member name="Windows.UrlIsFileUrlA">
    <summary>
      <para>Tests a URL to determine if it is a file URL.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the URL.</para>
    </param>
    <remarks>
      <para>A file URL has the form "File://
<i>xxx</i>". <b>UrlIsFileUrl</b> is actually one of the following macros, depending on whether ANSI or Unicode is selected.</para>
      <code>
#define  UrlIsFileUrlA(pszURL) UrlIsA(pszURL, URLIS_FILEURL)
#define  UrlIsFileUrlW(pszURL) UrlIsW(pszURL, URLIS_FILEURL)

</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlIsFileUrl as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="UrlIs" />
  </member>
  <member name="Windows.UrlIsFileUrlW">
    <summary>
      <para>Tests a URL to determine if it is a file URL.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the URL.</para>
    </param>
    <remarks>
      <para>A file URL has the form "File://
<i>xxx</i>". <b>UrlIsFileUrl</b> is actually one of the following macros, depending on whether ANSI or Unicode is selected.</para>
      <code>
#define  UrlIsFileUrlA(pszURL) UrlIsA(pszURL, URLIS_FILEURL)
#define  UrlIsFileUrlW(pszURL) UrlIsW(pszURL, URLIS_FILEURL)

</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlIsFileUrl as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="UrlIs" />
  </member>
  <member name="Windows.UrlIsFileUrl">
    <summary>
      <para>Tests a URL to determine if it is a file URL.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the URL.</para>
    </param>
    <remarks>
      <para>A file URL has the form "File://
<i>xxx</i>". <b>UrlIsFileUrl</b> is actually one of the following macros, depending on whether ANSI or Unicode is selected.</para>
      <code>
#define  UrlIsFileUrlA(pszURL) UrlIsA(pszURL, URLIS_FILEURL)
#define  UrlIsFileUrlW(pszURL) UrlIsW(pszURL, URLIS_FILEURL)

</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlIsFileUrl as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="UrlIs" />
  </member>
  <member name="Windows.UrlIsFileUrlA">
    <summary>
      <para>Tests a URL to determine if it is a file URL.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the URL.</para>
    </param>
    <remarks>
      <para>A file URL has the form "File://
<i>xxx</i>". <b>UrlIsFileUrl</b> is actually one of the following macros, depending on whether ANSI or Unicode is selected.</para>
      <code>
#define  UrlIsFileUrlA(pszURL) UrlIsA(pszURL, URLIS_FILEURL)
#define  UrlIsFileUrlW(pszURL) UrlIsW(pszURL, URLIS_FILEURL)

</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlIsFileUrl as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="UrlIs" />
  </member>
  <member name="Windows.UrlIsFileUrlW">
    <summary>
      <para>Tests a URL to determine if it is a file URL.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>LPCTSTR</b></para>
      <para>A pointer to a null-terminated string containing the URL.</para>
    </param>
    <remarks>
      <para>A file URL has the form "File://
<i>xxx</i>". <b>UrlIsFileUrl</b> is actually one of the following macros, depending on whether ANSI or Unicode is selected.</para>
      <code>
#define  UrlIsFileUrlA(pszURL) UrlIsA(pszURL, URLIS_FILEURL)
#define  UrlIsFileUrlW(pszURL) UrlIsW(pszURL, URLIS_FILEURL)

</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlIsFileUrl as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="UrlIs" />
  </member>
  <member name="Windows.UrlIsNoHistory">
    <summary>
      <para>Returns whether a URL is a URL that browsers typically do not include in navigation history.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns a nonzero value if the URL is a URL that is not included in navigation history, or zero otherwise.</para>
    </returns>
    <remarks>
      <para>This function is equivalent to the following:</para>
      <code>UrlIs(pszURL, URLIS_NOHISTORY)
</code>
    </remarks>
    <seealso cref="UrlIs" />
  </member>
  <member name="Windows.UrlIsNoHistoryA">
    <summary>
      <para>Returns whether a URL is a URL that browsers typically do not include in navigation history.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns a nonzero value if the URL is a URL that is not included in navigation history, or zero otherwise.</para>
    </returns>
    <remarks>
      <para>This function is equivalent to the following:</para>
      <code>UrlIs(pszURL, URLIS_NOHISTORY)
</code>
    </remarks>
    <seealso cref="UrlIs" />
  </member>
  <member name="Windows.UrlIsNoHistoryW">
    <summary>
      <para>Returns whether a URL is a URL that browsers typically do not include in navigation history.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns a nonzero value if the URL is a URL that is not included in navigation history, or zero otherwise.</para>
    </returns>
    <remarks>
      <para>This function is equivalent to the following:</para>
      <code>UrlIs(pszURL, URLIS_NOHISTORY)
</code>
    </remarks>
    <seealso cref="UrlIs" />
  </member>
  <member name="Windows.UrlIsNoHistory">
    <summary>
      <para>Returns whether a URL is a URL that browsers typically do not include in navigation history.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns a nonzero value if the URL is a URL that is not included in navigation history, or zero otherwise.</para>
    </returns>
    <remarks>
      <para>This function is equivalent to the following:</para>
      <code>UrlIs(pszURL, URLIS_NOHISTORY)
</code>
    </remarks>
    <seealso cref="UrlIs" />
  </member>
  <member name="Windows.UrlIsNoHistoryA">
    <summary>
      <para>Returns whether a URL is a URL that browsers typically do not include in navigation history.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns a nonzero value if the URL is a URL that is not included in navigation history, or zero otherwise.</para>
    </returns>
    <remarks>
      <para>This function is equivalent to the following:</para>
      <code>UrlIs(pszURL, URLIS_NOHISTORY)
</code>
    </remarks>
    <seealso cref="UrlIs" />
  </member>
  <member name="Windows.UrlIsNoHistoryW">
    <summary>
      <para>Returns whether a URL is a URL that browsers typically do not include in navigation history.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns a nonzero value if the URL is a URL that is not included in navigation history, or zero otherwise.</para>
    </returns>
    <remarks>
      <para>This function is equivalent to the following:</para>
      <code>UrlIs(pszURL, URLIS_NOHISTORY)
</code>
    </remarks>
    <seealso cref="UrlIs" />
  </member>
  <member name="Windows.UrlIsOpaque">
    <summary>
      <para>Returns whether a URL is opaque.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns a nonzero value if the URL is opaque, or zero otherwise.</para>
    </returns>
    <remarks>
      <para>A URL that has a scheme that is not followed by two slashes (//) is opaque. For example, mailto:xyz@litwareinc.com is an opaque URL. Opaque URLs cannot be separated into the standard URL hierarchy. <b>UrlIsOpaque</b> is equivalent to the following:</para>
      <code>UrlIs(pszURL, URLIS_OPAQUE)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlIsOpaque as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="UrlIs" />
  </member>
  <member name="Windows.UrlIsOpaqueA">
    <summary>
      <para>Returns whether a URL is opaque.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns a nonzero value if the URL is opaque, or zero otherwise.</para>
    </returns>
    <remarks>
      <para>A URL that has a scheme that is not followed by two slashes (//) is opaque. For example, mailto:xyz@litwareinc.com is an opaque URL. Opaque URLs cannot be separated into the standard URL hierarchy. <b>UrlIsOpaque</b> is equivalent to the following:</para>
      <code>UrlIs(pszURL, URLIS_OPAQUE)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlIsOpaque as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="UrlIs" />
  </member>
  <member name="Windows.UrlIsOpaqueW">
    <summary>
      <para>Returns whether a URL is opaque.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns a nonzero value if the URL is opaque, or zero otherwise.</para>
    </returns>
    <remarks>
      <para>A URL that has a scheme that is not followed by two slashes (//) is opaque. For example, mailto:xyz@litwareinc.com is an opaque URL. Opaque URLs cannot be separated into the standard URL hierarchy. <b>UrlIsOpaque</b> is equivalent to the following:</para>
      <code>UrlIs(pszURL, URLIS_OPAQUE)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlIsOpaque as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="UrlIs" />
  </member>
  <member name="Windows.UrlIsOpaque">
    <summary>
      <para>Returns whether a URL is opaque.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns a nonzero value if the URL is opaque, or zero otherwise.</para>
    </returns>
    <remarks>
      <para>A URL that has a scheme that is not followed by two slashes (//) is opaque. For example, mailto:xyz@litwareinc.com is an opaque URL. Opaque URLs cannot be separated into the standard URL hierarchy. <b>UrlIsOpaque</b> is equivalent to the following:</para>
      <code>UrlIs(pszURL, URLIS_OPAQUE)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlIsOpaque as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="UrlIs" />
  </member>
  <member name="Windows.UrlIsOpaqueA">
    <summary>
      <para>Returns whether a URL is opaque.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns a nonzero value if the URL is opaque, or zero otherwise.</para>
    </returns>
    <remarks>
      <para>A URL that has a scheme that is not followed by two slashes (//) is opaque. For example, mailto:xyz@litwareinc.com is an opaque URL. Opaque URLs cannot be separated into the standard URL hierarchy. <b>UrlIsOpaque</b> is equivalent to the following:</para>
      <code>UrlIs(pszURL, URLIS_OPAQUE)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlIsOpaque as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="UrlIs" />
  </member>
  <member name="Windows.UrlIsOpaqueW">
    <summary>
      <para>Returns whether a URL is opaque.</para>
    </summary>
    <param name="pszURL">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>Returns a nonzero value if the URL is opaque, or zero otherwise.</para>
    </returns>
    <remarks>
      <para>A URL that has a scheme that is not followed by two slashes (//) is opaque. For example, mailto:xyz@litwareinc.com is an opaque URL. Opaque URLs cannot be separated into the standard URL hierarchy. <b>UrlIsOpaque</b> is equivalent to the following:</para>
      <code>UrlIs(pszURL, URLIS_OPAQUE)
</code>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlIsOpaque as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="UrlIs" />
  </member>
  <member name="Windows.UrlIs">
    <summary>
      <para>Tests whether a URL is a specified type.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="UrlIs">
      <para>Type: <b>URLIS</b></para>
      <para>The type of URL to be tested for. This parameter can take one of the following values.</para>
      <h4>URLIS_APPLIABLE</h4>
      <para>Attempt to determine a valid scheme for the URL.</para>
      <h4>URLIS_DIRECTORY</h4>
      <para>Does the URL string end with a directory?</para>
      <h4>URLIS_FILEURL</h4>
      <para>Is the URL a file URL?</para>
      <h4>URLIS_HASQUERY</h4>
      <para>Does the URL have an appended query string?</para>
      <h4>URLIS_NOHISTORY</h4>
      <para>Is the URL a URL that is not typically tracked in navigation history?</para>
      <h4>URLIS_OPAQUE</h4>
      <para>Is the URL <see cref="opaque" />?</para>
      <h4>URLIS_URL</h4>
      <para>Is the URL valid?</para>
      <h5>- UrlIs.URLIS_APPLIABLE</h5>
      <para>Attempt to determine a valid scheme for the URL.</para>
      <h5>- UrlIs.URLIS_DIRECTORY</h5>
      <para>Does the URL string end with a directory?</para>
      <h5>- UrlIs.URLIS_FILEURL</h5>
      <para>Is the URL a file URL?</para>
      <h5>- UrlIs.URLIS_HASQUERY</h5>
      <para>Does the URL have an appended query string?</para>
      <h5>- UrlIs.URLIS_NOHISTORY</h5>
      <para>Is the URL a URL that is not typically tracked in navigation history?</para>
      <h5>- UrlIs.URLIS_OPAQUE</h5>
      <para>Is the URL <see cref="opaque" />?</para>
      <h5>- UrlIs.URLIS_URL</h5>
      <para>Is the URL valid?</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>For all but one of the URL types, <b>UrlIs</b> returns <b>TRUE</b> if the URL is the specified type, or <b>FALSE</b> if not.</para>
      <para>If <i>UrlIs</i> is set to <b>URLIS_APPLIABLE</b>, <b>UrlIs</b> will attempt to determine the URL scheme. If the function is able to determine a scheme, it returns <b>TRUE</b>, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlIs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="UrlIsFileUrl" />
    <seealso cref="UrlIsNoHistory" />
    <seealso cref="UrlIsOpaque" />
  </member>
  <member name="Windows.UrlIsA">
    <summary>
      <para>Tests whether a URL is a specified type.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="UrlIs">
      <para>Type: <b>URLIS</b></para>
      <para>The type of URL to be tested for. This parameter can take one of the following values.</para>
      <h4>URLIS_APPLIABLE</h4>
      <para>Attempt to determine a valid scheme for the URL.</para>
      <h4>URLIS_DIRECTORY</h4>
      <para>Does the URL string end with a directory?</para>
      <h4>URLIS_FILEURL</h4>
      <para>Is the URL a file URL?</para>
      <h4>URLIS_HASQUERY</h4>
      <para>Does the URL have an appended query string?</para>
      <h4>URLIS_NOHISTORY</h4>
      <para>Is the URL a URL that is not typically tracked in navigation history?</para>
      <h4>URLIS_OPAQUE</h4>
      <para>Is the URL <see cref="opaque" />?</para>
      <h4>URLIS_URL</h4>
      <para>Is the URL valid?</para>
      <h5>- UrlIs.URLIS_APPLIABLE</h5>
      <para>Attempt to determine a valid scheme for the URL.</para>
      <h5>- UrlIs.URLIS_DIRECTORY</h5>
      <para>Does the URL string end with a directory?</para>
      <h5>- UrlIs.URLIS_FILEURL</h5>
      <para>Is the URL a file URL?</para>
      <h5>- UrlIs.URLIS_HASQUERY</h5>
      <para>Does the URL have an appended query string?</para>
      <h5>- UrlIs.URLIS_NOHISTORY</h5>
      <para>Is the URL a URL that is not typically tracked in navigation history?</para>
      <h5>- UrlIs.URLIS_OPAQUE</h5>
      <para>Is the URL <see cref="opaque" />?</para>
      <h5>- UrlIs.URLIS_URL</h5>
      <para>Is the URL valid?</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>For all but one of the URL types, <b>UrlIs</b> returns <b>TRUE</b> if the URL is the specified type, or <b>FALSE</b> if not.</para>
      <para>If <i>UrlIs</i> is set to <b>URLIS_APPLIABLE</b>, <b>UrlIs</b> will attempt to determine the URL scheme. If the function is able to determine a scheme, it returns <b>TRUE</b>, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlIs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="UrlIsFileUrl" />
    <seealso cref="UrlIsNoHistory" />
    <seealso cref="UrlIsOpaque" />
  </member>
  <member name="Windows.UrlIsW">
    <summary>
      <para>Tests whether a URL is a specified type.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PCTSTR</b></para>
      <para>A null-terminated string of maximum length INTERNET_MAX_URL_LENGTH that contains the URL.</para>
    </param>
    <param name="UrlIs">
      <para>Type: <b>URLIS</b></para>
      <para>The type of URL to be tested for. This parameter can take one of the following values.</para>
      <h4>URLIS_APPLIABLE</h4>
      <para>Attempt to determine a valid scheme for the URL.</para>
      <h4>URLIS_DIRECTORY</h4>
      <para>Does the URL string end with a directory?</para>
      <h4>URLIS_FILEURL</h4>
      <para>Is the URL a file URL?</para>
      <h4>URLIS_HASQUERY</h4>
      <para>Does the URL have an appended query string?</para>
      <h4>URLIS_NOHISTORY</h4>
      <para>Is the URL a URL that is not typically tracked in navigation history?</para>
      <h4>URLIS_OPAQUE</h4>
      <para>Is the URL <see cref="opaque" />?</para>
      <h4>URLIS_URL</h4>
      <para>Is the URL valid?</para>
      <h5>- UrlIs.URLIS_APPLIABLE</h5>
      <para>Attempt to determine a valid scheme for the URL.</para>
      <h5>- UrlIs.URLIS_DIRECTORY</h5>
      <para>Does the URL string end with a directory?</para>
      <h5>- UrlIs.URLIS_FILEURL</h5>
      <para>Is the URL a file URL?</para>
      <h5>- UrlIs.URLIS_HASQUERY</h5>
      <para>Does the URL have an appended query string?</para>
      <h5>- UrlIs.URLIS_NOHISTORY</h5>
      <para>Is the URL a URL that is not typically tracked in navigation history?</para>
      <h5>- UrlIs.URLIS_OPAQUE</h5>
      <para>Is the URL <see cref="opaque" />?</para>
      <h5>- UrlIs.URLIS_URL</h5>
      <para>Is the URL valid?</para>
    </param>
    <returns>
      <para>Type: <b>BOOL</b></para>
      <para>For all but one of the URL types, <b>UrlIs</b> returns <b>TRUE</b> if the URL is the specified type, or <b>FALSE</b> if not.</para>
      <para>If <i>UrlIs</i> is set to <b>URLIS_APPLIABLE</b>, <b>UrlIs</b> will attempt to determine the URL scheme. If the function is able to determine a scheme, it returns <b>TRUE</b>, or <b>FALSE</b> otherwise.</para>
    </returns>
    <remarks>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlIs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
    <seealso cref="UrlIsFileUrl" />
    <seealso cref="UrlIsNoHistory" />
    <seealso cref="UrlIsOpaque" />
  </member>
  <member name="Windows.UrlUnescape">
    <summary>
      <para>Converts escape sequences back into ordinary characters.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string with the URL. If <i>dwFlags</i> is set to <b>URL_UNESCAPE_INPLACE</b>, the converted string is returned through this parameter.</para>
    </param>
    <param name="pszUnescaped">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that will receive a null-terminated string that contains the unescaped version of <i>pszURL</i>. If <b>URL_UNESCAPE_INPLACE</b> is set in <i>dwFlags</i>, this parameter is ignored.</para>
    </param>
    <param name="pcchUnescaped">
      <para>Type: <b>DWORD*</b></para>
      <para>The number of characters in the buffer pointed to by <i>pszUnescaped</i>. On entry, the value <i>pcchUnescaped</i> points to is set to the size of the buffer. If the function returns a success code, the value that <i>pcchUnescaped</i> points to is set to the number of characters written to that buffer, not counting the terminating <b>NULL</b> character. If an E_POINTER error code is returned, the buffer was too small, and the value to which <i>pcchUnescaped</i> points is set to the required number of characters that the buffer must be able to contain. If any other errors are returned, the value to which <i>pcchUnescaped</i> points is undefined.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that control which characters are unescaped. It can be a combination of the following flags.</para>
      <h4>URL_DONT_UNESCAPE_EXTRA_INFO</h4>
      <para>Do not convert the # or ? character, or any characters following them in the string.</para>
      <h4>URL_UNESCAPE_AS_UTF8</h4>
      <para>
        <b>Introduced in Windows 8</b>. Decode URLs that were encoded by using the <b>URL_ESCAPE_AS_UTF8</b> flag.</para>
      <h4>URL_UNESCAPE_INPLACE</h4>
      <para>Use <i>pszURL</i> to return the converted string instead of <i>pszUnescaped</i>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful. If the <b>URL_UNESCAPE_INPLACE</b> flag is not set, the value pointed to by <i>pcchUnescaped</i> will be set to the number of characters in the output buffer pointed to by <i>pszUnescaped</i>. Returns E_POINTER if the <b>URL_UNESCAPE_INPLACE</b> flag is not set and the output buffer is too small. The <i>pcchUnescaped</i> parameter will be set to the required buffer size. Otherwise, returns a standard error value.</para>
    </returns>
    <remarks>
      <para>An escape sequence has the form "%xy".</para>
      <para>Input strings cannot be longer than INTERNET_MAX_URL_LENGTH.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlUnescape as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlUnescapeA">
    <summary>
      <para>Converts escape sequences back into ordinary characters.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string with the URL. If <i>dwFlags</i> is set to <b>URL_UNESCAPE_INPLACE</b>, the converted string is returned through this parameter.</para>
    </param>
    <param name="pszUnescaped">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that will receive a null-terminated string that contains the unescaped version of <i>pszURL</i>. If <b>URL_UNESCAPE_INPLACE</b> is set in <i>dwFlags</i>, this parameter is ignored.</para>
    </param>
    <param name="pcchUnescaped">
      <para>Type: <b>DWORD*</b></para>
      <para>The number of characters in the buffer pointed to by <i>pszUnescaped</i>. On entry, the value <i>pcchUnescaped</i> points to is set to the size of the buffer. If the function returns a success code, the value that <i>pcchUnescaped</i> points to is set to the number of characters written to that buffer, not counting the terminating <b>NULL</b> character. If an E_POINTER error code is returned, the buffer was too small, and the value to which <i>pcchUnescaped</i> points is set to the required number of characters that the buffer must be able to contain. If any other errors are returned, the value to which <i>pcchUnescaped</i> points is undefined.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that control which characters are unescaped. It can be a combination of the following flags.</para>
      <h4>URL_DONT_UNESCAPE_EXTRA_INFO</h4>
      <para>Do not convert the # or ? character, or any characters following them in the string.</para>
      <h4>URL_UNESCAPE_AS_UTF8</h4>
      <para>
        <b>Introduced in Windows 8</b>. Decode URLs that were encoded by using the <b>URL_ESCAPE_AS_UTF8</b> flag.</para>
      <h4>URL_UNESCAPE_INPLACE</h4>
      <para>Use <i>pszURL</i> to return the converted string instead of <i>pszUnescaped</i>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful. If the <b>URL_UNESCAPE_INPLACE</b> flag is not set, the value pointed to by <i>pcchUnescaped</i> will be set to the number of characters in the output buffer pointed to by <i>pszUnescaped</i>. Returns E_POINTER if the <b>URL_UNESCAPE_INPLACE</b> flag is not set and the output buffer is too small. The <i>pcchUnescaped</i> parameter will be set to the required buffer size. Otherwise, returns a standard error value.</para>
    </returns>
    <remarks>
      <para>An escape sequence has the form "%xy".</para>
      <para>Input strings cannot be longer than INTERNET_MAX_URL_LENGTH.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlUnescape as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlUnescapeW">
    <summary>
      <para>Converts escape sequences back into ordinary characters.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string with the URL. If <i>dwFlags</i> is set to <b>URL_UNESCAPE_INPLACE</b>, the converted string is returned through this parameter.</para>
    </param>
    <param name="pszUnescaped">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that will receive a null-terminated string that contains the unescaped version of <i>pszURL</i>. If <b>URL_UNESCAPE_INPLACE</b> is set in <i>dwFlags</i>, this parameter is ignored.</para>
    </param>
    <param name="pcchUnescaped">
      <para>Type: <b>DWORD*</b></para>
      <para>The number of characters in the buffer pointed to by <i>pszUnescaped</i>. On entry, the value <i>pcchUnescaped</i> points to is set to the size of the buffer. If the function returns a success code, the value that <i>pcchUnescaped</i> points to is set to the number of characters written to that buffer, not counting the terminating <b>NULL</b> character. If an E_POINTER error code is returned, the buffer was too small, and the value to which <i>pcchUnescaped</i> points is set to the required number of characters that the buffer must be able to contain. If any other errors are returned, the value to which <i>pcchUnescaped</i> points is undefined.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that control which characters are unescaped. It can be a combination of the following flags.</para>
      <h4>URL_DONT_UNESCAPE_EXTRA_INFO</h4>
      <para>Do not convert the # or ? character, or any characters following them in the string.</para>
      <h4>URL_UNESCAPE_AS_UTF8</h4>
      <para>
        <b>Introduced in Windows 8</b>. Decode URLs that were encoded by using the <b>URL_ESCAPE_AS_UTF8</b> flag.</para>
      <h4>URL_UNESCAPE_INPLACE</h4>
      <para>Use <i>pszURL</i> to return the converted string instead of <i>pszUnescaped</i>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful. If the <b>URL_UNESCAPE_INPLACE</b> flag is not set, the value pointed to by <i>pcchUnescaped</i> will be set to the number of characters in the output buffer pointed to by <i>pszUnescaped</i>. Returns E_POINTER if the <b>URL_UNESCAPE_INPLACE</b> flag is not set and the output buffer is too small. The <i>pcchUnescaped</i> parameter will be set to the required buffer size. Otherwise, returns a standard error value.</para>
    </returns>
    <remarks>
      <para>An escape sequence has the form "%xy".</para>
      <para>Input strings cannot be longer than INTERNET_MAX_URL_LENGTH.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlUnescape as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlUnescapeInPlace">
    <summary>
      <para>Converts escape sequences back into ordinary characters and overwrites the original string.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>LPTSTR</b></para>
      <para>A pointer to a <b>null</b>-terminated string that contains the URL. The converted string is returned through this parameter.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>The flags that control which characters are unescaped.</para>
      <h4>URL_DONT_UNESCAPE_EXTRA_INFO</h4>
      <para>Do not convert the # or ? character, or any characters following them in the string.</para>
    </param>
    <remarks>
      <para>
        <b>UrlUnescapeInPlace</b> is equivalent to the following:</para>
      <code>
UrlUnescape(pszUrl, NULL, NULL, dwFlags | URL_UNESCAPE_INPLACE)

</code>
    </remarks>
    <seealso cref="UrlUnescape" />
  </member>
  <member name="Windows.UrlUnescape">
    <summary>
      <para>Converts escape sequences back into ordinary characters.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string with the URL. If <i>dwFlags</i> is set to <b>URL_UNESCAPE_INPLACE</b>, the converted string is returned through this parameter.</para>
    </param>
    <param name="pszUnescaped">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that will receive a null-terminated string that contains the unescaped version of <i>pszURL</i>. If <b>URL_UNESCAPE_INPLACE</b> is set in <i>dwFlags</i>, this parameter is ignored.</para>
    </param>
    <param name="pcchUnescaped">
      <para>Type: <b>DWORD*</b></para>
      <para>The number of characters in the buffer pointed to by <i>pszUnescaped</i>. On entry, the value <i>pcchUnescaped</i> points to is set to the size of the buffer. If the function returns a success code, the value that <i>pcchUnescaped</i> points to is set to the number of characters written to that buffer, not counting the terminating <b>NULL</b> character. If an E_POINTER error code is returned, the buffer was too small, and the value to which <i>pcchUnescaped</i> points is set to the required number of characters that the buffer must be able to contain. If any other errors are returned, the value to which <i>pcchUnescaped</i> points is undefined.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that control which characters are unescaped. It can be a combination of the following flags.</para>
      <h4>URL_DONT_UNESCAPE_EXTRA_INFO</h4>
      <para>Do not convert the # or ? character, or any characters following them in the string.</para>
      <h4>URL_UNESCAPE_AS_UTF8</h4>
      <para>
        <b>Introduced in Windows 8</b>. Decode URLs that were encoded by using the <b>URL_ESCAPE_AS_UTF8</b> flag.</para>
      <h4>URL_UNESCAPE_INPLACE</h4>
      <para>Use <i>pszURL</i> to return the converted string instead of <i>pszUnescaped</i>.</para>
      <h5>- dwFlags.URL_DONT_UNESCAPE_EXTRA_INFO</h5>
      <para>Do not convert the # or ? character, or any characters following them in the string.</para>
      <h5>- dwFlags.URL_UNESCAPE_AS_UTF8</h5>
      <para>
        <b>Introduced in Windows 8</b>. Decode URLs that were encoded by using the <b>URL_ESCAPE_AS_UTF8</b> flag.</para>
      <h5>- dwFlags.URL_UNESCAPE_INPLACE</h5>
      <para>Use <i>pszURL</i> to return the converted string instead of <i>pszUnescaped</i>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful. If the <b>URL_UNESCAPE_INPLACE</b> flag is not set, the value pointed to by <i>pcchUnescaped</i> will be set to the number of characters in the output buffer pointed to by <i>pszUnescaped</i>. Returns E_POINTER if the <b>URL_UNESCAPE_INPLACE</b> flag is not set and the output buffer is too small. The <i>pcchUnescaped</i> parameter will be set to the required buffer size. Otherwise, returns a standard error value.</para>
    </returns>
    <remarks>
      <para>An escape sequence has the form "%xy".</para>
      <para>Input strings cannot be longer than INTERNET_MAX_URL_LENGTH.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlUnescape as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlUnescapeA">
    <summary>
      <para>Converts escape sequences back into ordinary characters.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string with the URL. If <i>dwFlags</i> is set to <b>URL_UNESCAPE_INPLACE</b>, the converted string is returned through this parameter.</para>
    </param>
    <param name="pszUnescaped">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that will receive a null-terminated string that contains the unescaped version of <i>pszURL</i>. If <b>URL_UNESCAPE_INPLACE</b> is set in <i>dwFlags</i>, this parameter is ignored.</para>
    </param>
    <param name="pcchUnescaped">
      <para>Type: <b>DWORD*</b></para>
      <para>The number of characters in the buffer pointed to by <i>pszUnescaped</i>. On entry, the value <i>pcchUnescaped</i> points to is set to the size of the buffer. If the function returns a success code, the value that <i>pcchUnescaped</i> points to is set to the number of characters written to that buffer, not counting the terminating <b>NULL</b> character. If an E_POINTER error code is returned, the buffer was too small, and the value to which <i>pcchUnescaped</i> points is set to the required number of characters that the buffer must be able to contain. If any other errors are returned, the value to which <i>pcchUnescaped</i> points is undefined.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that control which characters are unescaped. It can be a combination of the following flags.</para>
      <h4>URL_DONT_UNESCAPE_EXTRA_INFO</h4>
      <para>Do not convert the # or ? character, or any characters following them in the string.</para>
      <h4>URL_UNESCAPE_AS_UTF8</h4>
      <para>
        <b>Introduced in Windows 8</b>. Decode URLs that were encoded by using the <b>URL_ESCAPE_AS_UTF8</b> flag.</para>
      <h4>URL_UNESCAPE_INPLACE</h4>
      <para>Use <i>pszURL</i> to return the converted string instead of <i>pszUnescaped</i>.</para>
      <h5>- dwFlags.URL_DONT_UNESCAPE_EXTRA_INFO</h5>
      <para>Do not convert the # or ? character, or any characters following them in the string.</para>
      <h5>- dwFlags.URL_UNESCAPE_AS_UTF8</h5>
      <para>
        <b>Introduced in Windows 8</b>. Decode URLs that were encoded by using the <b>URL_ESCAPE_AS_UTF8</b> flag.</para>
      <h5>- dwFlags.URL_UNESCAPE_INPLACE</h5>
      <para>Use <i>pszURL</i> to return the converted string instead of <i>pszUnescaped</i>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful. If the <b>URL_UNESCAPE_INPLACE</b> flag is not set, the value pointed to by <i>pcchUnescaped</i> will be set to the number of characters in the output buffer pointed to by <i>pszUnescaped</i>. Returns E_POINTER if the <b>URL_UNESCAPE_INPLACE</b> flag is not set and the output buffer is too small. The <i>pcchUnescaped</i> parameter will be set to the required buffer size. Otherwise, returns a standard error value.</para>
    </returns>
    <remarks>
      <para>An escape sequence has the form "%xy".</para>
      <para>Input strings cannot be longer than INTERNET_MAX_URL_LENGTH.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlUnescape as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.UrlUnescapeW">
    <summary>
      <para>Converts escape sequences back into ordinary characters.</para>
    </summary>
    <param name="pszUrl">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a null-terminated string with the URL. If <i>dwFlags</i> is set to <b>URL_UNESCAPE_INPLACE</b>, the converted string is returned through this parameter.</para>
    </param>
    <param name="pszUnescaped">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that will receive a null-terminated string that contains the unescaped version of <i>pszURL</i>. If <b>URL_UNESCAPE_INPLACE</b> is set in <i>dwFlags</i>, this parameter is ignored.</para>
    </param>
    <param name="pcchUnescaped">
      <para>Type: <b>DWORD*</b></para>
      <para>The number of characters in the buffer pointed to by <i>pszUnescaped</i>. On entry, the value <i>pcchUnescaped</i> points to is set to the size of the buffer. If the function returns a success code, the value that <i>pcchUnescaped</i> points to is set to the number of characters written to that buffer, not counting the terminating <b>NULL</b> character. If an E_POINTER error code is returned, the buffer was too small, and the value to which <i>pcchUnescaped</i> points is set to the required number of characters that the buffer must be able to contain. If any other errors are returned, the value to which <i>pcchUnescaped</i> points is undefined.</para>
    </param>
    <param name="dwFlags">
      <para>Type: <b>DWORD</b></para>
      <para>Flags that control which characters are unescaped. It can be a combination of the following flags.</para>
      <h4>URL_DONT_UNESCAPE_EXTRA_INFO</h4>
      <para>Do not convert the # or ? character, or any characters following them in the string.</para>
      <h4>URL_UNESCAPE_AS_UTF8</h4>
      <para>
        <b>Introduced in Windows 8</b>. Decode URLs that were encoded by using the <b>URL_ESCAPE_AS_UTF8</b> flag.</para>
      <h4>URL_UNESCAPE_INPLACE</h4>
      <para>Use <i>pszURL</i> to return the converted string instead of <i>pszUnescaped</i>.</para>
      <h5>- dwFlags.URL_DONT_UNESCAPE_EXTRA_INFO</h5>
      <para>Do not convert the # or ? character, or any characters following them in the string.</para>
      <h5>- dwFlags.URL_UNESCAPE_AS_UTF8</h5>
      <para>
        <b>Introduced in Windows 8</b>. Decode URLs that were encoded by using the <b>URL_ESCAPE_AS_UTF8</b> flag.</para>
      <h5>- dwFlags.URL_UNESCAPE_INPLACE</h5>
      <para>Use <i>pszURL</i> to return the converted string instead of <i>pszUnescaped</i>.</para>
    </param>
    <returns>
      <para>Type: <b>HRESULT</b></para>
      <para>Returns S_OK if successful. If the <b>URL_UNESCAPE_INPLACE</b> flag is not set, the value pointed to by <i>pcchUnescaped</i> will be set to the number of characters in the output buffer pointed to by <i>pszUnescaped</i>. Returns E_POINTER if the <b>URL_UNESCAPE_INPLACE</b> flag is not set and the output buffer is too small. The <i>pcchUnescaped</i> parameter will be set to the required buffer size. Otherwise, returns a standard error value.</para>
    </returns>
    <remarks>
      <para>An escape sequence has the form "%xy".</para>
      <para>Input strings cannot be longer than INTERNET_MAX_URL_LENGTH.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines UrlUnescape as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.wnsprintf">
    <summary>
      <para>Takes a variable-length argument list and returns the values of the arguments as a <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style formatted string.</para>
      <para>
        <b>Note</b>  Do not use this function. See Remarks for alternative functions.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the output string.</para>
    </param>
    <param name="cchDest">
      <para>Type: <b>int</b></para>
      <para>The maximum number of characters allowed in <i>pszDest</i>.</para>
    </param>
    <param name="pszFmt">
      <para>Type: <b>PCTSTR</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style format string. The %s format identifier should never be used in an unbounded form. To avoid potential buffer overruns, always specify a size; for instance "%32s".</para>
    </param>
    <param name="...">
      <para>Additional parameters that contain the data to be output.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b> characters. A negative value is returned if an error occurs.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The copied string is not guaranteed to be null-terminated. Consider using one of the following alternatives. <see cref="StringCbPrintf" />, <see cref="StringCbPrintfEx" />, <see cref="StringCbVPrintf" />, <see cref="StringCbVPrintfEx" />, <see cref="StringCchPrintf" />, <see cref="StringCchPrintfEx" />, <see cref="StringCchVPrintf" />, or <see cref="StringCchVPrintfEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <para>This is a Windows version of <a href="https://docs.microsoft.com//previous-versions/visualstudio/visual-studio-2010/ybk95axf(v=vs.100)">sprintf</a>. It does not support floating-point or pointer types. It supports only the left alignment flag.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines wnsprintf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.wnsprintfA">
    <summary>
      <para>Takes a variable-length argument list and returns the values of the arguments as a <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style formatted string.</para>
      <para>
        <b>Note</b>  Do not use this function. See Remarks for alternative functions.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the output string.</para>
    </param>
    <param name="cchDest">
      <para>Type: <b>int</b></para>
      <para>The maximum number of characters allowed in <i>pszDest</i>.</para>
    </param>
    <param name="pszFmt">
      <para>Type: <b>PCTSTR</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style format string. The %s format identifier should never be used in an unbounded form. To avoid potential buffer overruns, always specify a size; for instance "%32s".</para>
    </param>
    <param name="...">
      <para>Additional parameters that contain the data to be output.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b> characters. A negative value is returned if an error occurs.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The copied string is not guaranteed to be null-terminated. Consider using one of the following alternatives. <see cref="StringCbPrintf" />, <see cref="StringCbPrintfEx" />, <see cref="StringCbVPrintf" />, <see cref="StringCbVPrintfEx" />, <see cref="StringCchPrintf" />, <see cref="StringCchPrintfEx" />, <see cref="StringCchVPrintf" />, or <see cref="StringCchVPrintfEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <para>This is a Windows version of <a href="https://docs.microsoft.com//previous-versions/visualstudio/visual-studio-2010/ybk95axf(v=vs.100)">sprintf</a>. It does not support floating-point or pointer types. It supports only the left alignment flag.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines wnsprintf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.wnsprintfW">
    <summary>
      <para>Takes a variable-length argument list and returns the values of the arguments as a <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style formatted string.</para>
      <para>
        <b>Note</b>  Do not use this function. See Remarks for alternative functions.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the output string.</para>
    </param>
    <param name="cchDest">
      <para>Type: <b>int</b></para>
      <para>The maximum number of characters allowed in <i>pszDest</i>.</para>
    </param>
    <param name="pszFmt">
      <para>Type: <b>PCTSTR</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style format string. The %s format identifier should never be used in an unbounded form. To avoid potential buffer overruns, always specify a size; for instance "%32s".</para>
    </param>
    <param name="...">
      <para>Additional parameters that contain the data to be output.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b> characters. A negative value is returned if an error occurs.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The copied string is not guaranteed to be null-terminated. Consider using one of the following alternatives. <see cref="StringCbPrintf" />, <see cref="StringCbPrintfEx" />, <see cref="StringCbVPrintf" />, <see cref="StringCbVPrintfEx" />, <see cref="StringCchPrintf" />, <see cref="StringCchPrintfEx" />, <see cref="StringCchVPrintf" />, or <see cref="StringCchVPrintfEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <para>This is a Windows version of <a href="https://docs.microsoft.com//previous-versions/visualstudio/visual-studio-2010/ybk95axf(v=vs.100)">sprintf</a>. It does not support floating-point or pointer types. It supports only the left alignment flag.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines wnsprintf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.wnsprintf">
    <summary>
      <para>Takes a variable-length argument list and returns the values of the arguments as a <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style formatted string.</para>
      <para>
        <b>Note</b>  Do not use this function. See Remarks for alternative functions.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the output string.</para>
    </param>
    <param name="cchDest">
      <para>Type: <b>int</b></para>
      <para>The maximum number of characters allowed in <i>pszDest</i>.</para>
    </param>
    <param name="pszFmt">
      <para>Type: <b>PCTSTR</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style format string. The %s format identifier should never be used in an unbounded form. To avoid potential buffer overruns, always specify a size; for instance "%32s".</para>
    </param>
    <param name="...">
      <para>Additional parameters that contain the data to be output.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b> characters. A negative value is returned if an error occurs.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The copied string is not guaranteed to be null-terminated. Consider using one of the following alternatives. <see cref="StringCbPrintf" />, <see cref="StringCbPrintfEx" />, <see cref="StringCbVPrintf" />, <see cref="StringCbVPrintfEx" />, <see cref="StringCchPrintf" />, <see cref="StringCchPrintfEx" />, <see cref="StringCchVPrintf" />, or <see cref="StringCchVPrintfEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <para>This is a Windows version of <a href="https://docs.microsoft.com//previous-versions/visualstudio/visual-studio-2010/ybk95axf(v=vs.100)">sprintf</a>. It does not support floating-point or pointer types. It supports only the left alignment flag.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines wnsprintf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.wnsprintfA">
    <summary>
      <para>Takes a variable-length argument list and returns the values of the arguments as a <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style formatted string.</para>
      <para>
        <b>Note</b>  Do not use this function. See Remarks for alternative functions.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the output string.</para>
    </param>
    <param name="cchDest">
      <para>Type: <b>int</b></para>
      <para>The maximum number of characters allowed in <i>pszDest</i>.</para>
    </param>
    <param name="pszFmt">
      <para>Type: <b>PCTSTR</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style format string. The %s format identifier should never be used in an unbounded form. To avoid potential buffer overruns, always specify a size; for instance "%32s".</para>
    </param>
    <param name="...">
      <para>Additional parameters that contain the data to be output.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b> characters. A negative value is returned if an error occurs.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The copied string is not guaranteed to be null-terminated. Consider using one of the following alternatives. <see cref="StringCbPrintf" />, <see cref="StringCbPrintfEx" />, <see cref="StringCbVPrintf" />, <see cref="StringCbVPrintfEx" />, <see cref="StringCchPrintf" />, <see cref="StringCchPrintfEx" />, <see cref="StringCchVPrintf" />, or <see cref="StringCchVPrintfEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <para>This is a Windows version of <a href="https://docs.microsoft.com//previous-versions/visualstudio/visual-studio-2010/ybk95axf(v=vs.100)">sprintf</a>. It does not support floating-point or pointer types. It supports only the left alignment flag.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines wnsprintf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.wnsprintfW">
    <summary>
      <para>Takes a variable-length argument list and returns the values of the arguments as a <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style formatted string.</para>
      <para>
        <b>Note</b>  Do not use this function. See Remarks for alternative functions.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the output string.</para>
    </param>
    <param name="cchDest">
      <para>Type: <b>int</b></para>
      <para>The maximum number of characters allowed in <i>pszDest</i>.</para>
    </param>
    <param name="pszFmt">
      <para>Type: <b>PCTSTR</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style format string. The %s format identifier should never be used in an unbounded form. To avoid potential buffer overruns, always specify a size; for instance "%32s".</para>
    </param>
    <param name="...">
      <para>Additional parameters that contain the data to be output.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b> characters. A negative value is returned if an error occurs.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The copied string is not guaranteed to be null-terminated. Consider using one of the following alternatives. <see cref="StringCbPrintf" />, <see cref="StringCbPrintfEx" />, <see cref="StringCbVPrintf" />, <see cref="StringCbVPrintfEx" />, <see cref="StringCchPrintf" />, <see cref="StringCchPrintfEx" />, <see cref="StringCchVPrintf" />, or <see cref="StringCchVPrintfEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <para>This is a Windows version of <a href="https://docs.microsoft.com//previous-versions/visualstudio/visual-studio-2010/ybk95axf(v=vs.100)">sprintf</a>. It does not support floating-point or pointer types. It supports only the left alignment flag.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines wnsprintf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.wvnsprintf">
    <summary>
      <para>Takes a list of arguments and returns the values of the arguments as a <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style formatted string.</para>
      <para>
        <b>Note</b>  Do not use this function. See Remarks for alternative functions.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the output string.</para>
    </param>
    <param name="cchDest">
      <para>Type: <b>int</b></para>
      <para>The maximum number of characters allowed in <i>pszDest</i>.</para>
    </param>
    <param name="pszFmt">
      <para>Type: <b>PCTSTR</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style format string. The %s format identifier should never be used in an unbounded form. To avoid potential buffer overruns, always specify a size; for instance "%32s".</para>
    </param>
    <param name="arglist">
      <para>Type: <b>va_list</b></para>
      <para>A pointer to a list of command-line parameters used to customize the output.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b> characters. A negative value is returned if an error occurs.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The copied string is not guaranteed to be null-terminated. Consider using one of the following alternatives. <see cref="StringCbPrintf" />, <see cref="StringCbPrintfEx" />, <see cref="StringCbVPrintf" />, <see cref="StringCbVPrintfEx" />, <see cref="StringCchPrintf" />, <see cref="StringCchPrintfEx" />, <see cref="StringCchVPrintf" />, or <see cref="StringCchVPrintfEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines wvnsprintf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.wvnsprintfA">
    <summary>
      <para>Takes a list of arguments and returns the values of the arguments as a <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style formatted string.</para>
      <para>
        <b>Note</b>  Do not use this function. See Remarks for alternative functions.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the output string.</para>
    </param>
    <param name="cchDest">
      <para>Type: <b>int</b></para>
      <para>The maximum number of characters allowed in <i>pszDest</i>.</para>
    </param>
    <param name="pszFmt">
      <para>Type: <b>PCTSTR</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style format string. The %s format identifier should never be used in an unbounded form. To avoid potential buffer overruns, always specify a size; for instance "%32s".</para>
    </param>
    <param name="arglist">
      <para>Type: <b>va_list</b></para>
      <para>A pointer to a list of command-line parameters used to customize the output.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b> characters. A negative value is returned if an error occurs.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The copied string is not guaranteed to be null-terminated. Consider using one of the following alternatives. <see cref="StringCbPrintf" />, <see cref="StringCbPrintfEx" />, <see cref="StringCbVPrintf" />, <see cref="StringCbVPrintfEx" />, <see cref="StringCchPrintf" />, <see cref="StringCchPrintfEx" />, <see cref="StringCchVPrintf" />, or <see cref="StringCchVPrintfEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines wvnsprintf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.wvnsprintfW">
    <summary>
      <para>Takes a list of arguments and returns the values of the arguments as a <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style formatted string.</para>
      <para>
        <b>Note</b>  Do not use this function. See Remarks for alternative functions.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the output string.</para>
    </param>
    <param name="cchDest">
      <para>Type: <b>int</b></para>
      <para>The maximum number of characters allowed in <i>pszDest</i>.</para>
    </param>
    <param name="pszFmt">
      <para>Type: <b>PCTSTR</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style format string. The %s format identifier should never be used in an unbounded form. To avoid potential buffer overruns, always specify a size; for instance "%32s".</para>
    </param>
    <param name="arglist">
      <para>Type: <b>va_list</b></para>
      <para>A pointer to a list of command-line parameters used to customize the output.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b> characters. A negative value is returned if an error occurs.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The copied string is not guaranteed to be null-terminated. Consider using one of the following alternatives. <see cref="StringCbPrintf" />, <see cref="StringCbPrintfEx" />, <see cref="StringCbVPrintf" />, <see cref="StringCbVPrintfEx" />, <see cref="StringCchPrintf" />, <see cref="StringCchPrintfEx" />, <see cref="StringCchVPrintf" />, or <see cref="StringCchVPrintfEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines wvnsprintf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.wvnsprintf">
    <summary>
      <para>Takes a list of arguments and returns the values of the arguments as a <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style formatted string.</para>
      <para>
        <b>Note</b>  Do not use this function. See Remarks for alternative functions.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the output string.</para>
    </param>
    <param name="cchDest">
      <para>Type: <b>int</b></para>
      <para>The maximum number of characters allowed in <i>pszDest</i>.</para>
    </param>
    <param name="pszFmt">
      <para>Type: <b>PCTSTR</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style format string. The %s format identifier should never be used in an unbounded form. To avoid potential buffer overruns, always specify a size; for instance "%32s".</para>
    </param>
    <param name="arglist">
      <para>Type: <b>va_list</b></para>
      <para>A pointer to a list of command-line parameters used to customize the output.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b> characters. A negative value is returned if an error occurs.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The copied string is not guaranteed to be null-terminated. Consider using one of the following alternatives. <see cref="StringCbPrintf" />, <see cref="StringCbPrintfEx" />, <see cref="StringCbVPrintf" />, <see cref="StringCbVPrintfEx" />, <see cref="StringCchPrintf" />, <see cref="StringCchPrintfEx" />, <see cref="StringCchVPrintf" />, or <see cref="StringCchVPrintfEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines wvnsprintf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.wvnsprintfA">
    <summary>
      <para>Takes a list of arguments and returns the values of the arguments as a <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style formatted string.</para>
      <para>
        <b>Note</b>  Do not use this function. See Remarks for alternative functions.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the output string.</para>
    </param>
    <param name="cchDest">
      <para>Type: <b>int</b></para>
      <para>The maximum number of characters allowed in <i>pszDest</i>.</para>
    </param>
    <param name="pszFmt">
      <para>Type: <b>PCTSTR</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style format string. The %s format identifier should never be used in an unbounded form. To avoid potential buffer overruns, always specify a size; for instance "%32s".</para>
    </param>
    <param name="arglist">
      <para>Type: <b>va_list</b></para>
      <para>A pointer to a list of command-line parameters used to customize the output.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b> characters. A negative value is returned if an error occurs.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The copied string is not guaranteed to be null-terminated. Consider using one of the following alternatives. <see cref="StringCbPrintf" />, <see cref="StringCbPrintfEx" />, <see cref="StringCbVPrintf" />, <see cref="StringCbVPrintfEx" />, <see cref="StringCchPrintf" />, <see cref="StringCchPrintfEx" />, <see cref="StringCchVPrintf" />, or <see cref="StringCchVPrintfEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines wvnsprintf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
  <member name="Windows.wvnsprintfW">
    <summary>
      <para>Takes a list of arguments and returns the values of the arguments as a <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style formatted string.</para>
      <para>
        <b>Note</b>  Do not use this function. See Remarks for alternative functions.</para>
    </summary>
    <param name="pszDest">
      <para>Type: <b>PTSTR</b></para>
      <para>A pointer to a buffer that, when this function returns successfully, receives the output string.</para>
    </param>
    <param name="cchDest">
      <para>Type: <b>int</b></para>
      <para>The maximum number of characters allowed in <i>pszDest</i>.</para>
    </param>
    <param name="pszFmt">
      <para>Type: <b>PCTSTR</b></para>
      <para>A <a href="https://docs.microsoft.com//windows/desktop/direct3dhlsl/printf">printf</a>-style format string. The %s format identifier should never be used in an unbounded form. To avoid potential buffer overruns, always specify a size; for instance "%32s".</para>
    </param>
    <param name="arglist">
      <para>Type: <b>va_list</b></para>
      <para>A pointer to a list of command-line parameters used to customize the output.</para>
    </param>
    <returns>
      <para>Type: <b>int</b></para>
      <para>Returns the number of characters written to the buffer, excluding any terminating <b>NULL</b> characters. A negative value is returned if an error occurs.</para>
    </returns>
    <remarks>
      <para>
        <b>Security Warning:  </b>Using this function incorrectly can compromise the security of your application. The copied string is not guaranteed to be null-terminated. Consider using one of the following alternatives. <see cref="StringCbPrintf" />, <see cref="StringCbPrintfEx" />, <see cref="StringCbVPrintf" />, <see cref="StringCbVPrintfEx" />, <see cref="StringCchPrintf" />, <see cref="StringCchPrintfEx" />, <see cref="StringCchVPrintf" />, or <see cref="StringCchVPrintfEx" />. You should review <a href="https://docs.microsoft.com//windows/desktop/shell/sec-shell">Security Considerations: Microsoft Windows Shell</a> before continuing.</para>
      <blockquote>
        <para>[!NOTE]
The shlwapi.h header defines wvnsprintf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see <a href="https://docs.microsoft.com//windows/win32/intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.</para>
      </blockquote>
    </remarks>
  </member>
</doc>